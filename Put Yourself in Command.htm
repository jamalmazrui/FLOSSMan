<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="The Contributors" />
  <title>COMMAND LINE</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">COMMAND LINE</h1>
<p class="author">The Contributors</p>
<p class="date">2013.12.02-15.08</p>
</header>
<p><span id="ch001_introduction.xhtml"></span></p>
<h1>Put Yourself in Command</h1>
<p>Commands enable you to do all sorts of powerful things. We will demonstrate this by looking at an everyday task you might be familiar with. If you use a digital camera, you probably have a folder full of images on your computer. Imagine you wish to resize the image <em>profile.jpg</em> so it is 300 pixels wide and then save it as a new image called <em>profile_small.jpg</em>.</p>
<p>Using an image editing software, the steps you need to go through might be as follows:</p>
<ol>
<li>Open the image editor from the Applications menu.</li>
<li>Click <em>File&gt;Open</em>.</li>
<li>Browse to the folder where you have saved your images.</li>
<li>Click the image file <em>profile.jpg</em>, and then click <em>Open</em>.</li>
<li>Click <em>Image&gt;Scale Image</em> to resize the selected image.</li>
<li>Change the image width to 300 pixels, and then click <em>Scale</em>.</li>
<li>Click <em>File&gt;Save As</em> to save the image file.</li>
<li>Enter <em>profile_small.jpg</em> as the new file name, and then click <em>Save</em>.</li>
</ol>
<p> <img src="static/IntroCommandLine-CommandLineIntro-photo_gimp-en.png" alt="photo_gimp.png" width="503" height="519" /></p>
<p>Using the command line, you can achieve the same result by typing the following:</p>
<pre><code>convert -resize 300 profile.jpg profile_small.jpg</code></pre>
<p>That is one step in the command line instead of eight steps using the image editor. Perhaps, you think that the time you spend on reading this book and studying the commands is not worth saving seven steps. But what if there were 30 images to be resized? Do you still want to open each image individually and repeat the process 30 times using the image editor? That would require a total of 240 steps. Would you rather just type one command instead and get the job done?</p>
<p>A single command can do the same thing whether you have 30 images, 300, or 3000. This is one of the most compelling reasons to start using the command line. You might start with a slow learning curve, but in the long run, it will save a lot of time. Even more important, learning the command line will open up interesting possibilities and fun ways of working. Let us look at some more reasons why learning the command line is a good idea.<br />
</p>
<h2>Advantages of Using Commands</h2>
<p>Many people who give the command line a try are so amazed by its possibilities that they do not even want to go back to a Graphical User Interface(GUI)! Why? Well, in brief, the command line offers the following main advantages over common graphical software:</p>
<ul>
<li><strong>Flexibility-</strong>With graphical programs, you sometimes hit a limit; you just can't do what you want or you need to find cumbersome work-arounds to program limits. With the command line, you can combine commands to yield a virtually infinite range of new and interesting functions. By combining commands creatively, you can make the command line do exactly what you want; it puts you in control of your computer.</li>
<li><strong>Reliability-</strong>Graphical programs are often immature or even unstable. In contrast, most of the tools that the command line offers are highly reliable. One of the reasons for this reliability is their maturity; the oldest command line programs have been around since the late 1970s. This means that these command lines have been tested for over three decades. They also tend to work the same way across different operating systems, unlike most graphical tools. If you want a Swiss Army knife you can rely on, the command line is for you.</li>
<li><strong>Speed.</strong> Fancy graphics consume a lot of your hardware's resources, often resulting in slowness or instability. The command line, on the other hand, uses the computer's resources much more sparingly, leaving memory and processing power for the tasks that you actually want to accomplish. The command line is also intrinsically faster; instead of clicking through long chains of graphical menus, you can type commands in a dozen or so keystrokes, and often apply them to multiple files or other objects. If you can type fast, this will enable you to drastically increase your productivity.</li>
<li><strong>Experience.</strong> Using the command line is a great learning experience. When you use the command line, you communicate with your computer more directly than with the graphical programs, thus learning a lot about its inner workings. Using the command line on a regular basis is <em>the</em> way to becoming a GNU/Linux guru.</li>
<li><strong>Fun.</strong> Have you ever wanted to be like those cool computer hackers who can make a GNU/Linux machine do things that you have not even dreamed of? Once you learn to use this powerful tool, you will find yourself doing funny and interesting stuff that you have never imagined.</li>
</ul>
<ol>
</ol>
<h2>The Value of Scripting</h2>
<p>But wait, there's more! You can also store commands in text files. These text files are called <em>scripts</em> and can be used instead of typing a long series of commands each time. For example, if you store commands in a file called <em>mycommand.sh</em>, you don't have to type out the commands again. Instead, you can simply type:</p>
<pre><code>mycommand.sh</code></pre>
<p>In addition, you can combine commands together in simple or sophisticated ways. Further, you can schedule scripts to run at a specific time or specific date or at the occurrence of a specific event on your computer.</p>
<p>You can also write scripts that accept additional information from you. For example, an image resizing script might ask you to what size the images should be resized before it starts the process.</p>
<p>Ever tried to do anything remotely like that by using a GUI? Perhaps now you can see how working with the command line interface (CLI) starts to open a whole new world to using your computer.</p>
<h2>Is my Computer Sick?</h2>
<p>The command line is also used to check the well-being of your computer. There are many commands you can use to check every facet of your computer's health, from the amount of space left on the hard drive to the temperature of the CPU. If your computer is acting poorly and you do not know what the matter is, a few commands will help you quickly determine whether it is a hardware or a software issue, and help you quickly rectify the problem.<br />
</p>
<h2>Spanning the network</h2>
<p>Another interesting feature of command line interfaces that GUIs can't match is the interaction over a network. Imagine you have a computer in another room and you wish to turn it off. How do you do that? Easy right? Get up, walk to the computer, and click on the &quot;Shutdown&quot; button.</p>
<p>Well, those who know how to connect to the computer in the next room use the command line and type <code>halt</code> to do the same thing.</p>
<p>That might seem trivial. Perhaps it's actually better for you to get up off that comfy chair and expend 5 calories walking to the next room. However, what if the computer you wanted to shut down was in another suburb? In another city? Another country?  Then, remote control of that computer might be very useful.</p>
<p>Shutting down a remote computer is just a start. Everything you can do on the command line you can do on the remote computer. That means you can run scripts, execute commands, edit text files, check the diagnostics, and do many other tasks. The world of the command line just got a whole lot bigger.</p>
<h2>Even graphical programs are commands</h2>
<p>When you click an icon or menu item to start a program, you are actually running a command. You may require, at times, to understand what commands are you are running. For instance, if you suspect a program is running invisibly in the background and slowing your computer, you can find its command and terminate the program. GUI programs often send more error messages to the command line than to GUI dialog boxes. You can often use these command line messages to diagnose problems more precisely than you can using a graphical interface.<br />
</p>
<p><span id="ch002_about-this-manual.xhtml"></span></p>
<h1>About This Manual</h1>
<p>This manual was initially written at the first edition of the GNU/Linux conference LibrePlanet which was hosted at the Harvard Science Center, Cambridge, MA, on March 21-22, 2009.  LibrePlanet conferences are part of the LibrePlanet project, started in 2006, whose mission is to help further the ideals surrounding the free software via a social movement for user freedom organized as a global network of local teams and project-based ones. </p>
<p><img src="static/IntroCommandLine-About-logo_fsf-org_tiny-en.png" title="logo_fsf.org_tiny" alt="logo_fsf.org_tiny" width="360" height="42" /></p>
<p>The LibrePlanet conference 2009 was sponsored by the Free Software Foundation (FSF) and organized into three tracks, free software activism, freedom for network services, and high priority free software projects.  The creation of this manual was part of the free software activism track, and a collaboration between FLOSS Manuals and the FSF.  The book sprint was organized by Andy Oram and Adam Hyde, with assistance from Peter Brown, Deb Nicholson and Danny Clark.</p>
<p> </p>
<p>There was a good turnout for the event.  For the first time, a FLOSS Manuals book sprint had more authors participating remotely than physically.  On the second day of LibrePlanet, and as part of the un-conference schedule, there were 4-5 people working regularly on site.</p>
<p><img src="static/IntroCommandLine-About-sprint-en.jpg" title="sprint" alt="sprint" width="600" height="450" /></p>
<p>Big shout out to Tom Boyle for going tip to toe copy editing :)<br />
</p>
<p>The FSF plans to print and sell two hundred bound copies of this manual at $20 to provide funds for the second Gnubie book sprint.  You can purchase this book at:</p>
<p><a href="http://shop.fsf.org/product/Introduction_to_Command_Line/" class="uri">http://shop.fsf.org/product/Introduction_to_Command_Line/</a><br />
</p>
<p>This manual has been written within FLOSS Manuals.  This manual can be improved by you.  To improve this manual follow these steps:</p>
<h2>1. Register</h2>
<p>Register at FLOSS Manuals:<br />
<a href="http://en.flossmanuals.net/register">http://booki.flossmanuals.net/accounts/signin/?redirect=/</a></p>
<h2>2. Contribute!</h2>
<p>Select the manual (<a href="http://en.flossmanuals.net/bin/view/CommandLineIntro/WebHome">http://en.flossmanuals.net/bin/view/CommandLineIntro</a>) and a chapter to work on.<br />
</p>
<p>If you need to ask us questions about how to contribute then join the chat room listed below and ask us! We look forward to your contribution!</p>
<p>For more information on using FLOSS Manuals you may also wish to read our manual:<br />
<a href="http://en.flossmanuals.net/FLOSSManuals" class="uri">http://en.flossmanuals.net/FLOSSManuals</a></p>
<p>You may wish to also look at the Outline at the end of the book.  This is a guide as to how the manual might be extended.  Feel free to change the outline and improvise!</p>
<p><a href="http://en.flossmanuals.net/bin/view/CommandLineIntro/Outline">http://en.flossmanuals.net/command-line/ch054_outline/</a><br />
</p>
<h2>3. Chat</h2>
<p>It's a good idea to talk with us so we can help co-ordinate all contributions.  We have a chat room embedded in the FLOSS Manuals website so you can use it in the browser.<br />
</p>
<p>If you know how to use IRC you can connect to the following:<br />
server: irc.freenode.net<br />
channel: #flossmanuals</p>
<h2>4. Mailing List</h2>
<p>For discussing all things about FLOSS Manuals join our mailing list:<br />
<a href="http://lists.flossmanuals.net/listinfo.cgi/discuss-flossmanuals.net%20">http://lists.flossmanuals.net/listinfo.cgi/discuss-flossmanuals.net</a></p>
<h2>5. Translation</h2>
<p>If you would like to translate this manual, let us know, because we have a very good system to enable translations.  To start a translation join the mailing list (listed above) and send an email telling us which language you would like to translate the manual into. <br />
</p>
<p><span id="ch004_getting-started.xhtml"></span></p>
<h1>Getting Started</h1>
<p>Modern computing is highly interactive, and using the command line is just another form of interaction.  Most people use the computer through its desktop or graphical interface, interacting at a rapid pace.  They click on an object, drag and drop it, double-click another to open it, alter it, etc. </p>
<p>Although interactions happen so fast you don't think about it, each click or keystroke is a command to the computer, which it reacts to. Using the command line is the same thing, but more deliberate.  You type a command and press the <strong>Return</strong> or <strong>Enter</strong> key.  For instance, in my terminal I type:</p>
<pre><code>date</code></pre>
<p>And the computer replies with:</p>
<pre><code>Thu Mar 12 17:15:09 EDT 2009</code></pre>
<p>That's pretty computerish.  In later chapters we'll explain how to request the date and time in a more congenial format. We'll also explain how working in different countries and with different languages changes the output.  The idea is that you've just had an interaction.</p>
<h2>The Command Line Can Do Much Better</h2>
<p>The <em>date</em> command, as seen so far, compares poorly with the alternative of glancing at a calendar or clock.  The main problem is not the unappetizing appearance of the output, mentioned already, but the inability to do anything of value with the output.  For instance, if I'm looking at the date in order to insert it into a document I'm writing or update an event on my online calendar, I have to do some retyping.  The command line can do much better.</p>
<p>After you learn basic commands and some nifty ways to save yourself time, you'll find out more in this book about feeding the output of commands into other commands, automating activities, and saving commands for later use.</p>
<h2>What Do We Mean By a Command?</h2>
<p>At the beginning of this chapter we used the word &quot;command&quot; very generally to refer to any way of telling the computer what to do.  But in the context of this book, a command has a very specific meaning. It's a file on your computer that can be executed, or in some cases an action that is built into the shell program. Except for the <em>built-in commands</em>, the computer runs each command by finding the file that bears its name and executing that file. We'll give you more details as they become useful.</p>
<h2>Ways to Enter Commands</h2>
<p>To follow along on this book, you need to open a command-line interpreter (called a <em>shell</em> or <em>terminal</em> in GNU/Linux) on your computer.  Pre-graphical computer screens presented people with this interpreter as soon as they logged in.  Nowadays almost everybody except professional system administrators uses a graphical interface, although the pre-graphical one is still easier and quicker to use for many purposes.   So we'll show you how to pull up a shell.<br />
</p>
<h2>Finding a Terminal</h2>
<p>You can get a terminal interface from the desktop, but it may be easier to leave the desktop and use the original text-only terminal. To do that, use the &lt;ctrl&gt;&lt;alt&gt;&lt;F1&gt; key combination. You get a nearly blank screen with an invitation to log in. Give it your username and password. You can go to other terminals with &lt;alt&gt;&lt;F2&gt; and so on, and set up sessions with different (or the same) users for whatever tasks you want to do. At any time, switch from one to another by using the &lt;alt&gt;&lt;F#&gt; keystroke for the one you want. One of these, probably F7 or F8, will get you back to the desktop. In the text terminals you can use the mouse (assuming your system has gpm running) to select a word, line or range of lines.  You can then paste that somewhere else in that terminal or any other terminal.</p>
<p>GNU/Linux distributions come with different graphical user interfaces (<em>GUI</em> ) offering different <span class="clickable"><span class="hg"><span class="hw">aesthetics</span></span></span> and semantic metaphors.  Those running on top of the operating system are known as <em>desktop environments</em>.  GNOME, KDE and Xfce are among the most widely used ones.  Virtually every desktop environment provides a program that mimics the old text-only terminals that computers used to offer as interfaces.  On your desktop, try looking through the menus of applications for a program called Terminal.  Often it's on a menu named something such as &quot;Accessories&quot;, which is not really fair because once you read this book you'll be spending a lot of time in the terminal every day.</p>
<p>In GNOME you choose <strong>Applications -&gt; Accessories -&gt; Terminal</strong>.</p>
<p><img src="static/IntroCommandLine-GettingStarted-Screenshot_1-en.png" title="ubuntu_open" alt="Screenshot_1.png" width="500" height="347" /> </p>
<p>In KDE you choose <strong>K Menu -&gt; System -&gt; Terminal</strong>; in Xfce you choose <strong>Xfce Menu -&gt; System -&gt; Terminal</strong>. <br />
Wherever it's located, you can almost certainly find a terminal program.</p>
<p>When you run the terminal program, it just shows a blank window; there's not much in the way of help.  You're expected to know what to do--and we'll show you.</p>
<p>The following figure shows the Terminal window opened on the desktop in GNOME. <br />
</p>
<p> <img src="static/CommandLineIntro-GettingStarted-Screenshot_2-en.png" alt="Screenshot_2.png" width="600" height="449" /><br />
</p>
<h2>Running an Individual Command</h2>
<p>Many graphical interfaces also provide a small dialog box called something like &quot;Run command&quot;.  It presents a small text area where you can type in a command and press the <strong>Return</strong> or <strong>Enter</strong> key. <br />
</p>
<p><img src="static/IntroCommandLine-GettingStarted-Screenshot_Run_Application-en.png" title="run" alt="Screenshot_Run_Application.png" width="520" height="187" /> </p>
<p>To invoke this dialog box, try typing the <strong>Alt</strong> + <strong>F2</strong> key combination, or searching through the menus of applications.  You can use this box as a shortcut to quickly start up a terminal program, as long as you know the name of a terminal program installed on your computer.  If you are working on an unfamiliar computer and don't even know the name of the default terminal program, try typing <code>xterm</code> to start up a no-frills terminal program (no fancy menus allowing choice of color themes or fonts).  If you desperately need these fancy menus,</p>
<ul>
<li>in GNOME the default terminal program should be <code>gnome-terminal</code>;</li>
<li>in KDE it should be <code>konsole</code>;</li>
<li>in Xfce you'd try with <code>Terminal</code> or with version specific terminal names: for example in Xfce 4 you should find <code>xfce4-terminal</code>.</li>
</ul>
<h2>How We Show Commands and Output in This Book</h2>
<p>There's a common convention in books about the command-line. When you start up a terminal, you see a little message indicating that the terminal is ready to accept your command. This message is called a <em>prompt</em>, and it may be as simple as:</p>
<pre><code>$</code></pre>
<p>After you type your command and press the <strong>Return</strong> or <strong>Enter</strong> key, the terminal displays the command's output (if there is any) followed by another prompt. So my earlier interaction would be shown in the book like this:</p>
<pre><code>$ date
Thu Mar 12 17:15:09 EDT 2009
$</code></pre>
<p>You have to know how to interpret examples like the preceding one. All you type here is <em>date</em>. Then press the <strong>Return</strong> key. The word <em>date</em> in the example is printed in bold to indicate that it's something you type. The rest is output on the terminal.<br />
</p>
<p><span id="ch005_beginning-syntax.xhtml"></span></p>
<h1>The Parts of a Command</h1>
<p>The first word you type on a line is the command you wish to run.  In the &quot;Getting Started&quot; section we saw a call to the <code>date</code> command, which returned the current date and time.</p>
<h2>Arguments</h2>
<p>Another command we could use is <code>echo</code>, which displays the specified information back to the user.  This isn't very useful if we don't actually specify information to display.  Fortunately, we can add more information to a command to modify its behavior; this information consists of <em>arguments</em> .  Luckily, the <code>echo</code> command doesn't argue back; it just repeats what we ask it:</p>
<pre><code>$ echo foo
foo</code></pre>
<p>In this case, the argument was <strong>foo</strong>, but there is no need to limit the number of arguments to one. Every word of the text entered, excluding the first word, will be considered an additional argument passed to the command. If we wanted <code>echo</code> to respond with multiple words, such as <strong><code>foo bar</code></strong>, we could give it multiple arguments:</p>
<pre><code>$ echo foo bar
foo bar</code></pre>
<p>Arguments are normally separated by &quot;white space&quot; (blanks and tabs -- things that show up white on paper).  It doesn't matter how many spaces you type, so long as there is at least one. For instance, if you type:</p>
<pre><code>$ echo foo              bar
foo bar</code></pre>
<p>with a lot of spaces between the two arguments, the &quot;extra&quot; spaces are ignored, and the output shows the two arguments separated by a single space.  To tell the command line that the spaces are part of a single argument, you have to delimit in some way that argument.  You can do it by <em>quoting</em> the entire content of the argument inside double-quote (<code>&quot;</code>) characters:</p>
<pre><code>$ echo &quot;foo              bar&quot;
foo              bar</code></pre>
<p>As we'll see later, there is more than a way to quote text, and those ways may (or may not) differ in the result, depending on the content of the quoted text.<br />
</p>
<h2>Options</h2>
<p>Revisiting the <code>date</code> command, suppose you actually wanted the UTC date/time information displayed.  For this, <code>date</code> provides the <strong><code>--utc</code></strong> option.  Notice the two initial hyphens.  These indicate arguments that a command checks when it starts and that control its behavior.  The <code>date</code> command checks specially for the <strong><code>--utc</code></strong> option and says, &quot;OK, I know you're asking for UTC time&quot;.  This is different from arguments we invented, as when we issued <code>echo</code> with the arguments <strong><code>foo bar</code></strong>.</p>
<p>Other than the dashes preceding the word, <strong><code>--utc</code></strong> is entered just like an argument:</p>
<pre><code>$ date --utc
Tue Mar 24 18:12:44 UTC 2009</code></pre>
<p>Usually, you can shorten these options to a shorter value such as <strong><code>date -u</code></strong> (the shorter version often has only one hyphen).  Short options are quicker to type (use them when you are typing at the shell), whereas long options are easier to read (use them in scripts).<br />
</p>
<p>Now let's say we wanted to look at yesterday's date instead of today's.  For this we would want to specify the <strong><code>--date</code></strong> argument (or shortly <strong><code>-d</code></strong>), which takes an argument of its own. The argument for an option is simply the word following that option. In this case, the command would be <code>date --date yesterday</code>.</p>
<p>Since options are just arguments, you can combine options together to create more sophisticated behaviour.  For instance, to combine the previous two options and get  yesterday's date in UTC you would type:</p>
<pre><code>$ date --date yesterday -u
Mon Mar 23 18:16:58 UTC 2009</code></pre>
<p>As you see, there are options that expect to be followed by an argument (<code>-d</code>, <code>--date</code>) and others that don't take any one (<code>-u</code>, <code>--utc</code>).  Passing a little bit more complex argument to the <code>--date</code> option allows you to obtain some interesting information, for example whether this year is a leap year (in which the last day of February is 29).  You need to known what day immediately precedes the 1st of March:</p>
<pre><code>$ date --date &quot;1march yesterday&quot; -u
Sat Feb 28 00:00:00 UTC 2009</code></pre>
<p>The question you posed to <code>date</code> is: if today were the 1st of March of the current year, what date would it be yesterday?  So no, 2009 is not a leap year.  It may be useful to get the weekday of a given date, say the 2009 New Year's Eve:</p>
<pre><code>$ date -d 31dec +%A
Thursday</code></pre>
<p>which is the same as:</p>
<pre><code>$ date --date 31december2009 +%A
Thursday</code></pre>
<p>In this case we passed to <code>date</code> the option <code>-d</code> (<code>--date</code>) followed by the New Year's Eve date, and then a special argument (that is specific to the <code>date</code> command). ⁞ Commands may once in a while have strange esoteric arguments...  The <code>date</code> command can accept a <em>format</em> argument starting with a plus (<code>+</code>).  The format <code>%A</code> asks to print the weekday name of the given date (while <code>%a</code> would have asked to print the abbreviated weekday: try it!).  For now don't worry about these hermetic details: we'll see how to obtain help from the command line in learning command details.  Let's only nibble a more savory morsel that combines the <code>echo</code> and <code>date</code> commands:</p>
<pre><code>$ echo &quot;This New Year&#39;s Eve falls on a $( date -d 31dec +%A )&quot;
This New Year&#39;s Eve falls on a Thursday</code></pre>
<h2>Repeating and editing commands<br />
</h2>
<p>Use the <strong>Up-arrow</strong> key to retrieve a command you issued before.  You can move up and down using arrow keys to get earlier and later commands.  The <strong>Left-arrow</strong> and <strong>Right-arrow</strong> keys let you move around inside a single command.  Combined with the <strong>Backspace</strong> key, these let you change parts of the command and turn it into a new one.  Each time you press the <strong>Enter</strong> key, you submit the modified command to the terminal and it runs exactly as if you had typed it from scratch.</p>
<p><span id="ch006_moving-around.xhtml"></span></p>
<h1>Moving Around</h1>
<p>Anyone who has used a graphical interface has moved between folders. A typical view of folders appears in Figure 1, where someone has opened a home directory, then a folder named &quot;my-stuff&quot; under that, and a folder named &quot;music&quot; under that.</p>
<p><em>Figure 1 : Folders</em><br />
</p>
<p>When you use the command line, folders are called directories. That's just an older term used commonly in computing to refer to collections of things. (Try making an icon that suggests &quot;directory&quot;). Anything you do in a folder on the desktop is reflected in the directory when you're on the command line, and vice versa. The desktop and the command line provide different ways of viewing a directory/folder, and each has advantages and disadvantages.<br />
</p>
<p>Files contain your information--whether pictures, text, music, spreadsheet data, or something else--while the directories are containers for files. Directories can also store other directories. You'll be much more comfortable with the command line once you can move around directories, view them, create and remove them, and so on.</p>
<blockquote>

</blockquote>
<p>Directories are organized, in turn, into filesystems. Your hard disk has one type of filesystem, a CD-ROM or DVD has another, a USB mass storage device has yet another, and so on. That's why a CD-ROM, DVD, or USB device shows up as something special on the desktop when you insert it. Luckily, you don't have to worry much about the differences because both the desktop and the terminal can hide the differences. But sometimes in this book we'll talk about the information a filesystem has about your files.</p>
<blockquote>

</blockquote>
<p>The &quot;first&quot; directory is called the root and is represented by the name / (just a forward slash).  You can think of all the directories and files on the system as a tree that grows upside-down from this root (Figure 2):</p>
<p><img src="static/desktop_home_vim-en.png" alt="desktop_home_vim.png" width="600" height="557" /></p>
<p><em>Figure 2 : Root Directory</em><br />
</p>
<h2>Absolute and relative paths<br />
</h2>
<p>Every file and directory in the system has an &quot;address&quot; called its absolute path or sometimes just its path.  It describes the route you have to follow starting from the root that would take you to that particular file or directory.</p>
<p>For example, suppose you like the vim editor that we'll introduce in a later chapter, and are told you can start it by running the command <code>/usr/bin/vim</code>. This point underlines what we said in an earlier chapter: commands are just executable files. So the vim editor is a file with the path <em>/usr/bin/vim</em>, and if you run that command <code>/usr/bin/vim</code> you will execute the editor. As you can see from these examples, the slash / is also used as a separator between directories.</p>
<p>Can you find <em>/usr/bin/vim</em> in Figure 2? The pathname can be interpreted as follows:</p>
<ol>
<li>Start at the root (/) directory.<br />
</li>
<li>Move from / down to a directory named <em>usr</em>.</li>
</ol>
<ol>
<li>Move from <em>usr</em> down to a directory named <em>bin</em>.</li>
<li><em>vim</em> is located in that directory.<br />
</li>
</ol>
<blockquote>
<em>You are just getting used to the command line, and it may feel odd to be typing while reading this book. If you feel any confusion in this section, try scribbling the directory tree in Figure 2 on paper. Draw arrows on the paper as you run the commands in this section, to help orient you to where you are.</em><br />

</blockquote>
<p>Note that you can't tell whether something is a file or a directory just by looking at its path.</p>
<p>When you work with the command line you will be always working &quot;in&quot; a directory.  You can find the path of this directory using the command <code>pwd</code> (print working directory), like this:</p>
<pre><code>$ pwd
/home/ben</code></pre>
<p>You can see that <code>pwd</code> prints an absolute path.  If you want to switch your working directory you can use the command <code>cd</code> (change directory) followed by an argument which points to the target directory:</p>
<pre><code>$ cd /</code></pre>
<p>You just changed your working directory to the root of the filesystem!  If you want to return to the previous directory, you can enter the command:</p>
<pre><code>$ cd /home/ben</code></pre>
<p>As an alternative, you can &quot;work your way&quot; back to <em>/home/ben</em> using relative paths.  They are called that because they are specified &quot;in relation&quot; to your current working directory.  If you go back to the root directory, you could enter the following commands:</p>
<pre><code>$ cd /
$ cd home
$ cd ben
$ pwd
/home/ben</code></pre>
<p>The first command changes your current working directory to the root. The second changes to <em>home</em>, relative to /, making your current working directory <em>/home</em>.  The third command changes it to <em>ben</em>, relative to <em>/home</em>, landing you in <em>/home/ben</em>.</p>
<h3>Good to be back home<br />
</h3>
<p>Every user in the system has a directory assigned to him or her, called the home directory.  No matter what your current working directory is, you can quickly return to your home directory like this:</p>
<pre><code>$ cd</code></pre>
<p>That is, enter the <code>cd</code> command without any arguments.</p>
<p>All your files and preferences are stored in your home directory (or its subdirectories). Every user of your system with a login account gets her own home directory. Home directories are usually named the same as users' login names, and are usually found in <em>/home</em>, although a few systems have them in <em>/usr/home</em>. When you start your terminal, it will place you in your home directory.</p>
<p>There's a special shortcut to refer to your home directory, namely the symbol ~ (usually called a tilde, and found near the very left top of most keyboards). You can use it as part of more complex path expressions, and it will always refer to your home directory. For example, <em>~/Desktop</em> refers to the directory called <em>Desktop</em> that usually exists within your home directory.</p>
<h3>The . and .. directories</h3>
<p>The entries . and .. are special and they exist in every directory, even the root directory itself (/). The first one is a shorthand for &quot;this directory&quot; while the latter is a shorthand for &quot;the parent directory of this directory.&quot;  You can use them as a relative path, and you can try and see what happens when you do this:</p>
<pre><code>$ pwd
/usr/bin
$ cd .
$ pwd
/usr/bin</code></pre>
<p>If <em>vim</em> is in <em>/usr/bin</em>, at this point you could run it by typing the relative path:</p>
<pre><code>$ ./vim</code></pre>
<p>Continuing from the previous example, you can do this:</p>
<pre><code>$ cd ..
$ pwd
/usr</code></pre>
<p>Since they are actual entries in the filesystem, you can use them as part of more complex paths, for example:</p>
<pre><code>$ cd /usr/bin
$ pwd
/usr/bin
$ cd ../lib
$ pwd
/usr/lib
$ cd ../..
$ pwd
/
$ cd home
$ pwd
/home
$ cd ../usr/bin
$ pwd
/usr/bin</code></pre>
<p>The parent directory of the root directory, /.., is root itself.<br />
</p>
<p>Try moving around your computer on the command line and you will soon get used to it!</p>
<p><span id="ch008_basic-commands.xhtml"></span></p>
<h1>Basic commands</h1>
<p>By now you have some basic knowledge about directories and files and you can interact with the command line interface.  We can learn some of the commands you'll be using many times each day.</p>
<h3>ls<br />
</h3>
<p>The first thing you likely need to know before you can start creating and making changes to files is <em>what's already there?</em>  With a graphical interface you'd do this by opening a folder and inspecting its contents. From the command line you use the program <code>ls</code> instead to list a folder's contents.</p>
<pre><code>$ ls
Desktop  Documents  Music  Photos</code></pre>
<p>By default, <code>ls</code> will use a very compact output format. Many terminals show the files and subdirectories in different colors that represent different file types.  Regular files don't have special coloring applied to their names.  Some file types, like JPEG or PNG images, or tar and ZIP files, are usually colored differently, and the same is true for programs that you can run and for directories.  Try <code>ls</code> for yourself and compare the icons and emblems your graphical file manager uses with the colors that ls applies on the command line.  If the output isn't colored, you can call <code>ls</code> with the option <code>--color</code>:</p>
<pre><code>$ ls --color</code></pre>
<h3>man, info &amp; apropos<br />
</h3>
<p>You can learn about options and arguments using another program called <code>man</code> (<code>man</code> is short for manual) like this:</p>
<pre><code>$ man ls</code></pre>
<p>Here, <code>man</code> is being asked to bring up the manual page for <code>ls</code>. You can use the arrow keys to scroll up and down in the screen that appears and you can close it using the <strong>q</strong> key (for quit).</p>
<p>An alternative to obtain a comprehensive user documentation for a given program is to invoke <code>info</code> instead of <code>man</code>:</p>
<pre><code>$ info ls</code></pre>
<p>This is particularly effective to learn how to use complex GNU programs.  You can also browse the <code>info </code>documentation inside the editor Emacs, which greatly improves its readability.  But you should be ready to take your first step into the larger world of Emacs.  You may do so by invoking:</p>
<pre><code>$ emacs -f info-standalone</code></pre>
<p>that should display the Info main menu inside Emacs (if this does not work, try invoking <code>emacs</code> without arguments and then type <strong>Alt + x info</strong>, i.e. by depressing the <strong>Alt</strong> key, then pressing the <strong>x</strong> key, then releasing both keys and finally typing <strong>info</strong> followed by the <strong>Return</strong> or <strong>Enter</strong> key).  If you type then <strong>m ls</strong>, the interactive Info documentation for <code>ls</code> will be loaded inside Emacs.  In the standalone mode, the <strong>q</strong> key will quit the documentation, as usual with <code>man</code> and <code>info</code>.<code></code></p>
<p>Ok, now you know how to learn about using programs yourself.  If you don't know what something is or how to use it, the first place to look is its <code>man</code>ual and <code>info</code>rmation pages.  If you don't know the name of what you want to do, the <code>apropos</code> command can help.  Let's say you want to rename files but you don't know what command does that.  Try <code>apropos</code> with some word that is related to what you want, like this:<br />
</p>
<pre><code>$ apropos rename
...
mv (1)               - move (rename) files
prename (1)          - renames multiple files
rename (2)           - change the name or location of a file
...</code></pre>
<p>Here, <code>apropos</code> searches the manual pages that <code>man</code> knows about and prints commands it thinks are related to renaming.  On your computer this command might (and probably will) display more information but it's very likely to include the entries shown.</p>
<p>Note how the program names include a number besides them.  That number is called their <em>section</em>, and most programs that you can use from the command line will be in section 1.  You can pass <code>apropos</code> an option to display results from section 1 manuals only, like this:</p>
<pre><code>$ apropos -s 1 rename
...
mv (1)               - move (rename) files
prename (1)          - renames multiple files
...</code></pre>
<p>At this stage, the section number isn't terribly important.  Just know that section 1 manual pages are the ones that apply to programs you use on the command line.  To see a list of the other sections, look up the manual page for man using <code>man man</code>.<br />
</p>
<h3>mv<br />
</h3>
<p>Looking at the results from <code>apropos</code>, that <code>mv</code> program looks interesting.  You can use it like this:</p>
<pre><code>$ mv oldname newname</code></pre>
<p>Depending on your system configuration, you may not be warned when renaming a file will overwrite an existing file whose name happens to be <code>newname</code>.  So, as a safe-guard, always use `-i' option when issuing <code>mv</code> like this:</p>
<pre><code>$ mv -i oldname newname</code></pre>
<p>Just as the description provided by <code>apropos</code> suggests, this program moves files.  If the last argument happens to be an <em>existing</em> directory, <code>mv</code> will move the file to that directory instead of renaming it. Because of this, you can provide <code>mv</code> more than two arguments:</p>
<pre><code>$ mv one_file another_file a_third_file ~/stuff</code></pre>
<p>If <em>~/stuf</em>f exists, then <code>mv</code> will move the files there.  If it doesn't exist, it will produce an error message, like this:</p>
<pre><code>$ mv one_file another_file a_third_file stuff
mv: target &#39;stuff&#39; is not a directory</code></pre>
<h3>mkdir<br />
</h3>
<p>How do you create a directory, anyway?  Use the <code>mkdir</code> command:</p>
<pre><code>$ mkdir ~/stuff</code></pre>
<p>And how do you remove it?  With the <code>rmdir</code> command:</p>
<pre><code>$ rmdir ~/stuff</code></pre>
<p>If you wish to create a subdirectory (say the directory <em>bar</em>) inside another directory (say the directory <em>foo</em>) but you are not sure whether this one exists or not, you can ensure to create the subdirectory <em>and</em> (if needed) its parent directory without raising errors by typing:</p>
<pre><code>$ mkdir -p ~/foo/bar</code></pre>
<p>This will work even for nested sub-sub-...-directories.<br />
</p>
<p>If the directory you wish to remove is not empty, <code>rmdir</code> will produce an error message and will not remove it.  If you want to remove a directory that contains files, you have to empty it first.  To see how this is done, we will need to create a directory and put some files in it first.  These files we can remove safely later.  Let's start by creating a directory called <em>practice</em> in your home and change the current working directory there:</p>
<pre><code>$ mkdir ~/practice
$ cd ~/practice</code></pre>
<h3>cp, rm &amp; rmdir<br />
</h3>
<p>Now let's copy some files there using the program <code>cp</code>.  We are going to use some files that are very likely to exist on your computer, so the following commands should work for you:</p>
<pre><code>$ cp /etc/fstab /etc/hosts /etc/issue /etc/motd .
$ ls
fstab  hosts  issue  motd</code></pre>
<p>Don't forget the dot at the end of the line!  Remember it means &quot;this directory&quot; and being the last argument passed to<code> cp</code> after a list of files, it represents the directory in which to copy them.  If that list is very long, you'd better learn using <em>globbing</em> (expanding file name patterns containing wildcard characters into sets of existing file names) or some other tricky ways to avoid wasting your time in typing file names.  One trick can help when dealing with the copy of an entire directory content.  Passing to <code>cp</code> the option <code>-R</code> you can recursively copy all the files and subdirectories from a given directory to the destination:</p>
<pre><code>$ cp -R . ~/foo
$ ls ~/foo
bar  fstab  hosts  issue  motd
$ cp -R . ~/foo/bar
$ ls -R ~/
~/foo:
bar  fstab  hosts  issue  motd

~/foo/bar:
fstab  hosts  issue  motd</code></pre>
<p>In this case the current directory has no subdirectories so only files were copied.  As you can see, the option <code>-R</code> <code></code>can be passed even to <code>ls</code> to list recursively the content of a given directory and of its subdirectories.</p>
<p>Now, if you go back to your home and try to remove the directory called <em>practice</em>, <code>rmdir</code> will produce an error message:</p>
<pre><code>$ cd ..
$ rmdir practice
rmdir: failed to remove &#39;practice&#39;: Directory not empty</code></pre>
<p>You can use the program <code>rm</code> to remove the files first, like this:</p>
<pre><code>$ rm practice/fstab practice/hosts practice/issue practice/motd</code></pre>
<p>And now you can try removing the directory again:</p>
<pre><code>$ rmdir practice </code></pre>
<p>And now it works, without showing any output.</p>
<p>But what happens if your directories have directories inside that also have files, you could be there for weeks making sure each folder is empty!  The <code>rm</code> command solves this problem through the amazing option <code>-R</code>, which as usual stands for &quot;recursive&quot;.  In the following example, the command fails because <em>foo</em> is not a plain file:<br />
</p>
<pre><code>$ rm ~/foo/
rm: cannot remove `~/foo/`: Is a directory</code></pre>
<p>So maybe you try <code>rmdir</code>, but that fails because <em>foo</em> has something else under it:</p>
<pre><code>$ rmdir ~/foo
rmdir: ~/foo: Directory not empty</code></pre>
<p>So you use <code>rm -R</code>, which succeeds and does not produce a message.<br />
</p>
<pre><code>$ rm -R ~/foo/</code></pre>
<p>So when you have a big directory, you don't have to go and empty every subdirectory.<br />
</p>
<p>But be warned that <code>-R</code> is a very powerful argument and you may lose data you wanted to keep!</p>
<h3><strong>cat &amp; less</strong><br />
</h3>
<p>You don't need an editor to view the contents of a file.  What you need is just to display it.  The <code>cat</code> program fits the bill here:</p>
<pre><code>$ cat myspeech.txt
Friends, Romans, Countrymen! Lend me your ears!</code></pre>
<p>Here, <code>cat</code> just opens the file <em>myspeech.txt</em> and prints the entire file to your screen, as fast as it can.   However if the file is really long, the contents will go by very quickly, and when <code>cat</code> is done, all you will see are the last few lines of the file.  To just view the contents of a long file (or any text file) you can use the <code>less</code> program:</p>
<pre><code>$ less myspeech.txt</code></pre>
<p>Just as with using <code>man</code>, use the arrow keys to navigate, and press <strong>q</strong> to quit.<br />
</p>
<p><span id="ch009_standard-files.xhtml"></span></p>
<h1>More about redirection</h1>
<p>How do pipes work? They use three communication channels provided to every executing command.</p>
<p><strong>stdin</strong> (standard input) by default is what we type on the keyboard. We can use &quot;&lt;&quot; with a filename to make a program take input from a file.</p>
<p><strong>stdout</strong> <strong></strong> (standard output) by default is printed on your computer screen. We can use &quot;&gt;&quot; with a filename to send that to a file, overwriting whatever is there, or we can use &quot;&gt;&gt;&quot; to append standard output to the end of the file.</p>
<p><strong>stderr</strong> (standard error)  is an alternative kind of output. Programs use it to send error messages. This can be useful because you might want to see error messages on the terminal even if you redirect output to a file. Here's an example:</p>
<pre><code>$ ls *.bak &gt; listfile
ls: *.bak: No such file or directory</code></pre>
<p>Here, we wanted a list of all files ending in <em>.bak</em>. But no such files exist in this directory. If <code>ls</code> sent its error message to standard output (which in this case has been directed to a file), we wouldn't know that there is a problem without looking at the content of <em>listfile</em>. But because <code>ls</code> sent its message to standard error, we see it. The error message starts with the name of the program (<code>ls</code>) followed by a colon and the actual message.</p>
<p>A pipe simply redirects the standard output of the first program to the standard input of the second:</p>
<pre><code>$ ls *.bak | more</code></pre>
<p>Sometimes, we want to direct the output of a command to a file, but we also want to see the output as the program runs. The <code>tee</code> command does just that:</p>
<pre><code>$ ls -lR / | tee allMyFiles</code></pre>
<p>provides a complete, detailed list of your file system, saved to <em>allMyFiles</em>. This takes some time to run; <code>tee</code> saves you from staring at a lifeless screen, wondering whether any thing's happening.</p>
<p>Each program can open a lot of files, and each has a number called a <em>file descriptor</em> that is meaningful only within that program. The first three numbers are always reserved for the file descriptors we just described.</p>
<table>
<tbody>
<tr class="odd">
<td> stdin</td>
<td> 0</td>
</tr>
<tr class="even">
<td> stdout</td>
<td> 1</td>
</tr>
<tr class="odd">
<td> stderr</td>
<td> 2</td>
</tr>
</tbody>
</table>
<h2>Redirecting stderr</h2>
<p>When we redirect stdin as we did above, error messages still go to the screen.  For example</p>
<pre><code>$ ls /nosuchplace &gt; /dev/null
ls: /nosuchplace: No such file or directory
$</code></pre>
<p>To redirect stderr we have to use the more general form of redirection, which uses the file numbers mentioned in the previous section, and looks like this.</p>
<pre><code>$ ls /nosuchplace 2&gt;/tmp/errors
$</code></pre>
<p>This sends the error message sent to file number 2 (<em>stderr</em>) into the file <em>/tmp/errors</em>. </p>
<p>Now we can introduce a more complex redirection, which redirects standard output and standard error to the same file:</p>
<pre><code>$ ls *.bak &gt; listfile 2&gt;&amp;1</code></pre>
<p>The &amp; in that command has nothing to do with putting a command in the background. The &amp; here must directly follow the &gt; character, and it sends file number 2 onto file number 1.</p>
<p>Or in the case of a pipe, put this before the pipe:</p>
<pre><code>$ ls *.bak 2&gt;&amp;1 | more</code></pre>
<h2>Adding more descriptors</h2>
<p>Sometimes it is convenient to keep other files open and add to them in dribs and drabs. You can do this with redirection and <code>exec</code>.</p>
<pre><code>$ exec 3&gt;/tmp/thirdfile
$ exec 4&gt;/tmp/fourthfile
$ echo drib &gt;&amp;3
$ echo drab &gt;&amp;4
$ echo another drib &gt;&amp;3
$ echo another drab &gt;&amp;4
$ exec 3&gt;&amp;-
$ exec 4&gt;&amp;-</code></pre>
<p>The first two lines open connections to two more file descriptors, 3 and 4.  We can then echo text onto them, redirect programs into them, etc. using <code>&gt;&amp;3</code> or <code>&gt;&amp;4</code>.  Finally, we close them with the <code>3&gt;&amp;-</code> and <code>4&gt;&amp;-</code> syntax.<br />
</p>
<p><span id="ch010_cut-down-on-typing.xhtml"></span></p>
<h1>All That Typing...</h1>
<p>So, all this typing has got to stop being fun at some point. Fortunately, the command line offers a number of ways to make your work more efficient.</p>
<h2>Auto Completion</h2>
<p>Every keyboard has a <strong>Tab</strong> key, and its a very useful thing to have in the terminal. You might have used this keystroke before to indent words in a word processor. You can still do this in GNU/Linux word processors, but when you use <strong>Tab</strong> in the GNU/Linux terminal it becomes such a time saver that when you master it you will be using it all the time.</p>
<p>Essentially, the <strong>Tab</strong> is an auto-complete command. If, for example, I want to move the file 'dsjkdshdsdsjhds_ddsjw22.txt' somewhere with the <code>mv</code> command I can either type out every letter of the stupid filename, or I can type <code>mv</code> (for 'move') followed by the first few letters of the filename and press <strong>Tab</strong>. The rest of the filename will be automagically filled in. If the filename is not filled in it means that there are several files (or directories) that start with those first few letters I typed. To remedy this I could type a few more letters of the filename and press <strong>Tab</strong> again, or to help me out I could press <strong>Tab</strong> twice and it will give me a list of files that start with those letters.</p>
<p>You can also use <strong>Tab</strong> to auto-complete command names. </p>
<p><strong>Tab</strong> is your friend, use it a lot.</p>
<h2>Copy and Paste</h2>
<p>Just because you are working on the command line doesn't mean you can't use some of the conveniences you are used to in the GUI. While cut and paste may work a little differently here from its behavior in other operating systems, you'll soon find it very intuitive.</p>
<p><strong>Copying text</strong> is as simple as highlighting the text you wish to copy by holding down the left mouse button and highlighting the text as you are probably already used to doing. Or, left-click 2 times to select a word or 3 times to select a line.<br />
</p>
<p><strong>Pasting text</strong> The highlighted text that you just copied is held in the clipboard until you paste it where your cursor is by clicking the middle (wheel) mouse button.</p>
<p><strong>Note :</strong> if your mouse only has two buttons, pressing <em>both together</em> will be recognized as a &quot;middle button&quot; press.<br />
</p>
<p>Anyway, it works like that in a non-graphical terminal. You may find that it is not quite like this on the desktop. So it may be a good idea to log in a text session. Use &lt;<strong>ctrl</strong>&gt;&lt;<strong>alt</strong>&gt;&lt;<strong>F1</strong>&gt; to get out of the desktop. </p>
<p>Try it! Select the paragraph below with the left mouse button, open a new virtual terminal, and paste the text with the middle mouse button.</p>
<pre><code> echo &quot;This is pasted text.&quot;</code></pre>
<p>After you see the text in the terminal, press the <strong>Enter</strong> key and the <code>echo</code> command will repeat the text between the quotes on the command line.</p>
<p><strong>Note :</strong> If you are copying text from a web page, sometimes the punctuation isn't handled properly. You might actually copy some unseen formatting along with the text, which will break the syntax of the command you are copying.</p>
<h2>History</h2>
<p>It is also possible to use the up and down arrows on the keyboard to navigate back and forwards through the history of the commands you have typed. When you navigate to an earlier command this way, it is then just necessary to press the <strong>Return</strong> or <strong>Enter</strong> key and the command will be re-executed. You can edit it first to make it do something different.<br />
</p>
<p><span id="ch011_superusers.xhtml"></span></p>
<h1>The Superuser (Root)</h1>
<p>Some parts of the computer system are thought to require special protection (because they do). If somebody can change the basic <code>cat</code> or <code>less</code> command, for instance, they could cause you to corrupt your own files. So certain commands can be run and certain files can be accessed only by a user logged in with special privileges called <em>superuser</em> or <em>root</em> privileges.</p>
<p>In the days when computer systems cost hundreds of thousands of dollars and were shared by hundreds of people, <em>root</em> was assigned to an actual person (or a small group) who constituted a kind of priesthood. Nowadays every owner of a PC can execute superuser commands (this is not always true on mobile devices, though). There is still a user account on each GNU/Linux system called <em>root</em>. This allows the system to make this user the owner of sensitive system files.</p>
<p>The <em>root</em> user, incidentally, has nothing to do with the root directory (the / directory) in the filesystem.</p>
<p>Superuser commands are powerful and must be used carefully, but their use is quite common. For instance, whenever a desktop user installs software, he or she must become superuser for a few minutes.</p>
<h2>The sudo Command</h2>
<p>On many modern systems, whenever you want to enter a superuser command, you just precede it with <code>sudo</code>:</p>
<pre><code>$ sudo rm -r /junk_directory</code></pre>
<p>You are then prompted for your password, so nobody walking up casually to your system could execute a dangerous command. The system keeps your password around for a while, so you can enter further superuser commands without the bother of re-entering the password.</p>
<p>Systems also provide a <code>su</code> command that logs you in as superuser and gives you a new shell prompt. Not all systems allow users to use it, though, because you can get carried away, start doing everyday work as superuser --and suddenly realize you've trashed your system through a typo. It is much safer to do your home system administration using <code>sudo</code>.</p>
<p>If other people share your system and you want to give someone superuser privileges, for this you need to know a little more about System Administration.</p>
<p><span id="ch012_redirection.xhtml"></span></p>
<h1>Redirection</h1>
<p>Output redirection is one of the very powerful, and easily misunderstood, parts of the shell. To decrease misunderstandings, we'll keep to the basics.</p>
<p>The &gt; operator (an &quot;operator&quot; is a symbol like +,-,&lt;,&gt; that represents a specific action) is for redirecting output.  In a very simple example, if you want to list the files in a directory, you type <code>ls</code>.  That output goes to your screen.  If you want that list instead to go to a file, however, you'd do something like this:</p>
<pre><code>$ ls &gt; my-file-list </code></pre>
<p>The file <em>my-file-list</em> now contains a list of all of the files, directories, links and other things in the current working directory with names that do not start with '.'. (Note that the shell creates, if necessary, the files used for redirection before executing the command, so the file <em>my-file-list</em> wil also be included in your list.)</p>
<p>The &gt; operator is a &quot;clobbering&quot; operator -- if you are outputting to an existing file, it will overwrite the old contents. Sometimes, especially if you are keeping a logfile, what you want is the &gt;&gt; operator.  It works the same way as the &gt; operator, except that it appends to the end of an existing file.  (If the file doesn't yet exist, it creates it.)</p>
<p>There are other places you can redirect output to, like device special files such as terminals, or <em>/dev/null</em>, which is an infinitely big empty bucket (or more accurately it just ignores all input).  If you have a program that you know will produce voluminous output you don't care about, you could do this:</p>
<pre><code>$ bigprogram &gt; /dev/null</code></pre>
<p>The program will execute normally, but you won't see its normal output.  (You would, however, see any of its error output; more detail below under File Descriptors).</p>
<p>The &lt; operator is for redirecting input.  Most programs that would expect input from your terminal are happy to accept it from another source instead, such as an existing file.</p>
<p>For example, if you wish to email the contents of <em>myfile.txt</em> to joe you could do this:</p>
<pre><code>$ mail joe &lt; myfile.txt</code></pre>
<p>The redirection operators are particularly relevant for jobs running in the background.  When working with a graphical interface, you are already familiar with the concept of switching windows by, for example, minimizing the current window that is being engaged in playing musics and restoring another window to resume browsing the Internet.  Such a situation also happens when you are working with a command-line interface.  However, instead of minimizing the command to play your music files, you run it in background by appending an ampersand (&amp;) at the end of the command like this:</p>
<pre><code>$ ogg123 *.ogg &amp;</code></pre>
<p>Alas, any output it produces like announcing a new track along with its title and description goes to your terminal as usual cluttering your text-based Internet browser's screen.  So, you may want to avoid it.  Many programs have a silent mode to suppress the normal output.  Usually this mode can be enabled using the options <code>-q</code> or <code>--quiet</code>, but this is not a general convention and you should read the <code>man</code> or <code>info</code> documentation before relying on these options.  If you want to be sure avoiding any output irrespective of gentle program options, you can easily do so by redirecting the output to a file.  For instance, the following command places the output of <code>ogg123</code> into <em>/dev/null</em> because you do not care about any track announcement as long as the musics keep playing and any error messages into <em>music_err</em> so that you can easily find out why the musics suddenly stop playing.  This way, no output can confuse you by appearing at the terminal and you can always have a look at the result at a later time by doing something like <code>cat music_err</code>:<br />
</p>
<pre><code>$ ogg123 *.ogg &gt;/dev/null 2&gt;music_err &amp;</code></pre>
<p>A program running in the background cannot accept input from the terminal.  So if you mistakenly put such a program in the background (and don't redirect input from a file through the &lt; operator), it will get stuck waiting when it has to accept input.</p>
<p><span id="ch014_multiple-files.xhtml"></span></p>
<h1>Cheaper by the dozen</h1>
<p>After getting used to the command line, you will start looking for ways to do more in less time.  One of the easiest ways to achieve that is to work on multiple files at the same time, so that instead of:</p>
<pre><code>$ rm this
$ rm that
$ rm here
$ rm there</code></pre>
<p>you just remove all those files with one command. Many commands, including <code>rm</code>, let you simply specify all the files you want to delete as arguments in one go:</p>
<pre><code>$ rm this that here there</code></pre>
<ol>
</ol>
<p>Still, there has to be a better way!<br />
</p>
<h2>Globbing</h2>
<p>File globbing is the shell's way of dealing with multiple files with the fewest characters possible.  The shell treats certain characters as codes that you can use to specify groups of things you want the commands to affect. These characters are commonly called &quot;wildcards&quot; because they're like a card in a game that the players have designated to represent anything you want. <br />
</p>
<h3><strong>The &quot;*&quot; Wildcard</strong></h3>
<p>Imagine a directory of files:</p>
<pre><code>$ ls
here  that  there  this</code></pre>
<p>that you want to delete.  A tedious job can be turned simple by using the * or asterisk wildcard.</p>
<pre><code>$ rm *</code></pre>
<p>When used by itself, the asterisk wildcard refers to all the items in the directory except for those with names starting with &quot;.&quot;. We say that the shell <em>expands</em> the wildcard. Knowing what's in the directory, the shell substitutes those filenames for the asterisk and effectively executes the following command:</p>
<pre><code>$ rm here that there this</code></pre>
<p>You can combine * with other characters, however, to make it selective.</p>
<pre><code>$ rm t*
$ ls
here</code></pre>
<p>What happened here? The shell looked at &quot;t&quot; first and then expanded the asterisk to cover all the files that begin with &quot;t&quot;.  If you had requested &quot;h*&quot; instead, the shell would have removed any file that started with an &quot;h&quot;. Let's make the directory like it was and then remove the &quot;h&quot; files:<br />
</p>
<pre><code>$ touch that there this
$ rm h*
$ ls
that  there  this</code></pre>
<p>The asterisk wildcard can be placed anywhere within a word. Let's switch to an <code>ls</code> command because it's easier to see what's happening with wildcards:<br />
</p>
<pre><code>$ ls th*re
there</code></pre>
<p>By switching from <code>rm</code> to <code>ls</code> we see an important aspect of wildcard: you can use them with any command, because the shell interprets them before it even invokes the command. In fact, you can't issue a command <em>without</em> taking into account the behavior of wildcards, because they're a feature of the shell.  (Luckily, you're not likely to ever have to deal with a filename that contains a real asterisk.)<br />
</p>
<p>Multiple asterisks can also be used together. For instance, in this way you can find filenames where the middle of a series is the same, but they start and end differently. Let's try it on the original four files:<br />
</p>
<pre><code>$ ls *i*
this</code></pre>
<p>People often use the asterisk to remove files that are all of one type. For instance, if you've been working with a lot of photos and want to clean up files ending in <em>.jpg</em> when you're finished, you can remove all the ones in the current directly as follows:</p>
<pre><code>$ rm *.jpg</code></pre>
<p>Suppose you have some files ending in  <em>.jpg</em> and some ending in <em>.jpeg</em>. The asterisk still makes clean-up easy:</p>
<pre><code>$ ls *.jp*g</code></pre>
<p>And suppose the JPEG files are scattered among several subdirectories. You have directories named photos1, photos2, photos3, and so forth, each containing JPEGs you want to remove. A wildcard can help you list all the contents of those subdirectories:</p>
<pre><code>$ ls photos*
photos1:
centraal_station.jpg    nieuwe_kerk.jpg

photos2:
ica.jpeg                sanders_theater.jpeg

photos3:
bayeux_cathedral.jpeg   rouen_cathedral.jpeg    travel.odt</code></pre>
<p>And you can specify a directory along with the filenames you remove:</p>
<pre><code>$ rm photos*/*.jp*g
$ ls photos*
photos1:

photos2:

photos3:
travel.odt</code></pre>
<p>Only the <em>travel.odt</em> file remains (because it doesn't match &quot;.jp*g&quot;) as a record of all the trips you've taken.<br />
</p>
<p>There is, however, one limit to the asterisk wildcard.  By default, it will not match any hidden files (those with filenames that start with a dot, you need to <code>ls -a</code> to see these).</p>
<pre><code>$ ls -a
.
..
.hidden
this
that
here
there
$ rm *
$ ls -a 
.
..
.hidden</code></pre>
<p>If you want those hidden files deleted by a wildcard it is necessary to append a dot to the front of the wildcard. Note that normal files (those that are not hidden/do not start with a dot) will not be deleted when you do this:<br />
</p>
<pre><code>$ ls -a
.
..
.hidden
here
$ rm .*
$ ls -a 
.
..
here</code></pre>
<p>Finally, it's important to note that the asterisk can also match nothing when appropriate, as seen in the following example:</p>
<pre><code>$ ls task*
task  taskA  taskB  taskXY</code></pre>
<p> This is because the asterisk matches zero or more occurrences.  So, as in this example, &quot;task*&quot; matches any filename that starts with &quot;task&quot; even if it only consists of just &quot;task&quot;.</p>
<p><strong>CAUTION:</strong> When you use just an asterisk (&quot;*&quot;) with <strong><code>rm</code></strong>, and basically any other command, it is always a good idea to put an option terminator (&quot;--&quot;) before the wildcard like this:</p>
<pre><code>$ rm -- *</code></pre>
<p>Take this case for example:<br />
</p>
<pre><code>$ ls
-r    directory1    directory2    file1.txt$ rm *</code></pre>
<p>Normally, <strong>rm</strong> will not remove sub-directories and their contents, however, in this case everything in the directory will be removed even the sub-directories. This is because the asterisk(&quot;*&quot;) is expanded to &quot;-r directory1 directory2 file1.txt&quot;. Although &quot;-r&quot; is a filename, <strong><code>rm</code></strong> will confuse it as an option and think it has been told to delete the directories and their contents as well. Using an the option terminator (&quot;--&quot;) will prevent <strong><code>rm</code></strong> from treating anything following the terminator as an option. Therefore, generally it is a good idea to always use an option terminator after typing a command and its options, if there is any, to prevent the command from treating a filename as an option.<br />
</p>
<h3><strong>The &quot;?&quot; Wildcard</strong><br />
</h3>
<p>The &quot;?&quot; or question mark wildcard is very similar to the asterisk wildcard.  The crucial difference is that the question mark wildcard takes the place of only one character.</p>
<pre><code>$ ls task*
task  taskA  taskB  taskXY
$ ls task?
taskA  taskB
$ ls task??
taskXY</code></pre>
<p>As we've already seen, the asterisk matches all the files beginning with &quot;task&quot;. A single question mark matches files that have a single character after &quot;task&quot;. The double question mark requires exactly two characters in that position.<br />
</p>
<h3><strong>The &quot;[ ]&quot; Wildcards</strong></h3>
<p>The square brackets wildcards can get even more specific, denoting a ranges of characters.The following <code>ls</code> command includes a <code>-1</code> (the digit &quot;one&quot;) option, which means &quot;list one entry on each line.&quot; This makes it easier to see how the files in this example differ.<br />
</p>
<pre><code>$ ls -1
file_1
file_2
file_3
file_a
file_b
file_c </code></pre>
<p>By using the square brackets, you can remove specific files without typing every name completely.</p>
<pre><code>$ rm file_[13ac]
$ ls -1
file_2
file_b</code></pre>
<p>Furthermore, within the square brackets, the order of the characters doesn't matter.<br />
</p>
<p>Combining square brackets with a hyphen, you can also do ranges of files. Let's start with a directory containing lots of files ending in numbers:</p>
<pre><code>$ ls
file_1
file_2
file_3
...
file_9</code></pre>
<p>At first it might be tempting to use the asterisk wildcard here.  However, what if we need to remove only files 2-6? We could list each suffix in the brackets, but you would still have to type five numbers.  Fortunately, there is a much easier way.</p>
<pre><code>$ rm file_[2-6]</code></pre>
<p>Now the only files left are files 1 and 7-9.  By using the dash between a set of numerals in the square brackets, you make the shell expand the pattern by creating a name with every number between the starting value to the left of the dash and the end value to the right.</p>
<p>Ranges aren't just for numbers.  They can also use letters.</p>
<pre><code>$ ls -1
file_a
file_b
file_c
file_d
$ rm file_[a-c]
$ ls -1
file_d</code></pre>
<p>Both letters and ranges can be combined into the same instance of square brackets.</p>
<pre><code>$ ls -1
file_a
file_b
file_c
file_1
file_2
$ rm file_[a-c12]
$ ls</code></pre>
<p> Character groups can be inverted by prefixing them with the <strong>^</strong> (caret) character:</p>
<pre><code>$ ls -1
file_a
file_b
file_c
file_d
file_1
file_2
$ ls -1 file_[^c-z2-9]
file_a
file_b
file_1</code></pre>
<p><strong>CAUTION:</strong> Ranges can, at times, be tricky things. For one, their order can be affected by the current locale settings (in some locales [A-C] could mean the same as [ABCabc], while in others it could be equivalent to [ABC]). A good rule of thumb is to always know which files you are working with. You can do this by simply substituting <strong>echo</strong> or <strong>ls</strong> for whatever command you intend to run, such as:</p>
<pre><code>$ ls -1 file[A-b]
fileA
fileB
filea
fileb</code></pre>
<p>This allows you to ensure the pattern matches the files you want to work with.<br />
</p>
<h2>Brace Expansion</h2>
<p>We've seen the ability to get a range of characters or letters that fall in a single digit range (0-9 in our examples) but what about when you need to match a range of files that uses double or even triple digits?</p>
<pre><code>$ ls -1
file_1
file_2
file_3
...
file_78
$ rm file_[1-20]
$ ls -1
file_3
...
file_78</code></pre>
<p>Since the brackets glob can only interpret single character ranges it interprets, &quot;1-20&quot; not as a range but as the characters: &quot;1&quot;, &quot;-&quot;, &quot;2&quot;, and &quot;0&quot;.   Causing only &quot;file_1&quot; and &quot;file_2&quot; to be deleted because they are the only ones that match.  If you want to access ranges larger than 0-9, you have to using Bash's brace expansion, &quot;{start..end}&quot;.</p>
<pre><code>$ rm file_{1..20}</code></pre>
<p>In a brace range the double dot is the delimiter instead of a dash. </p>
<p>Braces can also be used when you need to get a series of files that have a common pattern but subtle differences.  Such as with:</p>
<pre><code>$ ls
file.txt
file.pdf
file.pl
file.odf</code></pre>
<p>If you just wanted to delete the <em>pdf</em>, <em>odf</em>, and <em>txt</em> files you could specify a comma separated list of strings in a brace pair:</p>
<pre><code>$ rm file.{txt,pdf,odf}
$ ls
file.pl</code></pre>
<h2>Globbing When No File Matches</h2>
<p>Suppose you specify a wildcard and the shell can't find any matching filename:</p>
<pre><code>$ ls -1
file_a
file_b
file_c
file_d
$ rm file?
rm: cannot remove `file?&#39;: No such file or directory</code></pre>
<p>When there is no file to match a pattern, the shell passes the wildcard to the program unexpanded.  That's why you get an error message from the <code>rm</code> program, not from the shell.<br />
</p>
<h2>Disabling A Wildcard</h2>
<p>Okay, we know the shell will pass a wildcard as an option to a program when it can't find a file, but what do we do when we want to send a character that also happens to be a wildcard to our program? Here's a common example: we want to search a file for every occurrence of an asterisk.</p>
<pre><code>$ ls 
2file
*file
*?****[a-b]</code></pre>
<p>Now we happen to want *file, but we get:</p>
<pre><code>*file   2file                                                                   </code></pre>
<p>Why? Because the asterisk is a wildcard, the shell expanded it before sending it to <code>ls</code>.  So after expansion, the command would look like:</p>
<pre><code>$ ls *file 2file</code></pre>
<p>If we want <code>ls</code> to find an asterisk something different is in order.</p>
<p>The &quot;\&quot;, or backslash, tells the shell to treat the following character as a normal character and do no expansion.</p>
<pre><code>$ ls \*file
*file</code></pre>
<p>Because the asterisk is the next character after the backslash, the shell sends the asterisk to <code>ls</code> unmodified.  In other words: the backslash <em>escapes</em> the asterisk.<br />
</p>
<p>The backslash modifier works well when we have only one wildcard character than we want to pass to a program, but what if we wanted to pass a string like <strong>*?****[a-b]</strong> with lots of characters that would normally be interpreted as wildcards?  If we used backslashes to escape them, we'd have to mark every single character.  A short string would end up turning into: <strong>\*\?\*\*\*\*\[a-b\]</strong>.  Instead of doubling our amount of typing, we can use a pair of single quotes.</p>
<pre><code>$ ls &#39;*?****[a-b]&#39;
*?****[a-b]</code></pre>
<p>Any string encased in single quotes will not be modified by the shell, even when it's filled with wildcards.  However, you cannot type a single quote within the single quotes like this:</p>
<pre><code>$ ls &#39;*?***&#39;*[a-b]&#39;</code></pre>
<p>So, if you happen to have a file whose name has some single quotes in it like this:</p>
<pre><code>*?*&#39;**&#39;*[a-b]</code></pre>
<p>There is no other way but to escape the single quotes individually like this:</p>
<pre><code>$ ls &#39;*?*&#39;\&#39;&#39;**&#39;\&#39;&#39;*[a-b]&#39; </code></pre>
<p>Simply to say, replace any occurence of a single quote in the filename with '\''.</p>
<p><br />
</p>
<p><span id="ch015_searching-for-files.xhtml"></span></p>
<h1>Searching for Files<br />
</h1>
<p>When you first get a computer, you tend to place files in just a couple folders or directories. But as your list of files grows, you have to create some subdirectories and spread the files around in order to keep your sanity. Eventually, you forget where files are. &quot;Where did I store those photos I took in Normandy?&quot;</p>
<p>You could run <code>ls -R</code>, as in the following section, and start running your finger down the screen, but why? Computers are supposed to be about automation. Let the computer figure out where the file is.</p>
<p>If you know your file is named &quot;somefile&quot;, telling the computer what to do is pretty easy.</p>
<pre><code>$ find . -name somefile -print 
./files/somefile</code></pre>
<p>The <code>find</code> command takes more arguments than the other commands we've seen so far, but if you use it for a while you'll find it becomes natural.  Its first argument (the '.') tells find where to start looking: the directory at the top of everything you're searching through. In this case, we're telling <code>find</code> to start looking in whatever directory we're in right now.</p>
<p>The <code>-name</code> argument tells it to look for a file named <em>somefile</em>.  Finally, the <code>-print</code> option tells the command to print out on our screen the location of any file that matches the name it was given.</p>
<h2><strong>Wildcards with Find</strong></h2>
<h3></h3>
<p>What if you don't remember the name of the file you're looking for?  You might only remember that it starts with &quot;some&quot;.  Luckily, <code>find</code> can handle that too. </p>
<pre><code>$ find . -name &#39;some*&#39; -print 
./dir1/subdir2/files/somefile_other
./some_other_file
./files/somefile </code></pre>
<p>This time it found a few more files than you were after but it still found the one you wanted.  As you can see, the <code>find</code> command can process wildcards in much the same way the shell can.  Here you asked it to look for anything that starts with the letters &quot;some&quot;.</p>
<p>The &quot;*&quot;, &quot;?&quot;, and &quot;[ ]&quot; wildcards can all be used just as they would be in the shell.  However, since <code>find</code> is using the wildcards you have to make sure they remain unaltered by the shell.  To do this you can surround the name you're searching for, and the wildcards it contains, in single quotes.</p>
<h2><strong>Trimming The Search Path</strong></h2>
<h3></h3>
<p>With just a name and a location, find will begin searching through every directory below its starting point, looking for matches.  Depending on how many subdirectories you have where you're searching, <code>find</code> can take a lot of time to look in places you know don't contain the file.</p>
<p>It is possible, however, to control how far <code>find</code> sinks in the directory tree.</p>
<pre><code>$ find . -maxdepth 1 -name &#39;some*&#39; -print 
./some_other_file</code></pre>
<p>By using the <code>-maxdepth</code> argument we can tell <code>find</code> to go no lower than the number of directories we specify.  A maxdepth of 1 says: don't leave the starting directory. A maxdepth of 3 would allow <code>find</code> to descend 3 directories from where it started, and so on.  It's important to note that <code>-maxdepth</code> should immediately follow the start location, or find will complain.</p>
<h2><strong>Using Criteria<br />
</strong></h2>
<h3></h3>
<p>The <code>find</code> command can search for files based on any criteria the filesystem know about files. For instance, you can search for files based on:</p>
<ul>
<li>When they were last modified or accessed (somebody read them)</li>
<li>How big they are<br />
</li>
<li>Who owns them, or what group they are in</li>
<li>What permissions (read, write, execute) they have</li>
</ul>
<ul>
<li>What type of file (directory, regular file) they are</li>
</ul>
<p>and other criteria described in the manual page. Here we'll just show a couple popular options.</p>
<p>The <code>-mtime</code> option shows the latest modification time. Suppose you just can't remember anything about a file's name, but know that you created or modified it within the past three days. You can find all the files in your home directory that were created or modified within the past three days through:</p>
<pre><code>$ find ~ -mtime -3 -print</code></pre>
<p>Notice the minus sign before the 3, for &quot;less than.&quot; If you know you created the file yesterday (between 24 and 48 hours ago), you can search for an exact day:<br />
</p>
<pre><code>$ find ~ -mtime 1 -print</code></pre>
<p> To find files that are more than 30 days old (caution: there will be a lot of these), use a plus sign:</p>
<pre><code>$ find ~ -mtime +30 -print</code></pre>
<p>Perhaps you want to remove old files that are large, before backing up a directory. Combine <code>-mtime</code> with <code>-size</code> to find these files. The file has to match all the criteria you specify in order to be printed.<br />
</p>
<pre><code>$ find directory_to_backup  -mtime +30  -size +500k  -print</code></pre>
<p>We've specified +500k as our <code>-size</code> option. The plus sign means &quot;greater than&quot; and &quot;500k&quot; means &quot;500 kilobytes in size&quot;.<br />
</p>
<h2><strong>Using Find To Run a Command on Multiple Files</strong></h2>
<h3></h3>
<p>The find command can do much more powerful things than print filenames. You can combine it with any other command you want, so that you can remove files, move them around, look for text in them, and so on. On those occasions, the <code>find</code> command with its <code>-exec</code> option is just what you'll need.</p>
<p>Because the next example is long, it is divided onto two lines, with a backslash at the end of the first so the shell keeps reading and keeps the two lines as one command. The first line is the same as the command to find old, large files in the previous section.</p>
<pre><code>$ find directory_to_backup  -mtime +30  -size +500k -print \
              -exec rm {} \;</code></pre>
<p>The <code>-exec</code> option is followed by an <code>rm</code> command, but there are two odd items after it:</p>
<ul>
<li>{} is a special convention in the <code>-exec</code> option that means &quot;the current file that was found&quot;</li>
<li>\; is necessary to tell find what the end of the command is. A command can have any number of arguments. Think of <code>-exec</code> and \; as surrounding the command you want to execute.</li>
</ul>
<p>So we find each file, print the name through <code>-print</code> (which we don't have to do, but we're curious to see what's being removed), and then remove it in the <code>-exec</code> option.</p>
<p>Clearly, a tiny mistake in a find command could lead to major losses of data when used with <code>-exec</code>. Test your commands on throw-away files first!<br />
</p>
<p>Using <code>cp</code> you can see how the bracket pairs can be specified multiple times, allowing the file's name to be easily duplicated.</p>
<pre><code>$ find . -name &#39;file*&#39; -exec cp {} {}.backup \;  </code></pre>
<p>Experiment and practice!<br />
</p>
<p><span id="ch016_piping.xhtml"></span></p>
<h1>Piping hot commands</h1>
<p>Pipes let programs work together by connecting the output from one to be the input for another. The term &quot;output&quot; has a precise meaning here:  it is what the program writes to the standard output, via C program statements such as printf or the equivalent, and normally it appears on the terminal screen. And &quot;input&quot; is the standard input, usually coming from the keyboard. Pipes are built using a vertical bar (&quot;|&quot;) as the pipe symbol.</p>
<p>Say you help your eccentric Aunt Hortense manage her private book collection. You have a file named <em>books</em> containing a list of her holdings, one per line, in the format &quot;author:title&quot;, something like this:</p>
<pre><code>$ cat books
Carroll, Lewis:Through the Looking-Glass
Shakespeare, William:Hamlet
Bartlett, John:Familiar Quotations
Mill, John Stuart:On Nature
London, Jack:John Barleycorn
Bunyan, John:Pilgrim&#39;s Progress, The
Defoe, Daniel:Robinson Crusoe
Mill, John Stuart:System of Logic, A
Milton, John:Paradise Lost
Johnson, Samuel:Lives of the Poets
Shakespeare, William:Julius Caesar
Mill, John Stuart:On Liberty
Bunyan, John:Saved by Grace</code></pre>
<p>This is somewhat untidy, as they are in no particular order. But we can use the <code>sort</code> command to straighten that out:</p>
<pre><code>$ sort books
Bartlett, John:Familiar Quotations
Bunyan, John:Pilgrim&#39;s Progress, The
Bunyan, John:Saved by Grace
Carroll, Lewis:Through the Looking-Glass
Defoe, Daniel:Robinson Crusoe
Johnson, Samuel:Lives of the Poets
London, Jack:John Barleycorn
Mill, John Stuart:On Liberty
Mill, John Stuart:On Nature
Mill, John Stuart:System of Logic, A
Milton, John:Paradise Lost
Shakespeare, William:Hamlet
Shakespeare, William:Julius Caesar</code></pre>
<p>Ah, now you have a list nicely sorted by author. How about getting a list just of authors, without titles? You can do that with the <code>cut</code> command:</p>
<pre><code>$ cut -d: -f1 books
Carroll, Lewis
Shakespeare, William
Bartlett, John
Mill, John Stuart
London, Jack
Bunyan, John
Defoe, Daniel
Mill, John Stuart
Milton, John
Johnson, Samuel
Shakespeare, William
Mill, John Stuart
Bunyan, John</code></pre>
<p>A little explanation here. The <code>-d</code> option chose a colon as the delimiter (separator). This tells <code>cut</code> to break up each line wherever a delimiter appears, and each separate part of the line is called a field. In our format, the author's name appears as the first field, so we have put a 1 with the <code>-f</code> option to tell <code>cut</code> that we want to see just that field.</p>
<p>But you'll notice the list is unsorted again. Pipelines to the rescue!</p>
<pre><code>$ sort books | cut -d: -f1
Bartlett, John
Bunyan, John
Bunyan, John
Carroll, Lewis
Defoe, Daniel
Johnson, Samuel
London, Jack
Mill, John Stuart
Mill, John Stuart
Mill, John Stuart
Milton, John
Shakespeare, William
Shakespeare, William</code></pre>
<p>Voila! You've taken the alphabetized list, which is the output of the <code>sort</code> command, and fed it as input to the <code>cut</code> command. Don't give the <code>cut</code> command a filename to use, because you want it to operate on the text that's piped out of the <code>sort</code> command.</p>
<p>Pipes are just that simple--text flows down the pipe from one command to the next.<br />
</p>
<p>How about if you wanted a sorted list of titles instead? Since the title is the second field, let's try using <code>-f2</code> with the <code>cut</code> command instead of <code>-f1</code>:</p>
<pre><code>$ sort books | cut -d: -f2
Familiar Quotations
Pilgrim&#39;s Progress, The
Saved by Grace
Through the Looking-Glass
Robinson Crusoe
Lives of the Poets
John Barleycorn
On Liberty
On Nature
System of Logic, A
Paradise Lost
Hamlet
Julius Caesar</code></pre>
<p>Oops. What happened? When looking at a pipeline, you need to go left-to-right. In this case, we sorted the file first before extracting the titles. So it dutifully sorted the lines starting with the author at the beginning of each line. To get the <em>titles</em> in the proper order, you need to do the sort <em>after</em> extracting them:</p>
<pre><code>$ cut -d: -f2 books | sort
Familiar Quotations
Hamlet
John Barleycorn
Julius Caesar
Lives of the Poets
On Liberty
On Nature
Paradise Lost
Pilgrim&#39;s Progress, The
Robinson Crusoe
Saved by Grace
System of Logic, A
Through the Looking-Glass</code></pre>
<p>Much better. Now this is all very nice, but you may be thinking you could have done these things with a spreadsheet. For simpler tasks, this is probably true. But suppose that Aunt Hortense is in the habit of asking odd questions about her collection. For example, she wants to know how many books she has from each author named John. A spreadsheet or other graphical program may have difficulty handling a request that wasn't anticipated by the program's authors. But the shell offers us many small, simple commands that can be combined in unforeseen ways to accomplish a complex task.</p>
<p>To find a particular string in a line of text, use the <code>grep</code> command. Now remember that when you combine commands, they need to go in the proper order. You can't run <code>grep</code> against the file first, because it will match the title &quot;John Barleycorn&quot; in addition to authors named John. So add it to the end of the pipeline:</p>
<pre><code>$ cut -d: -f1 books | sort | grep &quot;John&quot;
Bartlett, John
Bunyan, John
Bunyan, John
Johnson, Samuel
Mill, John Stuart
Mill, John Stuart
Mill, John Stuart
Milton, John</code></pre>
<p>This gets us close, but you don't want to get &quot;Samuel Johnson&quot; on the list and make Aunt Hortense angry. Often when working with <code>grep</code> you will need to refine the matching text to get exactly what you need. <code>grep</code> happens to offer a <code>-w</code> option that will let it match &quot;John&quot; only when &quot;John&quot; is a complete word, not when it's part of &quot;Johnson&quot;. But we'll solve this particular dilemma by adding a comma and space on the front of the string to match, so it will match only when John is a first name:</p>
<pre><code>$ cut -d: -f1 books | sort | grep &quot;, John&quot;
Bartlett, John
Bunyan, John
Bunyan, John
Mill, John Stuart
Mill, John Stuart
Mill, John Stuart
Milton, John</code></pre>
<p>Ah, that's better. Now you just need to total up the number of books for each author. A little command called <code>uniq</code> will work nicely. It removes duplicate lines (duplicates must be on consecutive lines, so be sure your text is sorted first), and when used with the <code>-c</code> option also provides a count:</p>
<pre><code>$ cut -d: -f1 books | sort | grep &quot;, John&quot; | uniq -c
      1 Bartlett, John
      2 Bunyan, John
      3 Mill, John Stuart
      1 Milton, John</code></pre>
<p>And there you are! A nicely sorted list of Johns and the number of books from each. For our example set this is a simple job, one you could even do with pencil and paper. But this very same pipeline can be used to process far more data--it won't blink even if Aunt Hortense has hundreds of thousands of books stored in the barn.</p>
<p>System administrators often use pipelines like these to deal with log files generated by web and mail servers. Such files can grow to tens or hundreds of megabytes in size, and a command pipeline can be a quick way to generate summary statistics without trying to read through the entire log.</p>
<p>A nice thing about building pipelines is that you can do it one command at a time, seeing exactly what effect each one has on the output. This can help you discover when you might need to tweak options or rearrange the order of commands. For instance, to put the authors in ranking order, you can just add a <code>sort -nr</code> to the previous pipeline:<br />
</p>
<pre><code>$ cut -d: -f1 books | sort | grep &quot;, John&quot; | uniq -c | sort -nr
      3 Mill, John Stuart
      2 Bunyan, John
      1 Milton, John
      1 Bartlett, John</code></pre>
<p>Experiment!</p>
<p><span id="ch017_processes.xhtml"></span></p>
<h1>Processes</h1>
<p>Processes are programs in action. Programs in binary/executable form reside on your disk; when they are executed (run), they are moved into memory and become a process. Each and every program we run is a process.<br />
</p>
<h2>Interrupting (CTRL-C)</h2>
<p>The kernel delivers signals to processes for many reasons. The SIGINT signal is raised when the user presses the &lt;ctrl&gt;&lt;C&gt; key combination. It is delivered to the process that is in the foreground in the currently active terminal. If that process has not set up a response to SIGINT (we say it catches SIGINT), then it will be terminated immediately with possible loss of data (but open files do get closed). Some programs catch SIGINT and use it for a specific purpose. For example, the nano editor responds to it by displaying the current position in the file being edited.<br />
</p>
<h2>ps and kill</h2>
<p>We can use the <code>ps</code> and <code>top</code> commands to view processes running on our machine.</p>
<p>The <code>ps</code> command, when you run it without any arguments, displays processes run by the current user.</p>
<pre><code>$ ps
 PID TTY          TIME CMD
3922 tty2     00:00:00 su
3923 tty2     00:00:00 sh
3941 pts/0    00:00:00 cat
3942 pts/0    00:00:00 ps</code></pre>
<p>Here we find there are 4 processes that we are running from our terminal. The 4 columns have the following interpretation:</p>
<pre><code>Process ID   Terminal   CPU Time   Program/Command </code></pre>
<blockquote>

</blockquote>
<p>Each process has an identifier by which the operating system tracks it. This is an integer number that is given to each new process, and is called the PID (for &quot;process ID&quot;). The gap between the PID 3923 for sh and the PID 3941 for cat merely shows that somebody started processes on the machine in between the times these two processes started.</p>
<p>The second column in the output of <code>ps</code> specifies the terminal to which the process is attached or the terminal that controls the process. You can use the <code>tty</code> command to find out which terminal you are presently in.</p>
<pre><code>$ tty
/dev/tty2</code></pre>
<p>Now, you may well expect that your machine has a lot more processes than the ones you see by running a simple <code>ps</code> without arguments. In fact, it shows only the processes you started from the terminal in which you issue the command. On a graphical desktop, that command doesn't show the programs you start from menus or by clicking on icons. The system also runs a lot of its own processes in the background. To see everything, add the <code>-e</code> option:</p>
<pre><code>$ ps -e
 PID TTY          TIME CMD
   1 ?        00:00:01 init
   2 ?        00:00:00 kthreadd
   3 ?        00:00:00 migration/0
   4 ?        00:00:00 ksoftirqd/0
   5 ?        00:00:00 watchdog/0
   6 ?        00:00:00 migration/1
   7 ?        00:00:00 ksoftirqd/1
   8 ?        00:00:00 watchdog/1
   9 ?        00:00:00 events/0
  10 ?        00:00:00 events/1
  11 ?        00:00:00 khelper
  44 ?        00:00:00 kblockd/0
  45 ?        00:00:00 kblockd/1
.........................................
.........................................
3534 tty1     00:00:00 getty
3535 tty2     00:00:00 login
3536 tty3     00:00:00 getty
3537 tty4     00:00:00 getty
3538 tty5     00:00:00 getty
3539 tty6     00:00:00 getty</code></pre>
<p>In case you want to terminate a process that you started, you can do so from a terminal using the <code>kill</code> command.</p>
<pre><code>$ kill 3941</code></pre>
<p>Here we provide the PID as the argument. Remember that the kill argument is non-interactive (it doesn't ask for confirmation before starting) and non-verbose (it doesn't tell you what it is doing) by default and hence must be used carefully. You can kill only your own processes. Also if the program has truly crashed it may not respond to the instruction so use the <code>-9</code> option in that case. That is the signal number for SIGKILL, and if you are really careful you will type &quot;kill -s SIGKILL (pid)&quot; since it is conceivable that your system has the numbers assigned differently.<br />
</p>
<h2>Processes and jobs (background)</h2>
<p>If you want to run something in the background and return control to your terminal, just put an ampersand (&quot;&amp;&quot;) after the command name.</p>
<pre><code>$ firefox &amp;
[1] 3694
$</code></pre>
<p>The shell prints a brief message and gives you another dollar sign prompt. Firefox is now running (and should pop up a window of its own, because it's a graphical program). You can continue to execute other commands in your terminal.</p>
<p>What are the two numbers printed after you put the program in the background? The number in square brackets is a special number assigned to each program you run in the background; it's called a <em>job number</em>. In this case, the job number is 1 because we don't have any other programs currently running in the background in this shell.</p>
<p>The second number, which is 3694 in this case, is the process number we saw in an earlier section.</p>
<p>To bring your job back in the foreground just type <code>fg</code>. The job takes over your terminal as commands usually do, until it finishes.</p>
<p>If you have multiple jobs in the background, you can pass the job to the <code>fg</code> command either as a process number:</p>
<pre><code>$ fg 3694</code></pre>
<p>or as a job number:</p>
<pre><code>$ fg %1</code></pre>
<p>To distinguish the job number from a process number, you must put a percent sign (&quot;%&quot;) before the job number.<br />
</p>
<p>If you want to run a process in the background that's now running in the foreground, type <strong>Ctrl + Z</strong>, which suspends the job, then issue the command <code>bg</code>.</p>
<p>To find out what jobs you've put in the background (and their status), enter <code>jobs</code>:</p>
<pre><code>$ jobs
[1]-  Running                 firefox &amp;
[2]+  Exit 2                  sort &gt; big_file_sorted 2&gt; big_file_err</code></pre>
<p>Firefox is still running, but the second job exited with an error status of 2.</p>
<p><span id="ch018_file-structure.xhtml"></span></p>
<h1>Files and Directories<br />
</h1>
<p>Although you're most interested in files in your own folder or directory, it helps to know what else is on your system. In this chapter we'll look around a GNU/Linux system.</p>
<p>Here is a list of the most common directories right beneath the root directory (the one whose name is just &quot;/&quot;):</p>
<pre><code>/bin     basic programs (Programs that are absolutely needed,
         shell and commands only)
/boot    initialization files (Required to actually boot your computer)
/dev     device files (Describe physical stuff like hard disks
         and partitions)
/etc     configuration files
/home    users&#39; home directories
/lib     libraries (collections of data and functions) for sytem boot
         and running system programs
/media   mount points for removable media
/mnt     mount points (For system admins who need to temporarily
         mount a filesystem)
/opt     third-party programs
/proc    proc filesystem (Describe processes and status info,
         not stored on disk)
/root    system administrator&#39;s files
/sbin    basic administration programs (Like bin, but only
         usable by administators)
/srv     service-specific files
/sys     sys filesystem (Similar to proc, stored in memory
         based filesytem: tempfs)
/tmp     temporary files (Files kept only a short time depending
         on system policy, often in tempfs)
/usr     users&#39; programs (Another bin, lib, sbin, plus local,
         share, src, and more)
/var     variable data preserved between reboots</code></pre>
<p>You don't need to know about the directory structure outside your home directory in order to run applications, but this knowledge occasionally comes in handy. Perhaps the most common uses are when you want to change a system-wide configuration file or view log messages. Log files generally contain progress information and error reports from programs, and may reveal the source of problems (bugs, configuration errors, missing or corrupted files) on your system. Many log files are kept in the <em>/var/log</em> directory, but some programs put their log files in hidden directories in the user's home directory. An example is ~/.sugar/default/logs.<br />
</p>
<p>Historically, GNU/Linux system configuration was done through editing text files. Today, most popular GNU/Linux systems encourage users to make changes to the system configuration through graphical administration tools. Sometimes however, this is not possible or desirable, and you may find yourself editing the configuration files in a text editor. This is usually trickier, as you need to know where these files are and how to edit them, and in some cases you also need to signal or restart a running program so it will read in your changes. That said, this method has its advantages, such as the ability to configure computers with no graphics capabilities, or configure programs that have no graphical configuration program (or a clumsy and incomplete one).</p>
<p>NOTE: For a full description of the file-system structure of a typical Linux system, try typing <code>man hier</code> in a terminal. This not only gives a brief on the above top-level directories, but also gives insight into why Linux has <em>both</em> a <em>/usr/bin</em> and a <em>/usr/sbin</em>, for instance.<br />
</p>
<p><br />
</p>
<p><span id="ch019_command-history.xhtml"></span></p>
<h1>Command History Shortcuts</h1>
<p>The shell lets you bring back old commands and re-enter them, making changes if you want. This is one of the easiest and most efficient ways to cut down on typing, because repeated sequences of commands are very common. For instance, in the following sequence we're going through various directories, listing what's there, deleting files we don't want, and saving certain files under different names:</p>
<pre><code>cd Pictures/                              
ls -l status.log.*
rm status.log.[3-5]
mv status.log.1 status.log.bak

cd ../Documents/
ls -l status.log*                                                            
rm status.log.[2-4]
mv status.log.1 status.log.bak

cd ../Videos/
ls -l status.log*
rm status.log.[2-5]
mv status.log.1 status.log.bak</code></pre>
<p>Eventually, if you had to do this kind of clean-up regularly, you would write a script to automate it and perhaps use a cron job to run it at regular intervals. But for now, we'll just see how to drastically reduce the amount of typing you need while entering the commands manually.</p>
<p>An earlier chapter showed you how to use arrow keys to move around in your command history as if you were editing a file. This chapter shows a more complicated and older method of manipulating the command history. Sometimes you'll find the methods in this chapter easier, so it's worth practicing them. For instance, suppose you know you entered the <code>mv</code> command you want (or another one very similar to what you want) an hour ago. Pressing the back arrow repeatedly is a lot more trouble than recalling the command using the technique in this section.</p>
<h2>Recalling a command by a string<br />
</h2>
<p>The <em>bang operator</em>, named after the ! character (an exclamation point, or more colloquially &quot;bang&quot;), allows you to repeat recent commands in your history.<br />
</p>
<p><em>!string</em> executes the most recent command that starts with <em>string</em>. Thus, to execute the exact same mv command you did before, enter:</p>
<pre><code>!mv</code></pre>
</p>
<p>What if you don't want the exact same command? What if you want to edit it slightly before executing it? Or just want to look at what the bang operator retrieves to make sure that's the command you want? You can retrieve it without executing it by adding <code>:p</code> (for &quot;print&quot;):<br />
</p>
<pre><code>!mv:p</code></pre>
</p>
<p>We'll show you how to edit commands soon.<br />
</p>
<p>Perhaps you issued a lot of <code>mv</code> commands, but you know there's a unique string in the middle of the command you want. Surround the string with ? characters, as follows:</p>
<pre><code>!?log?</code></pre>
</p>
<p>Entering two bangs in a row repeats the last run command. A very useful command history idiom is re-running the last command with superuser privilege:</p>
<pre><code>sudo !!</code></pre>
<p>as we all happen to type commands without the right permissions from time to time.</p>
</p>
<p>While running your last command may seem to have limited use, this method can be modified to select only portions of your last command, as we will see later.<br />
</p>
<h2>Recalling a command by number<br />
</h2>
<p>The shell numbers each command as it is executed, in order. If you like recalling commands by number, you should alter your prompt to include the number (a later chapter shows you how). You can also look at a list of commands with their numbers by executing the <code>history</code> command:</p>
<pre><code>$ history                                                       
...
  502  cd Pictures/
  503  ls -l status.log*
  504  rm status.log.[3-5]
  505  mv status.log.1 status.log.bak
  506  cd ../Documents/
  507  history                                      
$</code></pre>
<p>Here we've shown only the last few lines of output. If you want to re-execute the most recent <code>rm</code> command (command number 504), you can do so by entering:</p>
<pre><code>!504</code></pre>
<p>But  the numbers are probably more useful when you think backwards. For instance, if you remember that you entered the <code>rm</code> command followed by three more commands, you can re-execute the <code>rm</code> command through:</p>
<pre><code>!-4</code></pre>
<p>That tells the shell, &quot;start where I am now, count back four commands, and execute the command at that point&quot;.<br />
</p>
<h3><strong>Repeating arguments</strong></h3>
<p>You'll often find yourself reusing portions of a previous command, either because you made a typo, or because you are running a sequence of commands for a certain task. We accomplish this using the bang operator with modifiers.</p>
<p>The three most useful modifiers are: *, !^, and !$, which are shortcuts for all, first, and last arguments respectively. Let's look at these in order.</p>
<p><em>&quot;commandName *&quot;</em> executes the <em>commandName</em> with any arguments you used on your last command. This maybe useful if you make a spelling mistake. For example, if you typed <em>emasc</em> instead of <em>emacs</em>:</p>
<pre class="SCREEN"><code>emasc /home/fred/mywork.java /tmp/testme.java</code></pre>
<p>That obviously fails. What you can do now is type:</p>
<pre class="SCREEN"><code>emacs !*</code></pre>
<p>This executes <code>emacs</code> with the arguments that you last typed on the command-line. It is equivalent to typing:</p>
<pre class="SCREEN"><code>emacs /home/fred/mywork.java /tmp/testme.java</code></pre>
<p><em>&quot;commandName !^&quot;</em> repeats the first argument.</p>
<pre class="SCREEN"><code>emacs /home/fred/mywork.java /tmp/testme.java
svn commit !^    # equivalent to: svn commit /home/fred/mywork.java</code></pre>
<p><em>&quot;commandName !$&quot;</em> repeats the last argument.</p>
<pre class="SCREEN"><code>mv /home/fred/downloads/sample_screen_config /home/fred/.screenrc
emacs !$     # equivalent to: emacs /home/fred/.screenrc</code></pre>
<p>You can use these in conjunction as well. Say you typed:</p>
<pre class="SCREEN"><code>mv mywork.java mywork.java.backup</code></pre>
<p>when you really meant to make a copy. You can rectify that by running:</p>
<pre class="SCREEN"><code>cp mywork.java.backup mywork.java</code></pre>
<p>But since you are reusing the arguments in reverse, a useful shortcut would be:</p>
<pre class="SCREEN"><code>cp !$ !^</code></pre>
<p>For finer-grained control over arguments, you can use the double bang with the <code>:N</code> modifier to select the Nth argument.  This is most useful when you are running a command with <code>sudo</code>, since your original command becomes the first argument.  The example below demonstrates how to do it.</p>
<pre class="SCREEN"><code>sudo cp /etc/apache2/sites-available/siteconfig /home/fred/siteconfig.bak
echo !^ !!:2  # equivalent to echo cp /etc/apache2/sites-available/siteconfig</code></pre>
<p>A range is also possible with <code>!!:M-N</code>.<br />
</p>
<h3><strong>Editing arguments</strong><br />
</h3>
<p>Often you'll want to re-execute the previous command, but change one string within it. For instance, suppose you run a command on <em>file1</em>:</p>
<pre><code>$ wc file1
     443    1578    9800 file1</code></pre>
<p>Now you want to remove <em>file2</em>, which has a name very close to <em>file1</em>. You can use the last parameter of the previous command through &quot;!$&quot;, but alter it as follows:</p>
<pre><code>$ rm !$:s/1/2/                                    
rm file2</code></pre>
<p>That looks a little complicated, so let's take apart the argument:</p>
<pre><code>!$   :   s/1/2/</code></pre>
<p>The &quot;!$&quot; is followed by a colon and then a &quot;s&quot; command, standing for &quot;substitute&quot;. Following that is the string you want to replace (1) and the string you want to put in its place (2) surrounded by slashes. The shell prints the command the way it interprets your input, then executes it.</p>
<p>Because this kind of substitution is so common, you'll be glad to hear there's a much simpler way to rerun a command with a minor change. You can change only one string in the command through this syntax:<br />
</p>
<pre><code>$ wc file1                                                   
     443    1578    9800 file1
$ ^1^2                                        
wc file2</code></pre>
<p>We used a caret (^), the string we wanted to replace, another caret, and the string we want to put in its place.<br />
</p>
<h2>Searching through the Command History</h2>
<p>Use the <strong>Ctrl + R</strong> key combination to perform a &quot;reverse-i-search&quot;. For example, if you wanted to use the command you used the last time you used <code>snort</code>, start by typing <strong>Ctrl + R</strong>. In the terminal window you'll see:</p>
<pre><code>(reverse-i-search)`&#39;:</code></pre>
<p>As you type each letter (s, n, etc.) the shell displays the most recent command that has that string somewhere. When you finish typing &quot;snort&quot;, you can use <strong>Ctrl + R</strong> repeatedly to search back through all commands containing &quot;snort.&quot; When you find the command you're looking for, you can press the right or left arrow keys to place the command on an actual command line so you can edit it, or just press <strong>Enter</strong> to execute the command.</p>
<h2>Sharing Bash History</h2>
<p>The Bash shell saves your history so that you can recall commands from earlier sessions. But the history is saved only when you close the terminal. If you happen to be working in two terminals simultaneously, this means you can't share commands.</p>
<p>To fix this--if you want the terminal to save each command immediately after its execution--add the following lines to your <em>~/.bashrc</em> file:</p>
<pre><code>shopt -s histappend
PROMPT_COMMAND=&#39;history -a&#39;</code></pre>
<p>Learning these shortcuts can save you a tremendous amount of time so please experiment!</p>
<p><span id="ch021_permissions.xhtml"></span></p>
<h1>Permissions</h1>
<p>Your computer system stores a lot of information about files that normally remains hidden as you create and play with the files. One set of file attributes you'll run into, though, is permissions. Who's able to edit your files? Hopefully not every person who logs in to the system (and many systems are still shared by multiple people nowadays). This section discussion ownership and permissions.</p>
<p>First, let's see what the system itself can tell us about its files. We'll execute the familiar <code>ls</code> command with an addition <code>-l</code> (that's the lower-case letter &quot;L&quot;) option for a long listing:<br />
</p>
<pre><code>$ ls -l
total 72
drwxr-xr-x   2 root root  4096 Oct  5 09:31 bin
drwxr-xr-x   3 root root  4096 Oct  9 21:47 boot
drwxr-xr-x   1 root root     0 Jan  1  1970 dev
...</code></pre>
<p>The first line:<br />
</p>
<pre><code>total 72</code></pre>
<p>displays the total size of all the files together in <em>kilobytes</em> (kB). The rest provides information about the files and directories themselves.  This information is grouped into seven columns that can be summarized as follows:</p>
<pre><code>Permissions   Links   Owner   Group   Size   Date of modification   File Name</code></pre>
<h2>What can I do? What can others do?</h2>
<p>Every file and directory in the system has an <em>owner</em>, belongs to a <em>group</em>, and has a set of <em>permissions</em> associated to it. At the simplest level, these permissions define three access levels, one for the owner of the file, one for the group that the file belongs to, and one for the rest of the world. (Actually, &quot;world&quot; just means anyone who has the privileges to log on to the system.)<br />
</p>
<p>Let's look back at the output shown previously.  The third and fourth columns show the owner (root in this case) and group (root, too).  The first column presents the permissions in a very compact fashion, like this:<br />
</p>
<pre><code>drwxr-xr-x</code></pre>
<p>The first character denotes the type of file, the next three characters show the owner permissions, the next three are the group permissions, and the last three are the permissions for the rest of the world.</p>
<p>The following table shows what the first character means. The previous example showed a &quot;d&quot; for directory. Some of the characters are quite rare. All you usually have to think about are the regular file and the directory.<br />
</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>Character</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">-</td>
<td>regular file<br />
</td>
</tr>
<tr class="odd">
<td style="text-align: center;">d</td>
<td>directory<br />
</td>
</tr>
<tr class="even">
<td style="text-align: center;">l</td>
<td>symbolic link<br />
</td>
</tr>
<tr class="odd">
<td style="text-align: center;">b<br />
</td>
<td>block special file<br />
</td>
</tr>
<tr class="even">
<td style="text-align: center;">c<br />
</td>
<td>character special file<br />
</td>
</tr>
<tr class="odd">
<td style="text-align: center;">p<br />
</td>
<td>FIFO (named pipe)<br />
</td>
</tr>
<tr class="even">
<td style="text-align: center;">s<br />
</td>
<td>socket<br />
</td>
</tr>
<tr class="odd">
<td style="text-align: center;">?<br />
</td>
<td>something else unknown to ls<br />
</td>
</tr>
</tbody>
</table>
<p><br />
Permissions are classified into 3 types:</p>
<ul>
<li>Read (r): permission to read a file</li>
<li>Write (w): permission to write to a file</li>
<li>Execute (x): permission to execute a file</li>
</ul>
<p>A hyphen (-) marks any permission that is not set.<br />
</p>
<p>A simpler way to see how the permissions column is split up into their own columns is shown below:<br />
</p>
<pre><code>:type : owner : group : restofworld:
:d    : rwx   : r-x   : r-x</code></pre>
<p>If you wish to see the contents of a file, you need <em>read permission</em>.  If you wish to modify its contents, you need <em>write permission</em>.  If the file is a program and you wish to run it, you need <em>execute permission</em>.</p>
<p>In the case of directories, if you wish to see its contents, you need <em>both read and execute permissions</em>, just <em>read permissions</em> are not enough.  If you wish to add or remove files from that directory, you need <em>write permissions</em>.</p>
<p>Going back to the example, let's consider the following line:<br />
</p>
<pre><code>drwxr-xr-x   2 root root  4096 Oct  5 09:31 bin</code></pre>
<p>As you now can see, it's a directory.  How do you figure out what <em>you</em> can actually do with it?  Here's where you need to look at the user and group assigned to the file.  But first things first: who are you?</p>
<pre><code>$ whoami
joe</code></pre>
<p>That command will tell you just that: who you are, the name of your user account.  As you can see, you are not <em>root</em>. The user <em>root</em> can see the contents of that directory and can also add files to it, but you are not him.  What's your group then?</p>
<pre><code>$ id -G -n
joe dialout cdrom floppy audio video plugdev</code></pre>
<p>That's the list of groups you belong to.  If any of those were <em>root</em> you'd be able to see the contents of the <em>/bin</em> directory but not add files to it.  But you are not part of the <em>root</em> group.  The only option left is &quot;the rest of the world&quot; and you are included there, so what you can do is just see the contents of the directory.</p>
<p>Let's look at another file:</p>
<pre><code>$ ls -l /etc/issue
-rw-r--r-- 1 root root 36 2009-02-26 15:06 /etc/issue</code></pre>
<p>As you can see, it's a regular file that <em>root</em> can read and write and users in the <em>root</em> group, whoever they are, can only read.  And you, <em>joe</em>, can only read it too.</p>
<p>What about your own stuff?  Chances are you have a <em>Desktop</em> directory in your home directory. We'll check its permissions with <code>ls -l</code>, adding an extra <code>-d</code> option so we see just a line for <em>Desktop</em> and not the files or directories within it.</p>
<pre><code>$ ls -l -d ~/Desktop
drwxr-xr-x 8 joe joe 4096 2009-03-12 09:27 /home/joe/Desktop</code></pre>
<p>That directory belongs to you!  And according to the permissions, you can read the contents and put files there.  And other people can only look at its contents.</p>
<h2>Setting through chmod</h2>
<p>If you wish to change permissions of a file, you need to own it--you can't just go around changing other people's stuff.  If you own the file (or directory), you can change its permissions with the <code>chmod</code> command.  There are two ways of specifying the new file's permissions and both have their advantages.  Let's explore both.<br />
</p>
<p>Create a practice directory, and copy a couple of files there:</p>
<pre><code>$ mkdir ~/practice
$ cd ~/practice
$ cp /etc/issue /etc/motd .
$ ls -l
 total 8
-rw-r--r-- 1 joe joe  36 2009-03-21 14:34 issue
-rw-r--r-- 1 joe joe 354 2009-03-21 14:34 motd</code></pre>
<p>Let's say you wish to make <em>issue</em> readable and writable by you and your group only and <em>motd</em> readable and writeable by you only.  That means the last output needs to look something like this:</p>
<pre><code>$ ls -l
 total 8
-rw-rw---- 1 joe joe  36 2009-03-21 14:34 issue
-rw------- 1 joe joe 354 2009-03-21 14:34 motd</code></pre>
<p>You take care of <em>issue</em> like this:</p>
<pre><code>$ chmod u=rw,g=rw,o= issue</code></pre>
<p>That means:</p>
<ul>
<li>u=rw: set the user's permissions to read/write</li>
<li>g=rw: set the group's permission's to read/write</li>
<li>o=: set the other's permissions to nothing</li>
</ul>
<p>For <em>motd</em>, the command goes like this:</p>
<pre><code>$ chmod u=rw,g=,o= motd</code></pre>
<p>Pretty straightforward, isn't it?  It's also a lot of typing.  A shorter version would be:</p>
<pre><code>$ chmod ug=rw,o= issue
$ chmod u=rw,go= motd</code></pre>
<p>That's a little bit shorter, but there's an even shorter version:</p>
<pre><code>$ chmod 0660 issue</code></pre>
<p>That one needs a little bit of explaining.  The numbers express the same permissions as before.  If you want to understand how it works, consider the following diagram:<br />
</p>
<p> <img src="static/CommandLineIntro-octal_notation-en.png" alt="octal_notation.png" width="300" height="195" /></p>
<p>The top line shows us our goal: a file that its owner can read, write to, and execute, that its group can only read and execute, and that the rest of the world has no access to at all. Each  letter in in the symbolic notation corresponds to a bit in the binary representation.  If the letter is present, you have a 1 and if it's not you have a 0.  The first 1 in 111 is 4, the second is 2 and the third is 1.  You add all that up and you get 7.  If you do the same for the other triplets, you get 0750.</p>
<p>Returning to our previous example, for the file <em>issue</em>, we wish to have the permissions be -rw-rw----, that gives us 0, 4+2, 4+2 and 0, that is 0660.  Can you work out the <em>mode</em> (as this is called) for <em>motd</em>?</p>
<p><span id="ch022_interactive-editing.xhtml"></span></p>
<h1>Interactive Editing</h1>
<p>Many people, especially beginners, use the arrow keys to move the cursor around the command line. Most people can do that in much less time than it would take them to remember the more powerful but more complicated alternatives that are provided. But some of these methods are worth learning, so we will present them here.</p>
<p>The shell comes with two different sets of <em>key bindings</em> (keyboard shortcuts), inspired by two extremely powerful text editors, Emacs and vi (probably the two most powerful ones that exist). By exploiting the keyboard shortcuts that these bindings offer, command line wizards are able to enter and edit even long command lines in just a fraction of a second. If you take the time to practice with the key bindings that the shell offers, even if they may seem impractical at first, you will very soon be able to do so too.</p>
<p><strong>Note:</strong> You will only be able to take full advantage of the Emacs and vi bindings if you know how to type properly (using 10 fingers). If you don't, you should learn it as soon as possible. (There are a lot of free sites on the web that can teach you.) It is definitely worth it.There is an application called Klavaro you can use it to learn typing .<br />
</p>
<p>By default, the bash shell uses the Emacs bindings. If you want to try out the vi bindings, enter the following command:</p>
<pre><code>$ set -o vi</code></pre>
<p>You can switch back to the Emacs bindings by entering:</p>
<pre><code>$ set -o emacs</code></pre>
<p>The Emacs and vi bindings are very different, and both take some time to get used to. You should try out both bindings to find the ones that suits you best. This chapter covers the default, Emacs bindings. If you learn vi, you can switch to those bindings and you will find them pretty intuitive.<br />
</p>
<p><strong>Hint:</strong> Do not try to learn all shortcuts at once! The human brain isn't made for that kind of stuff, so you will forget almost all of them. Rather, we advise you to learn the 4-5 shortcuts that you find most useful and use them regularly -- learning by doing. Later, you can come back to this chapter to pick up more shortcuts. You will soon find yourself whirling across the command line.</p>
<h2>The Emacs bindings</h2>
<p>The Emacs bindings make heavy use of <strong>Ctrl</strong> and <strong>Alt</strong> as modifier keys. Experienced Emacs users usually remap their <strong>CapsLock</strong> key as <strong>Ctrl</strong> in order to enter Emacs commands more comfortably (and to avoid repetitive strain injury!). Once you start using the Emacs bindings on a regular basis, we advise you to do the same.</p>
<p><strong>*****************************************************************************************</strong></p>
<p>This space reserved for instruction on remapping the CapsLock key</p>
<p>*******************************************************************************************<br />
</p>
<h3>Moving around </h3>
<p>The two most basic keystrokes for moving around on the command line in Emacs mode are <strong>Ctrl + f</strong> and <strong>Ctrl + b</strong>. They move the cursor one character to the right and to the left, respectively:</p>
<table>
<tbody>
<tr class="odd">
<td> Ctrl + f</td>
<td> Move forward one character</td>
</tr>
<tr class="even">
<td> Ctrl + b</td>
<td> Move backward one character</td>
</tr>
</tbody>
</table>
<p>Of course, you can do the same cursor movements by using the arrow keys on your keyboard. But as was remarked above, using the Emacs bindings <strong>Ctrl + f</strong> and <strong>Ctrl + b</strong> may be more efficient, since your hands do not have to leave the letter block of your keyboard. At the moment, you may not notice the difference in speed (especially if you're not a fast typist yet), but once you get more experience in using the command line, you definitely won't want to touch the arrow keys again! (IMHO)<br />
</p>
<p>The following table lists some keystrokes which let you navigate the command line even faster:<br />
</p>
<table>
<tbody>
<tr class="odd">
<td> Alt + f</td>
<td> Move forward one word</td>
</tr>
<tr class="even">
<td> Alt + b</td>
<td> Move backward one word</td>
</tr>
<tr class="odd">
<td> Ctrl + a</td>
<td> Move to the beginning of the line</td>
</tr>
<tr class="even">
<td> Ctrl + e<br />
</td>
<td> Move to the end of the line</td>
</tr>
</tbody>
</table>
<p><strong>Hint:</strong> The German word for &quot;beginning&quot; is Anfang. Would you ever forget such a strange word? Let's hope not, because it can help you remember that <strong>Ctrl + a</strong> takes you to the beginning of the command line.</p>
<p>By taking advantage of the keystrokes summarized in the table above, you can dramatically speed up your command line editing. If, for example, you have misspelled the first letter of a terribly long filename, the keystroke <strong>Alt + b</strong> brings the cursor back to the beginning of the word -- making cumbersome characterwise movement of the cursor unnecessary. The <strong>home</strong> and <strong>end</strong> keys, if present, provide an alternative to <strong>Ctrl + a</strong> and <strong>Ctrl + e</strong>.<br />
</p>
<h3>Editing text<br />
</h3>
<p>Two of the most commonly used editing commands are the following:</p>
<table>
<tbody>
<tr class="odd">
<td> Ctrl + t<br />
</td>
<td> Transpose the character before the cursor and the character under/following the cursor<br />
</td>
</tr>
<tr class="even">
<td> Alt + t</td>
<td> Transpose the word before the cursor and the word under/following the cursor</td>
</tr>
</tbody>
</table>
<p>The two commands take a while to get used to, but both are very useful. While the main use of <strong>Ctrl + t</strong> is to correct typos, <strong>Alt + t</strong> is often used to &quot;drag&quot; a word forward on the command line. Have a look at the following command line (the underline marks the position of the cursor):</p>
<pre><code>$ echo one two three four</code></pre>
<p>If you press <strong>Alt + t</strong> in this situation, the word before the cursor (&quot;one&quot;) is exchanged with the word after the cursor (&quot;two&quot;). Try it out! The result should look like this:</p>
<pre><code>$ echo two one three four</code></pre>
<p>You will notice two things. First, the order of the words &quot;one&quot; and &quot;two&quot; has been reversed. Second, the cursor has moved forward along with the word &quot;one&quot;. Now, the cool thing about the cursor's moving along is that you just need to press <strong>Alt + t</strong> once more in order to transpose &quot;one&quot; with the following word, &quot;three&quot;:</p>
<pre><code>$ echo two three one four</code></pre>
<p>So, by pressing <strong>Alt + t</strong> repeatedly, you can &quot;drag&quot; forward the word before the cursor until it has reached the end of the command line. (Of course, you can do the same with a single character by using <strong>Ctrl + t</strong>.)</p>
<p>At first, the elaborate functionality of the two transpose commands may seem a bit confusing. Just play around with them for a while, and you will soon get the hang of it.<br />
</p>
<h3>Deleting/killing and reinserting text</h3>
<p>Here are some handy commands for deleting/killing text:</p>
<table>
<tbody>
<tr class="odd">
<td> Ctrl + d<br />
</td>
<td> Delete the character under the cursor<br />
</td>
</tr>
<tr class="even">
<td> Alt + d<br />
</td>
<td> Kill all text from the cursor to the end of the current word</td>
</tr>
<tr class="odd">
<td> Alt + Backspace<br />
</td>
<td> Kill all text from the cursor to the beginning of the current word</td>
</tr>
</tbody>
</table>
<p>Note that <strong>Alt + d</strong> and <strong>Alt + Backspace</strong> do not delete text, but kill it. Killing is different from deleting in that deleted text is gone, but killed text may be brought back to life (the term is &quot;yanked&quot;) later on by using the following command:</p>
<table>
<tbody>
<tr class="odd">
<td> Ctrl + y<br />
</td>
<td> Reinsert (yank) text that was previously killed<br />
</td>
</tr>
</tbody>
</table>
<p>Let's see how this works by way of an example:</p>
<pre><code>$ echo one two  </code></pre>
<p>Again, the cursor position is indicated by an underline. If you press <strong>Alt + Backspace</strong> in this situation, the word &quot;two&quot; as well as the whitespace after it will be killed, leaving the command line like this: </p>
<pre><code>$ echo one  </code></pre>
<p>If you now press <strong>Ctrl + y</strong>, the killed text is &quot;yanked&quot; back into the command line. You can do this several times. If you press <strong>Ctrl + y</strong> three times, for example, you end up with the following line:<br />
</p>
<pre><code>$ echo one two two two  </code></pre>
<p>As you can see, killing text is much like the &quot;cut&quot; function of most modern text editors. Note that text which is not killed, but deleted (by pressing <strong>Ctrl + d</strong>) cannot be reinserted into the command line. The only way to get it back is to use the undo function, which will be introduced below.<br />
</p>
<p>Probably the most useful commands for killing text are the following ones:<br />
</p>
<table>
<tbody>
<tr class="odd">
<td> Ctrl + k<br />
</td>
<td> Kill all text from the cursor to the end of the line<br />
</td>
</tr>
<tr class="even">
<td> Ctrl + u<br />
</td>
<td> Kill all text from the cursor to the beginning of the line (unix-discard-line)<br />
</td>
</tr>
</tbody>
</table>
<p>As usual, the best way to learn these commands is to experiment with them. You will find that killing and, where necessary, reinserting big stretches of text can save you a lot of time.<br />
</p>
<h3>Undoing changes</h3>
<p>You can undo the last change that you made by using the following command:</p>
<table>
<tbody>
<tr class="odd">
<td> Ctrl + _<br />
</td>
<td> Undo last change<br />
</td>
</tr>
</tbody>
</table>
<p>An alternative way of doing the same thing is to press <strong>Ctrl + xu</strong>. (Press <strong>x</strong> and <strong>u</strong> in turn while holding down <strong>Ctrl</strong>.)</p>
<h3>Navigating the shell's history</h3>
<p>The shell saves the last commands that you enter in its history. This allows you to get back to previously entered commands, which can save you a lot of typing. Here are the most important commands for navigating the shell's command history:</p>
<table>
<tbody>
<tr class="odd">
<td> Ctrl + p<br />
</td>
<td> Go to the previous command in the history<br />
</td>
</tr>
<tr class="even">
<td> Ctrl + n<br />
</td>
<td> Go to the next command in the history</td>
</tr>
<tr class="odd">
<td> Ctrl + &gt;<br />
</td>
<td> Go to the end of the history<br />
</td>
</tr>
<tr class="even">
<td> Ctrl + r<br />
</td>
<td> Search the history for previously entered commands (reverse-search-history)</td>
</tr>
<tr class="odd">
<td> Ctrl + g<br />
</td>
<td> Cancel the current history search<br />
</td>
</tr>
</tbody>
</table>
<p>Let's see how these commands work by way of a simple example. Open a shell and enter the following commands:</p>
<pre><code>$ echo two
two
$ echo three
three
$ echo four
four</code></pre>
<p>After you have entered these commands, you are left with an empty command line waiting for your input. Now, press <strong>Ctrl + p</strong>. You will notice that the previously entered command appears on your command line: <code>echo four</code>. If you press <strong>Ctrl + p</strong> once more, you move &quot;up&quot; in the history even further, so that <code>echo three</code> appears on the command line. Now, press <strong>Ctrl + n</strong>, and you will see that you have come back to <code>echo four</code>: <strong>Ctrl + n</strong> works exactly like <strong>Ctrl + p</strong>, but the other way round. The <strong>up</strong> and <strong>down</strong> arrow keys are alternatives to these.<br />
</p>
<p>After having pressed <strong>Ctrl + p</strong> and maybe also <strong>Ctrl + n</strong> a few times, you may want to get back to the command line that you were entering before you started navigating the history. You can do this by pressing <strong>Ctrl + &gt;</strong>.<br />
</p>
<p>As you can see, the shell's history is nothing else but a big list of all recently entered commands. You can move up and down the list by pressing <strong>Ctrl + p</strong> and <strong>Ctrl + n</strong>, respectively. And you can press the <strong>Enter</strong> key at any time in order to execute the currently selected command line.</p>
<p>Since the shell's command history is just a big list, it is also searchable. This is most commonly done by using the command <strong>Ctrl + R</strong>. Again, let's assume that you have entered the commands <code>echo two</code>, <code>echo three</code> and <code>echo four</code>. Try pressing <strong>Ctrl + R</strong> now. You will notice that a new prompt appears which says something like &quot;reverse-i-search&quot;. If you now enter the letter &quot;t&quot;, you immediately jump back in history to the last command line containing &quot;t&quot;, which is of course <strong>echo three</strong>. From there, you can use <strong>Ctrl + p</strong> and <strong>Ctrl + n</strong> to navigate the history as explained above. Or you can modify the search by entering a second letter, let's say &quot;w&quot;. You then jump to the command <strong>echo two</strong>, because it is the nearest command in history containing the letter sequence &quot;tw&quot;. Or you can just cancel the search by pressing <strong>Ctrl + g</strong>.</p>
<p>If you feel a bit lost in using the shell's history functions, don't worry! If you keep on practicing, you will quickly get into the routine of flipping back and forth in the shell's history, avoiding the cumbersome retyping of long command lines.</p>
<h3>Interactive editing: an example</h3>
<p>The following example is intended to show you how the interactive editing capabilities of the shell can drastically speed up your work. Let's suppose you have entered the following command line:</p>
<pre><code>$ echoo ne two three
bash: echoo: command not found</code></pre>
<p>Bash has thrown an error, because the command <em>echoo</em> doesn't exist. What you really meant, of course, was <em>echo one two three</em>. You will perhaps be surprised to hear that it takes just five keystrokes to correct the mistake:</p>
<ol>
<li>Press <strong>Ctrl + p</strong> to get the previous history item back on screen, namely the wrongly entered command line.</li>
<li>Press <strong>Ctrl + a</strong> to move the cursor to the beginning of the line.</li>
<li>Press <strong>Alt + f</strong> to move the cursor forward by one word. The cursor is now located between the wrongly entered words &quot;echoo&quot; and &quot;ne&quot;.</li>
<li>Press <strong>Ctrl + t</strong>. You will see that the &quot;o&quot; preceding the cursor and the whitespace under the cursor have been transposed: &quot;echoo ne&quot; has become &quot;echo one&quot;.</li>
<li>Finally, press <strong>Enter</strong> to execute the corrected command line.</li>
</ol>
<p><span id="ch023_checking-exit.xhtml"></span></p>
<h1>Exit status</h1>
<ol>
<ol>
</ol>
</ol>
<p>When you type commands, you can usually tell whether they worked or not. Commands that are unable to do what you asked usually print an error message. This is sufficient if you are typing in each command by hand and looking at the output, but sometimes (for example, if you are writing a script) you want to have your commands react differently when a command fails.</p>
<p>To facilitate this, when a command finishes it returns an <em>exit status</em>. The exit status is not normally displayed; instead it is placed in a variable (a named memory slot) named &quot;<strong>$?</strong>&quot;. The exit status is a number between 0 and 255 (inclusive); zero means success, and any other value means a failure.</p>
<p>One way to see the exit status of a command is to use the <code>echo</code> command to display it:<br />
</p>
<pre><code>$ echo &quot;this works fine&quot;
this works fine
$ echo $?
0
$ hhhhhh
bash: hhhhhh: command not found
$ echo $?
127</code></pre>
<p>Now we'll look at various ways to handle errors.<br />
</p>
<h2>if/then</h2>
<p>Handling an error is an example of something you do conditionally: <em>if</em> something happens, <em>then</em> you want to take action.   The shell provides a compound command--a command that runs other commands--called <code>if</code>.  The most basic form is:</p>
<pre><code>if
  &lt;command&gt;
then
  &lt;commands-if-successful&gt;
fi</code></pre>
<p>We will start with a basic example, then improve it to make it more useful.  After we type <code>if</code> and press the <strong>Enter</strong> key, the shell knows we're in the middle of a compound command, so it displays a different prompt (<strong>&gt;</strong>) to remind us of that.</p>
<pre class="SCREEN"><code>$ if
&gt; man ls
&gt; then
&gt; echo &quot;You now know more about ls&quot;
&gt; fi
The manual page for ls scrolls by
You now know more about ls</code></pre>
<p>Running this command brings up the manual page for <code>ls</code>.  Upon quitting with the <strong>q</strong> key, the <code>man</code> command exits successfully and the <code>echo</code> command runs.</p>
<h3><strong>Handling command failure</strong></h3>
<p>Adding an <code>else</code> clause allows us to specify what to run on failure:</p>
<pre><code>if
  &lt;command&gt;
then
  &lt;commands-if-successful&gt;
else
  &lt;commands-if-failed&gt;
fi</code></pre>
<p>Let's run <code>apropos</code> if the <code>man</code> command fails.</p>
<pre class="SCREEN"><code>$ if
&gt; man draw
&gt; then
&gt; echo &quot;You now know more about draw&quot;
&gt; else
&gt; apropos draw
&gt; fi
...
list of results for apropos draw
...
</code></pre>
<p>This time the <code>man</code> command failed because there is no <code>draw</code> command, activating the else clause.</p>
<h2>&amp;&amp; and ||</h2>
<p>The if-then construct is very useful, but rather verbose for chaining together dependent commands.  The &quot;<em>&amp;&amp;</em>&quot; <em>(and)</em> and &quot;<em>||</em>&quot; <em>(or)</em> operators provide a more compact format.</p>
<pre><code>command1 &amp;&amp; command2 [&amp;&amp; command3]...</code></pre>
<p>The &amp;&amp; operator links two commands together.  The second command will run only if the first has an exit status of zero, that is, if the first command was successful.  Multiple instances of the &amp;&amp; operator can be used on the same line.</p>
<pre><code>$ mkdir mylogs &amp;&amp; cd mylogs &amp;&amp; touch mail.log &amp;&amp; chmod 0660 mail.log</code></pre>
<p>Here is an example of multiple commands, each of which assume the prior one has run successfully.  If we were to use the if-then construct to do this, we would have ended up with an unwieldy mass of ifs and thens.</p>
<p>Note that the &amp;&amp; operator <em>short circuits</em>, that is, if one command fails, no subsequent command is run.  We take advantage of this property to prevent unwanted effects (like creating <em>mail.log</em> in the wrong directory in the above example).</p>
<p>If <em>&amp;&amp;</em> is the equivalent of <code>then</code>, the <em>|| operator</em> is the equivalent of <code>else</code>.  It provides us a mechanism to specify what command to run if the first fails.</p>
<pre><code>command1 || command2 || command3 || ...</code></pre>
<p>Each command in the chain will be run only if the previous command did not succeed (that is, had a nonzero exit status).</p>
<pre><code>$ cd Desktop || mkdir Desktop || echo &quot;Desktop directory not found and could not be created&quot;</code></pre>
<p>In this example we try to enter the <em>Desktop</em> directory, failing which we create it, failing which we inform the user with an error message.</p>
<p>With this knowledge we can write an efficient and compact <code>helpme</code> function.  Our previous examples have shown the two operators used in isolation, but they can be mixed as well.</p>
<pre><code>$ function helpme() {
  man $1 &amp;&amp; echo &quot;you now know more about $1&quot; || apropos $1
}</code></pre>
<p>As you probably suspect, the &quot;you now know...&quot; echo is not exactly the most useful command.  (It might not even be accurate, perhaps the <code>man</code> page introduced so many options and confused the poor user).  We heartily confess we threw it in just to match the original if-then syntax.  Now that we know about the <em>|| operator</em>, we can simplify the function to:</p>
<pre><code>$ function helpme() {
  man $1 || apropos $1
}</code></pre>
<h2>What does an exit status mean?</h2>
<p>Up to now, we considered only the difference between zero and non-zero exit statuses.  We know that zero means success, and non-zero means a failure.  But what kind of failure?  Some exit values may be used for user-specified exit parameters, so that their meaning may vary for one command to another.  However, some widely accepted meanings for particular values do exist.</p>
<p>For example, if you invoke an inexistent command (e.g. by wrongly typing an existing one or by omitting its correct path), you should expect to receive the standard notification of &quot;command not found&quot; which is generally associated with the exit status 127.  We encountered this value at the very beginning of this chapter:<br />
</p>
<pre><code>$ hhhhhh
bash: hhhhhh: command not found
$ echo $?
127</code></pre>
<p>Another exit status to which attention should be drawn is &quot;permission denied&quot;, usually the code 126.  When you encounter this value, it may be worth enhancing the level of attention.  The command you are trying to execute requires permissions you do not have.  There are some frequent cases.</p>
<p>First, you attempted to execute as a normal user a command which requires root privileges.  In this case, if you know what are you doing, you should log in as root and then invoke the command again.  However, if you are plenty of doubts about that command, it would probably be a good idea to spend some time documenting yourself about.  If that command requires root privileges, it is likely to be potentially harmful if not <em></em> <span id="ch023_checking-exit.xhtml#main"><span id="ch023_checking-exit.xhtml#search"><em></em> used correctly</span></span>.</p>
<p>Second, you may be trying to run a software which has been installed with the wrong privileges.  For instance, you may be collaborating with other people in developing an application which is hosted in the home path of another user and that user may have missed to allow you to run the executable.  The <code>chown</code> and <code>chmod</code> commands can help.</p>
<p>There is even the possibility you are trying to obtain information about your system without modifying the system status, so you may think this should be possible without the need to be root.  It is often possible, but not always.  For example, you may check the status of the <code>ssh</code> and <code>at</code> services: the first one is normally readable while the second one may not:<br />
</p>
<pre><code>$ /etc/init.d/sshd status
sshd (pid 1234) is running...

$ /etc/init.d/atd status
bash: /etc/init.d/atd: Permission denied
$ echo $?
126</code></pre>
<p>It may happen that an invoked command takes a long time to complete.  If that command is needed to generate or modify information which is required by your subsequent commands, then you should check that the time-demanding command you've started has not been unexpectedly terminated its execution.  This is different from checking that the command correctly terminated (exit status 0).  That command may encounter an error condition and decide to terminate with a non-zero exit code.  However it is very different the case in which the command cannot choose its exit status because it cannot terminate at all.  Whether an infinite loop inside the command requires an extern intervention or a premature extern intervention overrides the correctly running command,  an INT signal (which is a user interrupt) may be sent to the command by hitting <strong>ctrl + c</strong> or killing the command via:<br />
</p>
<pre><code>$ kill -int pid-of-the-command</code></pre>
<p>Such kind of termination may alter the expected output of the interrupted command and break some subsequent manipulation of that output.  When an INT signal terminates a command, a 130 exit status is returned.  For instance, consider the <code>yes</code> command which requires a <strong>ctrl + c</strong> to terminate:<br />
</p>
<pre><code>$ yes
y
y
y
...
# press ctrl+c 
$ echo $?
130</code></pre>
<p>That covers the concept of exit status and using it to control the flow of your command and scripts. We hope you leave this chapter with an exit status of zero!</p>
<p><span id="ch024_sub-commands.xhtml"></span></p>
<h1>Command Substitution</h1>
<p>In the shell, you can execute one command inside another. Here's a simple example:</p>
<pre><code>grep `date +%b` apache_error_log</code></pre>
<p>The <strong>back-quote</strong> key (also called the backtick) is usually located at the same place as the tilde, above the <strong>Tab</strong> key (dependent on your keyboard layout).</p>
<p>The command within the backticks `` is executed first. The output is then plugged into the larger command. So first the shell executes:</p>
<pre><code>date +%b</code></pre>
<p>This is the <code>date</code> command with an argument beginning with a + sign to indicate a format that you want for the output. The <code>%b</code> format is a rather odd convention asking the <code>date</code> command to print just a three-letter abbreviation of the current month. For instance, if we execute this command in March, it prints:</p>
<pre><code>Mar</code></pre>
<p>So the three-letter abbreviation of the current month is now inserted into the surrounding <code>grep</code> command. In the month of March, the command is equivalent to:</p>
<pre><code>grep Mar apache_error_log</code></pre>
<p>It just so happens that the <em>apache_error_log</em> file stores log messages with dates, and the date contains the three-letter abbreviation of the month:</p>
<pre><code>[Mon Mar 09 14:44:23 2009] [notice] Apache/2.0.59 (Ubuntu) PHP/5.2.6 DAV/2 configured</code></pre>
<p>So what is the effect of our command? It displays all the log messages from <em>apache_error_log</em> that were logged during the current month. (Of course, if there are multiple years in a single log file, you could get messages from March of previous years--but this example is meant to be simple.) By embedding the <code>date</code> command in the <code>grep</code> command, we have created a command we can store and execute any time without having to specify the right month. For instance, we could store this in the <em>.bashrc</em> start-up file:</p>
<pre><code>alias monthlog=&quot;grep `date +%b` apache_error_log&quot;</code></pre>
<p>Now we have our very own command, <code>monthlog</code>, to display current Apache log messages.<br />
</p>
<p>In Bash, you can do the same thing with a syntax many people find simpler:</p>
<pre><code>grep $(date +%b) apache_error_log</code></pre>
<p>Instead of backticks, insert a dollar sign and put the command between parentheses.<br />
</p>
<p>Command substitution is like a pipe (the | character). But command substitution is more flexible than a pipe because you can put one command anywhere you want inside another. There is one other subtle difference: a pipe allows both commands to execute at the same time. If an embedded command takes a long time, the outer command doesn't execute at all until the embedded one is done.</p>
<p>If the embedded command could produce output that is more than one word (such as &quot;Mar 09&quot;) you can pass it as a single argument by enclosing the command in double quotes. The <code>grep</code> command in this section, for instance, requires the string to be passed as a single argument.</p>
<p><span id="ch025_moving-again.xhtml"></span></p>
<h1>Moving Again</h1>
<p>So far you have probably already used the <code>cd</code> command to change your current working directory and the <code>pwd</code> command to find out what your current working directory is.  After you work with the command line for a while, you'll find yourself changing directories constantly.  In order to make this easier, Bash provides a &quot;directory stack&quot; that you can use to quickly move around directories where you are doing some work.  (We'll show some examples in a moment that help explain the idea of a &quot;stack.&quot;) You have the following commands at your disposal:</p>
<div data-align="center">

</div>
<table>
<tbody>
<tr class="odd">
<td>Command</td>
<td>Action<br />
</td>
</tr>
<tr class="even">
<td>dirs</td>
<td>Display directory stack, top level first (left); other commands do this after their main action. Not all command options are shown in this table.<br />
</td>
</tr>
<tr class="odd">
<td>pushd dir</td>
<td>Push dir to the top of the stack and change the current working directory to it<br />
</td>
</tr>
<tr class="even">
<td>pushd</td>
<td>Swap the top two stack levels and cd to the new top-of-stack<br />
</td>
</tr>
<tr class="odd">
<td>pushd <strong>+N</strong><br />
</td>
<td>Rotate the whole stack <strong>left</strong> through <strong>N</strong> steps and cd to the new top-of-stack<br />
</td>
</tr>
<tr class="even">
<td>pushd <strong>-N</strong></td>
<td>Rotate the whole stack <strong>right</strong> through <strong>N+1</strong> steps and cd to the new top-of-stack<br />
</td>
</tr>
<tr class="odd">
<td>popd</td>
<td>Remove the top-of-stack dir and cd to the new top-of-stack<br />
</td>
</tr>
</tbody>
</table>
<p>If you need to have more of a visual aid to understanding a &quot;stack&quot;, the simplest way is to imagine the &quot;stack&quot; as a pile of papers on your desk, you &quot;push&quot; new pieces of paper onto the top of the &quot;stack&quot; and you &quot;pop&quot; the top most piece of paper off the &quot;stack&quot;. Both methods work on the principle of LIFO (last in first out).<br />
</p>
<p>You can play around with these commands to understand how they work.  For example the following table provides a list of commands, their effect on the current working directory and their effect on the stack.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Command</td>
<td><p>Current working directory after command<br />
</p></td>
<td>Stack after command<br />
</td>
</tr>
<tr class="even">
<td>cd<br />
</td>
<td>~<br />
</td>
<td>~<br />
</td>
</tr>
<tr class="odd">
<td>pushd /<br />
</td>
<td>/<br />
</td>
<td><p>/</p>
<p>~<br />
</p></td>
</tr>
<tr class="even">
<td>pushd /usr/bin<br />
</td>
<td>/usr/bin<br />
</td>
<td><p>/usr/bin</p>
<p>/</p>
<p>~<br />
</p></td>
</tr>
<tr class="odd">
<td>pushd +1<br />
</td>
<td>/<br />
</td>
<td><p>/</p>
<p>~</p>
<p>/usr/bin<br />
</p></td>
</tr>
<tr class="even">
<td>pushd +1<br />
</td>
<td>~<br />
</td>
<td><p>~</p>
<p>/usr/bin</p>
<p>/<br />
</p></td>
</tr>
<tr class="odd">
<td>popd<br />
</td>
<td>/usr/bin<br />
</td>
<td><p>/usr/bin</p>
<p>/<br />
</p></td>
</tr>
<tr class="even">
<td>pushd +1<br />
</td>
<td>/<br />
</td>
<td><p>/</p>
<p>/usr/bin<br />
</p></td>
</tr>
<tr class="odd">
<td>popd<br />
</td>
<td>/usr/bin<br />
</td>
<td>/usr/bin<br />
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span id="ch026_customisation.xhtml"></span></p>
<h1>Useful customizations</h1>
<p>You can really make the shell your own, adapting every facet to the way you work (and even the different ways you work from week to week). In this section we'll look at quick changes you can make. Scripting, a way to extend and combine the functions offered by the shell, will be introduced later.<br />
</p>
<h2>Variables<strong></strong></h2>
<p>Each command-line shell has the concept of a <em>variable</em>.  Variables consist of two parts: the variable  <em>name</em> and the variable <em>value</em>.  If I were to say &quot;x=6&quot;, &quot;x&quot; is the name of the variable, and &quot;6&quot; is the value.  To see the value of a variable, one puts a dollar sign in front of the variable name.  Here is a very simple example.<br />
<br />
</p>
<pre><code>$ x=6
$ echo $x
6
$</code></pre>
<p>Above, the first line <em>assigns</em> the value 6 to the variable x and the second line asks the shell to display the value of x. Note that we put the dollar sign in front of the variable name when we want to see its value, but we never use the dollar sign when assigning the value.<br />
</p>
<p>So anything starting with a dollar sign ($) is interpreted by the shell as a variable. One variable sneaked into an earlier section on exit status: you saw that <strong>$?</strong> contains the exit status of the previous command.</p>
<p>Now, what kind of useful things can we do with variables? A common use is to save typing. Say that the files for the project you're working on all week are located in a directory called <em>/home/jsmith/projects/foo/confoobulator</em>.  <em>/home/jsmith/projects/foo/confoobulator</em> is a lot to type, but you can save typing by assigning the value to a variable.</p>
<pre><code>$ p=/home/jsmith/projects/foo/confoobulator</code></pre>
<p>Now you can change to my project directory by typing</p>
<pre><code>$ cd $p</code></pre>
<p>You can remove the value of a variable by setting it to an empty string:</p>
<pre><code>$ VAR=&quot;&quot;</code></pre>
<p>or by issuing the <code>unset</code> builtin command:<br />
</p>
<pre><code>$ unset VAR</code></pre>
<h2>Ordinary Variables and Environment Variables</h2>
<p>Most shells (including the GNU bash shell) recognize two kinds of variables: <em>ordinary variables and environment variables</em>.  An ordinary variable is available to your shell, but not to any programs that your shell runs.  On the other hand, an environment variable is available to both your shell and all of the commands it runs.  One can turn an ordinary variable into an environment variable by using the <code>export</code> command.  If I were to type</p>
<pre><code>$ export p</code></pre>
<p>The (ordinary) variable <strong>p</strong> becomes an environment variable, and can be used by any command that my shell runs.</p>
<h2>Shell Variables<br />
</h2>
<p>The shell provides a lot of its own variables. For instance, the output of the <code>whoami</code> command (which was shown near the beginning of the book) is the same as $USER. Your home directory is stored in $HOME. You can see any variable's value by echoing it:</p>
<pre><code>$ echo $HOME</code></pre>
<p>The first dollar sign shown in that example is just a prompt; it has nothing to do with variables.</p>
<p>You can see the shell's built-in variables (actually a subset known as <em>environment</em> variables) through:</p>
<pre><code>$ env
SHELL=/bin/bash
USER=jsmith
PATH=/usr/local/bin:/usr/bin:/bin:/usr/games
PWD=/home/jsmith
HOME=/home/smith
_=/usr/bin/env
...</code></pre>
<p>Your output will look different, but many of the variable names will be the same. You will find some of these useful in later work.</p>
<ul>
<li>SHELL is the path to your login shell.</li>
<li>USER is your username.  When you logged into your GNU/Linux system, this is the username you typed in. </li>
<li>PATH is a list of directories, separated by colons.  When you run a command (like <code>cat</code> or <code>ls</code>), your shell looks in these directories to find the executable program.  We'll talk more about PATH in just a moment.<br />
</li>
<li>PWD is your current working directory (that is, the folder you are in).</li>
<li>HOME is your home directory.  You start out in this directory when you first log in. </li>
<li>_ is the last executed command. In this case, /usr/bin/env.<br />
</li>
</ul>
<h2><strong>Controlling Variable Expansion</strong> </h2>
<p>If you jam a variable up against other characters, the shell won't recognize it. For instance, the following won't work:</p>
<pre><code>$ curr=myfile
$ rm $curr1.jpeg
rm: .jpeg: No such file or directory                                           </code></pre>
<p>The error message could easily be perplexing. Here's what has happened: the shell saw a variable named <strong><strong>$curr1</strong></strong>. When it couldn't find any such variable, it substituted an empty string. So you ended up trying to execute:<br />
</p>
<pre><code>$ rm .jpeg</code></pre>
<p>If you want to remove <em>myfile1.jpeg</em>, use curly braces around the variable so the shell knows where the variable name ends:<br />
</p>
<pre><code>$ rm ${curr}1.jpeg</code></pre>
<h2>The Search Path</h2>
<p>We've looked at several examples of running commands.  If I type &quot;ls -l&quot; on the command line, then my shell runs the <code>ls</code> command, which makes a list of files.  The <code>ls</code> command is actually a program sitting on your computer's hard drive.  You can ask your shell where a command lives by using the <code>which</code> command.   If I type</p>
<pre><code>$ which ls</code></pre>
<p>then my shell responds with &quot;/bin/ls&quot;, which tells me the <code>ls</code> command is a program that lives in the <em>/bin</em> directory of my hard drive.   We can even use the <code>ls</code> command to look at itself<br />
</p>
<pre><code>$ ls -l /bin/ls
-rwxr-xr-x 1 root root 92672 2007-01-30 15:48 /bin/ls</code></pre>
<p>My shell found the <code>ls</code> command by using the PATH environment variable.</p>
<pre><code>PATH=/usr/local/bin:/usr/bin:/bin:/usr/games</code></pre>
<p>The value of PATH is a list of directories, separated with colons. When I typed <code>ls</code>, my shell looked for the command in <em>/usr/local/bin/ls</em>, then <em>/usr/bin/ls</em>, and finally <em>/bin/ls</em>.  <em>/bin/ls</em> is where the command lives, so my shell was able to run that.  If there wasn't a <em>/bin/ls</em>, then my shell would have tried <em>/usr/games/ls</em>, and then given up.<br />
</p>
<h2>Configuration Files</h2>
<p>You may have seen a lot of nice customizations in the book--or even better, thought up a few customizations of your own--and may be ready to save some of them so you can reuse them in every terminal session. Anything you define in the shell is lost when you close the terminal window. So this is a good time to look at configuration files, which save useful customizations between sessions.</p>
<p>Your home directory contains several hidden files that contain settings for the shell and other programs. In addition, there are entire hidden directories where programs store information, such as the colors you chose to put on your desktop.</p>
<p>How are these directories hidden? Through a simple convention: any file that begins with a dot (.) is considered hidden. Your file manager in your desktop won't show you the files unless you choose a special option to display hidden files. Similarly, the shell doesn't display them by default in an <code>ls</code> command. To display them in the shell, add the <code>-a</code> (for &quot;all&quot;) option:</p>
<pre><code>$ ls -a
.
..
.bash_history
.bash_logout
.bashrc
.irssi
.profile
foo
examplefile</code></pre>
<p>In the previous listing (which will look different on your system) the <em>.bashrc</em> and <em>.profile</em> files are what we're particularly interested in. These are where you can put your customizations. It doesn't matter much which one you choose. The <em>.bashrc</em> file is particular to a type of shell (there are many types) called Bash, whereas <em>.profile</em> is read by other shells in case you decide to use something besides Bash.</p>
<p>Bash configuration works in a very simple manner: Bash just executes the commands when it starts up, exactly as if you typed them in before you did anything else. So anything you see in this section that you like--an alias, a function, a change to an environment variable, etc.--you can put in a configuration file. Entire scripts can be included.</p>
<p>Your startup files likely have commands in them already. Some are installed along with the operating system, while others are added by system administrators at workplaces. To change these customizations or add your own, check out the section on text editors in this book. Pick one editor and learn a dozen or so of its basic commands so you can do the minimal editing needed to put in your customizations.<br />
</p>
<h2>Functions<br />
</h2>
<p>You can combine a number of commands and give it a name; then you can use this name like any other command. Consider writing a function whenever you find yourself executing the same commands repeatedly. You can also write flexible functions that change their behavior based on arguments, just as other commands do.</p>
<p>As a simple example, suppose you want to save information in a file each day:</p>
<pre><code>echo ENTRY -------------- &gt;&gt;~/save/log
date &gt;&gt;~/save/log
du -c &gt;&gt;~/save/log
ls -R &gt;&gt;~/save/log
echo &gt;&gt;~/save/log</code></pre>
<p>To save your commands as a function, issue a command named <code>function</code> followed by the name you want to assign it, and the commands in curly braces. Note that we've used hash marks (#) to add some comments so we will remember what the function is for later. The shell ignores the hash mark and any text that follows on that line.<br />
</p>
<pre><code>function savelog {
# Add information about this directory a log file, ~/save/log
  echo ENTRY -------------- &gt;&gt;~/save/log
  date &gt;&gt;~/save/log
  du -c &gt;&gt;~/save/log  # Size of subdirectories
  ls -R &gt;&gt;~/save/log  # Complete file listing
  echo &gt;&gt;~/save/log
}</code></pre>
<p>Now you can issue the command <code>savelog</code> and execute the embedded commands. You can put the function definition in a startup file so you never have to type the definition in again.</p>
<p>The previous example was quite contrived because you very rarely issue the exact same commands in sequence. However, you often have a complicated command that you run on different files, or other objects.</p>
<p>For instance, here is a command that shows you the differences between the current version of a file and the most recently edited version, if you edit with Emacs. Emacs saves an old version of your file by creating another file with the same name but an added tilde (~). In this example, we view the differences between <em>txtfile</em> and the back-up <em>txtfile~</em> version:</p>
<pre><code>$ diff txtfile~ txtfile | less</code></pre>
<p>This is just complicated enough (and common enough) to be worth saving as a function. But you want to pass the filename as an argument so you can use the function on any file you edit. So specify the argument as $1, a special variable that the function understands:<br />
</p>
<pre><code>function d~ {
# Compare the Emacs back-up version with the current version.
  diff -u $1~ $1 | less
 }</code></pre>
<p> Now you can run your new <code>d~</code> command on any file that has a backup:</p>
<pre><code>$ d~ txtfile</code></pre>
<p>As you might guess, a function can take up to nine arguments, which you can refer to as $1, $2, up to and including $9. If you want more than nine arguments, you can save an argument and remove it from the list:</p>
<pre><code>function manyargs {
  $arg=$1
  shift
  ...
} </code></pre>
<p>The first thing this function does is save the first argument in its own <strong>$arg</strong> variable. The <code>shift</code> command removes the $1 argument and shifts all the other arguments over, so that the second argument is now $1. In the section on scripting, you'll see how to use loops to process arguments or other items one by one.</p>
<p>If you want to pass all the arguments to a command, use $*. For instance, the following <code>orth</code> function runs the spell utility on whatever string you pass:<br />
</p>
<pre><code>function orth () {
  echo $* | spell
}</code></pre>
<p>Functions can contain compound statements, such as if/then blocks. To show how flexible and powerful the combination of functions and compound statements can be, we'll include here an if/then statement that was shown earlier in the section &quot;Handling command failure&quot;.</p>
<pre><code>function helpme() {
  if man $1
    then echo &quot;you now know more about $1&quot;
    else apropos $1
  fi
}</code></pre>
<p>So the following:</p>
<pre><code>$ helpme draw</code></pre>
<p> will now be equivalent to:<br />
</p>
<pre><code>  if man draw
    then echo &quot;you now know more about draw&quot;
    else apropos draw
  fi</code></pre>
<p>As long as you can guess what errors or other conditions will occur, you can handle them automatically in a function.<br />
</p>
<h2>Sourcing in files</h2>
<p>If this chapter has gotten you excited about the possibilities of writing up your customizations and saving them in files, good. But you will eventually have lots of different functions that fall into various categories, and you'll find it confusing to keep them all in one file. At this point, you can start storing commands, variable settings, and functions in various files that meet different needs, and read them into your <em>.bashrc</em> file or any other script. Just use a dot to read a file and have its contents executed by the shell:</p>
<pre><code>.  scriptfile</code></pre>
<p>It's important to put a space after the dot, before the filename.<br />
</p>
<h2>Setting prompts</h2>
<p>Whenever bash or any other shell is waiting for the user to type a command, it displays a prompt, which can be as simple or complex as you like. A minimal prompt would be</p>
<pre><code>$</code></pre>
<p>The default prompt looks something like</p>
<pre><code> user@host:~$</code></pre>
<p>where user is the login name, host is the name of the computer, ~ is the working directory, short for the user's home, typically in the form <em>/home/user</em>, and $ means that the current user is not root.</p>
<p>To change the prompt, give a new value to the environment variable PS1. To make the change permanent, put the assignment in your <em>.profile</em> file, which bash reads whenever it starts up. The default value is \u@\h:\w\$, specifying username, host, working directory, and decorator characters. The following table describes the fields that can appear in a prompt, and various other useful characters. The prompt can ring the terminal &quot;bell&quot;, now more usually a beep; it can contain multiple lines using \r for Carriage Return; and it can contain embedded terminal control sequences, typically starting with the Escape character. We will not attempt to explain all of these options here. See <em>Bash Reference Manual</em>, by Brian Fox and Chet Ramey, for full details. <a href="http://www.gnu.org/software/bash/manual/" class="uri">http://www.gnu.org/software/bash/manual/</a><br />
</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">\a</td>
<td>an ASCII bell character (07)</td>
<td style="text-align: center;">\d</td>
<td>the date in &quot;Weekday Month Date&quot; format (e.g., &quot;Tue May 26&quot;)</td>
</tr>
<tr class="even">
<td style="text-align: center;">\]</td>
<td>end a sequence of non-printing characters</td>
<td style="text-align: center;">\e</td>
<td>an ASCII escape character (033)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\h</td>
<td>the hostname up to the first '.'</td>
<td style="text-align: center;">\H</td>
<td>the hostname</td>
</tr>
<tr class="even">
<td style="text-align: center;">\j</td>
<td>the number of jobs currently managed by the shell</td>
<td style="text-align: center;">\l</td>
<td>the basename of the shell's terminal device name</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\n</td>
<td>newline</td>
<td style="text-align: center;">\r</td>
<td>carriage return</td>
</tr>
<tr class="even">
<td style="text-align: center;">\s</td>
<td>the name of the shell, the basename of $0 (the portion following the final slash)</td>
<td style="text-align: center;">\t</td>
<td>the current time in 24-hour HH:MM:SS format</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\T</td>
<td>the current time in 12-hour HH:MM:SS format</td>
<td style="text-align: center;">\@</td>
<td>the current time in 12-hour am/pm format</td>
</tr>
<tr class="even">
<td style="text-align: center;">\A</td>
<td>the current time in 24-hour HH:MM format</td>
<td style="text-align: center;">\u</td>
<td>the username of the current user</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\v</td>
<td>the version of bash (e.g., 2.00)</td>
<td style="text-align: center;">\V</td>
<td>the release of bash, version + patchelvel (e.g., 2.00.0)</td>
</tr>
<tr class="even">
<td style="text-align: center;">\w</td>
<td>the current working directory</td>
<td style="text-align: center;">\W</td>
<td>the basename of the current working directory</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\!</td>
<td>the history number of this command</td>
<td style="text-align: center;">\#</td>
<td>the command number of this command</td>
</tr>
<tr class="even">
<td style="text-align: center;">\$</td>
<td>if the effective UID is 0 (root), a #, otherwise a $</td>
<td style="text-align: center;">\nnn</td>
<td>the character corresponding to the octal number nnn</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\\</td>
<td>a backslash</td>
<td style="text-align: center;">\[</td>
<td>begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code>$ PS1=&quot;\a\d, \e[31m\t\r\n\e[0m\u@\h:\w $&quot;</code></pre>
<p>would result in a sound from the computer, and the visible prompt</p>
<pre><code>Mon Mar 23, 13:47:43
user@host:~ $</code></pre>
<p>with the time printed in red. This uses \d for the date, \e[31m to turn on red color, \t for the time, \e[0m to turn off red, \r\n for Carriage Return and New Line, and the rest as in the default.<br />
</p>
<p>To make things more interesting, you can run a program within the prompt by enclosing it in [\$( )]. This example counts the number of files in the current directory, by counting the lines (<code>wc -l</code>) piped in from a directory listing (<code>ls</code>).</p>
<pre><code>$ PS1=&quot;\u@\h [\$(ls | wc -l)]:\$ &quot;
user@host [3]:$</code></pre>
<h2>Superuser Privileges</h2>
<p>Besides the configuration files in each user's directory, the system has a lot of configuration files that control system-wide behavior. Sometimes you'll find it necessary to edit one by hand, using a text editor. In this section we'll show how to grant someone superuser privileges, a system-wide issue controlled by a file named <em>/etc/sudoers</em>.</p>
<p>It is best not to edit this file in an ordinary text editor. The <code>sudoedit</code> command provides a much safer way to edit configuration files.</p>
<pre><code>$ sudoedit /etc/sudoers</code></pre>
<p>This makes a temporary copy of the file and opens the copy in an editor. You can override the default editor by setting the VISUAL or EDITOR environment variable to &quot;vi&quot;, &quot;emacs&quot;, or whatever you like.</p>
<p>Permission lines in <em>/etc/sudoers</em> identify the user, followed by the hosts the user can use <code>sudo</code> on, which groups the user can act as a member of, and which commands the user can execute using <code>sudo</code>.<br />
</p>
<p>An operator in a corporate or school system might have permissions that look like this.</p>
<pre><code>operator       ALL = DUMPS, KILL, SHUTDOWN, HALT, REBOOT, PRINTING,\
                       sudoedit /etc/printcap, /usr/oper/bin/</code></pre>
<p>(The '\' character continues the permissions on the next line.) This gives permission to run a specific set of commands, and to edit two specific configuration files, but no others. To give someone permission to run any superuser command using <code>sudo</code>, set the username's permission line to:</p>
<pre><code>username ALL = (ALL) ALL</code></pre>
<p>This also lets you edit any configuration file on your computer.</p>
<h2>Localization</h2>
<p>Different countries use different conventions for all sorts of things: character sets, currencies, the formats of dates and times, and even paper size and shape. Computers can be instructed which language to use, and which version of the language to use for a particular country. This combination of customized information is called the <em>locale</em>.<br />
</p>
<p>All of the locale settings are reported by the <code>locale</code> command. For example,</p>
<pre><code>$ locale
LANG=en_US.UTF-8
LC_CTYPE=&quot;en_US.UTF-8
LC_NUMERIC=&quot;en_US.UTF-8
LC_TIME=&quot;en_US.UTF-8&quot;
LC_COLLATE=&quot;en_US.UTF-8&quot;
LC_MONETARY=&quot;en_US.UTF-8&quot;
LC_MESSAGES=&quot;en_US.UTF-8&quot;
LC_PAPER=&quot;en_US.UTF-8&quot;
LC_NAME=&quot;en_US.UTF-8&quot;
LC_ADDRESS=&quot;en_US.UTF-8&quot;
LC_TELEPHONE=&quot;en_US.UTF-8&quot;
LC_MEASUREMENT=&quot;en_US.UTF-8&quot;
LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;
LC_ALL=</code></pre>
<p>The LANG setting <strong>en_US.UTF-8</strong> specifies English as the language, US as the country,  and Unicode UTF-8 as the encoding. Money in the US is in dollars, $. Paper is letter, 8.5&quot; × 11&quot;, as opposed to A4 for most of the rest of the world.</p>
<p>You usually specify a language and country when you install your operating system, and everything including the shell picks those values up. Originally, it was supposed that language, country, and character encoding would go together, but in our increasingly global society, it can happen that a Hungarian temporarily in the US on UN business would choose UTF-8, French language, metric (SI) measurements, Euros, Swiss address and telephone formats (for the home office in Geneva), and US letter paper.</p>
<p>You can change any of these settings in your shell by assigning an appropriate string to the relevant environment variable. The accepted values for locale settings are provided with options to the locale command.</p>
<pre><code>$ locale -m # available charmaps: character set and encoding identifiers
ANSI_X3.110-1983
ANSI_X3.4-1968
ARMSCII-8
ASMO_449
BIG5
BIG5-HKSCS
...         # 226 choices in Ubuntu 8.10
$ locale -a # available locales for English and UTF-8 in various countries
C
en_AU.utf8
en_BW.utf8
en_CA.utf8
en_DK.utf8
en_GB.utf8
en_HK.utf8
en_IE.utf8
en_IN
en_NG
en_NZ.utf8
en_PH.utf8
en_SG.utf8
en_US.utf8
en_ZA.utf8
en_ZW.utf8
POSIX</code></pre>
<p>You will get different locale specifications depending on the languages and encodings selected on your system at installation time or modified later. </p>
<p>To set your preferences, check for the correct format using these commands, and set the locale environment values in your <em>.profile</em> accordingly.</p>
<p>Another essential element of localization is your preferred keyboard layout, set with the <code>loadkeys</code> command for the command line, and <code>setxkbmap</code> for the X Window System (used on virtually all free desktops).</p>
<pre><code>$ loadkeys de-latin1 # German</code></pre>
<p>or</p>
<pre><code>$ setxkbmap dvorak # Dvorak keyboard for English</code></pre>
<p>The <code>setfont</code> command lets you change to a font for a specific writing system.</p>
<pre><code> $ setfont iso01.f16</code></pre>
<p>This sets a bitmap font covering ISO 8859-1, suitable for many Western European languages.</p>
<p>If you need to type documents in more than one writing system, you probably need to move to X. But there are extended versions of Emacs and vim that can create plain text files in multiple writing systems, either in their own format or in Unicode.<br />
</p>
<p><span id="ch027_parameter-substitution.xhtml"></span></p>
<h1>Parameter Substitution</h1>
<p>As we saw in the chapter on variables, you can put braces around a variable name to set it off from its surroundings:</p>
<pre><code>$ curr=myfile
$ rm ${curr}.jpeg</code></pre>
<p>There are also some nifty tricks you can perform inside the braces, such as changing parts of the string. Suppose you have a file named <em>mypicture.jpeg</em> instead of <em>myfile.jpeg</em>. You could alter the $curr variable when you insert it into a command:</p>
<pre><code>$ rm ${curr/file/picture}.jpeg</code></pre>
<h2><strong>Playing Safe With Variables That Don't Exist</strong></h2>
<p>Sometimes you might be using variables that have been removed (which you can do with the <code>unset</code> command) or were never initialized in the first place.  Since by default the shell uses an empty string for a nonexistent or undefined variable, as in the case of the <code>rm</code> command we showed earlier, it's useful to be able to substitute a default value for a variable.</p>
<pre><code>$ cat &quot;${VARIABLE_FILE_NAME:-/home/user/file}&quot;</code></pre>
<p>The '<strong>:-</strong>' operator asks the shell to check whether the variable is set. to see if it exists and is set to some string.  If it was never defined, or has no value, the shell substitutes the text after '<strong>:-</strong>'.</p>
<pre><code>$ cat &quot;${VARIABLE_FILE_NAME:=/home/user/file}&quot;</code></pre>
<p>The '<strong>:=</strong>' operator will do much the same, but instead of just substituting <em>/home/user/file</em> in the current <code>cat</code> command, if VARIABLE_FILE_NAME doesn't exist, the shell will also set the variable to the alternative text.</p>
<h2><strong>Cutting Corners With Variable Expansion</strong></h2>
<p>Variable expansion is by no means limited to filenames. It is also a handy way to pass complex, frequently used options to commands.</p>
<pre><code>$ export ALT_LS=&#39;--color=always -b -h --filetype&#39;
$ ls $ALT_LS</code></pre>
<p>Since the alternative options are stored and expanded in variable form, you can use whatever defaults you like for ninety-percent of your work but quickly use an alternative form in special cases.<br />
</p>
<p>Parameter expansion is an excellent way to abstractly deal with multiple files or tediously long series of options.  Once you understand it, it's bound to expand your abilities on the command line.<br />
</p>
<p><span id="ch028_gnuscreen.xhtml"></span></p>
<h1>GNU Screen<br />
</h1>
<p>GNU screen helps you get most out of your desktop's real estate, in cases where you need to work on more than one terminal simultaneously. Using GNU screen, you can have as many processes as you need, such as editors, web browsers and shells, all within a single terminal window. Every desktop system allows you to open multiple terminals in different windows, and most terminal programs let you run multiple sessions at once using tabs, but GNU screen is often easier to manage and less confusing when you have many sessions. Additionally, GNU screen offers a copy-paste mechanism to transfer pieces of text easily within the multiplicity of sessions handled by it. It can be used in an ordinary text terminal as well as on the desktop, and for most purposes it is an alternative to using multiple text terminal sessions and moving between them by the <strong>Alt + F#</strong> key combinations.<br />
</p>
<p>Start by typing <code>screen</code> in your command prompt.</p>
<pre><code>$ screen  </code></pre>
<p>You get a welcoming message and some versioning information, or your system may be configured so that it goes directly to a shell prompt.</p>
<p><img src="static/IntroCommandLine-Screen-screen-en.png" title="screen" alt="screen" width="507" height="366" /> </p>
<p>If you press <strong>Enter</strong> you get a shell prompt, just like before you invoked screen. You are now running within a single session of screen. In order to create a second session with its own shell, press <strong>ctrl + a</strong> followed by <strong>c</strong> or <strong>ctrl + c</strong>.  All screen commands begin with  <strong>ctrl + a</strong> but if you need to use that for some other purpose you can change that key binding. See the manual (type &quot;man screen&quot; at your bash prompt) for this and many details we will not present here.<br />
</p>
<p>If you want to run just one command in a new screen and then close the screen, specify the command as an argument:</p>
<pre><code>$ screen irssi</code></pre>
<h2>Switching Sessions</h2>
<p>To switch to the previous shell, enter <strong>ctrl + a</strong> followed by the <strong>p</strong> key. To go forward again, enter <strong>ctrl + a</strong> followed by the <strong>n</strong> key. You can see a list of all the sessions you have created using <strong>ctrl + a</strong> followed by the <strong>&quot;</strong> key. This presents a scroll-down menu listing all open sessions (very helpful when you have created many sessions!). If you want to save even the half second it takes to scroll down the menu, while being able to see a list of available sessions and instantly jump to another session, enter <strong>ctrl + a</strong> <strong>w</strong>. This keeps you in your current window, but adds, at the bottom of the screen, a list of sessions with a different number for each. Then enter <strong>ctrl + a <em>session_number</em></strong> to jump to the session of your choice.</p>
<p>Suppose you created a few sessions under GNU screen. In one session you have a Vim editor open, a couple more sessions you use for logging in to different remote servers, another session you use to run FTP, and so forth. By default, <strong>ctrl + a</strong> <strong>&quot;</strong> shows the program you used to start each session. Normally you started it with the shell, so <strong>ctrl + a</strong> <strong>&quot;</strong> shows &quot;bash&quot; for each session (or whatever your shell is). This isn't very helpful if you want to quickly find the session that's running Vim or FTP.</p>
<p>It turns out that customizing the display is easy. While you are in a session--say, editing in vim--press <strong>ctrl + a</strong><span> A</span> and you get a line at the bottom of your window with the name of your session, which you can edit to your liking.</p>
<h2>Copy &amp; Paste</h2>
<p>You can use the mouse (on systems running gpm) to select text in one session and paste it in any session or even another terminal. The screen program has its own method for copying text, like this:<br />
</p>
<ol>
<li>Press <strong>ctrl + a</strong> <strong>[</strong> to go into <em>screen copying</em> mode.</li>
<li>Navigate through the text anywhere in your window, using arrow keys or editor commands or whatever works in that session. At one end of the region of interest, press the <strong>spacebar</strong>.</li>
<li>Navigate to the end of the region of interest (text is highlighted as you proceed with your selection).</li>
<li>Press the <strong>spacebar</strong> again to copy the text to the clipboard.</li>
<li>Switch to the session where you want to copy the text, navigate to the right place and press <strong>ctrl + a</strong> <strong>]</strong>. This pastes the selected text into the edit buffer or onto the command line or whatever, depending on what that session is doing.</li>
<li>Repeat step 5 as desired.<br />
</li>
</ol>
<p>With either the mouse method or the screen method, text is taken from the video memory, which does not preserve the escape sequences that make colors, boldspace and so on. That is probably what you want if you are copying examples from a manual onto a command line, but maybe not what you want if you are taking exerpts from one file to another.<br />
</p>
<h2>Splitting The Screen</h2>
<p>Besides multiple full-screen windows, Screen can also allow two or more programs to share the screen at once.</p>
<p>Use <strong>ctrl + a</strong> <strong>S</strong> (capital S) to divide your screen into two parts. Your original session is at the top and a new blank session at the bottom. (Be careful you don't accidentally press <strong>ctrl + s</strong>. This can lock up your terminal. If you do accidentally hit <strong>ctrl + s</strong>, you can unlock the terminal with <strong>ctrl + q</strong>.) By default, there is no program running in this new region, but you can start one by using <strong>ctrl + a tab</strong> to move to that region and then typing <strong>ctrl + a c</strong>.</p>
<p>Each region acts as an independent session, and you can switch between sessions just as in fullscreen mode.</p>
<p>You can remove the current region by using <strong>ctrl + a X</strong>. This won't destroy the session or what's running in it. It just turns the other session back into a full-sized window.</p>
<h2>Detaching A Session</h2>
<p>One of Screen's most powerful features is the ability to halt and restore sessions.  Say you're doing something really interesting on your computer, but you have to leave and go to work.  Now say that while away you want to access what you were working on. If both machines are accessible through the Internet, you can do that with Screen.  For example you may start a session on a remote machine using the <code>telnet</code> or the safer <code>ssh</code> protocol, and then invoke <code>screen</code>.  When you have to leave, you can safely close the remote Screen session and later restore it, maybe accessing the remote machine from the command line of a third machine located in another suburb -- or in another continent.</p>
<p>Type <strong>ctrl + a d</strong> in your screen session. You return to your original terminal and the screen exits, printing <strong>[detached]</strong>. Now if you execute <code>ps</code>, you find that the screen is still running in the background. Get a list of all running sessions by passing <code>screen</code> the <code>-list</code> option.</p>
<pre><code>$ screen -list
There is a screen on:
12056.pts-0.hostname
(Detached)
1 Socket in
/var/run/screen/S-user_name.
$</code></pre>
<p>You can reconnect to this running session by entering:</p>
<pre><code>$ screen -r 12056.pts-0.hostname</code></pre>
<p>Or you can just use:</p>
<pre><code>$ screen -R</code></pre>
<p>This reconnects to the first session it finds.</p>
<p>Now all you have to do is log into your home machine from any remote machine and you are able to see whatever you were working on, exactly as you left it. Use the same procedure to put a download into the background with <code>wget</code>, or <code>ftp</code>. A detached session persists even if you log out from the machine.</p>
<h2>Quitting Screen</h2>
<p>If you have only a few programs open, you can exit screen simply by quitting them all. However, if you have many different application and windows open, you can exit them all by typing <strong>ctrl + a \</strong>. You are prompted for confirmation, and if you select yes, Screen terminates all its programs and exits.<br />
</p>
<p><span id="ch029_ssh.xhtml"></span></p>
<h1>SSH</h1>
<p>The command line is such a useful tool that it won't be long before you need to have access to the command line on a computer that is not sitting in front of you.  In the old days, before security was a concern, people used <code>telnet </code>to get a command line on a remote computer.  For most purposes, <code>telnet</code> is no longer a good idea, because data is transmitted in a raw, unencrypted format.  The standard secure way to gain access to a command line on a remote computer is via <code>ssh</code> (secure shell).  The simplest invocation of the command is</p>
<pre><code>$ ssh othermachine.domain.org</code></pre>
<p>This command assumes that your username on the remote machine is the same as your username on the local machine at which you type the command.  The remote machine prompts you for your password.  If your username on the remote machine is different than your username on the local machine, use the <code>-l</code> (lower-case &quot;L&quot;) option to indicate your username on the remote machine.<br />
</p>
<pre><code>$ ssh -l remoteusername othermachine.domain.org</code></pre>
<p>Alternatively, you can use email-style notation to indicate a different username.<br />
</p>
<pre><code>$ ssh remoteusername@othermachine.domain.org</code></pre>
<p>So far, all these commands display a command line on the remote machine from which you can then execute whatever commands that machine provides to you.  Sometimes you may want to execute a single command on a remote machine, returning afterward to the command line on your local machine. This can be achieved by placing the command to be executed by the remote machine in single quotes.<br />
</p>
<pre><code>$ ssh remoteusername@othermachine.domain.org &#39;mkdir /home/myname/newdir&#39;</code></pre>
<p><code>Sometimes</code> what you need is to execute time consuming commands on a remote machine, but you aren't sure to have sufficient time during your current <code>ssh</code> session.  If you close the remote connection before a command execution has been completed, that command will be aborted.  To avoid losing your work, you may start via <code>ssh</code> a remote <code>screen</code> session and then detach it and reconnect to it whenever you want.  To detach a remote <code>screen</code> session, simply close the <code>ssh</code> connection: a detached <code>screen</code> session will remain running on the remote machine.</p>
<p><code>ssh</code> offers many other options, which are described on the manual page. You can also set up your favorite systems to allow you to log in or run commands without specifying your password each time. The setup is complicated but can save you a lot of typing; try doing some Web searches for &quot;ssh-keygen&quot;, &quot;ssh-add&quot;, and &quot;authorized_keys&quot;.</p>
<h2>scp: file copying</h2>
<p>The SSH protocol extends beyond the basic <code>ssh</code> command.  A particularly useful command based on the SSH protocol is <code>scp</code>, the secure copy command.  The following example copies a file from the current directory on your local machine to the directory <em>/home/me/stuff</em> on a remote machine.</p>
<pre><code>$ scp myprog.py me@othermachine.domain.org:/home/me/stuff</code></pre>
<p>Be warned that the command will overwrite any file that's already present with the name <em>/home/me/stuff/myprog.py</em>. (Or you'll get an error message if there's a file of that name and you don't have the privilege to overwrite it.) If <em>/home/me</em> is your home directory, the target directory can be abbreviated.<br />
</p>
<pre><code>$ scp myprog.py me@othermachine.domain.org:stuff</code></pre>
<p>You can just as easily copy in the other direction: from the remote machine to your local one.</p>
<pre><code>$ scp me@othermachine.domain.org:docs/interview.txt yesterday-interview.txt</code></pre>
<p>The file on the remote machine is <em>interview.txt</em> in the <em>docs</em> subdirectory of your home directory. The file will be copied to <em>yesterday-interview.txt</em> in the home directory of your local system</p>
<p><code>scp</code> can be used to copy a file from one remote machine to another.</p>
<pre><code>$ scp user1@host1:file1 user2@host2:otherdir</code></pre>
<p>To recursively copy all of the files and subdirectories in a directory, use the <code>-r</code> option.</p>
<pre><code>$ scp -r user1@host1:dir1 user2@host2:dir2</code></pre>
<p>See the <code>scp</code> man page for more options.</p>
<h2>rsync: automated bulk transfers and backups</h2>
<p><code>rsync</code> is a very useful command that keeps a remote directory in sync with a local directory. We mention it here because it's a useful command-line way to do networking, like <code>ssh</code>, and because the SSH protocol is recommended as the underlying transmission for <code>rsync</code>.</p>
<p>The following is a simple and useful example. It copies files from your local <em>/home/myname/docs</em> directory to a directory named <em>backup/</em> in your home directory on the system <em>quantum.example.edu</em>. <code>rsync</code> actually minimizes the amount of copying necessary through various sophisticated checks.<br />
</p>
<pre><code>$ rsync -e ssh -a /home/myname/docs me@quantum.example.edu:backup/</code></pre>
<p>The <code>-e</code> option to <code>ssh</code> uses the SSH protocol underneath for transmission, as recommended. The <code>-a</code> option (which stands for &quot;archive&quot;) copies everything within the specified directory. If you want to delete the files on the local system as they're copied, include a <code>--delete</code> option. See the <code>rsync</code> manual page for more details about <code>rsync</code>.</p>
<h2>Making life easier when you use SSH often</h2>
<p>If you use SSH to connect to a lot of different servers, you will often make mistakes by mistyping usernames or even host names (imagine trying to remember 20 different username/host combinations). Thankfully, SSH offers a simple method to manage session information through a configuration file.</p>
<p>The configuration file is hidden in your home directory under the directory <em>.ssh</em> (the full path would be something like <em>/home/jsmith/.ssh/config</em> --if this file does not exist you can create it). Use your favorite editor to open this file and specify hosts like this:</p>
<pre><code>Host dev
HostName example.com
User fc</code></pre>
<p>You can set up multiple hosts like this in your configuration file, and after you have saved it, connect to the host you called &quot;dev&quot; by running the following command.</p>
<pre><code>$ ssh dev</code></pre>
<p>Remember, the more often you use these commands the more time you save.</p>
<p><span id="ch030_installing-software.xhtml"></span></p>
<h1>Installing Software</h1>
<p>Installing software on GNU/Linux is a broad subject because each version of GNU/Linux has its own way of doing things. Most are variations on apt-get (Advanced Packaging Tool), used by Debian, Ubuntu, gNewSense, and related distributions) or yum (Yellowdog Update Manager), used by Fedora, BLAG, and related distributions.  The basic syntax is<br />
</p>
<pre><code>$ sudo apt-get install packagename
$ sudo yum install packagename</code></pre>
<p>Several apt-get and yum functions have the same name and act in the same way, but by no means all. When you want to go beyond the simple cases described here, be sure to check the documentation for whichever you are using.<br />
</p>
<p>These examples use <code>sudo</code> to remind you that installing software and editing configuration files require superuser privileges. You can either use <code>sudo</code> with each command, or switch to being superuser with the <code>su</code> command. (Remember to exit your superuser session before resuming normal user work.)<br />
</p>
<p>There are numerous options to each command. To uninstall a package, use this command.<br />
</p>
<pre><code>$ sudo apt-get remove packagename 
$ sudo yum remove packagename</code></pre>
<p>To read repository index files, and update the local package database.</p>
<pre><code>$ sudo apt-get update
$ sudo yum update</code></pre>
<p>To install all available newer versions of packages.</p>
<pre><code>$ sudo apt-get upgrade</code></pre>
<p>To fix broken dependencies, if any.<br />
</p>
<pre><code>$ sudo apt-get --fix-broken</code></pre>
<p>The <code>yum</code> command does not have this option. There are other ways to deal with broken RPM package dependencies, but they require more help than we can give you here.<br />
</p>
<p>Users can configure multiple package repositories to download from by editing <em>/etc/apt/sources.list</em> as superuser. Be careful. Back up the current file before making any changes.</p>
<p>All types of GNU/Linux allow the user to install software using the source code. For software in Debian-style packages, you can use<br />
</p>
<pre><code> $ apt-get source packagename</code></pre>
<p>The <code>yum</code> utility does not handle source installs.<br />
</p>
<p>Compiling from source is especially important for software that is not available in packages, typically because it is too new. You probably don't want to tackle this process unless you know a little bit about how to use GNU/Linux commands and a little about the GNU/Linux file system, but whenever you decide to try out something brand new and possibly unfinished, this is the most common method. If you don't know about commands and file systems, you can easily get lost doing a source code installation. It is better to read up on them first, get comfortable with them, and then return here.</p>
<p>Installing from source works on any GNU/Linux system that has the compiler and related tools and libraries, so it's a good process to know, and it more or less follows this route once you have a source package:</p>
<ol>
<li>Unpack the archive and <code>cd</code> to its base directory.<br />
</li>
<li>Run the configure script <strong>./configure</strong><br />
</li>
<li>Compile the software <strong>make</strong><br />
</li>
<li>Install the software <strong>make install</strong><br />
</li>
</ol>
<p>To carry out the second and third steps, you must have compiler tools on your system. Some GNU/Linux systems come with these tools automatically, but others do not. Any system you are likely to use with this book, though, allows you to download the tools you need for free; search for the packages containing <code>gcc</code> and <code>binutils</code>.<br />
</p>
<h2>Dependencies</h2>
<p>Before we start, a word on dependencies. GNU/Linux developers often don't write an application from scratch; they rely heavily on work that has been done previously by other programmers. This is a smart practice, of course, because it saves time, and to aid this process many kind-hearted individuals have made libraries of code that other programmers can easily access and use within their own programs. These libraries are stored in fixed places in the GNU/Linux file system, usually in the directories whose names begin with <em>/lib</em>, <em>/usr/lib</em>, and <em>/usr/share/lib</em>.</p>
<p>If you install an application that requires certain libraries, it's easy as long as you have those libraries already installed on your system. However, if you don't have the required libraries, you need to find them and install them. If the programmers are thoughtful, they will have included information about dependencies in either the <em>README</em> or <em>INSTALL</em> files that you will find in the source directory of the application. Some extremely nice programmers give you both the name and the URL where you can get the necessary bits.</p>
<p>However, if you are installing software on a distribution other than the one it was developed on, you are likely to find libraries packaged quite differently than on the developer's system. In this case you may have to use the trial and error method: try compiling the source, and when you get an error message telling you of a missing dependency, try to install it. If you can't install it using the name given, you may need to ask someone more experienced how to find the appropriate package, or go looking for documentation of your distribution's packaging policies.<br />
</p>
<p>Usually, lazy GNU/Linux users don't bother to read these files so they just go through the standard process and find that the configure stage will give an error telling them what libraries are missing. These lazy types (this author included) then find the required bits and pieces online and install them.</p>
<p>However, if you are new to GNU/Linux, I suggest that you read the <em>README</em> and <em>INSTALL</em> before starting any installation process. It will save you time and heartache.</p>
<p>Just remember that although a dependency list might be long, you simply get all the necessary packages and install them one by one, following the same process described in the previous section, until finally you have everything you need for the program of your dreams to install and run.</p>
<p>Next, let's look at the installation process a little more in depth.</p>
<h2>Unpack the archive</h2>
<p>Most software sources come in the form of a compressed &quot;tape archive&quot; files that usually have a suffix like &quot;.tar&quot; or &quot;.tgz&quot;. The GNU <code>tar</code> command can automatically uncompress files ending with a <em>.gz</em> or <em>.tgz</em> suffix (which means the distributor used GZIP compression) but if other forms of compression were used (such as BZIP2 or LZMA) you have to use the appropriate uncompression program to retrieve the <em>.tar</em> file (colloquially known as a <em>tar ball</em>). To unpack the archive, use the <code>tar</code> command:</p>
<pre><code>$ tar zxvf packagename.tar.gz</code></pre>
<p>Where &quot;packagename&quot; in the example above is the actual name of your package that you wish to install. The <code>tar</code> command followed by the parameters <code>zxvf</code> uncompresses a <em>tar.gz</em> file and creates a new directory with all the extracted sources. The 'z' specifies BZIP compression; if the file suffix is &quot;.tgz2&quot;, specifiy BZIP2 compression by using a 'j'. Don't worry-- if it fails to extract you just get an error message. You can remove the <em>tar.gz</em> file after it successfully unpacks.<br />
</p>
<p>Now you must change your working directory to this new directory using the <code>cd</code> command. Usually the new directory name is the name of the compressed source package minus the compression suffix. For example, if my package really was called <em>newsoftpack-1.0-alpha.tar.gz</em>, then after running the <code>tar zxvf</code> command on it I would be left with a new directory called <em>newsoftpack-1.0-alpha</em> and would type <code>cd newsoftpack-1.0-alpha</code> to enter this new directory. If you are not sure of the name of the newly created directory, type <code>ls</code>.</p>
<h2>Run the configure script</h2>
<p>Once inside the new directory, we want to start the actual installation process. To do this, most of the time you will need to type the following:</p>
<pre><code>$ ./configure</code></pre>
<p>Properly packaged source distributions usually contain a script that checks for needed utilities and libraries and prepares the source tree for building and installation. In this case, we will assume that it is <code>configure</code>, since it is a very popular choice for such a script. Sometimes, the command you need to use is different. In those cases, look for information in the <em>README</em> or <em>INSTALL</em> file.</p>
<p>In the command shown, by putting a dot and a slash before the name of the script (<code>./configure</code>) you are telling GNU/Linux to execute (run) a script called <code>configure</code> from the current directory (denoted by &quot;<code>./</code>&quot;). The script then does its stuff, checking what kind of a computer you have, what you already have installed, what kind of GNU/Linux you are running, and so on.</p>
<p>One option to <code>configure</code> is particularly common: the <code>--prefix</code> option, which tells <code>configure</code> you want the software installed in a non-default location. On most systems, the default is fine, and it may be where other software expects to find the software or library you're installing. But sometimes you can't install the software into a shared location or you want it somewhere under your own home directory because you know you're the only person using it. To change the directory where the software will ultimately be installed, specify it with <code>--prefix</code>:</p>
<pre><code>$ ./configure --prefix ~/bin/myprogs</code></pre>
<p>The most common problem that will occur at this stage is that the configure script will halt and tell you that some software library that the new software depends on is missing. If you do experience this error, check the <em>README</em> and <em>INSTALL</em> files in case they tell you how to repair the problem, then use a search engine if necessary to find out what software the error message is talking about and where to get it. Then start the installation process again with this new package. This means that an installation sometimes can take days while you search and download all the packages you need. This is one of the great advantages of package management systems such as yum and apt-get: when developers create packages for these systems, they automate the installation of dependencies.</p>
<p>In some cases, dependencies are optional. The <code>configure</code> script actually supports a lot of options. You can see what options your software package supports by running:</p>
<pre><code>$ ./configure --help</code></pre>
<h2>Compile the software</h2>
<p>Assuming the <code>configure</code> process finished successfully, the next command to type in the installation process is:</p>
<pre><code>$ make</code></pre>
<p>If you have several processors or processor cores, you can use multiple jobs to speed up processing by adding a <code>-j</code> option:</p>
<pre><code>$ make -j3</code></pre>
<p>These commands actually make (&quot;compile&quot;) the software for you. You will then end up with a whole lot of compiled files which in total makes up your software. The <code>make</code> process can take a while, depending on the speed of your machine and the size of the package sources you are installing. Running other processor-intensive applications will also slow down the process.</p>
<p>In the second command shown, <code>-j3</code> tells <code>make</code> to try to run 3 compilation processes simultaneously, which will allow you to utilize processor resources better if you have a dual-core or bigger machine. The number after <code>-j</code> is arbitrary, but a good rule of thumb is the number of processor cores plus one.</p>
<p>As with <code>configure</code>, you may encounter errors during compilation. In such a case, if you can't fix the problem yourself, contact the developer of the software and politely ask for help, explaining your problem very clearly. The Web page <a href="http://www.catb.org/~esr/faqs/smart-questions.html" class="uri">http://www.catb.org/~esr/faqs/smart-questions.html</a> explains how to write polite and helpful problem reports. But first, see if there are log files from the configure and make steps. These may give you more information than was presented on the screen, even if you managed to see what was on the screen as it all flashed by. You can also repeat these steps, adding &quot; &amp;&gt; logfile&quot; to the command in order to capture all output in logfile (use a filename that does not already exist). Before repeting the make step you should probably do &quot;make clean&quot;  in order to remove objects made by previous attempts.<br />
</p>
<h2>Install the software</h2>
<p>After <code>make</code> has finished without errors, type the following:</p>
<pre><code>$ sudo make install</code></pre>
<p>This will install the newly created files from your software in the correct locations in your system. This is usually under <em>/usr/local/</em>, though this can be overridden with a <code>configure</code> option, as we have seen. Because software is usually installed in a shared directory that only the root user can write to, you need to start the command with <code>sudo</code> to have permission to add your software. You don't need the <code>sudo</code> if you told <code>configure</code> to install into a directory under your own home directory.<br />
</p>
<p>So now you just need to type the name of the application in your terminal window and it should run. If it fails to start, a common remedy is to type <code>ldconfig</code> and then try again. <code>ldconfig</code> updates the system so that your operating system knows that there are new library files present.</p>
<p><span id="ch031_making-your-own-interpreter.xhtml"></span></p>
<h1>Making Your Own Interpreter<br />
</h1>
<p>The bash shell and many other programs obtain lines of command input from the keyboard or a file, and then interpret them. In the case of keyboard input, editing facility is provided (or should be). Often this is done by using the readline library. Here we present a simple calculator program which uses command lines. You can lift the C source code out of this manual, put it in a file and compile and run it in order to study the construction and use of a command line interpreter. The tremendous advantages that this programming approach gives relative to the GUI approach have been discussed elsewhere in this manual. With bdc you can recall and re-execute complicated calculations, and you can make script files in which such calculations are saved.</p>
<p> This is the source code, written for GNU-Linux:<br />
</p>
<pre><code>/* The Brain-Dead Calculator.
  Build:
gcc -g -O -Wall -o bdc bdc.c -lm -lreadline -lcurses
  Run:
./bdc    or   ./bdc path-to-command-file   or   path-to-exe-bdc-command-file
  Example commands:
3 q c -2.15 * s +     # calculates sqrt(3) + sin(-2.15*sqrt(3))
?                     # prints help message
*/
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;readline/readline.h&gt;
#include &lt;readline/history.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

#define MAXLEVS 12
int levs = 8;
double st[MAXLEVS];

int do_file( char *path );

int parse( char *comm )
{
  int cc, pop, ii, ps;
  int cp = 0, cp0;
  int cl = strlen(comm);
  double rollin;
  char *endp, *comfile;

  if ( !cl ) return 0;
  do {
    rollin = 0.0;  pop = 1;
    cc = comm[cp];
    switch( cc ) {
      default:  if ( (cc &gt;= &#39;0&#39;) &amp;&amp; (cc &lt;= &#39;9&#39;) ) goto num;
        printf( &quot;\nERROR at input position %d\n&quot;, cp );
        pop = 5;  break;
      case &#39;#&#39;:
        pop = 3;  break;
      case &#39;?&#39;:  printf(
&quot;\nBrain-Dead Calculator with %d-level stack;  x=quit\n&quot;, levs );
                 printf(
&quot;op=  + - * /   perform arithmetic:&quot;
&quot;   st[1] = st[1] op st[0]   and shift st[j-1] &lt;-- st[j]\n&quot;
&quot;op=   s  q     perform functions:&quot;
&quot;  st[0] = func(st[0])  s= sine  q= square-root\n&quot;
&quot;op=   d c r    manipulate stack:&quot;
&quot;  d= discard st[0];  c= copy st[0];  r= rotate st[j-1] &lt;-- st[j]\n&quot;
&quot;op=   &amp;path    run the command file specified by path\n&quot; );
      case &#39; &#39;:  pop = 0;  break;
      case &#39;+&#39;:  if ( (comm[cp+1] &gt;= &#39;0&#39;) &amp;&amp; (comm[cp+1] &lt;= &#39;9&#39;) ) { num:
          memmove( st+1, st, (levs-1)*sizeof(double) );
          st[0] = strtod( comm+cp, &amp;endp );
          cp += (endp-(comm+cp))-1;
          pop = 0;  break;
        }
        st[1] += st[0];  break;
      case &#39;-&#39;:  if ( (comm[cp+1] &gt;= &#39;0&#39;) &amp;&amp; (comm[cp+1] &lt;= &#39;9&#39;) ) goto num;
        st[1] -= st[0];  break;
      case &#39;.&#39;:  goto num;
      case &#39;*&#39;:  st[1] *= st[0];  break;
      case &#39;/&#39;:  st[1] /= st[0];  break;
      case &#39;q&#39;:  st[0] = sqrt(st[0]);  pop = 0;  break;
      case &#39;s&#39;:  st[0] = sin(st[0]);  pop = 0;  break;
      case &#39;d&#39;:  break;
      case &#39;c&#39;:  memmove( st+1, st, (levs-1)*sizeof(double) );
                 pop = 0;  break;
      case &#39;r&#39;:  pop = 2;  break;
      case &#39;&amp;&#39;:
        ii = 0;  cp += 1;  cp0 = cp;
        while ( comm[cp] &gt; &#39; &#39; ) {
          cp += 1;  ii += 1;
        }
        comfile = malloc( ii+1 );  // we really should check malloc failure
        memcpy( comfile, comm+cp0, ii );  comfile[ii] = 0;
        ps = do_file( comfile );
        free( comfile );
        pop = 0;  break;
      case &#39;x&#39;:  pop = 4;  break;
    }
    switch( pop ) {
      case 0:  break;
      case 2:  rollin = st[0];
      case 1:  memmove( st, st+1, (levs-1)*sizeof(double) );
               st[levs-1] = rollin;  break;
      default:  return pop;
    }
    cp += 1;
  } while ( cp &lt; cl );
  return 0;
}

int do_file( char *path )
{
  FILE *do_fb;
  char *comm;
  ssize_t len;  size_t len1;
  int  ps, ii, comcount = 0;

  do_fb = fopen( path, &quot;r&quot; );
  if ( !do_fb ) {
    perror( &quot;do_file: cannot open&quot; );
    return 0;
  }
  do {
    comm = NULL;
    len = getline( &amp;comm, &amp;len1, do_fb );
    if ( len == -1 ) { ps = 0;  break; }
    comm[len-1] = 0;
    ps = parse( comm );
    free( comm );  comcount += 1;
  } while ( (ps != 4) &amp;&amp; (ps != 5) );
  fclose( do_fb );  // we really should check for fclose failure
  printf( &quot;file %d st=&quot;, comcount );
  for ( ii = 0;  ii &lt; levs;  ii++ ) printf( &quot;  %g&quot;, st[ii] );
  printf( &quot;\n&quot; );
  return ps;
}

int main( int argc, char **argv )
{
  char *comm;
  int ii, ps, comcount=0;

  if ( argc &gt; 1 ) {
    ps = do_file( argv[1] );
    if ( ps == 4 ) return 0;
    if ( ps == 5 ) return 1;
  }
  do {
    do {
      comm = readline( &quot;bdc&gt; &quot; );
    } while ( comm == NULL );
    add_history( comm );
    ps = parse( comm );
    free( comm );  comcount += 1;
    printf( &quot;comm %d st=&quot;, comcount );
    for ( ii = 0;  ii &lt; levs;  ii++ ) printf( &quot;  %g&quot;, st[ii] );
    printf( &quot;\n&quot; );
  } while ( ps != 4 );
  return 0;
}

</code></pre>
<p>Here are instructions for building and running bdc. We are doing it in /tmp just for concreteness, but you could put it anywhere. </p>
<ul>
<li>Lift the source out of this manual and put it in the file /tmp/bdc.c</li>
<li>cd to /tmp</li>
<li>Build the program by running the gcc command shown in the comment at top of bdc.c</li>
<li>Run the program by typing <strong>./bdc</strong></li>
<li><strong></strong> Give bdc commands strings at the <strong>bdc&gt;</strong> prompt, such as <em>1.23 s 3 + q</em></li>
</ul>
<p><em></em></p>
<ul>
<li>To quit, use the <em>x</em> command</li>
</ul>
<p>The bdc command interpreter starts at the beginning of a command string and processes commands and numbers until it gets to the end (or an error). It maintains a stack of numbers, and commands act on them in various ways. The command interpreter is called in two places: a loop that gets command strings from a file, and a loop that gets command strings from the keyboard. The keyboard input is obtained by readline, and the strings are stored in a history list. Therefore, commands can be edited just like shell commands, and previous ones can be recalled.</p>
<p>Here is a small bdc command file. Lift it out and put it in /tmp/example.bdc. Then you can run it by typing <strong>&amp;example.bdc</strong> on the bdc command line. You can also run it from the shell by typing <strong>./bdc example.bdc</strong>. It will perform the calculations, display the resulting stack and give an input prompt. You can then do more calculations. If you make it executable (<strong>chmod +x example.bdc</strong>) you can start bdc from the shell by typing <strong>./example.bdc</strong>. This has the same effect as typing <strong>./bdc example.bdc</strong>; in both cases the shell starts the bdc program and passes &quot;example.bdc&quot; as an argument.<br />
</p>
<pre><code>#!/tmp/bdc
# Calculate sin(1.5+sqrt(3.14))*7.9
3.14 q 1.5 + s 7.9 *
# Calculate sqrt(5+(previous result))
c 5 t + q</code></pre>
<p>For simplicity we have used only one-character commands, and very few of them. The experix project on SourceForge is a much more capable calculator. Its stack can hold numbers, arrays, strings, file controls and other things, and its operators and commands do what makes sense with the stack arguments that they get. There are comparison and conditional branch operators so that experix command strings can be full-fledged programs. Stack objects and command sequences can be packaged in variables and then invoked by name. It draws graphs and writes text on a framebuffer screen, using a separate server program. In order to see the command line on the graphics screen, characters from stdout are packaged into server commands. Some of the command files demonstrate the technique of passing arguments to experix by including them on the &quot;#!...&quot; line of the command file. Installation of experix is far from being simple and automated, but help is available by contacting the author.<br />
</p>
<p> </p>
<p><span id="ch033_text-editors.xhtml"></span></p>
<h1>Text Editors</h1>
<p>Besides running simple commands like <code>ls</code> and <code>grep</code>, you can use the command line to start large, complex programs. Before graphical interfaces were common, programs were designed to use plain text and take up the screen. Now these programs run within the same window that you use for the command line.</p>
<p>In this book we'll focus on text editors, because you need them to save your commands for later use and to write scripts. They're handy for lots of other things too; for instance, you may want to edit HTML files on a web server using a text editor.</p>
<h2>Word Processing vs Text Editing</h2>
<p>Almost everybody who uses a computer is familiar with a word processor. The free software world provides several powerful ones, including OpenOffice.org and KWrite. The text editors we show in this book manipulate text, like word processors, but there's a fundamental difference.</p>
<ul>
<li>Word processors store a lot more than a stream of text characters you see on the screen. They want to provide &quot;rich text,&quot; with italic and bold, numbering and bullets, colors--you name it. This is obviously valuable for many purposes. A plain text resume does not impress many employers.<br />
</li>
<li>On the other hand, word processors are showing their limitations these days: some word processors have proprietary formats that make it hard to use documents in other programs. In fact, sometimes you cannot open a document with another version of the same word processor, or the document has display problems.</li>
<li>Many people find online collaboration tools (such as the wiki software we used to write this manual) and content management systems (such as many weblog sites use) easier for modern document production than a word processor. But word processors are also evolving to do a better job supporting collaboration; probably all these tools will merge over time and evolve into something better than any of them offered before.</li>
</ul>
<p>Word processors, wikis, content management systems, and text editors all have their place. The tasks in this book require a text editor. If you want to use a word processor to edit these files, you can do so, but make sure to choose a plain text form when you save the file.<br />
</p>
<h3></h3>
<h2>Why do you need a text editor?</h2>
<p>GNU/Linux is a very file-centric operating system: everything is (or looks like) a file. All basic configuration is done via carefully crafted text files, in the right place with the right contents. You can find many graphical tools to configure your GNU/Linux box, but most of them just tweak text files on your behalf.</p>
<p>Those text files have an exact syntax that you must follow. A simple misplaced character could jeopardize your system, so using a word processor for this matter is not only a bad idea but could corrupt your files with extra formatting information. Configuration files don't need italic or bold, they only need the right information.</p>
<p>With source code it's the same thing. Compilers (programs that turn code into other programs) are very strict with syntax. Some of them even care about where in the line a specific command is. Word processors mess up the position of text in lines far too much for compiler to like them. What you need is a clean view of what's in the source code or the configuration file to know that what you're writing is exactly what your system will get.<br />
</p>
<p>Some editors go even further: they became Integrated Development Environments (IDEs), that not only understand what you're typing (be it an Apache configuration or Java code) but can predict what you want to type, suggest modifications, or show your mistakes. They can color specific keywords, automatically place things in the right place, and so on.</p>
<p>But the most important is that all those colors and highlighting are done <em>only</em> within the display. Those fancy changes are <strong>not</strong> propagated to the text files, which are meant to be plain text. This is one particular useful feature that word processing programs can't do and is most essential to text editing.</p>
<h2>Why are most text editors command-line programs?</h2>
<p>In the beginning... was the command line (Neil Stephenson). Twenty years ago there weren't many graphical interfaces around and Unix was already a grown-up operating system running on a whole lot of very important computers. All configuration was already stored in text files because of the KISS principle (keep it short and simple). Unix made the most of KISS and plain text by helping programs work together on text files. Pipes (using the | character) are one powerful method of working together that you've seen in this book.<br />
</p>
<p>Nowadays, computers have thousands of times more power than those early ones, but keeping configuration in text files still gives a big advantage when the only connection you have to your server is through a 56-Kbit modem line and it's in a different country. Having to open a graphical interface might not be possible and if that's the only way you have to fix a problem, you're in big trouble.</p>
<p>Making graphical programs that deal with configuration was a big plus, as the average user can now change things without reading tons of documentation and isn't likely to break the system by inserting one wrong character to a point where it's irrecoverable, but providing text files and the command-line editor is fundamental to any operating system.</p>
<p>Although most text editors came from the command-line world, most also have a graphical interface today. Menus and buttons do help a lot when using Gvim or Emacs. GEdit and Kate (which are purely graphical) are short and simple, still providing the same basic functionality and the same important features for text editing.</p>
<h2>Setting a default text editor</h2>
<p>Because the terminal and command line are so tied in with the text editors, many commands open up a text editor for you. We saw one example <code>sudoedit</code>, in the &quot;Useful Customizations&quot; section. You can set the default editor though by setting either the EDITOR or the VISUAL environment variable. For instance:<br />
</p>
<pre><code>$ export EDITOR=emacs</code></pre>
<p>Put this in a startup file such as <em>./bashrc</em>, and commands will use your chosen editor when they present a file for editing.<br />
</p>
<h4></h4>
<p><span id="ch034_nano.xhtml"></span></p>
<h1>Nano</h1>
<p>Nano is a simple editor. To open it and begin creating a new text file, type the following at the command line:</p>
<pre><code>$ nano filepath</code></pre>
<p>where <em>filepath</em> is the path to the file you want to edit (or nothing). The screen is taken over by the program as shown in Figure 1.<br />
</p>
<p><strong><em></em></strong></p>
<p><img src="static/IntroCommandLine-nano-nano_openfile-en.png" title="nano_openfile" alt="nano_openfile" width="507" height="341" /></p>
<p> Figure 1. Opening screen for nano<br />
</p>
<p>The screen is no longer a place to execute commands; it has <em>become</em> a text editor.<br />
</p>
<h2>Exiting nano<br />
</h2>
<p>To exit <code>nano</code>, hold down the <strong>Ctrl</strong> key and press the <strong>x</strong> key (a combination we call <strong>ctrl + x</strong> in this book).  If you have created or altered some text but have not yet saved it, <code>nano</code> asks:</p>
<pre><code>Save modified buffer (ANSWERING &quot;No&quot; WILL DESTROY CHANGES) ? </code></pre>
<p>To save the changes, just type <strong>y</strong> and nano prompts for a destination filepath. To abandon your changes, type <strong>n</strong>.<br />
To save changes without exiting, press <strong>ctrl + o</strong>. <code>nano</code> asks you for the filename in which to save the text:</p>
<pre><code>File Name to Write:</code></pre>
<p>Type the name of the file, and press the <strong>Enter</strong> key (or if the buffer already has the right name just press <strong>Enter</strong>).  For instance:</p>
<pre><code>File Name to Write: textfile.txt</code></pre>
<h2>Exploring Files<br />
</h2>
<p>You can move around the file and view different parts using the arrow keys. This is a very fast and responsive way to explore a file.</p>
<h2> Help</h2>
<p>Be sure to read the man page because it has a lot of good hints. There is help available in your nano session by typing <strong>ctrl + g</strong> and to get back to your file type <strong>ctrl + x</strong>.<br />
</p>
<p><span id="ch035_vim.xhtml"></span></p>
<h1>vi and vim</h1>
<p>Vi is a very powerful command-line text editor. It's used for everything from quick fixes in configuration files to professional programming and even for writing large, complex documents like this book. It's popular on the one hand because it's fast and light-weight, and you can accomplish a lot with a few keystrokes. On the other hand it's also powerful: highly configurable, with many built-in functions.</p>
<p>Vim is an enhanced version of Vi, offering a lot of features that make life easier for both the novice and expert (Vim stands for &quot;Vi IMproved&quot;). On many modern systems, Vim is installed as the default version of Vi. So if you invoke the <code>vi</code> command you actually run Vim. This is usually not confusing, because everything in Vi works in Vim as well. We will look at Vim in this chapter, but if your system has Vi you can apply these techniques, just replace any reference to <code>vim</code> in the commands to <code>vi</code>.<br />
</p>
<p>The best feature about Vim/Vi is that it's shipped with virtually all GNU/Linux variants by default. Once you learn Vim, whenever you are, you can have the power of efficient editing.</p>
<p>The main drawback of Vim is, as for Emacs (another command line editor), the learning curve. The keyboard short-cuts can be daunting to learn.</p>
<p>Fortunately, you can work around those drawbacks by using a graphical version of Vim (GVim) with all the buttons and menus for more graphical users. You can also try easy-Vim, with Notepad style editing.</p>
<p>These simplified versions of Vim reduce the learning curve a lot and expose less advanced users to the power of efficient editing, which in turn increases one's will to learn a more powerful editor.</p>
<h2>Basic commands</h2>
<p>To open Vim and begin creating a new text file, get a command-line open and type:</p>
<pre><code>$ vim</code></pre>
<p>This presents you with a blank screen, or (if the program running is Vim) a screen of information looking something like this:</p>
<p><img src="static/IntroCommandLine-nano-vim-en.png" title="vim" alt="vim" width="507" height="366" /></p>
<p>If you want to open an existing file, just specify it on the command line as an argument. For instance, the following opens a file called <em>/etc/fstab</em>:<br />
</p>
<pre><code>$ vim /etc/fstab</code></pre>
<p>This file already exists on most GNU/Linux systems, but if you open a non-existent file, you'll get a blank screen. The next section shows you how to insert text; when you're finished you can then save the file.</p>
<h3>Inserting Text</h3>
<p>Whether you have a blank screen or a file with text in it, you can add text by entering what's known as <em>edit mode</em>. Just press <strong>i</strong>. You should see this on the bottom of the screen:</p>
<pre><code>-- INSERT --</code></pre>
<p>Whenever this appears on the bottom of the screen, you are in edit mode. Whatever you type becomes part of the file. For instance, try entering &quot;This is line 1.&quot; Then press the <strong>Enter</strong> key and enter &quot;This is line 2&quot;. Here's what this fascinating contribution to literature looks like in Vim:</p>
<p><img src="static/IntroCommandLine-nano-vim_insert-en.png" title="vim_insert" alt="vim_insert" width="507" height="366" /></p>
<p>When you are finished inserting text, press the <strong>Esc</strong> (Escape) key to leave edit mode; that puts you in normal mode.</p>
<h3>Only One Place At a Time: The Cursor</h3>
<p>Vim, like every editor, keeps track of where you are and shows a cursor at that point, which may look like an underline or a box in a different color. In edit mode, you can backspace to remove characters. Vim also allows you to move around using arrow keys and edit the whole document freely. But normal Vi doesn't let you move around; it restricts you to adding text or backspacing to remove it.</p>
<p>In normal Vi, if you want to go back over what you edited, or move to another place in the file, you must press the <strong>Esc</strong> key, move to the place where you want to insert text, and enter edit mode again. This may seem cumbersome. But Vi provides so many alternate ways of moving around and adding text that you'll find, with some practice, that it's no barrier to productivity. As already mentioned, Vim lets you move around freely and edit the whole file when you're in edit mode--but you'll find yourself leaving edit mode often in order to make use of Vim's powerful commands.<br />
</p>
<h3>Basic Movement Commands</h3>
<p>To practice moving around in a file, you can press the <strong>Esc</strong> key to get out of edit mode. If you have only a small amount of text in the file, you may prefer to find another text file on your system that's larger, and open that. Remember that when you open a file you're in normal mode, not edit mode.</p>
<p>To move around use the arrow keys.</p>
<p>To jump to a specific line use the colon button followed by a line number. The following jumps to line 20:</p>
<pre><code>:20</code></pre>
<p>You can move quickly up or down a text file by pressing the <strong>PgUp</strong> and <strong>PgDn</strong> keys.</p>
<p>Search for text by pressing the slash key (/) and then typing the text you want to find:</p>
<pre><code>/birthday party</code></pre>
<p>You can simply repeat the <strong>/</strong> key to search for the next occurrence of the string. The search is case-sensitive. To search backward, press the question-mark key (?) instead of the slash key.<br />
</p>
<h3>Saving and exiting</h3>
<p>If you're in edit mode, you can save your changes by pressing <strong>Esc</strong> to go to normal mode, typing <strong>:w</strong> and pressing the <strong>Enter</strong> key. This saves your changes to the file you specified when you opened Vim.</p>
<blockquote>
<p>Note: Vim, by default, does not save a backup of the original version of the file. Your <strong>:w</strong> command deletes the old contents forever. Vim can be configured to save backups, though.</p>
</blockquote>
<p>If you opened Vim without specifying a file name, you receive an error message when you press <strong>:w</strong>:</p>
<pre><code>E32: No file name</code></pre>
<p>To fix this, specify <strong>:w</strong> with a filename:</p>
<pre><code>:w mytestfile.txt</code></pre>
<p>This must also be followed by the <strong>Enter</strong> key.</p>
<p>To exit Vim, press <strong>:q</strong>. If you have unsaved text, you receive an error message:</p>
<pre><code>E37: No write since last change (add ! to override)</code></pre>
<p>Like most word processors, Vim tries to warn you when you might make a mistake that costs you work.  As the message suggests, you can abandon your text and exit by pressing <strong>:q!</strong>. Or use <strong>:w</strong> to save your changes and then enter <strong>:q</strong> again. You can combine writing and quitting through any of the following:</p>
<pre><code>:wq (followed by Enter)
:x (followed by Enter)
ZZ</code></pre>
<h3>Using your mouse with Vim.<br />
</h3>
<p>Sometimes it's convenient to use your mouse with Vim, to select text or even just to quickly position the cursor. To enable this mode pass Vim the command:<br />
</p>
<pre><code>:set mouse=a (followed by Enter)</code></pre>
<h3>Opening up several files at the same time</h3>
<p>Since version 7 Vim has had the (rarely noticed) feature of tabs, that's right, just like those in Firefox or other tabbed applications.</p>
<p>To use tabs in Vim pass the command :tabnew &lt;file&gt;. For instance, to open up a file foo.txt so that it appears in a tab I would:</p>
<pre><code>:tabnew /path/to/foo.txt (followed by Enter)</code></pre>
<p>To move back and forth between this file and the one you were working on previously, use the keys <strong>g</strong> and then <strong>t</strong>. To help remember this key combination you can think of &quot;g&quot; as in goto and &quot;t&quot; as in tab. You can open up as many files as you like into tabs and use <strong>gt</strong> to traverse between them. If you have enabled mouse input (see &quot;Using your mouse with Vim&quot;, above) then you can simply click on the tab itself.<br />
</p>
<p>You can close a tab in the same way you would a normal file, with <strong>:wq</strong> to commit the changes, or just <strong>:q</strong> to close without committing. </p>
<h3>Copy, Cut and Paste (A quick introduction to Visual Mode in Vim)</h3>
<p>Vim uses a mode called <em>Visual Mode</em> to select text for copying to the 'buffer' (think of a buffer as a clipboard) to be used elsewhere.</p>
<p>To activate Visual Mode, just hit the <strong>v</strong> key on your keyboard and hit enter. Using the cursor keys (arrow keys) select the text you would like to copy or cut. <br />
<br />
To copy the selected text, hit the <strong>y</strong> key ('y' stands for &quot;yank&quot;). Now, use the cursor keys and move to a new location in your document. Now press the <strong>p</strong> key ('p' stands for &quot;put&quot; but you can think of it as &quot;paste&quot;) to place the text in the given position.</p>
<p>To cut the selected text, hit the <strong>x</strong> key (who knows what 'x' stands for!). Now move to a new position in your document and press <strong>p</strong> to &quot;put&quot; the text in that place.</p>
<p>Sometimes it's useful to select text in lines or columns. Experiment with these other forms of Visual Mode by holding <strong>SHIFT+v</strong> to select whole lines or <strong>CTRL+v</strong> to select columns. Before you know it you'll be working just as quickly as you would with a mouse in a word editor! </p>
<p>Practice!</p>
<p><span id="ch036_emacs.xhtml"></span></p>
<h1>Emacs</h1>
<p>Emacs is a very powerful text editor.  You can invoke Emacs by typing its name at the command line.</p>
<pre><code>$ emacs</code></pre>
<p>If you are using a typical graphics-based GNU/Linux distribution, this command opens a new window with Emacs running in that new window. </p>
<p><img src="static/IntroCommandLine-Emacs-emacs-en.png" alt="emacs.png" width="600" height="559" /> <br />
 </p>
<p>Due to its versatility, many users find themselves resorting to Emacs constantly, and they open an Emacs session soon after turning their computer on and leave it open for the duration of their computing endeavor.  If you plan to have Emacs running for an extended time, it is helpful to run Emacs in the background or another virtual terminal so that the command line becomes available for another command.<br />
</p>
<pre><code>$ emacs &amp;</code></pre>
<p>You may occasionally want to run Emacs directly in the terminal window.  Use the <code>-nw</code> (no window) option for this.<br />
</p>
<pre><code>$ emacs -nw</code></pre>
<p>You can load a file for editing at the time you start Emacs by giving the file name after the <code>emacs</code> command.</p>
<pre><code>$ emacs filename</code></pre>
<p><img src="static/IntroCommandLine-Emacs-Screenshot_emacs_montage-office-fsf-org_1-en.png" alt="Screenshot_emacs_montage.office.fsf.org_1.png" /> </p>
<h2>Basic editing commands</h2>
<p>Once Emacs is running, there are a number of basic editing commands you can use.  In most of this book, outside of this Emacs chapter, we use a notation like <strong>ctrl + x</strong> to denote depressing the <strong>Ctrl</strong> (Control) key, then pressing the <strong>x</strong> key while <strong>Ctrl</strong> is depressed, then releasing both keys.  In this Emacs chapter, we employ the notation used in the Emacs documentation, which abbreviates <strong>ctrl + x</strong> as <strong>C-x</strong>.<br />
</p>
<h3>C-x C-f (load file into buffer)<br />
</h3>
<p>The command <strong>C-x</strong> <strong>C-f</strong> (press the <strong>Ctrl</strong> key, press and release <strong>x</strong>, press and release <strong>f</strong>, release <strong>Ctrl</strong>) loads a file on disk into an Emacs <em>buffer</em> (an Emacs working area) for editing.  You are prompted for the name of the file to load.  You may then make changes to the buffer by typing and by using other Emacs commands.  The buffer is not saved to a file on disk until you specifically request it with, for example, the <strong>C-x</strong> <strong>C-s</strong> command.</p>
<h3>C-x C-s (save buffer to file)<br />
</h3>
<p>The command <strong>C-x</strong> <strong>C-s</strong> saves the current Emacs buffer to disk as the currently named file.  The name of the file is located on a bar at the bottom of the window.</p>
<h3>C-x C-c (exit Emacs)</h3>
<p>This command exits Emacs.  If buffers remain that are unsaved, Emacs asks you whether you want to save them.</p>
<h3>C-h t (start the Emacs tutorial)<br />
</h3>
<p>The command <strong>C-h</strong> <strong>t</strong> (press the <strong>Ctrl</strong> key, press and release <strong>h</strong>, release <strong>Ctrl</strong>, press and release <strong>t</strong>) starts the Emacs tutorial.  This takes you step-by-step through some basic Emacs commands.</p>
<h3>C-h ? (general help)</h3>
<p>This command offers a number of help options.</p>
<h3>C-k (kill line)</h3>
<p>The command <strong>C-k</strong> kills (deletes) the current line in the current buffer from the cursor to the end of the line.</p>
<h3>C-y (yank back line)</h3>
<p>This command &quot;yanks back&quot; the most recently killed line or set of lines and pastes it into the current cursor position.<br />
</p>
<h2>Other Emacs features<br />
</h2>
<p>Emacs has <em>major modes</em> for editing a variety of common and not-so-common file types, such as plain text, shell scripts, python language scripts, and so on.  Each mode redefines the effect of hitting the <strong>Tab</strong> key, for example, to do the most appropriate thing for a particular file type.  These modes start automatically for many types of files, based on the file extension or the first line in the file.<br />
</p>
<p>Emacs is extensible.  You can program it to behave as you like, for example by using the inbuilt, easy to learn scripting language Emacs Lisp.  See the Emacs documentation for more about this.</p>
<h2>Emacs documentation</h2>
<p>Emacs is well documented in free sources.  Type <code>info emacs</code> at the command line (or <strong>C-h</strong> <strong>r</strong> from within Emacs) to read the full official documentation. There is also an abbreviated manual page (type <code>man emacs </code>at the command line).  For beginners, the best way to start learning Emacs is the inbuilt interactive tutorial mentioned above.<br />
</p>
<p><span id="ch037_kedit.xhtml"></span></p>
<h1> Kedit, KWrite, &amp; Kate<br />
</h1>
<p>Although Kedit is part of the KDE software suite, which includes the KDE desktop environment, it does not require KDE to run. It is just as happy under Gnome. KDE has several built-in tools to help you edit text files (including scripts). The simplest of these is &quot;KEdit&quot;, a basic text editor. You can start it from the KDE menu or from the command line, if you prefer. For example, you could run:</p>
<pre><code>$ kedit /etc/profile &amp;</code></pre>
<p>You should see something like this.</p>
<p><img src="static/IntroCommandLine-Kedit-kedit1_4_1-en.png" title="kedit1_4_1" alt="kedit1_4_1" width="594" height="408" /></p>
<p>Using it is simple. You can move around the file with the arrow keys, Page Up (<strong>PgUp</strong>) and Page Down (<strong>PgDn</strong>) keys, or the mouse. Opening a new file is done from the <strong>File-&gt;Open</strong> menu, and you can spell-check your file with the <strong>Tools-&gt;Spelling...</strong> menu option.</p>
<p>At the bottom of the window is some useful information (if you don't see it, the <strong>Settings-&gt;Show Statusbar</strong> menu option brings it up). The line and column display shows the current position of the cursor. The &quot;INS&quot; means that you are in <em>insert mode</em>, and that if there is text to the right of the cursor, it is pushed over as you type. The opposite of this is &quot;OVR&quot;, which stands for <em>overtype mode</em>, where text to the right is replaced by the newly typed text. You can switch between these with the <strong>Insert</strong> key on the keyboard.</p>
<p>If you make any changes to the current file, then &quot;[modified]&quot; appears in the title bar to remind you that you need to save changes before exiting.</p>
<p><img src="static/IntroCommandLine-Kedit-kedit2-en.png" alt="How KEdit indicates a file has been changed" width="300" height="30" /></p>
<h2>KWrite<br />
</h2>
<p>While KEdit is useful, it is quite limited. KDE offers other options that are worth investigating. KWrite is very similar-looking, but offers useful additional features.</p>
<p><img src="static/IntroCommandLine-Kedit-Screenshot_profile___KWrite-en.png" alt="Screenshot_profile___KWrite.png" width="598" height="650" /></p>
<p>The most obvious advantage is <em>syntax highlighting</em>. For shell scripts, programs, and many other types of files, KWrite colors the text to make it easier to figure out what is going on. Here, comments are shown in gray, parameters are in green, built-in bash commands are shown in dark purple, and other shell commands in light purple. Generally KWrite tries to pick highlighting based on what it guesses the type of file to be. If it guesses wrongly, or doesn't do highlighting at all, you can manually choose an option under <strong>Tools-&gt;Highlighting</strong>.</p>
<p>You might have also noticed the little minus symbols and lines in the left margin. This is part of what is known as <em>code folding</em>. KWrite tries to match up &quot;if&quot; statements with the corresponding &quot;fi&quot;, &quot;for&quot; with &quot;done&quot;, and so on. Clicking on the minus symbol collapses the block, which can be useful if you are reading through a script and are interested in viewing what comes before and after a block, but not what's inside it. There are many more helpful features that KWrite offers--take a look around the menu and see what things do!</p>
<h2>Kate<br />
</h2>
<p>Last up in this overview is Kate. It is essentially the same editor as KWrite. However, it offers additional tools that make working on a project, as opposed to a single file, easier.</p>
<p><img src="static/IntroCommandLine-Kedit-Screenshot_profile___Kate-en.png" title="kate1_1" alt="Screenshot_profile___Kate.png" width="604" height="526" /></p>
<p>On the left side of the window are tabs that let you view the documents open in the current Kate session (KEdit and KWrite open multiple files in separate windows, while Kate can open them all in one), or navigate through your computer's filesystem to open a file. Kate also does syntax highlighting like KWrite, but also adds a &quot;Terminal&quot; tab at the bottom. Clicking on this tab opens and closes a mini-terminal where you can enter commands. In this case, if we wanted to see what &quot;id -u&quot; in the script does, and can simply type it in to the terminal to try it out.</p>
<p>For KDE users, KEdit, KWrite, and Kate offer three nice choices for editing text files. Chances are that all three came pre-installed on any system with KDE. Have fun trying them out!</p>
<p><span id="ch038_gedit.xhtml"></span></p>
<h1>Gedit</h1>
<p>Gedit, the default GUI editor if you use Gnome, also runs under KDE and other desktops. Most gNewSense and Ubuntu installations use Gnome by default. To start Gedit open a terminal and type</p>
<pre><code>$ gedit &amp;</code></pre>
<p>You should see this:</p>
<p><img src="static/IntroCommandLine-Gedit-gedit-en.png" title="gedit" alt="gedit" width="504" height="456" /></p>
<p>This looks like most basic editors on any operating system. You can use Gedit through the GUI, and the commands are simple:</p>
<p><strong>File-&gt;Open</strong> : Opens an existing file</p>
<p><strong>File-&gt;New</strong> : Creates a new (blank) file</p>
<p><strong>File-&gt;Save</strong> : Saves a file</p>
<p><strong>ctrl + c</strong> : copy</p>
<p><strong>ctrl + v</strong> : paste<br />
</p>
<p>That's all you really need to do. To add text just type!</p>
<h2>Line Numbers</h2>
<p>Gedit tracks your cursor and displays the position at the bottom of the interface:</p>
<p><img src="static/IntroCommandLine-Gedit-gedit_cursor-en.png" title="gedit_cursor" alt="gedit_cursor" width="504" height="456" /> </p>
<p>This can be handy information to know. If you keep track of the line numbers you can use these to jump quickly around the text file by using the &quot;Go to Line&quot; feature. This can be accessed via the interface (<strong>Search -&gt; Go to Line</strong>) or via the shortcut <strong>ctrl</strong> + <strong>i</strong>.</p>
<p><span id="ch040_scripting.xhtml"></span></p>
<h1>Scripting</h1>
<p>If you have a collection of commands you'd like to run together, you can combine them in a script and run them all at once. You can also pass arguments to the script so that it can operate on different files or other input.<br />
</p>
<p>Like an actor reading a movie script, the computer runs each command in your shell script, without waiting for you to whisper the next line in its ear. A script is a handy way to:</p>
<ul>
<li>Save yourself typing on a group of commands you often run together.<br />
</li>
<li>Remember complicated commands, so you don't have to look up, or risk forgetting, the particular syntax each time you use it.</li>
<li>Use control structures, like loops and case statements, to allow your scripts to do complex jobs. Writing these structures into a script can make them more convenient to type and easier to read. </li>
</ul>
<p>Let's say you often have collections of images (say, from a digital camera) that you would like to make thumbnails of. Instead of opening hundreds of images in your image editor, you choose to do the job quickly from the command line. And because you may need to do this same job in the future, you might write a script. This way, the job of making thumbnails takes you only two commands:</p>
<pre><code>$ cd images/digital_camera/vacation_pictures_March_2009
$ make_thumbnails.sh</code></pre>
<p>The second command, <code>make_thumbnails.sh</code>, is the script that does the job. You have made it previously and it resides in a directory on your search path. It might look something like this:<br />
</p>
<pre><code>#!/bin/bash
# This makes a directory containing thumnails of all the jpegs in the current dir.
mkdir thumbnails
cp *.jpg thumbnails
cd thumbnails
mogrify -resize 400x300 *.jpg</code></pre>
<p>If the first line begins with #! (pronounced &quot;shee-bang&quot;), it tells the kernel what interpreter is to be used. (Since bash is usually the default, you might omit this line). After this you should put in some comments about what the script is for and how to use it . Scripts without clear and complete usage instructions often do not &quot;work right&quot;. For bash, comments start with the hash (#) character and may be on the ends of executable lines.<br />
</p>
<p>The file includes commands conforming to the syntax of the interpreter. We've seen three of them before: <code>mkdir</code>, <code>cp</code>, and <code>cd</code>. The last command, <code>mogrify</code>, is a program that can resize images (and do a lot of other things besides). Read its manual page to learn more about it.<br />
</p>
<h2>Making scripts executable</h2>
<p>To write a script like the one we've shown, open your favorite text editor and type in the commands you would like to run. For bash, you can put multiple commands on a single line so long as you put a semi-colon after each command so the shell knows a new command is starting.<br />
</p>
<p>Save the script. One common convention for bash is to use the <code>.sh</code> extension -- for example, <em>make_thumbnails.sh</em>.</p>
<p>There is one more step before you can run the script: it has to be <em>executable</em>. Remember from the section on permissions that executability is one of the permissions a file can have, so you can make your script executable by granting the execute (<strong>x</strong>) permission. The following command allows any user to execute the script:</p>
<pre><code>$ chmod +x make_thumbnails.sh</code></pre>
<p>Because you're probably planning to use the script often, you'll find it worthwhile to check your PATH and add the script to one of the directories in it (for instance, <em>/home/jdoe/bin</em> is an easy choice given the PATH shown here).<br />
</p>
<pre><code>$ echo $PATH
/usr/bin:/usr/local/bin:/home/jdoe/bin</code></pre>
<p>For simple testing, if you're in the directory that contains the script, you can run it like this:</p>
<pre><code>$ ./make_thumbnails.sh</code></pre>
<p>Why do you need the preceding ./ path? Because most users don't have the current directory in their PATH environment variables. You can add it, but some users consider that a security risk.</p>
<p>Finally, you can also execute a script, even without its execute bit set, by passing it as an argument to the command interpreter, thusly:</p>
<pre><code>$ bash make_thumbnails.sh</code></pre>
<h2>More control</h2>
<p>To provide the flexibility you want, the bash shell and many other interpreters let you make choices in a script and run things repeatedly on a variety of inputs. In that regard, the shell is actually a programming language, and a nice way to get used to using the powerful features a programming language provides. We'll get you started here and show you the kinds of control the bash shell provides through compound statements.<br />
</p>
<h3>if</h3>
<p>This statement was already introduced in the section on checking for errors, but we'll review it here. <code>if</code> is more or less what you'd expect, though its syntax is quite a bit different from its use in most other languages. It follows this form:</p>
<pre><code>if [ test-condition ]
then
  do-something
else
  do-something-else
fi</code></pre>
<p>You read that right: the block must be terminated with the keyword <code>fi</code>.  (It's one of the things that makes using <code>if</code> fun.) The <code>else</code> portion is optional. Make sure to leave spaces around the opening and closing brackets; otherwise <code>if</code> reports a syntax error.<br />
</p>
<p>For example, if you need to check to see if you can read a file, you could write a chunk like this:</p>
<pre><code>if [ -r /home/joe/secretdata.txt ]
then
    echo &quot;You can read the file&quot;
else
    echo &quot;You can&#39;t read that file!&quot;
fi</code></pre>
<p><code>if</code> accepts a wide variety of tests. You can put any set of commands as the <em>test-condition</em>, but most <code>if</code> statements use the tests provided by the square bracket syntax. These are actually just a synonym for a command named <code>test</code>. So the first line of the preceding example could just as well have been written as follows.</p>
<pre><code>if test -r /home/joe/secretdata.txt</code></pre>
<p>You can find out more about tests such as <code>-r</code> in the manual page for <code>test</code>. All the test operators can be used with square brackets, as we have.</p>
<p>Some useful <code>test</code> operators are:<br />
<br />
</p>
<table>
<tbody>
<tr class="odd">
<td>-r</td>
<td>File is readable</td>
</tr>
<tr class="even">
<td>-x</td>
<td>File is executable</td>
</tr>
<tr class="odd">
<td>-e</td>
<td>File exists</td>
</tr>
<tr class="even">
<td>-d</td>
<td>File exists and is a directory</td>
</tr>
</tbody>
</table>
<p>There are many, many more of them, and you can even test for multiple conditions at once. See the the manual page for <code>test</code>.</p>
<h3>while (and until)<br />
</h3>
<p><code>while</code> is a loop control structure. It keeps cycling through until its test condition is no longer true. It takes the following form:</p>
<pre><code>while test-condition
do
  step1
  step2
  ...
done</code></pre>
<p>You can also create loops that run until they are interrupted by the user. For example, this is one way (though not necessarily the best one) to look at who is logged into your system once every 30 seconds:<br />
</p>
<pre><code>while true
do
    who
    sleep 30
done</code></pre>
<p>This is inelegant because the user has to press <strong>Ctrl + c</strong> or kill it in some other way. You can write a loop that ends when it encounters a condition by using the <code>break</code> command. For instance the following script uses the <code>read</code> command (quite useful in interactive scripts) to read a line of input from the user. We store the input in a variable named <em>userinput</em> and check it in the next line. The script uses another compound command we've already seen, <code>if</code>, within the <code>while</code> block, which allows us to decide whether to finish the <code>while</code> block. The <code>break</code> command ends the <code>while</code> block and continues with the rest of the script (not shown here). Notice that we use two tests through <code>-o</code>, which means &quot;or&quot;. The user can enter <strong>Q</strong> in either lowercase or uppercase to quit.<br />
</p>
<pre><code>while true
do
  echo &quot;Enter input to process (enter Q to quit)&quot;
  read userinput

  if [ $userinput == &quot;q&quot; -o $userinput == &quot;Q&quot; ]
  then
    break
  fi

  process input...

done</code></pre>
<p><code>until </code>works exactly the same way, except that the loop runs until the test condition becomes true.<br />
</p>
<h3>case</h3>
<p><code>case</code> is a way for a script to respond to a set of test conditions. It works similarly to case statements in other programming languages, though it has its own peculiar syntax, which is best illustrated through an example.</p>
<pre><code>user=`whoami` # puts the username of the user executing the script
              # into the $user variable.
case $user in
    joe)
        echo &quot;Hello Joe. I know you&#39;d like to know what time it is, so I&#39;ll show you below.&quot;
        date
        ;;
    amy)
        echo &quot;Good day, Amy. Here&#39;s your todo list.&quot;
        cat /home/amy/amy-todo.txt
        ;;
    sam|tex)
        echo &quot;Hi fella. Don&#39;t forget to watch the system load. The current system load is:&quot;
        uptime
        ;;
    *)
        echo &quot;Welcome, whoever else you are. Get to work now, please.&quot;
        ;;
esac</code></pre>
<p>Each case must be followed by the ) character, then a newline, then the list of steps to take, then a double semicolon (;;). The &quot;*)&quot; condition is a catchall, similar to the <code>default</code> keyword in some languages' <code>case</code> structures. If no other cases match, the shell executes this list of statements. Finally, the keyword <code>esac</code> ends the <code>case</code> statement. In the example shown, note the case that matches either the string &quot;sam&quot; or &quot;tex&quot;. </p>
<h3>for</h3>
<p><code>for</code> is a useful way of iterating through items in a list. It can be any list of strings, but it's particularly useful for iterating through a file list. The following example iterates through all of the files in the directory <em>myfiles</em> and creates a backup file for each one. (It would choke on any directories, but let's keep the example simple and not test for whether the file is a directory.) ⁞<br />
</p>
<pre><code>for filename in myfiles/*
do
    cp $filename $filename.bak
done</code></pre>
<p>As with any command that sets a variable, the first line of the <code>for</code> block sets the variable called <em>filename</em> without a dollar sign.</p>
<p>There's another variety of <code>for</code>, which is similar to the <code>for</code> construct used in other languages, but which is used less in shell scripting than it's used in other languages, partially because the syntax for incrementing and decrementing variables in the shell is not entirely straightforward.</p>
<h3>parallel</h3>
<p><code>parallel</code> is a useful way of iterating through items in a list while maximizing the use of your computer by running jobs in parallel. The following example iterates through all of the files in the directory <em>myfiles</em> and creates a backup file for each one replacing the extension with <code>.bak</code>. (It would choke on any directories, but let's keep the example simple and not test for whether the file is a directory.)<br />
</p>
<pre><code>ls myfiles/* | parallel cp {} {.}.bak</code></pre>
<p><code>parallel</code> can often be used instead of <code>for</code> loops and <code>while read</code> loops, make these run faster by running them in parallel and make the code easier to read.</p>
<p><code>parallel</code> can be used for a lot of more advanced features. You can watch an intro video here: <a href="http://www.youtube.com/watch?v=OpaiGYxkSuQ" class="uri">http://www.youtube.com/watch?v=OpaiGYxkSuQ</a></p>
<p><br />
</p>
<p><span id="ch041_maintaining-scripts.xhtml"></span></p>
<h1>Maintainable Scripts</h1>
<p>You are slowly delving into programming by the way of shell scripting.  Now it's the best time to start to learn about how to be a good programmer.  Since this book is just an introduction to the command line, we are only going to provide few but nevertheless very important hints centered around the idea of <em>maintainability</em>.</p>
<p>When programmers talk about maintainability they are talking about the ease with which a program can be modified, whether it's to correct defects, add new functionality, or improve its performance.  Unmaintainable programs are very easy to spot: they lack structure, so functionality is spread all over the place. When you push <em>here</em> they break way over <em>there</em>, a real nightmare. In general, they are very hard to read.  Consider for example this:</p>
<pre><code>#!/bin/sh
identify `find ~/Photos/Vacation/2008 -name \*.jpg` | cut -d &#39; &#39; -f 3 | sort | uniq -c</code></pre>
<p>use your favorite editor to save this file as <em>foo</em>, then:</p>
<pre><code>$ chmod +x foo
$ ./foo
     11 2304x3072
     12 3072x2304</code></pre>
<p>What that small monster does is find files that ends with &quot;.jpg&quot; in a certain directory, run <code>identify</code> on all of them, and report some kind of information that someone at some time must have thought very useful. If the programmer would only have added some hints as to what the programs does...</p>
<h2>Don't use long lines</h2>
<p>The first thing you'll note is that our example of an unmaintainable program is one long line. There's really no need for that.  What if the program looked like this instead:</p>
<pre><code>#!/bin/sh
identify `find ~/Photos/Vacation/2008 -name \*.jpg` |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<p>It becomes a little bit easier to spot where each command begins and ends.  It's still the same set of piped programs, only their presentation is different.  You can break long lines at pipes and the functionality will be the same.</p>
<p>You can also split one command into several lines by using the <strong>\</strong> character at the end of a line to join it with the next:</p>
<pre><code>#!/bin/sh
echo This \
     is \
     really \
     one \
     long \
     command.</code></pre>
<h2>Use descriptive names for your scripts<br />
</h2>
<p>The second thing you might have noticed is that the script is called &quot;foo&quot;.  It's short and convenient but it doesn't provide a clue as to what the program does.  What about this:</p>
<pre><code>$ mv foo list_image_sizes</code></pre>
<p>Now the name helps the user understand what the script does.  Much better, isn't it?<br />
</p>
<h2>Use variables</h2>
<p>One bothersome thing about that program is its use of backticks.  Sure, it works, but it also has drawbacks.  Perhaps the biggest one is the least evident one, too: remember that backticks substitute the output of the command they contain in the position where they appear.  Some systems have a limit of the command line length they allow.  In this particular case, if the specified directory has lots and lots of pictures, the command line can become extraordinarily long, producing an obscure error when you call the program.  There are several methods that you can use to remedy this, but for the purpose of this explanation, let's try the following:</p>
<pre><code>#!/bin/sh
find ~/Photos/Vacation/2008 -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<p>Now <code>find</code> is running the same as before, but its output, the list of filenames, is piped into a while-loop.  The condition for the loop is <code>read image</code>.  <code>read</code> is a function that reads one line at a time, splits its input into fields and then assigns each field to a variable, <em>image</em> in this case.  Now <code>identify</code> works on one image at a time.</p>
<p>Notice how introducing a variable makes the program a bit easier to read: it literally says that you wish to identify an image.  Also note how the effect on future programmers wouldn't have been the same if the variable was called something like <em>door</em> or <em>cdrom</em>.  Names are important!<br />
</p>
<p>But there's still something bothersome about the program: that directory name is glowing like a sore thumb.  What if we change the program like this:</p>
<pre><code>#!/bin/sh
START_DIRECTORY=~/Photos/Vacation/2008

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<p>That's a little bit better: now you can edit your script and change the directory each time you wish to process a different one.</p>
<h2>Use arguments<br />
</h2>
<p>That last bit didn't sound quite right, did it?  After all, you don't edit <code>ls</code> each time you wish to list the contents of a different directory, do you? Let's make our program just as adaptable:<br />
</p>
<pre><code>#!/bin/sh
START_DIRECTORY=$1

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<p>The <em>$1</em> variable is the first argument that you pass to your script ($0 is the name of the script you're running).  Now you can call your script like this:</p>
<pre><code>$ ./list_image_sizes ~/Photos/Vacation/2008</code></pre>
<p>Or you can examine the 2007 pictures, if you wish:</p>
<pre><code>$ ./list_image_sizes ~/Photos/Vacation/2007</code></pre>
<h2>Know where you begin</h2>
<p>Consider what happens if you run the script like this:</p>
<pre><code>$ ./list_image_sizes</code></pre>
<p>Maybe that's what you want, but maybe it isn't.  What happens is that <em>$1</em> is empty, so <em>$START_DIRECTORY</em> is empty as well and in turn the first argument to find is also empty.  That means that find will search your current working directory.  You might wish to make that behavior explicit:<br />
</p>
<pre><code>#!/bin/sh
if test -n &quot;$1&quot; ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<p>The program behaves exactly as before, with the only difference that in six months, when you come back and look at the program, you won't have to wonder why it's producing results even when you don't pass it a directory as argument.</p>
<h2>Look before you leap<br />
</h2>
<p>Speaking of which, what happens if you do pass an argument to the script, but that argument isn't a directory or better yet, it doesn't even exist?  Try it.</p>
<p>Not pretty, ah?</p>
<p>What if we do this:</p>
<pre><code>#!/bin/sh
if test -n &quot;$1&quot; ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    exit
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<p>That's better.  Now the script won't even attempt to run if the argument it receives isn't a directory.  It isn't very polite, though: <em>it silently exits</em> with no hint of what went wrong.</p>
<h2>Complain if you must<br />
</h2>
<p>That's easily fixed:</p>
<pre><code>#!/bin/sh
if test -n &quot;$1&quot; ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    echo \&quot;$START_DIRECTORY\&quot; is not a directory or it does not exist.  Stop.
    exit
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<h2>Mind your exit<br />
</h2>
<p>The program now produces an error message if you don't pass it an existing directory as argument and it exits without further action.  It would be nice if you let other programs that might eventually call your script know that there was an error condition.  That is, it would be nice if your program exits with an error code.  Something like this:</p>
<pre><code>#!/bin/sh
if test -n &quot;$1&quot; ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    echo \&quot;$START_DIRECTORY\&quot; is not a directory or it does not exist.  Stop.
    exit 1
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<p>Now, if there's an error, your script's exit code is 1. If the program exits normally, the exit code is 0.</p>
<h2>Use comments</h2>
<p>Anything following a <strong>#</strong> symbol on a line will be ignored, allowing you to add notes about how your script works.  For example:</p>
<pre><code>#!/bin/sh
# This script reports the sizes of all the JPEG files found under the current
# directory (or the directory passed as an argument) and the number of photos
# of each size.

if test -n &quot;$1&quot; ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    echo \&quot;$START_DIRECTORY\&quot; is not a directory or it does not exist.  Stop.
    exit 1
fi

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f 3 |
sort |
uniq -c</code></pre>
<p>Comments are good, but don't fall prey to writing too many comments.  Try to construct your program so that the code itself is clear.  The reason behind this is simple: next year, when <em>someone else</em> changes your script, that other person could well change the commands and forget about the comments, making the later misleading.  Consider this:</p>
<pre><code># count up to three
for n in `seq 1 4` ; do echo $n ; done</code></pre>
<p>Which one is it?  Three or four?  Evidently the program is counting up to four, but the comment says it's up to three.  You could adopt the position that the program is right and the comment is wrong.  But what if the person who wrote this meant to count to three and that's the reason why the comment is there?  Let's try it like this:</p>
<pre><code># There are three little pigs
for n in `seq 1 3` ; do echo $n ; done</code></pre>
<p>The comment documents the <em>reason</em> why the program is counting up to three: it is not describing what the program <em>does</em>, it's describing what the program <em>should do</em>.  Let's consider a different approach:</p>
<pre><code>TOTAL_PIGS=3
for pig in `seq 1 $TOTAL_PIGS` ; do echo $pig ; done</code></pre>
<p>Same result, slightly different program.  If you reformat your program, you can do without the comments (as a side note, the fancy word for the kinds of change we have been making is <em>refactoring</em>, but that goes outside the scope for this book).</p>
<h2>Avoid magic numbers<br />
</h2>
<p>In our current example, there's a <em>magic number</em>, a number that makes the program work, but no one knows why it has to be <em>that</em> number.  It's magic!</p>
<pre><code>...
cut -d &#39; &#39; -f 3 |
...</code></pre>
<p>You have two choices: write a comment and document why it has to be &quot;3&quot; instead of &quot;2&quot; or &quot;4&quot; or introduce a variable that explains why by way of its name.  Let's try the latter:<br />
</p>
<pre><code>#!/bin/sh
# This script reports the sizes of all the JPEG files found under the current
# directory (or the directory passed as an argument) and the number of photos
# of each size.

if test -n &quot;$1&quot; ; then
    START_DIRECTORY=$1
else
    START_DIRECTORY=.
fi

if ! test -d $START_DIRECTORY ; then
    echo \&quot;$START_DIRECTORY\&quot; is not a directory or it does not exist.  Stop.
    exit 1
fi

IMAGE_SIZE_FIELD=3

find $START_DIRECTORY -name \*.jpg |
while read image ; do identify $image ; done |
cut -d &#39; &#39; -f $IMAGE_SIZE_FIELD |
sort |
uniq -c</code></pre>
<p>It does improve things a little; at least now we know where the 3 comes from.  If ImageMagick ever changes the output format, we can update the script accordingly.</p>
<h2>Did it work?</h2>
<p>Last but not least, check the exit status of the commands you run.  As it stands right now, in our example there's not much that can fail.  So let's try one last example:<br />
</p>
<pre><code>#!/bin/sh
# Copy all the HTML and image files present in the source directory to the
# specified destination directory.

SRC=$1
DST=$2

if test -z &quot;$SRC&quot; -o -z &quot;$DST&quot; ; then
    cat&lt;&lt;EOT
Usage:

    $0 source_directory destination_directory
EOT
    exit 1
fi

if ! test -d &quot;$SRC&quot; ; then
    echo \&quot;$SRC\&quot; is not a directory or it does not exist.  Stop.
    exit 1
fi

if test -e &quot;$DST&quot; ; then
    echo \&quot;$DST\&quot; already exists.  Stop.
    exit 1
fi

if ! mkdir -p &quot;$DST&quot; ; then
    echo Can\&#39;t create destination directory \&quot;$DST\&quot;.  Stop.
    exit 1
fi

# Obtain the absolute path for $DST
cd &quot;$DST&quot;
DST=`pwd`
cd -

cd &quot;$SRC&quot;

find ! -type d \( -name \*.html -o -name \*.jpg -o -name \*.png \) |
while read filename ; do
    dir=`dirname &quot;$filename&quot;`
    mkdir -p &quot;$DST/$dir&quot; &amp;&amp; cp -a &quot;$filename&quot; &quot;$DST/$filename&quot;
    if test $? -ne 0 ; then
        echo Can\&#39;t copy \&quot;$filename\&quot; to \&quot;$DST/$filename\&quot;
        echo Abort.
        exit 1
    fi
done</code></pre>
<p>Note that this example makes use of many things you learned in this book. It does not try to be definitive; you can practice improving it!</p>
<p>The thing you should note now is how the program pays attention to the error conditions that the different programs might produce.  For example, instead of just calling <code>mkdir</code> to check if a program worked, it does this:</p>
<pre><code>if ! mkdir -p &quot;$DST&quot; ; then
    echo Can\&#39;t create destination directory \&quot;$DST\&quot;.  Stop.
    exit 1
fi</code></pre>
<p>It calls <code>mkdir</code> as the condition for <code>if</code>.  If <code>mkdir</code> encounters an error, it will exit with a non-zero status and the <code>if</code> clause will interpret that as a false condition. The &quot;!&quot; is a negation operator that inverts false to true (or vice versa. So the line as a whole basically says &quot;Run the <code>mkdir</code> command, turn an error into a true value with the &quot;!&quot; operator, and take action if it's true that there's an error.&quot; In short, if <code>mkdir</code> encounters an error, the flow will enter the body of the <code>if</code>.  This might happen, for example, if the user running the script doesn't have permissions to create the requested directory.<br />
</p>
<p>Note also the usage of &quot;&amp;&amp;&quot; to verify error conditions:<br />
</p>
<pre><code>mkdir -p &quot;$DST/$dir&quot; &amp;&amp; cp -a &quot;$filename&quot; &quot;$DST/$filename&quot;</code></pre>
<p>If <code>mkdir</code> fails, <code>cp</code> won't be called.  Furthermore, if either <code>mkdir</code> or <code>cp</code> fails, the exit status will be non-zero.  That condition is checked in the next line:</p>
<pre><code>if test $? -ne 0 ; then</code></pre>
<p>Since this might indicate something going awfully wrong (e.g., is the disk full?), we had better give up and stop the program.</p>
<h2>Wrapping up</h2>
<p>Writing scripts is an art. You can become a better artist by looking at what others have done before you and doing a lot yourself. In other words: <em>read a lot of scripts and write a lot of scripts yourself</em>.</p>
<p>Happy hacking!<br />
</p>
<p><span id="ch042_other-languages.xhtml"></span></p>
<h1>Other scripting languages</h1>
<p>The shell is a wonderful friend. If you have read the rest of the book up to this point, you may well be dizzy with the possibilities it presents. But the shell is still tremendously limited compared to many languages. We'll give you just a taste of other tools and languages you can explore.</p>
<p>Two classic tools, AWK and Sed, are commonly invoked from the shell. Each operates on input one line at a time. You can think of them as assembly lines on which workers load a file line by line. Each line is processed in order. These are classic examples of <em>filters</em>, an idea closely associated with GNU/Linux. Filters are strung together in pipes with the | character, with the output of each command becoming the input for the next.</p>
<p>The next section introduces regular expressions. They're a language all their own, but one where you can do a lot by learning a few simple features. They turn up in very similar forms all over: in text editors such as vi, in commands such as <code>grep</code>, in AWK and Sed, and in all the languages that follow.<br />
</p>
<p>Scripting languages were invented to make programming easy and allow people to create applications quickly. Unlike AWK and Sed, they usually run by themselves, not as part of pipes or other contexts where they just produce a line of output for each line of input. In contrast to the shell, these languages offer such advantages as:</p>
<ul>
<li>Versatile integer and floating-point arithmetic</li>
<li>Objects, which help you keep data together with the functions that manipulate it</li>
<li>Complex data structures that can store related data of many types<br />
</li>
</ul>
<p>This book has short sections on the three most popular scripting languages in the free software world today: Perl, Python, and Ruby. You will encounter many tools and products that provide customization through those languages.</p>
<p><span id="ch043_sed.xhtml"></span></p>
<h1>The Sed Text Processor</h1>
<p>Sed (stream editor) is a utility that does transformations on a line-by-line basis. The commands you give it are run on each line of input in turn. It is useful both for processing files and in a pipe to process output from other programs, such as here:</p>
<pre><code>$ wc -c * | sort -n | sed ...</code></pre>
<h2>Basic Syntax and Substitution</h2>
<p>A common use of Sed is to change words within a file. You may have used &quot;Find and Replace&quot; in GUI based editors. Sed can do this much more powerfully and faster:</p>
<pre><code> $ sed &quot;s/foo/bar/g&quot; inputfile &gt; outputfile</code></pre>
<p>Let's break down this simple command. First we tell the shell to run <code>sed</code>. The processing we want to do is enclosed in double quotation marks; we'll come back to that in a moment. We then tell Sed the name of the <em>inputfile</em> and use standard shell redirection (&gt;) to the name of our <em>outputfile</em>. You can specify multiple input files if you want; Sed processes them in order and creates a single stream of output from them.<br />
</p>
<p>The expression looks complex but is very simple once you learn to take it apart. The initial &quot;s&quot; means &quot;substitute&quot;. This is followed by the text you want to find and the replacement text, with slashes (/) as separators. Thus, here we want to find &quot;foo&quot; in the inputfile and put &quot;bar&quot; in its places. Only the output file is affected; Sed never changes its input files.</p>
<p>Finally, the trailing &quot;g&quot; stands for &quot;global&quot;, meaning to do this for the whole line. If you leave off the &quot;g&quot; and &quot;foo&quot; appears twice on the same line, only the first &quot;foo&quot; is changed to &quot;bar&quot;.</p>
<pre><code>$ cat testfile
this has foo then bar then foo then bar
this has bar then foo then bar then foo
$ sed &quot;s/foo/bar/g&quot; testfile &gt; testchangedfile
$ cat testchangedfile
this has bar then bar then bar then bar
this has bar then bar then bar then bar</code></pre>
<p>Now let's try that again without the <code>/g</code> on the command and see what happens.<br />
</p>
<pre><code>$ cat testfile
this has foo then bar then foo then bar
this has bar then foo then bar then foo
$ sed &quot;s/foo/bar/&quot; testfile &gt; testchangedfile
$ cat testchangedfile
this has bar then bar then foo then bar
this has bar then bar then bar then foo</code></pre>
<p>Notice that without the &quot;g&quot;, Sed performed the substitution only the first time it finds a match on each line.</p>
<p>This is all well and good, but what if you wanted to change the second occurrence of the word foo in our testfile? To specify a particular occurrence to change, just specify the number after the substitute commands.</p>
<pre><code>$ sed &quot;s/foo/bar/2&quot; inputfile &gt; outputfile </code></pre>
<p>You can also combine this with the <code>g</code> flag (in some versions of Sed) to leave the first occurrence alone and change from the 2nd occurrence to the end of the line.</p>
<pre><code>$ sed &quot;s/foo/bar/2g&quot; inputfile &gt; outputfile</code></pre>
<h2>Sed Expressions Explained</h2>
<p>Sed understands regular expressions, to which a chapter is devoted in this book. Here are some of the special characters you can use to match what you wish to substitute.</p>
<pre><code>$ matches the end of a line
^ matches the start of a line
* matches zero or more occurrences of the previous character
[ ] any characters within the brackets will be matched</code></pre>
<p>For example, you could change any instance of the words &quot;cat&quot;, &quot;can&quot;, and &quot;car&quot; to &quot;dog&quot; by using the following:</p>
<pre><code> $ sed &quot;s/ca[tnr]/dog/g&quot; inputfile &gt; outputfile</code></pre>
<p>In the next example, the first [0-9] ensures that at least one digit must be present to be matched. The second [0-9] may be missing or may be present any number of times, because it is followed by the * metacharacter. Finally, the digits are removed because there is nothing between the second and third slashes where you can put your replacement text.</p>
<pre><code> $ sed &quot;s/[0-9][0-9]*//g&quot; inputfile &gt; outputfile</code></pre>
<p>Inside an expression, if the first character is a caret (^), Sed matches only if the text is at the start of the line.<br />
</p>
<pre><code>$ echo dogs cats and dogs | sed &quot;s/^dogs/doggy/&quot;
doggy cats and dogs</code></pre>
<p>A dollar sign at the end of a pattern expression tells Sed to match the text only if it is at the end of the line.</p>
<pre><code>$ echo dogs cats and cats | sed &quot;s/cats$/kitty/&quot;
dogs cats and kitty</code></pre>
<p>A line changes only if the matching string is where you require it to be; if the same text occurs elsewhere in the sentence it is not be modified.</p>
<h2>Deletion</h2>
<p>The &quot;d&quot; command deletes an entire line that contains a matching pattern. Unlike the &quot;s&quot; (substitute) command, the &quot;d&quot; goes after the pattern.<br />
</p>
<pre><code>$ cat testfile
line with a cat
line with a dog
line with another cat
$ sed &quot;/cat/d&quot; testfile &gt; newtestfile
$ cat newtestfile
line with a dog</code></pre>
<p>The regular expression ^$ means &quot;match a line that has nothing between the beginning and the end&quot;, in other words, a blank line. So you can remove all blank lines using the &quot;d&quot; command with that regular expression:</p>
<pre><code>$ sed &quot;/^$/d&quot; inputfile &gt; outputfile</code></pre>
<h2>Controlling Printing</h2>
<p>Suppose you want to print certain lines and suppress the rest. That is, instead of specifying which lines to delete using &quot;d&quot;, you want specify which lines to keep.</p>
<p>This can be done with two features:</p>
<p>Specify the <code>-n</code> option, which means &quot;do not print lines by default&quot;.</p>
<p>End the pattern with &quot;p&quot; to print the line matched by the pattern.</p>
<p>We'll show this with a file that contains names:<br />
</p>
<pre><code>$ cat testfile
Mr. Jones
Mrs. Jones
Mrs. Lee                                                                        Mr. Lee</code></pre>
<p>We've decided to standardize on &quot;Ms&quot; for women, so we want to change &quot;Mrs.&quot; to &quot;Ms&quot;. The pattern is:</p>
<pre><code> s/Mrs\./Ms/</code></pre>
<p>and to print only the lines we changed, enter:<br />
</p>
<pre><code>$ sed -n &quot;s/Mrs\./Ms/p&quot; testfile</code></pre>
<h2>Multiple Patterns</h2>
<p>Sed can be passed more than one operation at a time. We can do this by specifying each pattern after an <code>-e</code> option.</p>
<pre><code>$ echo Gnus eat grass | sed -e &quot;s/Gnus/Penguins/&quot; -e &quot;s/grass/fish/&quot;
Penguins eat fish.</code></pre>
<h2>Controlling Edits With Patterns</h2>
<p>We can also be more specific about which lines a pattern gets applied to.  By supplying a pattern before the operation, you restrict the operation to lines that have that pattern.</p>
<pre><code>$ cat testfile
one: number
two: number
three: number
four: number
one: number
three: number
two: number
$ sed &quot;/one/ s/number/1/&quot; testfile &gt; testchangedfile
$ cat testchangedfile
one 1
two: number
three: number
four: number
one: 1
three: number
two: number</code></pre>
<p>The <code>sed</code> command in that example had two patterns. The first pattern, &quot;one&quot;, simply controls which lines Sed changes. The second pattern replaces &quot;number&quot; with &quot;1&quot; on those lines.</p>
<p>This works with multiple patterns as well.<br />
</p>
<pre><code>$ cat testfile
one: number
two: number
three: number
four: number
one: number
three: number
two: number
$ sed -e &quot;/one/ s/number/1/&quot; -e &quot;/two/ s/number/2/&quot; \
      -e &quot;/three/ s/number/3/&quot; -e &quot;/four/ s/number/4/&quot; \
      &lt; testfile &gt; testchangedfile
$ cat testchangedfile
one: 1
two: 2
three: 3
four: 4
one: 1
three: 3
two: 2</code></pre>
<h2>Controlling Edits With Line Numbers</h2>
<p>Instead of specifying patterns that can operate on any line, we can specify an exact line or range of lines to edit.</p>
<pre><code>$ cat testfile
even number
odd number
odd number
even number
$ sed &quot;2,3 s/number/1/&quot; &lt; testfile &gt; testchangedfile
$ cat testchangedfile
even number
odd 1
odd 1
even number</code></pre>
<p>The comma acts as the range separator, telling Sed to work only on lines two through three.</p>
<pre><code>$ cat testfile
even number
odd number
odd number
$ sed -e &quot;2,3 s/number/1/&quot; -e &quot;1 s/number/2/&quot; &lt; testfile &gt; testchangedfile
$ cat testchangedfile
even 2
odd 1
odd 1</code></pre>
<p>Sometimes you might not know exactly how long a file is, but you want to go from a specified line to the end of the file. You could use <code>wc</code> or the like and count the total lines, but you can also use a dollar sign ($) to represent the last line:</p>
<pre><code>$ sed &quot;25,$ s/number/1/&quot; &lt; testfile &gt; testchangedfile</code></pre>
<p>The $ in an address range is Sed's way of specifying, &quot;all the way to the end of the file&quot;.</p>
<h2>Scripting SED commands</h2>
<p>By using the <code>-f</code> argument to the <code>sed</code> command, you can feed Sed a list of commands to run. For example, if you put the following patterns in a file called <em>sedcommands</em>:<br />
</p>
<pre><code>s/foo/bar/g
s/dog/cat/g
s/tree/house/g
s/little/big/g</code></pre>
<p>You can use this on a single file by entering the following:</p>
<pre><code>$ sed -f sedcommands &lt; inputfile &gt; outputfile</code></pre>
<p>Note that each command in the file must be on a separate line.<br />
</p>
<p>There is much more to Sed than can be written in this chapter. In fact, whole books have been written about Sed, and there are many excellent tutorials about Sed online.</p>
<p><span id="ch044_awk.xhtml"></span></p>
<h1>Awk</h1>
<p>AWK is a programming language designed for processing plain text data.  It is named after its founders, Alfred <strong>A</strong>ho, Peter <strong>W</strong>einberger and B<span></span>rian <strong>K</strong>ernighan.  AWK is quite a small language and easy to learn, making it the ideal tool for quick and easy text processing.  Its prime use is to extract data from table-like input.<br />
</p>
<p>Since programs written in AWK tend to be rather small, they are mostly entered directly on the command line.  Of course, saving larger scripts as text files is also possible.</p>
<p>In the next paragraphs, we present the basics of AWK through three simple examples.  All of them will be run on the following text file (containing the five highest scores ever achieved in the video game Donkey Kong as of March 2009):<br />
</p>
<pre><code>1050200 Billy Mitchell 2007
1049100 Steve Wiebe 2007
895400 Scott Kessler 2008
879200 Timothy Sczerby 2001
801700 Stephen Boyer 2007</code></pre>
<p>The file is a table organized into <em>fields</em>.  The first field of each row contains the respective score, the second and third fields contain the name of the person who has achieved it, and the fourth and last field of each row contains the year in which the score was set.  You should copy and paste the text above into a text file and name it something like <em>highscores.txt</em> so that you can try out the following examples.</p>
<h2>Example 1</h2>
<p>Let's say we want to print only those scores higher than 1,000,000 points. Also, we want only the first names of the persons who have achieved the scores.  By using AWK, it's easy to extract this information: </p>
<pre><code>$ awk &#39;$1 &gt; 1000000 { print $2, $1 }&#39; highscores.txt
Billy 1050200
Steve 1049100</code></pre>
<p>Try it out!</p>
<p>The little AWK program that we've just entered on the command line consists of two parts:</p>
<ol>
<li>The part preceding the curly braces (<em>$1 &gt; 1000000</em>) says &quot;Do this for all lines where the value of field no. 1 is greater than 1,000,000.&quot;</li>
<li>The part inside the curly braces (<em>print $2, $1</em>) says &quot;Print field no. 2, followed by field no. 1.&quot;<br />
</li>
</ol>
<p>What the combined program says is: &quot;For all lines, if the value of the first field is greater than 1,000,000, print the second field of the line followed by the first field of the line.&quot;  (Note that AWK programs entered on the command line are usually enclosed in single quotation marks in order to prevent the shell from interpreting them.)</p>
<p>As we have seen in the previous example, the structure of an AWK statement is as follows:</p>
<pre><code>pattern { action }</code></pre>
<p>The expression <em>pattern</em> specifies a condition that has to be met for <em>action</em> to take effect. AWK programs consist of an arbitrary number of these statements.  (The program we have discussed above contains only a single statement.)  An AWK program basically does the following:</p>
<ol>
<li>It reads its input (e.g. a file or a text stream from standard input) line by line.</li>
<li>For each line, AWK carries out all statements whose condition/pattern is met.</li>
</ol>
<p>Simple, isn't it?</p>
<h2>Example 2</h2>
<p>Let's look at another example:</p>
<pre><code>$ awk &#39;$4 == 2007 { print &quot;Rank&quot;, NR, &quot;-&quot;, $3 }&#39; highscores.txt
Rank 1 - Mitchell
Rank 2 - Wiebe
Rank 5 - Boyer</code></pre>
<p>The program, again consisting of a single statement, may be paraphrased like this: &quot;For each line, if the value of field no. 4 equals 2007, print the word 'Rank', followed by the value of the variable 'NR', followed by a dash ('-'), followed by field no. 3.&quot;</p>
<p>So what this little program does is print the surnames of all high score holders having set their record in 2007 along with their respective ranks in the high score table.</p>
<p>How does AWK know which ranks the individual high score holders occupy?  Since the table is sorted, the rank of each high score holder is equal to the row number of the entry.  And AWK can access the number of each row by means of the built-in variable NR (<strong>N</strong>umber of <strong>R</strong>ow).  AWK has quite a lot of useful built-in variables, which you can look up in its documentation.<br />
</p>
<h2>Example 3</h2>
<p>The third and final example is a bit more complex than the other two, since it contains three AWK statements in total:</p>
<pre><code>$ awk &#39;BEGIN {print &quot;Together, the five best Donkey Kong players have achieved:&quot;}\
{total += $1} END {print total, &quot;points&quot;}&#39; highscores.txt</code></pre>
<p>This will output the following:<br />
</p>
<pre><code>Together, the five best Donkey Kong players have achieved:
4675600 points</code></pre>
<p>Let's break up this program into its three parts/statements (which we have entered on a single command line): </p>
<h3><strong>First statement</strong></h3>
<p><em>pattern</em>: BEGIN<br />
<em>action</em>: print &quot;Together, the five best Donkey Kong players have achieved:&quot;</p>
<h3><strong>Second statement</strong></h3>
<p><em>pattern:</em> none (= always execute <em>action</em>)<br />
<em>action</em>: add the value of field no. 1 to the variable <em>total</em></p>
<h3><strong>Third statement</strong></h3>
<p><em>pattern:</em> END<br />
<em>action</em>: print the value of the variable <em>total</em>, followed by the string &quot;points&quot;</p>
<p>OK, now let's look at what is new in this short AWK program.</p>
<p>First of all, the patterns BEGIN and END have a special meaning: the action following BEGIN is executed before any input is read and the action introduced by END is executed when AWK has finished reading the input.</p>
<p>In the second statement, we can observe that an AWK statement does not need a pattern, only <em>action</em> is obligatory.  If a statement doesn't contain a pattern, the condition of the statement is always met and AWK executes the action for every single input line.</p>
<p>Finally, we have used our own variable for the first time, which we have called <em>total</em>. AWK variables do not need to be declared explicitly; you can introduce new ones by simply using them.  In our example program, the value of the variable <em>total</em>, starting out at 0 (zero), is increased by the value of field no. 1 for each input line. The += operator means &quot;add the math expression on the right to the variable on the left.&quot;</p>
<p>So after all input lines have been read, <em>total</em> contains the sum of all field 1 values, that is, the sum of all high scores.  The END statement outputs the value of <em>total</em> followed by the string &quot;points&quot;.<br />
</p>
<h2>Where to go from here?<br />
</h2>
<p>We have seen that AWK is a fun and easy to use little programming language that may be applied to a wide range of data extraction tasks.  This short introduction to AWK can of course be little more than an appetizer.  If you want to learn more, we recommend you have a look at GAWK, the GNU implementation of AWK.  It is one of the most feature-rich implementations of the language, and comes with a comprehensive and easy to read manual (see <a href="http://www.gnu.org/software/gawk/manual/" class="uri">http://www.gnu.org/software/gawk/manual/</a>).<br />
</p>
<p><span id="ch045_regular-expressions.xhtml"></span></p>
<h1>Regular Expressions</h1>
<p>When you're looking through files or trying to change text, your needs are often ambiguous or approximate. Typical searches include:</p>
<ul>
<li>Finding an indeterminate number of things, such as &quot;one or more zeroes&quot;.</li>
<li>Finding text that can have variants, such as &quot;color&quot; and &quot;colour&quot;, or &quot;gray&quot; and &quot;grey&quot;. </li>
<li>Extracting parts of text that forms a pattern. For instance, suppose you have a list of email addresses such as <a href="mailto:somebody@fsf.org">somebody@fsf.org</a> and <a href="mailto:whoever@flossmanuals.net">whoever@flossmanuals.net</a>, and you want to extract the parts after the @ sign (fsf.org and flossmanuals.net, respectively).<br />
</li>
</ul>
<p>To search for such strings and (if you want) make replacements, a special language called <em>regular expressions</em> is invaluable. This section offers a quick introduction to regular expressions. The language can be intimidating at first--but it is not complicated, only terse. You have to use it a bit so that your brain gets used to picking the regular expressions apart.</p>
<p>The easiest way to learn and practice regular expressions is to use the simple filters provided with the shell, such as grep, Sed, and AWK. The grep command has popped up several times already in this book. In this section we'll use an &quot;extended&quot; version named egrep, because it provides more of the features people use frequently in regular expressions. Sed and AWK were introduced in previous sections; we'll use Sed a lot in this one.</p>
<p>By the end of this section, you'll understand grep, egrep, and Sed pretty well. You will then be able to move on and use regular expressions in other situations where they are even more powerful. Nearly every modern language, including the other scripting languages mentioned in this book (Perl, Python, and Ruby) offer regular expressions. Even databases offer some form of regular expressions.</p>
<p>The details of regular expressions vary from one tool to another, and even from one version of a tool to another version of the same tool. We'll show pretty common features, but they don't all work in every tool.<br />
</p>
<h2>Plain text</h2>
<p>A regular expression doesn't have to be fancy. Up to now, the grep commands we've shown look for plain text:</p>
<pre><code>$ cat color_file
Primary colors blue and red make the color magenta
Primary colors blue and green make the colour cyan
Primary colors red and green make the colour yellow
Black and white make grey
$ grep &#39;colour&#39; color_file
Primary colors blue and green make the colour cyan
Primary colors red and green make the colour yellow</code></pre>
<p>Because &quot;colour&quot; contains no metacharacters the shell would interpret, we don't need the single quotes, but we're using them to get into the habit. The egrep commands in this section will use lots of metacharacters.</p>
<h2>Indeterminate quantities</h2>
<p>One simple application of regular expressions is to search for &quot;any number&quot; of something, or a fuzzy amount such as &quot;3 to 5&quot; hyphens. Here are the metacharacters that support this. For the sake of simplicity, we'll show some in isolation and then use them in some tools.</p>
<table>
<tbody>
<tr class="odd">
<td> Match zero or more of X</td>
<td> X*</td>
</tr>
<tr class="even">
<td> Match one or more of X<br />
</td>
<td> X+</td>
</tr>
<tr class="odd">
<td> Match zero or one of X<br />
</td>
<td> X?</td>
</tr>
<tr class="even">
<td> Match from 3 to 5 of X<br />
</td>
<td> X{3,5}</td>
</tr>
</tbody>
</table>
<p>These look a lot like shell (globbing) metacharacters, but there are subtle differences. Focus on what they mean in regular expressions and remember that it is really a separate language from the shell metacharacters.</p>
<p>Now we can see how to find both &quot;color&quot; and &quot;colour&quot; in one search. We want either zero or 1 &quot;u&quot;, so we specify:</p>
<pre><code>$ egrep &#39;colou?r&#39; color_file
Primary colors blue and red make the color magenta
Primary colors blue and green make the colour cyan
Primary colors red and green make the colour yellow</code></pre>
<p>The asterisk (*) is one of the most common and useful metacharacters in regular expressions, but also one of the most confusing and misused. Suppose you wanted to remove zeros from a line. You might try to remove &quot;any number of zeros&quot; through an asterisk:</p>
<pre><code>$ echo &quot;There are 40006 items&quot; | sed &quot;s/0*/X/&quot;</code></pre>
<p>But the output is:</p>
<pre><code>XThere are 40006 items</code></pre>
<p>This happened because Sed replaces the first occurrence of the pattern you request. You requested &quot;zero or more&quot; and the first occurrence of that is the beginning of the line!<br />
</p>
<p>In this case, you want the plus sign (0+), but many versions of Sed don't support it. You can work around that with:</p>
<pre><code>$ echo &quot;There are 40006 items&quot; | sed &quot;s/00*/X/&quot;
There are 4X6 items</code></pre>
<p>If you put a single digit in the brackets, such as {3}, it means &quot;match this number exactly&quot;. If you include the comma without a second digit, such as {3,}, it means &quot;match any number of three or more.&quot;</p>
<h2>Indeterminate Matches, Classes, and Ranges</h2>
<p>To match any character, just specify a dot or period (.). Thus, the following matches a slash followed by any single character and another slash:</p>
<pre><code>$ egrep &#39;/./&#39; file</code></pre>
<p>The dot is commonly combined with one of the fuzzy quantifiers in the previous section. So the following matches any number of characters (but there has to be at least one) between slashes:</p>
<pre><code>$ egrep &#39;/.+/&#39; file</code></pre>
<p>The following is the same except that it also finds lines with two slashes in a row (//):</p>
<pre><code>$ egrep &#39;/.*/&#39; file</code></pre>
<p>A period is a common character in text, so you often want a dot to mean a dot--not to have its special metacharacter meaning. Whenever you need to search for a character that your tools considers a metacharacter, precede it with a backslash:</p>
<pre><code>$ egrep &#39;\.&#39; file</code></pre>
<p>That command finds just a dot. Because the backslash causes the dot character to escape being treated as a metacharacter, we speak of <em>escaping</em> characters through a backslash.</p>
<p>If you find yourself searching for strings that contain punctuation and you don't want any of the punctuation treated as a metacharacter, it can be tiresome and difficult to escape each character. Consider using fgrep (which stands for &quot;fixed grep&quot;) for these strings instead of grep or egrep. The fgrep command looks for exactly what you pass, and doesn't treat anything as a metacharacter. You still have to use single quotes so the shell doesn't treat anything as a metacharacter.<br />
</p>
<p>Square brackets let you specify combinations of characters. For instance, to search for both &quot;gray&quot; and &quot;grey&quot; you specify:</p>
<pre><code>$ egrep &quot;gr[ae]y&quot; color_file
Black and white make grey</code></pre>
<p>To match the letters that are commonly used as vowels in English, write:</p>
<pre><code>[aeiouy]</code></pre>
<p>The order of characters never matters inside the brackets. We can find lines without vowels by submitting the regular expression to egrep. We'll start with a rather garbled file name <em>letter_file</em>:</p>
<pre><code>This is readable text.
Ths s grbg txt.
This is more readable text.
aaaai</code></pre>
<p>Note that the second line contains no vowels, whereas the last line contains only vowels. First we'll search for a vowel:</p>
<pre><code>$ grep &#39;[eauoi]&#39; letter_file
This is readable text.
This is more readable text.
aaaai </code></pre>
<p>The line without vowels failed to match.</p>
<p>Now let's look for non-vowel characters. That means not only consonants, but punctuation and spaces. We can <em>invert</em> the character class by putting a caret (^) at the front. In a character class (and nowhere else) the caret means &quot;everything except the following&quot;. We'll do that here with five vowels (allowing the &quot;y&quot; to be matched because it can also be a consonant):</p>
<pre><code>$ grep &#39;[^eauoi]&#39; letter_file
This is readable text.
Ths s grbg txt.
This is more readable text.</code></pre>
<p>This time only the last line was left out, because it had vowels and nothing else.</p>
<p>A character class can also contains ranges, which you indicate by a hyphen separating two characters. Instead of [0123] you can specify [0-3]. People often use the following combinations:</p>
<table>
<tbody>
<tr class="odd">
<td>Any digit<br />
</td>
<td> [0-9]</td>
</tr>
<tr class="even">
<td>Any lowercase letter<br />
</td>
<td> [a-z]</td>
</tr>
<tr class="odd">
<td>Any uppercase letter<br />
</td>
<td> [A-Z]</td>
</tr>
<tr class="even">
<td>Any letter<br />
</td>
<td> [a-zA-Z]</td>
</tr>
</tbody>
</table>
<p>As the last example in the table shows, you can combine ranges inside the brackets. You can even combine ranges with other characters, such as the following combination of letters with common punctuation:</p>
<pre><code>[a-zA-Z.,!?]</code></pre>
<p>We didn't have to escape the dot in this example because it isn't treated as a metacharacter inside the square brackets.<br />
</p>
<p>Note that a character class, no matter how large, always matches a single character. If you want it to match a lot of characters, use one of the quantifiers from the previous section:</p>
<pre><code>$ egrep &#39;\([a-zA-Z.,!?]+\)&#39; file</code></pre>
<p>This matches parentheses that enclose any number of the characters in the character set. We had to escape the parentheses because they are metacharacters--very special ones, it turns out. We'll look at that next.<br />
</p>
<h2>Groups</h2>
<p>Parentheses allow you to manipulate multiple characters at once. Remember that character classes in square brackets always match a single character, even though that single character can be many different things. In contrast, groups can match a sequence. For instance, suppose you want to match quantities of a thousand, a million, a billion, a trillion, etc. You want to match:</p>
<p>1,000</p>
<p>1,000,000</p>
<p>1,000,000,000</p>
<p>etc.</p>
<p>You can do that by putting the string &quot;,000&quot; in a group, enclosing it in parentheses. Now anything you apply to it--such as the + character--applies to the whole group:<br />
</p>
<pre><code>$ egrep &#39;1(,000)+&#39; file</code></pre>
<p>But parentheses do even more. They store what they match, which is called <em>capturing</em> it. Then you can refer to it later.<br />
</p>
<p>This is a subtle and possibly confusing feature. Let's show it by looking at a file that repeats some sequences of characters:</p>
<pre><code>This bell is a tam-tam.
This sentence doesn&#39;t appear in the egrep-generated output.
I want it quick-quick.</code></pre>
<p>The first line contains the word &quot;tam&quot;, a hyphen, and then &quot;tam&quot; again. The third line contains &quot;quick&quot;, a hyphen, and then &quot;quick&quot; again. These lines don't actually have strings in common, except for the hyphen (which appears in the second line too, so searching for it doesn't distinguish the first and third lines from the second). What the first and third lines share is a pattern: a word followed by a hyphen and itself. So we can grab those two lines by capturing a word and repeating it (the file is named <em>doubles</em>):</p>
<pre><code>$ egrep &#39; ([a-z]+)-\1&#39; doubles
This bell is a tam-tam.
I want it quick-quick.</code></pre>
<p>Puzzled? The regular expression, broken into pieces, is:</p>
<table>
<tbody>
<tr class="odd">
<td> (</td>
<td> Start a group<br />
</td>
</tr>
<tr class="even">
<td> [a-z]+</td>
<td> Any number (one or more) of letters<br />
</td>
</tr>
<tr class="odd">
<td> )</td>
<td> Close the group<br />
</td>
</tr>
<tr class="even">
<td> -</td>
<td> Hyphen (a simple match)<br />
</td>
</tr>
<tr class="odd">
<td> \1</td>
<td> Repeat the group captured earlier<br />
</td>
</tr>
</tbody>
</table>
<p>The \1 is a special syntax recognized by tools that allow parentheses to capture text. In the first line of the files, it matches &quot;tam&quot; because that's what [a-z]+ matched. In the third line, it matches &quot;quick&quot; because that's what [a-z]+ matched. It says, &quot;whatever you found, I want it again.&quot;</p>
<p>To extract the second part of an email address, such as &quot;fsf.org&quot; from &quot;<a href="mailto:someone@fsf.org">someone@fsf.org</a>&quot;, use a regular expression such as:</p>
<pre><code>([a-z._]+)@([a-z._]+)</code></pre>
<p>In this case, \1 matches the part before the @ sign, while \2 matches the part after the @. So extract \2 to get &quot;fsf.org&quot;.</p>
<h2>Alternation</h2>
<p>We saw that a character class matches only one character at a time. If you have two or more sequences that can appear in the same place, you specify them through <em>alternation</em>. This involves separating them with a vertical bar (|). Thus, the following finds an instance of &quot;FSF&quot; or &quot;Free Software Foundation&quot;:<br />
</p>
<pre><code>FSF|Free Software Foundation</code></pre>
<p>You can put as many alternatives as you want in alternation:</p>
<pre><code>gnu.org|FSF|Free Software Foundation</code></pre>
<p>Because the alternatives are usually embedded in a larger regular expression, you generally need to put them in parentheses to mark where they start and end:</p>
<pre><code>The (FSF|Free Software Foundation)</code></pre>
<h2>Anchoring</h2>
<p>If you want to match something when it occurs at the beginning of the line, but nowhere else, preface the regular expression with a caret (^). Thus, you can use the following to catch lines that begin with a lowercase letter:<br />
</p>
<pre><code>^[a-z]</code></pre>
<p>This use of the caret has nothing to do with the caret that we saw before inside of square brackets. A caret means &quot;beginning of line&quot; when it's the first character of a regular expression, but only in that position.</p>
<p>Similarly, you can match something at the end of a line by adding a dollar sign ($) to the end of the regular expression:<br />
</p>
<pre><code>[0-9]$</code></pre>
<p>In the phrase &quot;I added 3 and 5 to make 8&quot;, the previous regular expression will match the 8 because it's at the end of the line.</p>
<p>When you're searching for lines that match a regular expression exactly (no extra text at the start or end), use both anchors. For instance, if you want to make sure a line consists only of digits, enter:</p>
<pre><code>^[0-9]+$</code></pre>
<p>The [0-9]+ part specifies &quot;one or more digits&quot;, and the ^ and $ ensure that the regular expression takes up the whole line.<br />
</p>
<p>We wanted to take you just far enough to get a sense of what regular expressions can do for you. There are many, many more features, but some of them are useful only in programming languages. As we warned before, different tools support different features, so you have to read the documentation for egrep, Sed, or any other tool or language to find out what works there.</p>
<p>When you're testing regular expressions, you can try lots of online or stand-alone tools (some offered gratis and some for sale) that help debug problems such as mismatched brackets and parentheses. Such tools can help you learn the more complex features and make complex regular expressions easier to write.</p>
<p><span id="ch047_perl.xhtml"></span></p>
<h1>Perl</h1>
<p>Perl <strong><strong></strong></strong> is a programming language that can be used to perform tasks that would be difficult or cumbersome on the command line. Perl is included by default with most GNU/Linux distributions. Usually, one invokes Perl by using a text editor to write a file and then passing it to the <code>perl</code> program.</p>
<p>Perl scripts can be named anything but conventionally end with &quot;.pl&quot;. You can use any text editor to create this file -- Emacs, Vim, Gedit, or whatever your favorite is. A script could look like this:</p>
<pre><code>my $a = 1 + 2;
print $a,&quot;\n&quot;;</code></pre>
<p>In this example, we create a variable (by using <em>my</em>) which is called <em>$a</em> (the dollar sign is Perl's way of denoting a variable), which stores the result of &quot;1 + 2&quot;. It then uses the <em>print</em> function to print the result, which should be 3. The comma concatenates two or more strings together. In this case a newline is appended to the end of the printed string. All statements in Perl are terminated with a semicolon, even if they are on separate lines. If we save this file as <em>first.pl</em>, we can run it from the command line.</p>
<pre><code>$ perl first.pl
3</code></pre>
<p>The Perl program printed out &quot;3&quot;, just like we expected. If we don't want to type &quot;perl&quot; in order to run the script, we can put this line:</p>
<p>#!/usr/bin/perl</p>
<p>at the start (be sure to use the correct path on your system), and do <em>chmod +x first.pl</em> to make it executable. Then we type <em>./first.pl</em> to run it.<br />
</p>
<p>Of course, we can use Perl to do more useful things. For example, we can look at all the files in the current directory.</p>
<pre><code>my $filename;
opendir DH, &quot;.&quot; or die &quot;Could not open directory!&quot;;
while( $filename = readdir(DH) ){
  print $filename,&quot;\n&quot;;
}</code></pre>
<pre><code>$ perl first.pl
perl-script.perl
other-script.perl
document.odt
photo.png</code></pre>
<p>Here we use the <em>opendir</em> function to open a directory for reading. &quot;DH&quot;, will be our directory handle, how we refer to the open directory for reading. A directory handle is not declared like a variable, just created at the invocation of the <em>opendir</em> function. We pass the directory name as a string (enclosed in double quotes); the single dot refers to the current directory. The <em>or</em> and <em>die</em> statements tell Perl to terminate execution if the directory cannot be opened. The final string tells Perl what to print as an error message.</p>
<p>Inside the <em>while</em> loop, the <em>readdir</em> function takes our directory handle and returns the next <em>filename</em> in the directory, storing it in the default variable &quot;$_&quot;.</p>
<p>Let's try doing something with these files -- here's a way to find all of the &quot;.pl&quot; files in a directory.</p>
<pre><code>opendir DH, &quot;.&quot; or die &quot;Could not open directory!&quot;;
while( $_ = readdir(DH) ){
  print $_,&quot;\n&quot; if /.pl$/;
}</code></pre>
<p>Above we use a Perl shorthand to compress the print and evaluation into one line since both <em>print</em> and <em>if</em> take the default variable &quot;$_&quot; as their argument if one is not specified. The &quot;/.pl$/&quot; operator says: match any word that ends with &quot;.pl&quot;. Below is a simpler but wordier way to pick out the all of the files with &quot;.txt&quot; in them.</p>
<pre><code>my $filename;
opendir DH, &quot;.&quot; or die &quot;Could not open directory!&quot;;
while( $filename = readdir(DH) ){
  if ($filename =~ /.txt$/){
    print $filename,&quot;\n&quot;;
  }
}</code></pre>
<p>Perl uses braces ({ }) to group statements in branching and loop constructs, such as <em>if</em> and <em>while</em>. The &quot;=~&quot; operator tells <em>if</em>, yes, when &quot;.txt&quot; appears at the end of the variable or string.<br />
</p>
<p>We can also use command line code in Perl by using the <em>system</em> function. For example, if we wanted to delete all of the &quot;.txt&quot; files, we could use.</p>
<pre><code>my $dir = &quot;./&quot;;
system(&quot;rm $dir*.txt&quot;);</code></pre>
<p>Above, <em>system</em> passes its argument to a shell, which executes it exactly as it would if we typed it in. Now if we look for any files ending in, &quot;.txt&quot; we won't find any.</p>
<pre><code>system(&quot;ls *.txt&quot;);</code></pre>
<h2>More information about Perl</h2>
<p>The Perl web site at <a href="http://www.perl.org/">http://www.perl.org</a> contains an impressive amount of information and documentation about the Perl language.</p>
<p><span id="ch048_python.xhtml"></span></p>
<h1>Python</h1>
<p>Python <strong></strong> is a programming language that can be used to perform tasks that would be difficult or cumbersome on the command line. Python is included by default with most GNU/Linux distributions. Just like the command line, you can either use Python by typing commands individually, or you can create a script file. If you want to type commands individually, start the Python interpreter by typing <code>python</code>.<br />
</p>
<pre><code>$ python
&gt;&gt;&gt; 10 + 10
20</code></pre>
<p><strong></strong></p>
<p>To exit an interactive Python session, type <strong>Ctrl + d</strong>.</p>
<p>To write a multi-line script in Python that you can run from outside of the Python interactive console, put the commands in a file. You can use any text editor to create this file -- Emacs, Vim, Gedit, or whatever your favorite is; and call it what you like (often the filename ends with &quot;.py&quot; to help distinguish it in a directory listing). A script could look like this:</p>
<pre><code>a = 1 + 2
print a</code></pre>
<p>In this example, we create a variable, <em>a</em>, which stores the result of &quot;1 + 2&quot;. It then uses the <em>print</em> command to print out the result, which should be 3. If we save this file as <em>first.py</em>, we can run it from the command line.</p>
<pre><code>$ python first.py
3</code></pre>
<p>The Python program printed out &quot;3&quot;, just like we expected. We can add a first line specifying the python interpreter, make it executable and then just type <em>./first.py</em> to run it. If we still have the first.pl file from the previous chapter, it does exactly the same thing and we can make a link to one of them in order to choose the method by which we add 1 and 2.</p>
<pre><code>$ ln -s first.py 1plus2
$./1plus2
3
$ln -sf first.pl 1plus2
$./1plus2
3</code></pre>
<p>Of course, we can use Python to do more useful things. For example, we can look at all the files in the current directory.</p>
<pre><code>$ python
&gt;⁞⁞&gt;&gt; import os
&gt;&gt;&gt; os.listdir(&#39;.&#39;)
[&#39;notes.txt&#39;, &#39;readme.txt&#39;, &#39;first.py&#39;]</code></pre>
<p>Here we import the standard library &quot;os&quot;, which has operating system-like functions in it.  We call the <em>listdir</em> function to return a list of names of files in the current directory.  We pass the directory name as a string (enclosed in single quotes); the single dot refers to the current directory.<br />
</p>
<p>Let's try doing something with these files -- here's a way to find all of the &quot;.py&quot; files in a directory.</p>
<pre><code>&gt;&gt;&gt; files = os.listdir(&#39;.&#39;)
&gt;&gt;&gt; files
[&#39;notes.txt&#39;, &#39;readme.txt&#39;, &#39;first.py&#39;]
&gt;&gt;&gt; [file for file in files if &#39;.py&#39; in file]
[&#39;first.py&#39;]</code></pre>
<p>Above we use a powerful construction called a <em>list comprehension</em> to produce a new list by transforming and filtering a list.  Below is a simpler but wordier way to pick out the all of the files with &quot;.txt&quot; in them.</p>
<pre><code>&gt;&gt;&gt; for file in files:
...     if &#39;.txt&#39; in file:
...         print file
... 
notes.txt
readme.txt</code></pre>
<p>The indentation is required in Python.  Indentation tells the Python interpreter what to include in the <em>for</em> loop and what to include in the <em>if</em> statement.  Also, a you must press an additional <strong>Enter</strong> at the last set of three dots to tell the Python interpreter that you're done.</p>
<p>We can also use command line code in Python by passing it to the <em>os.system</em> function. For example, if we wanted to delete all of the &quot;.txt&quot; files, we could use.</p>
<pre><code>&gt;&gt;&gt; for file in files:
...     if &#39;.txt&#39; in file:
...         cmd = &#39;rm &#39; + file
...         os.system(cmd)
...</code></pre>
<p>Above, we construct a shell command <em>cmd</em> as a Python string by concatenating (using the &quot;+&quot; operator) the strings &quot;rm &quot; and the filename, then pass it to the <em>os.system</em> function.  Now we can check to see that the files have been deleted.<br />
</p>
<pre><code>&gt;&gt;&gt; os.system(&#39;ls&#39;)
first.py</code></pre>
<h2>More information about Python</h2>
<p>The Python web site at <a href="http://www.python.org" class="uri">http://www.python.org</a>  contains an impressive amount of information and documentation about the Python language.  If you are just getting started with programming, the book &quot;How to Think Like a Computer Scientist&quot; by Jeffrey Elkner, Allen B. Downey and Chris Meyers at <a href="http://openbookproject.net/thinkCSpy/index.html" class="uri">http://openbookproject.net/thinkCSpy/index.html</a> is a good place to start.</p>
<p><span id="ch049_ruby.xhtml"></span></p>
<h1>Ruby</h1>
<p>Ruby is a programming language that can be used to perform tasks that would be difficult or cumbersome on the command line. To get started with Ruby, you need to install it. Usually, there is a program on your computer such as &quot;Add/Remove Programs&quot; or &quot;Package Manager&quot; which allows you to easily install Ruby. You can also go to <a href="http://www.ruby-lang.org" class="uri">http://www.ruby-lang.org</a>, where you can find downloads for Ruby as well as more information on the language.</p>
<p>Just like the command line, you can either use Ruby by typing commands in individually, or you can create a script file. If you want to type commands in individually, install the &quot;irb&quot; program and use the <code>irb</code> command at the command line:</p>
<pre><code>$ irb
&gt; 10 + 10
=&gt; 20
&gt; exit
$</code></pre>
<p>As you can see, you can use Ruby to do basic mathematics. An important note about Ruby is that instead of printing a value only when you use <em>echo</em> (which is <em>puts</em> in Ruby) , Ruby will print out the result of whatever command you enter -- this is what the &quot;=&gt;&quot; means. When you enter the &quot;10 + 10&quot; command, the result is &quot;20&quot;. Also, remember that you can use <em>exit</em> to get out of the <code>irb</code> program.</p>
<p>To write a multi-line script in Ruby, you create a file and save it with a &quot;.rb&quot; at the end. You can use any text editor to create this file -- Emacs, Vim, Gedit, or whatever your favorite is. A script could look like this:</p>
<pre><code>a = 1 + 2
puts a</code></pre>
<p>In this example, we create a variable, <em>a</em>, which stores the result of &quot;1 + 2&quot;. It then uses the <em>puts</em> command to print out the result, which should be 3. If we save this file as <em>ruby.rb</em>, we can run it from the command line:</p>
<pre><code>$ ruby ruby.rb
3</code></pre>
<p>The Ruby program printed out &quot;3&quot;, just like we expected. Of course, we can use Ruby to do more useful things. For example, we can look at all the files in a directory:</p>
<pre><code>$ irb
&gt; Dir.entries(&#39;my-directory&#39;)
=&gt; [&quot;ruby-script.rb&quot;, &quot;other-script.rb&quot;, &quot;document.odt&quot;, &quot;photo.png&quot;]</code></pre>
<p>We used the <em>Dir.entries</em> method to look at the files in <em>my-directory</em>. You probably noticed that we pass parameters differently in Ruby. Instead of separating them with spaces, we surround them in parenthesis. We also need to enclose all words in quotes - not just ones that have special characters in them.</p>
<p> Let's try doing something with these files -- here's a way to find all of the &quot;.rb&quot; files in a directory:</p>
<pre><code>&gt; files = Dir.entries(&#39;my-directory&#39;)
=&gt; [&quot;ruby-script.rb&quot;, &quot;other-script.rb&quot;, &quot;document.odt&quot;, &quot;photo.png&quot;]
&gt; for file in files
&gt; puts file if file.include?(&#39;.rb&#39;)
&gt; end
ruby-script.rb
other-script.rb</code></pre>
<p>First, we used the <em>for</em> command to loop through each of the files. We then get to work with each file. The next line says that we want to print out the file if it includes the text &quot;.rb&quot;. Finally, we end the <em>for</em> loop.</p>
<p>We can also use command line code in Ruby by enclosing it in backticks. For example, if we wanted to delete all of the &quot;.rb&quot; files, we could use:</p>
<pre><code>&gt; files = Dir.entries(&#39;my-directory&#39;)
=&gt; [&quot;ruby-script.rb&quot;, &quot;other-script.rb&quot;, &quot;document.odt&quot;, &quot;photo.png&quot;]
&gt; for file in files
&gt; `rm #{file}` if file.include?(&#39;.rb&#39;)
&gt; end</code></pre>
<p>Notice how we enclosed the <code>rm</code> command in backticks. We also used #{} to enclose the Ruby variable, so it is put in to the command properly instead of the literal string &quot;file&quot;.</p>
<h2>Learning More About Ruby</h2>
<p>If you want to learn more about Ruby, <a href="http://www.ruby-lang.org" class="uri">http://www.ruby-lang.org</a> is the homepage for Ruby, and <a href="http://www.ruby-doc.org" class="uri">http://www.ruby-doc.org</a>  is a great place to find tutorials and documentation.</p>
<p><span id="ch050_gnu-octave.xhtml"></span></p>
<h1>GNU OCTAVE</h1>
<p>GNU Octave <strong><strong></strong></strong> is both a programming language and a command-line language interpreter. The peculiarity of GNU Octave is that it enables sequences of activities to be performed as if they were a single activity to be silently iterated over all elements of a given set of things (e.g. files, lines, numbers, ...).</p>
<p>This is not new to experienced command-line users and many other languages allow such a convenient conciseness.  However, GNU Octave language belongs to the category of array-programming oriented languages and this can be summarized by saying that the typical elementary object within GNU Octave is not a single element (a certain file, line, number, ...) but a collection (<em>arrays</em>) of such elements on which an activity is to be applied element by element without the need to explicitly tell GNU Octave to do so.</p>
<p>GNU Octave is included by default with most GNU/Linux distributions. The easiest way to experiment with it is to open its interactive intepreter:<br />
</p>
<pre><code>$ octave -q
octave:1&gt;</code></pre>
<p>The text &quot;octave:1&gt;&quot; is the prompt of the GNU Octave interpreter, ready to read your first (&quot;:1&gt;&quot;) command. <br />
</p>
<p>A sequence (an array) with the first ten natural numbers can be generated by typing 1:10 (meaning: from 1 to 10):</p>
<pre><code>octave:1&gt; 1:10
ans =

    1    2    3    4    5    6    7    8    9   10</code></pre>
<p>Summing the first ten natural numbers can be easily done with the command sum :<br />
</p>
<pre><code>octave:2&gt; sum( 1:10 )
ans = 55</code></pre>
<p>Iterating the sum by showing the partial cumulate sums is also straightforward:<br />
</p>
<pre><code>octave:3&gt; cumsum( 1:10 )
ans =

    1    3    6   10   15   21   28   36   45   55</code></pre>
<p>A multiplication table can be generated by multiplying the first ten natural numbers each other, in all possible combinations. Instead of explicitly iterating over the array [1:10] , it is possible to let GNU Octave take care of the details:</p>
<pre><code>octave:3&gt; [1:10]&#39;*[1:10]
ans =
     1     2     3     4     5     6     7     8     9    10
     2     4     6     8    10    12    14    16    18    20
     3     6     9    12    15    18    21    24    27    30
     4     8    12    16    20    24    28    32    36    40
     5    10    15    20    25    30    35    40    45    50
     6    12    18    24    30    36    42    48    54    60
     7    14    21    28    35    42    49    56    63    70
     8    16    24    32    40    48    56    64    72    80
     9    18    27    36    45    54    63    72    81    90
    10    20    30    40    50    60    70    80    90   100</code></pre>
<p> The GNU Octave programming language is largely compatible with the MATLAB language so that most of the commands and scripts you can write for GNU Octave can also be used as MATLAB language commands or scripts, and vice-versa. This compatibility could enable you to suggest users of non-free interpreters of MATLAB/GNU Octave languages to experiment free software alternatives.</p>
<p>Apart from directly using the interactive interpreter, one could also invoke GNU Octave by using a text editor to write a file and then passing it to the <code>octave</code> program.</p>
<p>GNU Octave scripts can be named anything but conventionally end with &quot;.m&quot;. You can use any text editor to create this file -- Emacs, Vim, Gedit, or whatever your favorite is. A script could look like this:</p>
<pre><code>a = sum( 1:10 );
disp( a );</code></pre>
<p>In this example, we create a variable called <em>a</em> , which stores the result of the sum of all natural numbers between 1 and 10. It then uses the <em>disp</em> function to display the result, which should be 55. If we save this file as <em>first.m</em>, we can run it from the command line.</p>
<pre><code>$ octave -q first.m
55</code></pre>
<p>The GNU Octave program printed out &quot;55&quot;, just like we expected. If we don't want to type &quot;octave&quot; in order to run the script, we can put this line:</p>
<p>#!/usr/bin/octave</p>
<p>at the start (be sure to use the correct path on your system), and do <em>chmod +x first.m</em> to make it executable. Then we type <em>./first.m</em> to run it.<br />
</p>
<p>Of course, we can use GNU Octave to do more useful things. For example, we can look at all the files in the current directory to list only those whose extension is &quot;.m&quot;.</p>
<pre><code>filename = cellstr( ls( &#39;*.m&#39; ) );
fprintf( 1, &#39;file: %s\n&#39;, filename{:} )</code></pre>
<pre><code>$ octave first.m
file: octave-script.m
file: other-script.m</code></pre>
<p>Here we use the <em>ls</em> function to silently invoke the <em>ls</em> command-line utility looking for all files with pattern &quot;*.m&quot;. Since the result is a string, we split the string in rows by using the <em>cellstr</em> function so that the variable <em>filename</em> is assigned with an array of strings (more precisely, a <em>cell-array</em> whose elements are all strings). The final command tells GNU Octave what to print as output. In particular, here we ask GNU Octave to prefix each file name with the string &quot;file: &quot; followed by the file name (&quot;%s&quot;) and by an endline (&quot;\n&quot;).</p>
<p>Note that no explicit loops are needed.</p>
<h2>More information about GNU Octave</h2>
<p>The GNU Octave web site at <a href="http://www.gnu.org/software/octave/" class="uri" title="http://www.gnu.org/software/octave/">http://www.gnu.org/software/octave/</a> contains a variety of information and documentation about the GNU Octave language and interpreter.</p>
<p> </p>
<p><span id="ch052_glossary.xhtml"></span></p>
<h1>Glossary</h1>
<h2></h2>
<h2><strong>&amp;</strong></h2>
<p>(ampersand) Execute command in background.</p>
<h2><strong>&gt;</strong></h2>
<p>Redirect standard output.</p>
<h2><strong>&gt;&gt;</strong></h2>
<p>Append standard output.<br />
</p>
<h2><strong>&lt;</strong></h2>
<p>Redirect standard input.</p>
<h2><strong>|</strong></h2>
<p>Pipe, connecting the standard output of the preceding program with the standard input of the following program. You can break long program lines after pipe symbols without changing their effect.</p>
<h2><strong>.</strong></h2>
<p>(dot) In a file path, this refers to the current directory. Before a shell script name, this means to execute the script as if typed into the current shell, rather than starting a new shell and executing the command in its environment.<br />
</p>
<h2><strong>..</strong><br />
</h2>
<p>(double dot) Parent of the current directory. The parent of the root directory <code>/</code> is itself.<br />
</p>
<h2><strong>~</strong></h2>
<p>(tilde) Home directory.</p>
<h2><strong>/</strong></h2>
<p>(slash) By itself or at the beginning of a path, the root directory; in a path, the directory separator. Thus in <code>/usr/bin</code>, it serves both functions.</p>
<h2></h2>
<p>(backslash) At the end of a line, continues a long command on the next line. Before a special character, escapes that character, so that commands can deal with filenames that contain special characters. This allows users to search for text containing special characters, for example by using &quot;\*&quot; to search for &quot;*&quot;.<br />
</p>
<h2><strong>#</strong></h2>
<p>(hash) Comment.</p>
<h2><strong>*</strong></h2>
<p>(splat) In file globbing, wildcard to match any string. In regular expressions, wildcard to match any number of occurrences of the previous element.<br />
</p>
<h2><strong>?</strong></h2>
<p>Wildcard to match any character.</p>
<h2>^</h2>
<p>(caret) Wildcard to match the beginning of a line.</p>
<h2>!</h2>
<p>(bang) On the command line, execute the last command that begins with the following characters. Thus <code>!mv</code> says to run the last <code>mv</code> command. This function has modifiers to allow editing the last command before running it, to search for strings within commands, to run commands by number, to run the most recent command and to run different commands with the same arguments.</p>
<p>In logical expressions, such as those inside if and while statements, negate the result of the following expression. For example,</p>
<pre><code>$ if ! mkdir -p &quot;$DST&quot; ; then exit 1 </code></pre>
<p>attempts to create a new directory, and exits if the directory cannot be created.<br />
</p>
<h2>{}</h2>
<p>In a command following the <code>-exec</code> option of the <code>find</code> command, this is replaced by the name of a file that was found, so that the given command is applied to every found file.<br />
</p>
<h2><strong>` `</strong></h2>
<p>(backtick backtick) Execute command inline, and replace it with the result.</p>
<h2><strong>$( )</strong></h2>
<p>Execute command inline, and replace it with the result.</p>
<h2> [\$( )]</h2>
<p>Execute a command within a prompt.<br />
</p>
<h2>$</h2>
<p>(dollar) In a command, indicates that the value of the following environment variable should be used, not the name. For example, <code>echo $USER</code>. In regular expressions, a wildcard to match the end of a line. Dollar is also usually the last character in a bash prompt.</p>
<h2><strong>#!</strong></h2>
<p>(hashbang) Marks the beginning of an executable script. Follow with the program to execute this file, as in <code>#!/bin/bash</code>.<br />
</p>
<h2><strong>absolute path</strong></h2>
<p>A file path starting from the root directory, such as <code>/usr/share/doc</code>. Contrast with <strong>relative path</strong>.<br />
</p>
<h2><strong>alias</strong></h2>
<p>The alias command gives a name to a command string. Aliases can be made permanent by putting them in a bash startup script such as <code>~/.profile</code>.</p>
<h2>apt-get</h2>
<p>Advanced Packaging Tool, a user interface command for managing and installing gNewSense and Debian packages.</p>
<h2><strong>aptitude</strong></h2>
<p>Terminal-mode package manager for Debian-style packages.</p>
<h2><strong>archive</strong></h2>
<p>A file, usually compressed, containing multiple files.<br />
</p>
<h2><strong>argument</strong></h2>
<p>An input value required for a command to process. Also called &quot;parameter&quot;. Contrast with <strong>option</strong>.<br />
</p>
<h2><strong>ash</strong></h2>
<p>A smaller version of the Bourne shell (sh). The ash shell is a clone of Berkeley's Bourne shell (sh). Ash supports all of the standard sh shell commands, but is considerably smaller than sh. The ash shell lacks some Bourne shell features (for example, command-line histories), but it uses a lot less memory.</p>
<h2><strong>aspell</strong></h2>
<p>GNU Aspell is a free software spell checker designed to eventually replace Ispell. It can either be used as a library or as an independent spell checker.</p>
<h2>awk</h2>
<p>A scripting language for data extraction and analysis from structured text files.<br />
</p>
<h2><strong>auto completion</strong></h2>
<p>When the shell can determine that there is only one file starting with the latest text on the command line, pressing <strong>Tab</strong> will fill in the rest of the name. If there are several matches, the shell will fill in the part of the names (if any) that is unique, and let the user continue from there.</p>
<h2>background</h2>
<p>By adding an ampersand, &quot;&amp;&quot;, at the end of a command you tell the shell to run the program in the background, without terminal input, and to give you a prompt so that you can continue to give commands.<br />
</p>
<h2><strong>bash</strong></h2>
<p>The GNU Bourne Again shell, the default shell in the GNU/Linux operating system. Bash is an sh-compatible shell that incorporates useful features from the Korn shell (ksh) and C shell (csh). It is intended to conform to the IEEE POSIX P1003.2/ISO 9945.2 Shell and Tools standard. It offers functional improvements over sh for both programming and interactive use. Most sh scripts can be run by Bash without modification.</p>
<h2>bug</h2>
<p>Program behavior other than expected or desired.</p>
<h2>bug report</h2>
<p>Usually an e-mail or an entry in a bug database asking for help with a specific bug. Good bug reports state what software was used (Linux distribution and version, application name and version), what the user tried to do and what was the expected result, what happened instead, and what the user tried in order to fix it. It is particularly helpful to explain how to reproduce the problem, if it is repeatable. Log files of the incident should be attached.<br />
</p>
<h2>builtin</h2>
<p>A command executed by the shell itself, not by calling a separate program. The bash command</p>
<pre><code>$ man builtins</code></pre>
<p>gives details on builtins for bash itself.</p>
<h2>character set</h2>
<p>A collection of abstract characters, independent of the shapes in any particular font, with a numbering and one or more encodings. The ASCII character set maps to the numbers 0-127, encoded in seven bits of an eight-bit byte. ISO-8859-1 and related character sets have the range 0-255, and are encoded in 8 bits.  Unicode maps to the numbers 0-1,114,111 (17 16-bit code pages of 65,536 code points each), and has several encodings, of which the most commonly seen is the variable-length UTF-8.</p>
<h2>clobber</h2>
<p>Overwrite a file with new data. A common result of forgetting to append standard output with &quot;&gt;&gt;&quot; and instead writing a new file with &quot;&gt;&quot;.<br />
</p>
<h2><strong>command</strong></h2>
<p>Executable file or shell builtin.</p>
<h2>command completion</h2>
<p>In bash and other shells typing part of a command or file name that is on the path or in the current directory, and then pressing <strong>Tab</strong>, often fills in the rest of the name. If not, pressing <strong>Tab</strong> again gives a list of names beginning with the characters so far typed.<br />
</p>
<h2><strong>coreutils</strong></h2>
<p>The GNU Core Utilities are the basic file, shell and text manipulation utilities of the GNU operating system. These are the core utilities which are expected to exist on every operating system.</p>
<h2><strong>cron job</strong></h2>
<p>A command to be executed automatically on a schedule set with the <code>cron</code> command or one of its variants, such as <code>anacron</code>.</p>
<h2>default</h2>
<p>In many commands, the value preset for a particular option if the command line does not specify something different. The user can specify a default value for unset environment variables, for example,</p>
<pre><code>$ cat &quot;${VARIABLE_FILE_NAME:=/home/user/file}&quot;</code></pre>
<h2><strong>dependency</strong></h2>
<p>Software required to run a particular piece of software. This can include other applications, library files, fonts, images, and other data.</p>
<h2>directory</h2>
<p>A special kind of file that lists specific information on the files it contains, including owner, group, and permissions.<br />
</p>
<h2><strong>directory stack</strong></h2>
<p>A place to store recently used directory paths for easy retrieval with the commands <code>pushd</code> and <code>popd</code>. The command <code>dirs</code> displays the directory stack.<br />
</p>
<h2><strong>emacs</strong></h2>
<p>GNU Emacs text editor, originally short for Editing Macros, now jocularly Escape, Meta, Alt, Control, Shift, from its pervasive reliance on key combinations. You can be sure that emacs can do it, you just need to find out how.</p>
<h2><strong>environment variable</strong></h2>
<p>A string value assigned to a name in the environment of the current shell.</p>
<h2>escape</h2>
<p>A character that changes the interpretation of a character or sequence of characters that follow it. This is the original use of the Escape character. For example, in a text search the character &quot;*&quot; matches a wide range of text, while the string &quot;\*&quot; matches only an asterisk.<br />
</p>
<h2><strong>exit status</strong></h2>
<p>A value returned by a command to the shell, useful in scripting for deciding what to do next.<br />
</p>
<h2><strong>file</strong></h2>
<p>Utility for determining file types.</p>
<h2><strong>filesystem</strong></h2>
<p>The basic directory layout for a GNU/Linux system.</p>
<h2><strong>filter</strong></h2>
<p>Command-line program that reads standard input and writes standard output so that it is suitable for use in a pipeline, where each command performs a specific transformation on the data.<br />
</p>
<h2><strong>findutils</strong></h2>
<p>The GNU versions of find utilities. find, locate, updatedb and xargs.</p>
<h2><strong>FLOSS</strong></h2>
<p>Free/Libre Open Source Software, licensed so as to guarantee the essential freedoms of software users to source code and reuse. A combination of Free Software and Open Source Software, with Libre added in to emphasize that software freedom is essentially a matter of rights, not price.<br />
</p>
<h2>folder</h2>
<p>The name used in GUIs for directories.<br />
</p>
<h2><strong>fontconfig</strong></h2>
<p>Font configuration and customization library. </p>
<h2><strong>ftp</strong></h2>
<p>The standard File Transfer Protocol client.</p>
<h2><strong>function</strong></h2>
<p>In bash, the function builtin allows the user to create functions on the fly with the syntax</p>
<pre><code>$ function name() {body}</code></pre>
<h2>gawk</h2>
<p>The GNU version of the awk text processing utility. gawk is a program that you can use to select particular records in a file and perform operations upon them.</p>
<h2><strong>gedit</strong></h2>
<p>A simple and easy text editor for GNOME. It is UTF-8 compatible, provides tools for editing source code and can be extended using plugins.</p>
<h2><strong>globbing</strong></h2>
<p>Referring to a group of files with an abbreviation, such as &quot;*&quot; for all of the files in a directory.<br />
</p>
<h2><strong>GNOME</strong></h2>
<p>A desktop, set of libraries, and application suite for X.<br />
</p>
<h2><strong>GNU</strong></h2>
<p>Recursive acronym for GNU's Not Unix. It is the Free Software Foundation project to create a freely-licensed replacement for the proprietary Unix operating system.<br />
</p>
<h2><strong>GNU/Linux</strong></h2>
<p>Operating system combining the Linux kernel with GNU software tools.</p>
<h2>Graphical User Interface (GUI)</h2>
<p>User interface offering windows, icons, mouse control, multiple fonts, and so on.<br />
</p>
<h2><strong>grep</strong></h2>
<p>The GNU versions of grep pattern matching utilities. Grep searches one or more input files for lines containing a match to a specified pattern.</p>
<h2>group</h2>
<p>To simplify security, Unix systems organize users into groups, and assign a group owner as well as an individual owner to every file. In this way, system operators, for example, can be given control over certain system resources all at once, or everybody working on a project can gain access to all project files by joining the project group. Each user has a group with the same name for that user's files.<br />
</p>
<h2><strong>gzip</strong></h2>
<p>The GNU data compression application. gzip.org</p>
<h2><strong>history</strong></h2>
<p>Record of previously executed commands that can be recalled and executed again with the up arrow key.<br />
</p>
<h2><strong>intltool</strong></h2>
<p>Utility for internationalizing various kinds of data files.</p>
<h2><strong>kernel</strong></h2>
<p>The Linux kernel, core of the GNU/Linux operating system. kernel.org</p>
<h2><strong>kernel-utils</strong></h2>
<p>Kernel and Hardware related utilities.</p>
<h2><strong>less</strong></h2>
<p>A text file browser similar to <code>more</code>, but better as it can move back and forth through the file.</p>
<h2><strong>locale</strong></h2>
<p>Values of a set of environment variables that store information on the user's language, country, and character encoding, and options for date and time formatting, money, measurements, and other such information. Also the name of the command to display all of these environment variables.</p>
<h2>log</h2>
<p>A file, often in the <code>/var/log</code> directory, that contains notes made by running programs about their progress and about any problems they encounter. Vital information whenever something goes wrong.<br />
</p>
<h2><strong>lsof</strong></h2>
<p>A utility which lists open files on a GNU/Linux system.</p>
<h2><strong>lynx</strong></h2>
<h3></h3>
<p>A text-based Web browser. lynx.browser.org</p>
<h2>make</h2>
<p>An essential program for installing much unpackaged source code software. The developers can write down all of the complex information about how to configure, compile, and install their work in make files that you usually won't have to read. Just check the README or INSTALL files that come with the source code to see whether it uses this system, or has different instructions. Another program with similar functions is jhbuild.<br />
</p>
<h2><strong>man</strong></h2>
<p>A set of documentation tools: man, apropos and whatis.</p>
<h2><strong>mc</strong></h2>
<p>The Midnight Commander, a user-friendly text console file manager and visual shell. </p>
<h2><strong>more</strong></h2>
<p>A utility for displaying text files one screenful at a time. See also <em>less</em>.<br />
</p>
<h2><strong>openssh</strong></h2>
<p>The OpenSSH implementation of SSH protocol versions 1 and 2.</p>
<h2><strong>option</strong></h2>
<p>A value specified to a command using the form <code>--option</code> (long option) or <code>-o</code> (short option). Contrast with <strong>argument</strong>, which is a required input.<br />
</p>
<h2><strong>package manager</strong></h2>
<p>Software to install, remove, and otherwise manage applications as packaged by a particular distribution, particularly making sure that dependencies and compatibilities between software components are observed. The two main varieties are Red Hat/Yellow Dog <code>yum</code> and Debian <code>apt-get</code>.</p>
<h2><strong>parameter</strong></h2>
<p>Argument.<br />
</p>
<h2><strong>passwd</strong></h2>
<p>The passwd utility for setting/changing passwords using PAM. netadmintools.com</p>
<h2><strong>PATH</strong></h2>
<p>Environment variable specifying where the current shell should look for command files.<br />
</p>
<h2>Perl</h2>
<p>Practical Extraction and Report Language, or jocularly, Pathologically Eclectic Rubbish Lister. Perl is a dynamic programming language particularly suitable for text processing and manipulation.<br />
</p>
<h2>pipe</h2>
<p>A connection between two commands, so that the standard output of the first becomes the input of the second. Indicated with the character &quot;|&quot;.</p>
<h2>plain text</h2>
<p>A message or file represented as a sequence of characters in a specific character encoding, with no extra formatting information. Contrast with <strong>rich text</strong>. HTML files are plain text, but contain markup tags so that they represent rich text.<br />
</p>
<h2>process</h2>
<p>A running program. Each process has a process ID, a number that you can use to identify the process in a command.</p>
<h2>prompt</h2>
<p>The text string displayed by a shell when waiting for command input. </p>
<h2><strong>recursive command execution</strong></h2>
<p>With the <code>-r</code> or <code>-R</code> options, many commands will act on the current directory and any subdirectories. Check command documentation to determine the precise syntax.<br />
</p>
<h2><strong>redirection</strong></h2>
<p>Sending a file or standard output from a command to standard input of a command, or sending standard output or error output of a command to standard input of another command, or to a file.<br />
</p>
<h2><strong>regular expression</strong></h2>
<p>A string such as &quot;*.png&quot; that defines a pattern for matching text or filenames using special characters to indicate which alternatives to include.<br />
</p>
<h2><strong>relative path</strong></h2>
<p>A file path starting from the current directory, such as <code>docs</code> or <code>../Pictures</code>. Contrast with <strong>absolute path</strong>.</p>
<h2><strong>rich text</strong></h2>
<p>Text with formatting, including fonts, multiple type sizes, positioning, color, and much more. HTML and word processing files are forms of rich text. Contrast with <strong>plain text</strong>.<br />
</p>
<h2><strong>root</strong></h2>
<ol>
<li>root user, or superuser, a required account with permission to do anything on a GNU/Linux system.<br />
</li>
<li>The starting point of the directory tree, written &quot;/&quot;. All other directories are specified by paths from this root directory.</li>
</ol>
<h2><strong>script</strong></h2>
<p>An executable text file.<br />
</p>
<h2><strong>sed</strong></h2>
<p>A GNU stream text editor.</p>
<h2><strong>shell</strong></h2>
<p>A command interpreter such as sh or bash.</p>
<h2>stack</h2>
<p>A way to keep track of tasks and other information so that the last item saved (pushed) on the stack is the first item retrieved (popped) from the top of the stack. An example is the bash history stack.<br />
</p>
<h2>standard input, standard output, and standard error</h2>
<p>Communication channels provided to every running command. If not otherwise specified at the command line, they connect to the user's terminal, but they can be redirected to files or through pipes to other programs.</p>
<h2>string</h2>
<p>A <span class="il">string</span> is a <span class="il">sequence</span> of characters in a particular character set. Examples in ASCII include the sentence &quot;Hello, World&quot;, the URL &quot;<a href="http://www.flossmanuals.net/" class="uri">http://www.flossmanuals.net/</a>&quot;, and  the text message &quot;No such file or directory.&quot; Unicode strings can include any combination of languages, such as &quot;Japan (日本) and Korea (대한민국)&quot;.</p>
<h2><strong>sudo</strong></h2>
<p>A command to allow specified users and groups to run specified programs with superuser privileges. The file <code>/etc/sudoers</code> contains the specifications. The command <code>sudoedit</code> is provided for editing this file. It checks whether the edited file is in the correct format.</p>
<h2><strong>superuser</strong></h2>
<p>The root account, which has all permissions.</p>
<h2>syntax highlighting</h2>
<p>Displaying the text of various elements of a program, such as function names, variable names, strings, and keywords, in distinctive colors appropriate to the programming language (bash, Perl, Python, etc.) or markup format (HTML, XML, etc.) used. The colors are not stored with the file, but computed by the text editor when loading a file and during editing.<br />
</p>
<h2><strong>telnet</strong></h2>
<p>The client program for the telnet remote login protocol.</p>
<h2><strong>terminal</strong></h2>
<p>Originally, a printing terminal such as a Teletype, or a video terminal. Now a virtual terminal in a text or graphics window. In all cases, a device or program for typing input and displaying output.<br />
</p>
<h2><strong>time</strong></h2>
<p>A GNU utility for monitoring a program's use of system resources.</p>
<h2><strong>Unicode<br />
</strong></h2>
<p>The universal character set, meant to replace the jumble of more than a hundred other character set standards for 30 modern writing systems and dozens of others.</p>
<h2><strong>unzip</strong></h2>
<p>A utility for unpacking zip archives.</p>
<h2>UTC</h2>
<p>Coordinated Universal Time, or Temps Universel Coordonné, which has replaced Greenwich Mean Time as the world standard. The abbreviation UTC is a compromise between the English and French names.<br />
</p>
<h2><strong>vi</strong></h2>
<p>Visual editor, a powerful terminal-mode editor.<br />
</p>
<h2><strong>vim</strong></h2>
<p>The VIM editor, an extension of vi.</p>
<h2><strong>wget</strong></h2>
<p>A utility for retrieving files using the HTTP or FTP protocols.</p>
<h2><strong>which</strong></h2>
<p>Displays where a particular program in your path is located.</p>
<h2><strong>wildcard</strong></h2>
<p>A character that can match more than one string in file globbing or regular expression matching.<br />
</p>
<h2><strong>X</strong></h2>
<p>The standard windowing system for GNU/Linux.<br />
</p>
<h2><strong>yum</strong></h2>
<p>Yellowdog Update Manager, a package manager used in Red Hat and related GNU/Linux distributions that use RPM packages.</p>
<h2><strong>zip</strong></h2>
<p>A file compression and packaging utility compatible with PKZIP.</p>
<p><span id="ch053_command-quickie.xhtml"></span></p>
<h1>Command Quick Survey</h1>
<p>In each of the command examples in this chapter, the dollar sign ($) at the beginning of the line is a minimal GNU/Linux command prompt. (Your default prompt is usually more complex.)</p>
<p>The rest of the line is the command, with options and arguments. We use the following conventions.</p>
<ul>
<li>Lines that do not begin with &quot;$ &quot; are responses from the command execution.</li>
<li>The &quot;|&quot; character pipes the output of any command to another command.</li>
<li>The &quot;&gt;&quot; character redirects the output of any command to a file.</li>
<li>To append output to a file, use &quot;&gt;&gt;&quot;.</li>
<li>Many commands have no output. They succeed or fail silently, but return an error code that a script can use to decide what to do next.</li>
<li>The &quot;;&quot; character separates commands on the same line. They are executed in sequence, starting at the left.</li>
<li>The &quot;&amp;&quot; character at the end of a command line says to execute the command in the background, and give the user prompt for the next command immediately.</li>
<li>The &quot;\&quot; character at the end of a command line says that the command continues on the next line. Although the examples given in this manual are generally quite short, there are cases where commands span five or six lines in script files.<br />
</li>
<li>In '<em>some text with spaces</em> ' and &quot;<em>more text with spaces</em>&quot;, the single and double quotes indicate that the text inside is one argument, including the trailing space in the first example. Without them, the shell would interpret each word as a separate argument and discard whitespace.</li>
<li>Backticks &quot;``&quot; mark commands to be executed. The result is substituted for the command. </li>
<li>A number of commands have an option, usually written <code>-r</code> or <code>-R</code>, for applying the command to every file in every subdirectory of the location where the command starts its work. Since these options can be and are used for other functions, you should check the documentation on any command where you want to use this capability.<br />
</li>
</ul>
<p>A change that many people make is to put this command in their their startup file, <em>.bashrc</em> or <em>.profile</em>.<br />
</p>
<pre><code>$ PATH=$PATH:.</code></pre>
<p>This adds the current directory (.) to the path, so that you can execute your own private commands from one of your directories by changing to the directory and typing the command name. Without this, you have to type <code>./command</code> to execute a command in the current directory. Some people consider this a security risk. Some prefer<br />
</p>
<pre><code>$ PATH=~/bin:$PATH</code></pre>
<p>so that they can execute scripts in a directory of their choosing that they own, and those scripts will take precedence over others of the same name. However they will not accidentally execute scripts randomly anywhere in the filesystem that they happen to be.<br />
</p>
<h2>ls</h2>
<p><code>ls</code> is the command to list filenames.</p>
<p>It can have options (Flags) added after the command with a minus sign &quot;-&quot;.<br />
Arguments (parameters) can also be added.<br />
</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>$ ls</p></td>
<td>ordinary file listing</td>
</tr>
<tr class="even">
<td><p>$ ls | less</p></td>
<td>pipe listing to less, which displays it a page at a time<br />
</td>
</tr>
<tr class="odd">
<td><p>$ ls &gt; filelist</p></td>
<td>redirect listing to file named &quot;filelist&quot;</td>
</tr>
<tr class="even">
<td><p>$ ls -l</p></td>
<td>long file listing (file sizes, change times,..)</td>
</tr>
<tr class="odd">
<td><p>$ ls -a</p></td>
<td>include filenames starting with &quot;.&quot;, normally not listed</td>
</tr>
<tr class="even">
<td><p>$ ls -l -a</p></td>
<td>applies both the above options</td>
</tr>
<tr class="odd">
<td><p>$ ls -la</p></td>
<td>equivalent to the previous command</td>
</tr>
<tr class="even">
<td><p>$ ls *.fort</p></td>
<td>list files called &quot;ANYTHING.fort&quot;</td>
</tr>
<tr class="odd">
<td><p>$ ls -lat *.fort</p></td>
<td>the t means list them in time order, not alphabetically</td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><br />
 <br />
These examples show the main points of all GNU/Linux commands.  They are short, they take options, they take parameters, you can user several options together, you can chain commands together with pipes, you can redirect the output of a command to a file.</p>
<p>To list all files under a particular directory, use the <code>-R</code> option.<br />
</p>
<pre><code>$ ls -R
photos1 photos2 photos3

./photos1:
centraal_station.jpg    nieuwe_kerk.jpg

./photos2:
ica.jpeg                sanders_theater.jpeg

./photos3:
bayeux_cathedral.jpeg   rouen_cathedral.jpeg    travel.odt</code></pre>
<p>The &quot;R&quot; stands for &quot;recursive.&quot; Note that the recursive option is uppercase <code>-R</code> in the <code>ls</code> command (<code>-r</code> is used to reverse the ordering the directory contents), but can be either uppercase or lowercase in the <code>rm</code> command.</p>
<h2>man, info<br />
</h2>
<p>Now that you know the basics of shell commands, use these often; you can learn almost anything you need from the ample (if terse) documentation they provide.</p>
<p>You can get a summary of almost any GNU/Linux command with the <code>man</code> command or the more recently developed <code>info</code> command. If the <code>man</code> command doesn't work, it is probably because your shell can't find the manual pages. This requires you to set the variable MANPATH to the correct directories. To find the directories that contain manual pages, try the following command. It means &quot;print directories that have the name <em>man</em>&quot;:<br />
</p>
<pre><code>$ find / -type d -name man -print </code></pre>
<p>Manual pages follow a fairly rigid format. They start with a command synopsis, then list all the options and arguments to the command. Other sections that may be present include a short description; examples, overview, defaults, exit status, environment variables, and known bugs.</p>
<p>Info presents similar material, but often with more detail, and split into several pages with navigation links.</p>
<h2>apropos</h2>
<p>The <code>apropos</code> command tells you about <code>man</code> files that contain any keyword you specify, including <code>man</code> pages about topics other than commands. You would have a hard time guessing the names of some of these topics without help from <code>apropos</code>.</p>
<pre><code>$ apropos -a samba password
smbpasswd (5)        - The Samba encrypted password file</code></pre>
<h2>pwd</h2>
<p>GNU/Linux has directories to help you organize your files. <code>pwd</code> tells you your &quot;current working directory&quot; or CWD. In directory specifications, &quot;.&quot; stands for the current directory, and &quot;..&quot; for the parent directory. Paths starting with &quot;/&quot; are absolute, with no dependence on the current directory. Paths starting without a &quot;/&quot; are relative to the current directory.<br />
</p>
<p>An example directory name would be <em>/home/allen/handy/scripts</em>. The full name starts with a slash &quot;/&quot; and directory names are separated by slashes. This differs from Windows, which uses the backslash &quot;\&quot;, and Macintosh, which uses &quot;:&quot;.</p>
<pre><code>$ pwd
/home/myname</code></pre>
<h2>cd</h2>
<p>Changes your CWD.</p>
<table>
<tbody>
<tr class="odd">
<td>$ cd</td>
<td>change to your &quot;home directory&quot;</td>
</tr>
<tr class="even">
<td>$ cd  ..</td>
<td>takes you to the parent directory, for example from<br />
/usr/lib to /usr</td>
</tr>
<tr class="odd">
<td>$ cd Docs</td>
<td>change to documents directory in current directory,<br />
if there is one (uses relative path)</td>
</tr>
<tr class="even">
<td>$ cd  /usr/lib</td>
<td>takes you to the dir &quot;/usr/lib&quot; from anywhere (uses absolute<br />
path)</td>
</tr>
<tr class="odd">
<td>$ cd /</td>
<td>The root directory - there are none above this.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Your &quot;home directory&quot; is the one you log in to. It is defined in the file <em>/etc/passwd</em> (unless some special network system is in use, in which case it is found in the output from <code>ypcat passwd</code>).</p>
<h2>mkdir</h2>
<p>Make a directory.</p>
<pre><code>$ mkdir mydirectory</code></pre>
<h2>rmdir</h2>
<p>Remove a directory.</p>
<pre><code>$ rmdir mydirectory</code></pre>
<h2>touch</h2>
<p>If a file exists, this updates its modification date and time. If there is no such file, it is created with nothing in it.</p>
<pre><code>$ touch newfile</code></pre>
<h2>rm</h2>
<p>This command removes files (and directories).<br />
</p>
<p><em>By default, you get no second chance, and once files are gone they are irretrievable.</em> A nasty joke sometimes played on Newbies is to suggest &quot;<code>rm -r *</code>&quot; as the remedy for whatever problem they have. Don't try this unless you want to install a new operating system from scratch anyway, and you have a complete, current backup.<br />
</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td>$ rm     filename(s) </td>
<td> </td>
</tr>
<tr class="even">
<td>$ rm -r  filename(s)</td>
<td>Remove directories and all their contents.  </td>
</tr>
<tr class="odd">
<td>$ rm -i  filename(s)</td>
<td>Prompt for a y/n choice before each file (recommended!)</td>
</tr>
<tr class="even">
<td>$ rm -f  filename(s)</td>
<td><p>Do not complain if the file does not exist.<br />
Also overrides the -i flag.</p></td>
</tr>
</tbody>
</table>
<p><br />
</p>
<p><br />
<br />
<br />
<br />
<br />
 <br />
</p>
<h2>ln</h2>
<p>Make hard links or symbolic (aka &quot;soft&quot;) links to files. Both hard links and soft links are references to other files. If you don't know what an &quot;inode&quot; is, stick with using soft links. (Even if you <em>do</em> know what an inode is, chances are good that you will use soft links the vast majority of the time).</p>
<p>A soft link is a special type of file that serves as an alias to another file (or directory) -- same basic concept as &quot;desktop shortcuts&quot; in Windows, where you have a shortcut icon on your desktop that points to a program, file, or folder that is located elsewhere on your computer.  The file or directory that the link points to is called the &quot;target&quot; of the link.</p>
<p>When using <code>ln</code>, remember to include the <code>-s</code> option to choose soft type of link, and put the path to the target <em>before</em> the destination path for the new link.<br />
</p>
<p>To create a soft link named &quot;linkname&quot; pointing to a target named &quot;file&quot;:<br />
</p>
<pre><code>$ ln -s file linkname</code></pre>
<p>To create links in the current directory (also known as &quot;.&quot;) that point to files in ending in &quot;.so&quot; located in the <em>../lib</em> directory, giving the soft links the same names as the original files:</p>
<pre><code>$ ln -s ../lib/*.so .</code></pre>
<h2>cp</h2>
<p>This command copies files.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td>$ cp file1 file2</td>
<td><p>Copies file1 over file2, if it exists.<br />
Creates file2 if it did not exist.<br />
</p></td>
</tr>
<tr class="even">
<td>$ cp /etc /home/allen     <br />
</td>
<td>Copies  /etc to /home/allen/etc</td>
</tr>
<tr class="odd">
<td>$ cp -r mydir mynewdir</td>
<td><p>With the -r flag, copies directories too<br />
</p></td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h2>mv</h2>
<p>This moves and renames files and directories.</p>
<table>
<tbody>
<tr class="odd">
<td>$ mv file2 file3</td>
<td>Renames a file or directory<br />
</td>
</tr>
<tr class="even">
<td>$ mv /home/allen/etc /tmp</td>
<td>Moves a file or directory</td>
</tr>
</tbody>
</table>
<p><br />
<br />
</p>
<h2>whoami</h2>
<p>This tells you your id name, for example, &quot;allen&quot;</p>
<p>So you can type</p>
<pre><code>$ grep `whoami` /etc/passwd</code></pre>
<p>to see your home directory and some other things.</p>
<pre><code>allen:!:5037:1:P. Allan:/u/allen:/bin/csh</code></pre>
<p>The <code>grep</code> command is used to search for strings in text files.</p>
<p>The backticks `` cause execution of the command inside. The result, in this case &quot;allen&quot;, is substituted in the outer command, exactly as if the user had typed <code>grep allen /etc/passwd</code>.<br />
</p>
<p>The ! in the second field tells the computer that the encrypted password is held in another file.  This makes it a bit harder for dishonest people to get hold of your password.</p>
<h2>passwd</h2>
<p>This should be one of the first commands you use when given a new id.  It sets your password, and can do a few other things too.  You will be prompted for the old password (if any) and will be asked for the new password twice. (length = 8 characters)</p>
<p> EXAMPLE</p>
<pre><code>$ passwd
Changing password for &quot;allen&quot;
allen&#39;s Old password:
allen&#39;s New password:
Enter the new password again:
$</code></pre>
<p>There are restrictions on what you can choose, but they are in <em>/etc/security</em> and so not readable!</p>
<p>Good passwords are hard to guess, but also hard to remember.  It is best to use all 8 characters and include at least one of [a-z], [A-Z] and [0-9].  There are programs around that guess many passwords, so it is unwise to use any passwords based on names, real words, the user id, the hostname, or other guessable strings.</p>
<h2>exit</h2>
<p>This stops your session or just one window (if in a window). <code>exit</code> detects jobs that are paused (by <strong>Ctrl + z</strong> for instance) because they would die if you used <code>exit</code>.  Type <code>exit</code> a second time if you are happy with that. Running background jobs continue.</p>
<p>When using a graphical interface, a menu accessed with the mouse can be used to end your whole session. Window managers are not built into GNU/Linux, and vary greatly.</p>
<h2>ps</h2>
<p>Get a list of running processes. By default, <code>ps</code> lists only processes in the current shell. To get a list of all of your processes, use <code>ps -e</code>.<br />
</p>
<pre><code>$ ps
  PID TTY          TIME CMD
29477 pts/0    00:00:00 bash
29811 pts/0    00:00:00 ps</code></pre>
<h2>kill</h2>
<p>Terminate a running process without allowing it to complete. Particularly useful if a program has gotten into an infinite loop in which it does not receive or process keyboard input.</p>
<pre><code>$ kill 29477</code></pre>
<p>Kills the process with Process ID 29477. In the <code>ps</code> example above, this would be the current shell.<br />
</p>
<h2>chown</h2>
<p>Every file has an owner and a group, as you can see with the <code>ls</code> command. You should have a group named the same as your account. The Change Owner command, <code>chown</code>, lets you set these ownership attributes for files that you have the right to write.<br />
</p>
<p>You can give an entire group permission to read, write, or execute files with one command. If you want to keep files private, set the group to consist only of you, and use <code>chmod</code> (below) to restrict access by others. The following assumes that, when your user account was created, a group just for you with the same name was created. This is true on many modern systems, but not on all.<br />
</p>
<pre><code>$ chown user:user myfile</code></pre>
<p>If you have imported some directories that came in with the wrong ownership, you can change them all with one command. Just <code>cd</code> to the top directory, and execute this command, with the appropriate user and group names. The <code>-R</code> option tells <code>chown</code> to go through every subdirectory, and the * wildcard tells it to change ownership of every file and directory it finds there.<br />
</p>
<pre><code>$ chown -R user:group *</code></pre>
<h2>chmod</h2>
<p>Every file and directory has a &quot;filemode&quot; consisting of a list of attributes.</p>
<p>You can see this with <code>ls -l</code>.</p>
<pre><code>$ cd ; ls -la</code></pre>
<p>The &quot;;&quot; separates two commands on the same line.</p>
<p>That shows you the modes of the files in your home directory.</p>
<p>Included in the list should be two entries called &quot;.&quot; and &quot;..&quot;,  which refer to your current directory and its parent.</p>
<p>You will see a set of characters showing the file's permissions, followed by the owner (your ID, probably, for all except ..) and the group (perhaps &quot;staff&quot;), a file size, the time and date of the last change to the file, and the name. The listing will resemble the following:</p>
<pre><code>total 312
drwxr-x---  16 allen    staff       1024 Oct 21 14:07 .
drwxr-xr-x  21 sys      sys          512 Oct 13 16:25 ..
-rwxr-----   1 allen    staff        896 Oct 20 14:44 .cshrc
drwx------   2 allen    staff        512 Oct  6 08:51 .elm
-rw-r--r--   1 allen    staff         59 Oct 17 13:59 .exrc
-rwxr-----   1 allen    staff        461 Oct 17 12:18 .login
...</code></pre>
<p>A &quot;d&quot; in column 1 means the entry is a directory. A &quot;-&quot; means it is a file.</p>
<p>See the manual page for <code>ls</code>, under the <code>-l</code> option, for other possible file types.</p>
<p>There are 9 other characters in 3 sets of 3.</p>
<p>Columns 2-4  are for the file's OWNER.  (named later on the line, &quot;allen&quot; in this case)</p>
<p>Columns 5-7  are for the file's GROUP.  (named later on the line, &quot;staff&quot; in this case)</p>
<p>Columns 8-10 are for everyone else, except the superuser who always has all permissions.</p>
<ul>
<li>&quot;r&quot; grants read permission.</li>
<li>&quot;w&quot; grants write permission.</li>
<li>&quot;x&quot; grants execute permission. For a directory, this means search permission.</li>
<li>&quot;-&quot; denies the permission in that location.</li>
</ul>
<p>See <code>man ls</code> under the <code>-l</code> flag for other possible modes. Notice that write permission on a directory allows you to remove files from that directory <em>even if you do not own the files.</em></p>
<pre><code>chmod 640     file1   # sets file1 to -rw-r-----
chmod 755     file2   # sets file2 to -rwxr-xr-x
chmod go=     file3   # sets file3 to -???-------  (removes group &amp; other)
chmod -R go-w $HOME   # GOOD SAFE COMMAND: only you can write in your home dir</code></pre>
<h2>more, less, pg, cat</h2>
<p>These commands allow you to look at text files.<br />
</p>
<pre><code>$ more .bashrc
$ less /etc/motd
$ cat /etc/fstab</code></pre>
<p>The <code>more</code>, <code>less</code>, and <code>pg</code> commands allow you to page through a file and search for strings. The <code>less</code> command ironically has somewhat more options than more.</p>
<p>When in a <code>more</code>, <code>less</code>, or <code>pg</code> session type the <strong>h</strong> key to see what commands you can use.</p>
<p>The <code>cat</code> command displays the entire file, so it is good only for files that fit on one or two screens. The original purpose of <code>cat</code> (catenate) is to join text files together, but it is extremely useful for displaying short individual files.</p>
<pre><code>$ cat file1 file2 &gt; file3</code></pre>
<h2>grep</h2>
<p>Find and display lines in one or more files. The earliest version, grep, is named after a common command form in an early line editor, Global Regular Expression Print, which searched through an entire file for text patterns and displayed the matching lines. Regular expressions, described in another section of this manual, provide methods for specifying text patterns. Options permit searching groups of files, including all subdirectories of the starting point. One of the most common uses of grep is to find lines in configuration and log files specific to one user or one program.<br />
</p>
<pre><code>$ grep `whoami` /etc/passwd</code></pre>
<p>looks for the result of the <code>whoami</code> command in the password file, returning the user's account information, though with the password obscured.<br />
</p>
<h2>df</h2>
<p>Disk Free. Show sizes of storage media, space used, and space available. Shows sizes in blocks (a size that varies from one filesystem to another) by default, so use the <code>-h</code> option to get sizes in &quot;human-readable&quot; form: K for thousands of bytes, M for millions of bytes, and G for billions of bytes.</p>
<pre><code>$ df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda1             143G   41G   96G  30% /
tmpfs                 941M     0  941M   0% /lib/init/rw
varrun                941M  380K  941M   1% /var/run
varlock               941M     0  941M   0% /var/lock
udev                  941M  2.7M  939M   1% /dev
tmpfs                 941M  844K  940M   1% /dev/shm
lrm                   941M  2.4M  939M   1% /lib/modules/2.6.27-11-generic/volatile</code></pre>
<h2>echo</h2>
<p>Repeat after me, with substitutions if desired. Literal echoes are quite useful in scripts.</p>
<pre><code>$ echo &quot;Hello, world.&quot;
Hello, world.
$ echo $PATH
/home/myname/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</code></pre>
<h2>file</h2>
<p>This makes an attempt to recognize files, classifying them as English Text or executable or data.<br />
type</p>
<pre><code>$ file * | less</code></pre>
<p>to see some examples.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>XLF:</p></td>
<td><p>ascii text</p></td>
</tr>
<tr class="even">
<td><p>doc:</p></td>
<td><p>directory</p></td>
</tr>
<tr class="odd">
<td><p>handy:</p></td>
<td><p>directory</p></td>
</tr>
<tr class="even">
<td><p>groceries:</p></td>
<td><p>ascii text</p></td>
</tr>
<tr class="odd">
<td><p>.Xauthority:</p></td>
<td><p>data or International Language text</p></td>
</tr>
<tr class="even">
<td><p>.cshrc:</p></td>
<td><p>commands text</p></td>
</tr>
<tr class="odd">
<td><p>.exrc:</p></td>
<td><p>English text</p></td>
</tr>
</tbody>
</table>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h2>diff</h2>
<p>Differences between two text files. It also tells you whether two binary files differ.</p>
<pre><code>$ diff .profile~ .profile
 23a22
&gt; scim -d &amp;</code></pre>
<p>This says that line 23 was added (in this case, to support typing in multiple languages and character sets), and shows the new contents of the line.<br />
</p>
<h2>wc</h2>
<p>Word counts, plus line and character counts.</p>
<pre><code>$ wc .login
6       7     461 .login</code></pre>
<p>This <em>.login</em> file has 6 lines, 7 words, and 461 characters.</p>
<p>The program counts any string of printing characters between whitespace as a word, which can give strange results by human standards.<br />
</p>
<h2>find</h2>
<p>To list all files or directories named <em>core</em> under the current working directory:</p>
<pre><code>$ find . -name core -ls</code></pre>
<p>To remove all files named <em>core</em> under the current working directory (useful because programs create these files when they terminate through a programming error, but the files are of little value to you unless you possess and can read the source code):</p>
<pre><code>$ find . -name core -exec rm {} \;</code></pre>
<p>To list all files or directories named <em>&quot;something</em>.core&quot; under the current working directory:</p>
<pre><code>$ find . -name &#39;*.core&#39; -ls</code></pre>
<p>To name all directories called <em>man</em> under <em>/usr</em>:</p>
<pre><code>$ find /usr -name man -type d -print</code></pre>
<p>The next 2 examples are useful for removing temporary files you no longer want.</p>
<pre><code>$ find /tmp /var/tmp -mtime +3 -type f -user allen -exec rm {} \;
$ find /var/preserve -mtime +8 -type f -user allen -exec rm {} \;</code></pre>
<p>The next example names files and directories which <em>either</em> have changed in the last 2 days, <em>or</em> have execute permission for the owner.</p>
<pre><code>$ find . \( -mtime -2  -o -perm -100 \) -print</code></pre>
<p>Checking what has changed during the last few days is a great way to find out why your computer isn't working any more!<br />
</p>
<h2>ftp</h2>
<p>Upload and download files using File Transfer Protocol. Use:</p>
<pre><code>$ ftp hostname</code></pre>
<p>to connect to the ftp archive at <em>hostname</em>. The FTP protocol specifies how to log in, navigate directories on the archive, upload and download files or groups of files, and much more. This summary gives you enough commands to navigate an archive and to download files (and upload them, if you have permission).<br />
</p>
<p>When you connect to a repository, you will see a &gt; prompt where you can enter commands.</p>
<pre><code>&gt; binary</code></pre>
<p>Set to binary mode, which passes every byte of the file unchanged. This should be the first command you give, unless you are absolutely certain that you will download only text files.<br />
</p>
<pre><code>&gt; ascii</code></pre>
<p>Set to text mode, which converts line ends. This is the default when FTP starts. It is safe for text in ASCII, other 8-bit encodings, and Unicode UTF-8. <strong>Do not use for programs, images, music, and other binary files.</strong><br />
</p>
<pre><code>&gt; dir</code></pre>
<p>List files in the current directory on the remote host.</p>
<pre><code>&gt; cd directory-name</code></pre>
<p>Change directory.<br />
</p>
<pre><code>&gt; cdup</code></pre>
<p>Change to the parent directory of the current directory on the remote host.</p>
<pre><code>&gt; get remote-file [local-file]</code></pre>
<p> Download a file and optionally rename it.<br />
</p>
<pre><code>&gt; put local-file [remote-file]</code></pre>
<p>Upload a file and optionally rename it.<br />
</p>
<pre><code>&gt; bye</code></pre>
<p>End the <code>ftp</code> session.<br />
</p>
<h2>wget</h2>
<p>Download files from the Internet reliably, even over unreliable connections. If the connection goes down during a download, <code>wget</code> can resume from where it left off when the connection comes back up. </p>
<pre><code>$ wget URL</code></pre>
<p>will download the file at the URL to the current directory, using the same name. There are, as you would expect, numerous options.</p>
<h2>tar</h2>
<p>The Tape Archive utility creates a single tar file containing the contents of one or more files, or extracts files from a tar file. Although originally designed to produce combinations of files for backup to tape, it is still the standard utility for packing together files so you can move them around as a unit. As an option, the files can be compressed in a tgz file.<br />
</p>
<pre><code>$ tar -cf foo.tar foo/</code></pre>
<p>Store contents of folder <em>foo</em> in <em>foo.tar</em>. The <code>-c</code> option creates a tar file. The <code>-f</code> option says to use the filename given. Without <code>-f</code>, the result would go to standard output. You can use this form in a pipeline to use a different compression method, such as bzip2, described below.<br />
</p>
<pre><code>$ tar -cvfz foo.tgz foo/</code></pre>
<p>Store compressed contents of folder <em>foo</em> in <em>foo.tgz</em>, and give moderately verbose output on the console as each file is processed. More verbose output is available with the <code>vv</code> option.</p>
<pre><code>$ tar -xf foo.tar</code></pre>
<p>Extract <em>foo.tar</em> in the current directory.<br />
<br />
</p>
<pre><code>$ tar -xzf foo.tgz</code></pre>
<p>Extract gzipped <em>foo.tgz</em>. The tgz extension is an abbreviation of the formerly common .tar.gz, used when combining files and compressing the result required piping the output of tar to the input of gzip.<br />
</p>
<h2>gzip, gunzip, zcat, bzip2, bunzip2, bzcat</h2>
<p>The zip and bzip2 file compression algorithms are among the most popular of many ways to make files smaller (originally for transmission over slow modem connections), so that the inverse algorithms restore the full original files unchanged. Although the bzip2 method achieves better compression than zip, it also requires more processor time. For each one, we'll show a command for compression, decompression, and combining multiple files into one. The tar utility can use gzip compression.<br />
</p>
<pre><code>$ gzip file</code></pre>
<p>or</p>
<pre><code>$ bzip2 file </code></pre>
<p>compresses a file into an archive. The name of the archive file is the same as the original file, with the extension &quot;.gz&quot; or &quot;.bz2&quot; added. </p>
<pre><code>$ gunzip file.gz</code></pre>
<p>Decompress the <em>file.gz</em> archive to the original file.<br />
</p>
<p>The <code>gunzip</code> command is equivalent to <code>gzip -d</code>, where the <code>-d</code> option stands for &quot;decompress&quot;. Similarly, <code>bunzip2</code> is equivalent to <code>bzip2 -d</code>.</p>
<p>The <code>zcat</code> utility is equivalent to <code>gunzip  -c</code>, where the <code>-c</code> option says to write the uncompressed results into a single file. This is frequently useful when a directory contains a number of compressed text files. For example,</p>
<pre><code>$ zcat *.txt.gz </code></pre>
<p>Combining the output into one file makes it easier to search. You could pipe the output of this command to <code>grep</code>, for example. Similarly, <code>bzcat</code> is equivalent to <code>bzip2 -c</code>.</p>
<h2>Lynx</h2>
<p>The World-Wide Web is so widely used that some people think it is the entire Internet, but originally the Web was designed to use only text, and there are several text browsers for it still in use. Lynx (a pun on &quot;links&quot;) remains popular among those who spend more time at the command line or inside Emacs than in a GUI.</p>
<p>A text browser can simply ignore any material marked with HTML tags that refer to graphical content, or can display the ALT text that is often supplied with images, both for the sake of text browsers and for the blind and visually impaired.<br />
</p>
<pre><code>$ lynx url</code></pre>
<p>starts Lynx. If you specify a URL, Lynx will start with that page. Otherwise, it will go to its current default home page, which you can set to point wherever you like.</p>
<p>The following table gives you enough commands to use Lynx, but there are many more.</p>
<table>
<tbody>
<tr class="odd">
<td> ?</td>
<td> Help<br />
</td>
</tr>
<tr class="even">
<td> K</td>
<td> List commands<br />
</td>
</tr>
<tr class="odd">
<td>+</td>
<td> Scroll down one screen<br />
</td>
</tr>
<tr class="even">
<td> -</td>
<td> Scroll up one screen<br />
</td>
</tr>
<tr class="odd">
<td> ↓</td>
<td> Next link<br />
</td>
</tr>
<tr class="even">
<td> ↑</td>
<td> Previous link<br />
</td>
</tr>
<tr class="odd">
<td> Return or →<br />
</td>
<td> Follow link<br />
</td>
</tr>
<tr class="even">
<td> ←</td>
<td> Back</td>
</tr>
<tr class="odd">
<td> a</td>
<td> Add current link as bookmark<br />
</td>
</tr>
<tr class="even">
<td> d</td>
<td> Download current link to file<br />
</td>
</tr>
<tr class="odd">
<td> g</td>
<td> Go to URL<br />
</td>
</tr>
<tr class="even">
<td> o</td>
<td> Set options<br />
</td>
</tr>
<tr class="odd">
<td> p</td>
<td> Print</td>
</tr>
<tr class="even">
<td> s</td>
<td> Search</td>
</tr>
<tr class="odd">
<td> v</td>
<td> View bookmarks<br />
</td>
</tr>
<tr class="even">
<td> q</td>
<td> Quit Lynx.<br />
</td>
</tr>
</tbody>
</table>
<p><br />
</p>
<h2>Midnight Commander</h2>
<p>The Midnight Commander (mc) is based on concepts from the Norton Commander for PCDOS, which provides a two-pane file browser, and puts many DOS commands on function keys and menus. For GNU/Linux, of course, mc offers GNU/Linux commands in a text terminal window. The command to start it is, of course, <code>mc</code>.</p>
<pre><code>$ mc</code></pre>
<p>The screen shot below shows a typical display in Midnight Commnander. You will have a different directory structure and different files.</p>
<p><img src="static/IntroCommandLine-Midnight_Commander-mc-en.png" alt="Midnight Commander" width="600" height="450" /></p>
<p>You can navigate using either the mouse or the keyboard. <strong>Tab</strong> moves you to the other panel. The <strong>Insert</strong> key highlights files and directories for actions such as copy, rename, move, and delete, which you can see on the function key buttons, or for various commands on the pull-down menus.</p>
<p>The Left and Right menus let you change views to give different information, to enter a regular expression that determines which files to display, or to sort in a different order, among other things. You can invoke FTP from either of these menus, and use Midnight Commander's file commands to upload and download files. The File menu includes commands such as chmod and chown, with a visual dialog for selecting options and on-screen help, as shown in the screenshot below.</p>
<p><img src="static/IntroCommandLine-Midnight_Commander-chmod-en.png" title="chmod" alt="chmod" width="657" height="452" /></p>
<p> </p>
<p>The Commander provides hints, as in the screenshot above, to alert you to useful functions that you might not discover on your own. This one is particularly useful. Setting this configuration option lets you use the left and right arrow keys to navigate between directories, in the same way that Lynx lets you navigate URLs. There are a great many more configuration options available.<br />
</p>
<p>You can set and access bookmarks on a Directory Hotlist within your file system using the <strong>Ctrl + \</strong> key combination, or by selecting the list on the Commands menu. The dialog lets you create and navigate between named bookmark lists.</p>
<p>There is a great deal more to Midnight Commander, of course. You can learn about other functions in the Help dialog (<strong>F1</strong>).<br />
</p>
<h2>emacs, vi, nano, pico</h2>
<p>There is a wide choice of text editors to serve a variety of needs. One of the most venerable is Emacs (originally Editing Macros; jocularly Escape, Meta, Alt, Control, Shift, for its profusion of keyboard commands), written in LISP, with the ability to add commands in LISP, and to change any key bindings for commands. It includes the ability to run external commands, including mail and news (Usenet) readers and compilers, so some users do everything from emacs. Some prefer vi (visual editor), which has a similar ability to add commands and change key bindings, but does not replace the command line for its users. Others still, including most of those who do not program for a living, prefer simpler editors such as nano and pico.</p>
<p>In each case, one can invoke an editor and have it load up a file ready to edit in the form</p>
<pre><code>$ editor filename</code></pre>
<p>Consult specific program documentation for other command-line options and for editing commands and the rest. For example,<br />
</p>
<p><a href="http://www.gnu.org/software/emacs/" class="uri">http://www.gnu.org/software/emacs/</a> <br />
</p>
<p><a href="http://www.ccsf.edu/Pub/Fac/vi.html" class="uri">http://www.ccsf.edu/Pub/Fac/vi.html</a> </p>
<p><a href="http://www.nano-editor.org">http://www.nano-editor.org/</a> <br />
</p>
<p><a href="http://www.itd.umich.edu/itcsdocs/r1168/" class="uri">http://www.itd.umich.edu/itcsdocs/r1168/</a> <br />
</p>
<h2>pr</h2>
<p>This adds titles and page numbers to your text files.<br />
</p>
<pre><code>$ pr /etc/sendmail.cf | less  </code></pre>
<p>Keep pressing enter to watch the file go past slowly. You can also use <strong>Page Up</strong> and <strong>Page Down</strong> keys, and arrow keys.</p>
<h2>lpr</h2>
<p>prints a file. Useful for plain text, and can print some other formats (notably PostScript and PDF) if the system has printer drivers that understand those formats.</p>
<pre><code>$ lpr .profile</code></pre>
<h2>split<br />
</h2>
<p>Suppose you have a 600MB ISO file you'd like to split into several pieces for easier storage. You can do so with:</p>
<pre><code>$ split -b 200m image.iso image_iso_</code></pre>
<p>This example generates three files named <em>image.iso_aa</em>, <em>image.iso_ab</em>, and <em>image.iso_ac</em>, each 200MB in size. If you want to join them again, use the command:</p>
<pre><code>$ cat image.iso_* &gt; new-image.iso</code></pre>
<p>Remember, the more you practice, the easier and more efficient you can work. Experiment with these commands --the only way to get better at using them is practice!</p>
<p><span id="ch054_outline.xhtml"></span></p>
<h1><strong>Outline</strong></h1>
<p><em>Feel free to improvise over this outline by adding new sections, chapters etc</em><br />
</p>
<p>This book is an introduction to using the shell with a focus on empowering GNU/Linux newbies.  This page has an outline. The book itself is being written at:</p>
<p><a href="http://en.flossmanuals.net/bin/view/CommandLineIntro/WebHome" class="uri">http://en.flossmanuals.net/bin/view/CommandLineIntro/WebHome</a><br />
</p>
<p>It is meant to be fun and encourage the reader to play, so it is not organized in a formal manner (for instance, discussing all metacharacters in one place). Instead, features are introduced in the context of useful tasks. Rarely used features are not discussed.<br />
</p>
<p>The main topic is the GNU/Linux Bash shell, but useful features of the Korn shell and zsh may be introduced in advanced chapters. The C family of shells and non-Unix shells are beyond the scope of the book.<br />
</p>
<p>It assumes the reader is familiar with graphical interfaces, and refers to one or more free desktop environments where discussions of GUIs are necessary.<br />
</p>
<ol>
<li>
<p>Put yourself in command: why knowing the command line is useful</p>
</li>
<ol>
<li>
<p>Example: show a set of operations that require many menus and clicks to accomplish in a GUI (for instance, image manipulation) and then how to do the same things in a single command (for instance, using ImageMagick).</p>
</li>
<li>
<p>The value of scripting</p>
</li>
<li>
<p>Other places where command-line skills are useful</p>
</li>
<ol>
<li>Working over a network (when remote terminals or X redirection are unavailable or too slow)<br />
</li>
<li>At jobs and cron jobs</li>
<li>Invoking commands through GUI launchers</li>
<li>Seeing what's going on (ps output, other system trouble-shooting)</li>
</ol>
</ol>
</ol>
<blockquote>

</blockquote>
<ol>
<li>
<p>Getting started</p>
</li>
<ol>
<li>
<p>What do we mean by a &quot;command&quot;? </p>
</li>
<li>
<p>What ways can you enter commands?</p>
</li>
<ol>
<li>Opening a terminal window</li>
<li>Alternative ways to run a command on various popular desktops</li>
</ol>
<li>
<p>Different shells</p>
</li>
<ol>
<li>This book focuses on Bash</li>
<li>We tell you what's non-portable (doesn't work with older shells)<br />
</li>
</ol>
<li>
<p>Privileged (superuser) commands</p>
</li>
</ol>
</ol>
<blockquote>
<blockquote>
<ol>
<li>sudo</li>
<li>su<br />
</li>
</ol>
</blockquote>
</blockquote>
<ol>
<li>Beginning syntax: command-line options</li>
</ol>
<blockquote>
<ol>
<li>
<p>Moving around directories</p>
</li>
<ol>
<dl>
<dd>
<dl>
<dt>
<li>
<p>Pathnames</p>
<dd>
<p>simple, absolute, and relative</p>
</dd>
</li>
<li>
<p>The . and .. directories</p>
</li>
<li>
<p>cd, pushd, etc.<br />
</p>
</li>
</dt>
</dl>
</dd>
</dl>
</ol>
<li>
<p>Pathnames (syntax) </p>
</li>
<li>
<p>Using the history (through the readline facility)</p>
</li>
<ol>
<li>Emacs mode</li>
<li>vi mode</li>
</ol>
<li>
<p>A few useful bits of syntax</p>
</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>Enclosing strings in quotation marks</li>
<li>Escaping special characters through quotation marks and backslashes </li>
<li>Continuing a command over multiple lines</li>
<li>White space as separators (any amount is treated the same)<br />
</li>
</ol>
</blockquote>
</blockquote>
<ol>
<li>Basic commands</li>
</ol>
<blockquote>
<ol>
<li>Commands people use every day</li>
</ol>
<ol>
<li>pwd</li>
<li>ls -al<br />
</li>
<li>cd</li>
<li>chown</li>
<li>chmod</li>
<li>more, less</li>
<li>mv</li>
<li>cp</li>
<li>rm<br />
</li>
<li>wc</li>
<li>diff</li>
<li>gzip, gunzip, gzcat</li>
<li>rm, rmdir</li>
<li>mkdir</li>
<li>find</li>
<li>grep</li>
<li>passwd</li>
<li>kill</li>
<li>telnet, ssh</li>
<li>ftp</li>
<li>apt-get, yum</li>
<li>echo</li>
<li>setenv, unset</li>
<li>du -h</li>
<li>lynx</li>
<li>ln<br />
</li>
</ol>
<ol>
<li>
<p>Permissions</p>
</li>
<ol>
<li>
<p>Viewing through ls</p>
</li>
<li>
<p>Setting through chmod</p>
</li>
<ol>
<li>+x syntax</li>
<li>777 octal syntax (a figure is useful to show bits<br />
</li>
</ol>
</ol>
<li>
<p>Manipulating processes</p>
</li>
<ol>
<li>Interrupting (CTRL-C)</li>
<li>ps and kill</li>
<li>Processes and jobs (background)<br />
</li>
</ol>
<li>
<p>Redirection</p>
</li>
<ol>
<li>Using &lt; and &gt; and variations</li>
<li>File descriptors (standard input, output, and error)<br />
</li>
</ol>
</ol>
</blockquote>
<ol>
<li>Cheaper by the dozen: operating on lots of files in a single command<br />
</li>
</ol>
<blockquote>
<ol>
<li>Globbing</li>
<li>The find command </li>
<li>The &quot;for&quot; control construct<br />
</li>
</ol>
</blockquote>
<ol>
<li>
<p>All that typing is too much work</p>
</li>
<ol>
<li>Command and filename completion </li>
<li>Using the history, part 2 (through the ! and ^ facilities) </li>
<li>Aliases</li>
<li>Functions</li>
</ol>
</ol>
<blockquote>

</blockquote>
<ol>
<li>
<p>More command-line mastery</p>
</li>
<ol>
<li>
<p>Piping commands </p>
</li>
<li>
<p>Taking advantage of the exit status<br />
</p>
</li>
<ol>
<li>The if/then construct</li>
<li>The &amp;&amp; and || constructs<br />
</li>
</ol>
<li>
<p>Subcommands</p>
</li>
<ol>
<li>The $(command) syntax</li>
<li>The `` backtick syntax</li>
</ol>
<li>
<p>Parameter substitution</p>
</li>
<li>
<p>Multiple and remote sessions<br />
</p>
</li>
<ol>
<li>GNU Screen</li>
<li>SSH</li>
<li>Virtual terminals (GNU/Linux)<br />
</li>
</ol>
</ol>
<li>
<p>Useful customizations<br />
</p>
</li>
<ol>
<li>
<p>Variables<br />
</p>
</li>
<ol>
<li>Syntax</li>
<li> Environment variables</li>
</ol>
<li>
<p>The search path</p>
</li>
<ol>
<li>Finding a command (which)</li>
<li>Multiple locations for commands, and using symbolic links<br />
</li>
</ol>
<li>
<p>Setting prompts</p>
</li>
<li>
<p>Localization</p>
</li>
<ol>
<li>How the computer generally chooses locale</li>
<li>How to explicitly control locale</li>
<li>Effects of locale on Bash</li>
<li>Effects of locale on common programs and operations<br />
</li>
</ol>
</ol>
</ol>
<ol>
<li>Before scripting: learning a text editor (keep it short; use screenshots)<br />
</li>
</ol>
<blockquote>
<ol>
<li>gedit</li>
<li>Kedit<br />
</li>
<li>nano<br />
</li>
<li>vi </li>
<li>Emacs<br />
</li>
<li>Saving useful changes: .bashrc and other startup/shutdown files </li>
<li>The value of portability (lowest common denominator commands)<br />
</li>
</ol>
</blockquote>
<ol>
<li>Scripting (mostly an example-based or recipe-based chapter, because all the important constructs have been introduced)</li>
</ol>
<blockquote>
<ol>
<li>
<p>Making scripts executable</p>
</li>
<li>
<p>More control constructs (while, until, case, etc.) </p>
</li>
<li>
<p>Argument lists<br />
</p>
</li>
<li>
<p>How to keep the script maintainable<br />
</p>
</li>
<ol>
<li>Use variables<br />
</li>
<li>Know where you begin (which directory, whether you're superuser) </li>
<li>Look before you leap (does a file you want to read exist, etc.) </li>
<li>Check error status </li>
<li>Error messages<br />
</li>
</ol>
<li>
<p>Here documents (the &lt;&lt; syntax)<br />
</p>
</li>
<li>
<p>Sourcing other files</p>
</li>
<li>
<p>Restricting access<br />
</p>
</li>
</ol>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>Using permissions</li>
<li>The suid bit<br />
</li>
</ol>
</blockquote>
</blockquote>
<ol>
<li>Other scripting languages</li>
</ol>
<ol>
<li>Why use something else besides a shell</li>
<li>Python</li>
<li>Ruby </li>
<li>Perl </li>
<li>Awk</li>
</ol>
<p><span id="ch055_credits.xhtml"></span></p>
<h1>License</h1>
<p>All chapters copyright of the authors (see below). Unless otherwise stated all chapters in this manual licensed with the <strong>Free Documentation License.</strong></p>
<p>This documentation is free documentation; you can redistribute it and/or modify it under the terms of the GNU Free Documentation License as published by the Free Software Foundation; either version 1.3 of the License, or (at your option) any later version.</p>
<p>This documentation is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Free Documentation License for more details.</p>
<p>You should have received a copy of the GNU Free Documentation License along with this documentation; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
<h2>Authors</h2>
<p>Some material taken from the great manual by Gareth Anderson :</p>
<p><a href="http://tldp.org/LDP/GNU-Linux-Tools-Summary/html/" class="uri">http://tldp.org/LDP/GNU-Linux-Tools-Summary/html/</a></p>
<p>and from :</p>
<p><a href="http://www.gnu.org/software/bash/manual/bashref.html" class="uri">http://www.gnu.org/software/bash/manual/bashref.html</a></p>
<p><em>ABOUT THIS MANUAL</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009, 2010<br />
Carolyn Anhalt 2009<br />
Daniele de Rigo 2010<br />
Peter Brown 2009<br />
Scott Walck 2009<br />
Tom Boyle 2009<br />
Viktor Becher 2009<br />
William Abernathy 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>AWK</em><br />
© Viktor Becher 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
David Fernández Piñas 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
Vitor Baptista 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>BASIC COMMANDS</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Ben Woodacre 2009<br />
Daniele de Rigo 2009<br />
Dennis Kibbe 2009<br />
edoardo batini 2009<br />
Freaky Clown 2009<br />
Marc Mengel 2009<br />
Marcelo Magallon 2009<br />
Max Newell 2009<br />
Peter Davies 2009<br />
Sameer Thahir 2009<br />
Steffen Schaumburg 2009<br />
sylvain charzat 2009<br />
TWikiGuest 2010<br />
Tadeus Prastowo 2009<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>BEGINNING SYNTAX</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Aputsiaq Niels Janussen 2009<br />
Ben Weissmann 2009<br />
Colin Williams 2009<br />
Daniele de Rigo 2009<br />
Edward Cherlin 2009<br />
Jason Woof 2009<br />
Johannes Becher 2009<br />
Leif Biberg Kristensen 2009<br />
Marc Mengel 2009<br />
Marcelo Magallon 2009<br />
Peter Davies 2009<br />
Tom Boyle 2009<br />
Viktor Becher 2009<br />
William McConnaughey 2009<br />
William Merriam 2009<br />
</p>
<hr />
<p><em>CHECKING EXIT</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Daniele de Rigo 2009<br />
Edward Cherlin 2009<br />
Jason Woof 2009<br />
TWikiGuest 2010<br />
Tim Goh 2009<br />
Tom Boyle 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>COMMAND HISTORY</em><br />
© Gareth Anderson 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Federico Lucifredi 2009<br />
Freaky Clown 2009<br />
hari raj k 2009<br />
Steffen Schaumburg 2009<br />
TWikiGuest 2010<br />
Tim Goh 2009<br />
Tom Boyle 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>INTERACTIVE EDITING</em><br />
© Viktor Becher 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Dennis Kibbe 2009<br />
Siddharth Ravikumar 2010<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>COMMAND QUICKIE</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
John Sullivan 2009<br />
S. Lockwood-Childs 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>MAKING YOUR OWN INTERPRETER</em><br />
© William McConnaughey 2009</p>
<hr />
<p><em>CREDITS</em><br />
© adam hyde 2006, 2007, 2009</p>
<hr />
<p><em>CUSTOMISATION</em><br />
© Steve Revilak 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
John Sullivan 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
Vitor Baptista 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>CUT DOWN ON TYPING</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Dennis Kibbe 2009<br />
hari raj k 2009<br />
Luigi Bai 2009<br />
Pierre Fortin 2009<br />
sylvain charzat 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>MOVING AGAIN</em><br />
© Andy Oram 2009<br />
Modifications:<br />
adam hyde 2009<br />
Freaky Clown 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>EMACS</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Edward Cherlin 2009<br />
John Sullivan 2009<br />
Matt Lee 2009<br />
Scott Walck 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
Viktor Becher 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>FILE STRUCTURE</em><br />
© adam hyde 2009<br />
Modifications:<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
Jason Woof 2009<br />
John Sullivan 2009<br />
Julian Oliver 2009<br />
Marcelo Magallon 2009<br />
Peter Davies 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>GNUSCREEN</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Daniele de Rigo 2009<br />
Darren Hall 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
Michael Dorrington 2010<br />
Ntino Krampis 2009<br />
S. Lockwood-Childs 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>GEDIT</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Edward Cherlin 2009<br />
John Sullivan 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>GETTING STARTED</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Barbaros Catkan 2009<br />
Daniele de Rigo 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
John Sullivan 2009<br />
Matt Lee 2009<br />
S. Lockwood-Childs 2009<br />
Tom Boyle 2009<br />
Viktor Becher 2009<br />
William McConnaughey 2009<br />
</p>
<hr />
<p><em>GLOSSARY</em><br />
© Dave Pawson 2009<br />
Modifications:<br />
adam hyde 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
John Sullivan 2009<br />
Michel Barakat 2009<br />
Tom Boyle 2009<br />
Vitor Baptista 2009<br />
</p>
<hr />
<p><em>INSTALLING SOFTWARE</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Jarkko Oranen 2009<br />
John Sullivan 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>INTRODUCTION</em><br />
© Free Software Foundation 2006<br />
Modifications:<br />
adam hyde 2006, 2007, 2009<br />
Andy Oram 2009<br />
Ben Weissmann 2009<br />
Freaky Clown 2009<br />
Michel Barakat 2009<br />
Peter Davies 2009<br />
S. Lockwood-Childs 2009<br />
Scott Walck 2009<br />
Sreeraj Nair 2009<br />
sylvain charzat 2009<br />
Tom Boyle 2009<br />
Viktor Becher 2009<br />
William Abernathy 2009<br />
William Merriam 2009<br />
</p>
<hr />
<p><em>KEDIT</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Edward Cherlin 2009<br />
Matt Lee 2009<br />
Tom Boyle 2009<br />
Vance Kochenderfer 2009<br />
</p>
<hr />
<p><em>MAINTAINING SCRIPTS</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
Marcelo Magallon 2009<br />
Michael Gauland 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
Vitor Baptista 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>MOVING AROUND</em><br />
© Free Software Founation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
Peter Davies 2009<br />
Steffen Schaumburg 2009<br />
TWikiGuest 2010<br />
Tadeus Prastowo 2009<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>MULTIPLE FILES</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Bernie Innoccenti 2009<br />
Darren Hall 2009<br />
Edward Cherlin 2009<br />
Eric Bavier 2010<br />
hari raj k 2009<br />
Kent Tenney 2009<br />
Luigi Bai 2009<br />
Marcelo Magallon 2009<br />
Peter Davies 2009<br />
Steffen Schaumburg 2009<br />
Tadeus Prastowo 2009<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
</p>
<hr />
<p><em>NANO</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Scott Wells 2009<br />
sylvain charzat 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>OTHER LANGUAGES</em><br />
© Andy Oram 2009<br />
Modifications:<br />
adam hyde 2009<br />
Edward Cherlin 2009<br />
John Sullivan 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>OUTLINE</em><br />
© Andy Oram 2009<br />
Modifications:<br />
adam hyde 2009<br />
Edward Cherlin 2009<br />
TWikiGuest 2010<br />
douglas 2010<br />
</p>
<hr />
<p><em>PARAMETER SUBSTITUTION</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009, 2010<br />
Andy Oram 2009<br />
Darren Hall 2009<br />
Freaky Clown 2009<br />
Jason Woof 2009<br />
Michael Gauland 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
Viktor Becher 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>PERL</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Darren Hall 2009<br />
Edward Cherlin 2009<br />
Stephen Compall 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>PERMISSIONS</em><br />
© Andy Oram 2009<br />
Modifications:<br />
adam hyde 2009<br />
Daniel Kahn Gillmor 2009<br />
Freaky Clown 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>PIPING</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Leif Biberg Kristensen 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
Vance Kochenderfer 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>PROCESSES</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
Edward Cherlin 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>PYTHON</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Austin Martin 2009<br />
Freaky Clown 2009<br />
Scott Walck 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>REDIRECTION</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
Andreas Jonsson 2009<br />
Daniele de Rigo 2009<br />
Edward Cherlin 2009<br />
TWikiGuest 2010<br />
Tadeus Prastowo 2009<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>REGULAR EXPRESSIONS</em><br />
© Andy Oram 2009<br />
Modifications:<br />
adam hyde 2009<br />
Darren Hall 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>RUBY</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Ben Weissmann 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
Vitor Baptista 2009<br />
Xie Haichao 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>SED</em><br />
© Freaky Clown 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Darren Hall 2009<br />
Edward Cherlin 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>SSH</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Daniele de Rigo 2009<br />
Freaky Clown 2009<br />
Scott Walck 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>SCRIPTING</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Beth Skwarecki 2009<br />
edoardo batini 2009<br />
Max Newell 2009<br />
Ole Tange 2010<br />
TWikiGuest 2010<br />
Tom Boyle 2009, 2010<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>SEARCHING FOR FILES</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
Luigi Bai 2009<br />
Tom Boyle 2009<br />
</p>
<hr />
<p><em>STANDARD FILES</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Dev Devarajan 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
Marc Mengel 2009<br />
Michael Gauland 2009<br />
Michel Barakat 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
Viktor Becher 2009<br />
Vitor Baptista 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>SUB COMMANDS</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
Freaky Clown 2009<br />
John Sullivan 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>SUPERUSERS</em><br />
© Andy Oram 2009<br />
Modifications:<br />
adam hyde 2009<br />
Edward Cherlin 2009<br />
John Sullivan 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
William McConnaughey 2009<br />
douglas 2010<br />
</p>
<hr />
<p><em>TEXT EDITORS</em><br />
© Free Software Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Edward Cherlin 2009<br />
John Sullivan 2009<br />
mike mcneely 2009<br />
Renato Golin 2009<br />
Tom Boyle 2009<br />
</p>
<hr />
<p><em>VIM</em><br />
© Free SOftware Foundation 2009<br />
Modifications:<br />
adam hyde 2009<br />
Andy Oram 2009<br />
Freaky Clown 2009<br />
John Sullivan 2009<br />
Julian Oliver 2009<br />
TWikiGuest 2010<br />
Tom Boyle 2009<br />
douglas 2010<br />
</p>
<hr />
<p> </p>
<p><a href="http://www.flossmanuals.net/"><img src="static/Floss-100-en.gif" alt="100.gif" width="110" height="54" /></a><br />
<strong></strong></p>
<p><sub>Free manuals for free software</sub></p>
<p> </p>
<p> </p>
<p><br />
</p>
<pre><code>                GNU Free Documentation License
                 Version 1.3, 3 November 2008


 Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

0. PREAMBLE

The purpose of this License is to make a manual, textbook, or other
functional and useful document &quot;free&quot; in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.

This License is a kind of &quot;copyleft&quot;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.


1. APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &quot;Document&quot;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &quot;you&quot;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.

A &quot;Modified Version&quot; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A &quot;Secondary Section&quot; is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document&#39;s overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

The &quot;Invariant Sections&quot; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.

The &quot;Cover Texts&quot; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.

A &quot;Transparent&quot; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &quot;Transparent&quot; is called &quot;Opaque&quot;.

Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML, PostScript or PDF designed for human modification.  Examples of
transparent image formats include PNG, XCF and JPG.  Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML, PostScript or PDF produced by some word
processors for output purposes only.

The &quot;Title Page&quot; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &quot;Title Page&quot; means
the text near the most prominent appearance of the work&#39;s title,
preceding the beginning of the body of the text.

The &quot;publisher&quot; means any person or entity that distributes copies of
the Document to the public.

A section &quot;Entitled XYZ&quot; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &quot;Acknowledgements&quot;,
&quot;Dedications&quot;, &quot;Endorsements&quot;, or &quot;History&quot;.)  To &quot;Preserve the Title&quot;
of such a section when you modify the Document means that it remains a
section &quot;Entitled XYZ&quot; according to this definition.

The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.

2. VERBATIM COPYING

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no
other conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.


3. COPYING IN QUANTITY

If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document&#39;s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to
give them a chance to provide you with an updated version of the
Document.


4. MODIFICATIONS

You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

A. Use in the Title Page (and on the covers, if any) a title distinct
   from that of the Document, and from those of previous versions
   (which should, if there were any, be listed in the History section
   of the Document).  You may use the same title as a previous version
   if the original publisher of that version gives permission.
B. List on the Title Page, as authors, one or more persons or entities
   responsible for authorship of the modifications in the Modified
   Version, together with at least five of the principal authors of the
   Document (all of its principal authors, if it has fewer than five),
   unless they release you from this requirement.
C. State on the Title page the name of the publisher of the
   Modified Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modifications
   adjacent to the other copyright notices.
F. Include, immediately after the copyright notices, a license notice
   giving the public permission to use the Modified Version under the
   terms of this License, in the form shown in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections
   and required Cover Texts given in the Document&#39;s license notice.
H. Include an unaltered copy of this License.
I. Preserve the section Entitled &quot;History&quot;, Preserve its Title, and add
   to it an item stating at least the title, year, new authors, and
   publisher of the Modified Version as given on the Title Page.  If
   there is no section Entitled &quot;History&quot; in the Document, create one
   stating the title, year, authors, and publisher of the Document as
   given on its Title Page, then add an item describing the Modified
   Version as stated in the previous sentence.
J. Preserve the network location, if any, given in the Document for
   public access to a Transparent copy of the Document, and likewise
   the network locations given in the Document for previous versions
   it was based on.  These may be placed in the &quot;History&quot; section.
   You may omit a network location for a work that was published at
   least four years before the Document itself, or if the original
   publisher of the version it refers to gives permission.
K. For any section Entitled &quot;Acknowledgements&quot; or &quot;Dedications&quot;,
   Preserve the Title of the section, and preserve in the section all
   the substance and tone of each of the contributor acknowledgements
   and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document,
   unaltered in their text and in their titles.  Section numbers
   or the equivalent are not considered part of the section titles.
M. Delete any section Entitled &quot;Endorsements&quot;.  Such a section
   may not be included in the Modified Version.
N. Do not retitle any existing section to be Entitled &quot;Endorsements&quot;
   or to conflict in title with any Invariant Section.
O. Preserve any Warranty Disclaimers.

If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version&#39;s license notice.
These titles must be distinct from any other section titles.

You may add a section Entitled &quot;Endorsements&quot;, provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.


5. COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled &quot;History&quot;
in the various original documents, forming one section Entitled
&quot;History&quot;; likewise combine any sections Entitled &quot;Acknowledgements&quot;,
and any sections Entitled &quot;Dedications&quot;.  You must delete all sections
Entitled &quot;Endorsements&quot;.


6. COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other
documents released under this License, and replace the individual
copies of this License in the various documents with a single copy
that is included in the collection, provided that you follow the rules
of this License for verbatim copying of each of the documents in all
other respects.

You may extract a single document from such a collection, and
distribute it individually under this License, provided you insert a
copy of this License into the extracted document, and follow this
License in all other respects regarding verbatim copying of that
document.


7. AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &quot;aggregate&quot; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation&#39;s users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document&#39;s Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.


8. TRANSLATION

Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.

If a section in the Document is Entitled &quot;Acknowledgements&quot;,
&quot;Dedications&quot;, or &quot;History&quot;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.


9. TERMINATION

You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.

However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.


10. FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions of the
GNU Free Documentation License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in
detail to address new problems or concerns.  See
http://www.gnu.org/copyleft/.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License &quot;or any later version&quot; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy&#39;s public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.

11. RELICENSING

&quot;Massive Multiauthor Collaboration Site&quot; (or &quot;MMC Site&quot;) means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
&quot;Massive Multiauthor Collaboration&quot; (or &quot;MMC&quot;) contained in the site
means any set of copyrightable works thus published on the MMC site.

&quot;CC-BY-SA&quot; means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.

&quot;Incorporate&quot; means to publish or republish a Document, in whole or in
part, as part of another Document.

An MMC is &quot;eligible for relicensing&quot; if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole or
in part into the MMC, (1) had no cover texts or invariant sections, and
(2) were thus incorporated prior to November 1, 2008.

The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.


ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

    Copyright (c)  YEAR  YOUR NAME.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled &quot;GNU
    Free Documentation License&quot;.

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &quot;with...Texts.&quot; line with this:

    with the Invariant Sections being LIST THEIR TITLES, with the
    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.

If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.</code></pre>
</body>
</html>
