<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="The Contributors" />
  <title>CSOUND</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">CSOUND</h1>
<p class="author">The Contributors</p>
<p class="date">2012.04.25-23.54</p>
</header>
<p><span id="ch001_introduction.xhtml"></span></p>
<h1>PREFACE</h1>
<p><img src="static/montage3.jpg" /></p>
<p>Csound is one of the best known and longest established programs in the field of audio-programming. It was developed in the mid-1980s at the Massachusetts Institute of Technology (MIT) by Barry Vercoe.</p>
<p>Csound's history lies deep in the roots of computer music. It is a direct descendant of the oldest computer-program for sound synthesis, 'MusicN' by Max Mathews. Csound is free, distributed under the LGPL licence and is tended and expanded by a core of developers with support from a wider community.</p>
<p>Csound has been growing for more than 25 years. There are few things related to audio that you cannot do with Csound. You can work by rendering offline, or in real-time by processing live audio and synthesizing sound on the fly. You can control Csound via MIDI, OSC, or via the Csound API (Application Programming Interface). In Csound, you will find the widest collection of tools for sound synthesis and sound modification, including special filters and tools for spectral processing.</p>
<p>Is Csound difficult to learn? Generally, graphical audio programming languages like Pure Data (more commonly known as Pd - see the Pure Data FLOSS Manual for further information), Max or Reaktor are easier to learn than text-coded audio programming languages like Csound, SuperCollider or ChucK. You cannot make a typo which produces an error which you do not understand. You program without being aware that you are programming. It feels like patching together different units in a studio. This is a fantastic approach. But when you deal with more complex projects, a text-based programming language is often easier to use and debug, and many people prefer to program by typing words and sentences rather than by wiring symbols together using the mouse.</p>
<p>Thanks to the work of Victor Lazzarini and Davis Pyon, it is also very easy to use Csound as a kind of audio engine inside Pd or Max. See the chapter Csound in other applications and the information on <a href="http://en.flossmanuals.net/csound/ch052_csound-in-pd">CSound with Pd</a> and <a href="http://en.flossmanuals.net/csound/ch053_csound-in-maxmsp">CSound in MaxMSP</a> for further information.<br />
</p>
<p>Amongst text-based audio programming languages, Csound is arguably the simplest. You do not need to know anything about objects or functions. The basics of the Csound language are a straightforward transfer of the signal flow paradigm to text.</p>
<p>For example, to create a 400 Hz sine oscillator with an amplitude of 0.2, this is the signal flow:</p>
<p><img src="static/IntroFlowchart.png" width="240" height="214" /> </p>
<p>  This is a possible transformation of the signal graph into Csound code:</p>
<pre><code>    instr Sine
aSig      oscils    0.2, 400, 0
          out       aSig
    endin</code></pre>
<p>The oscillator is represented by the opcode <em>oscils</em> and gets its input arguments amplitude (0.2), frequency (400) and phase (0) righthand. It produces an audio signal called <em>aSig</em> at the left side, which is in turn the input of the second opcode <em>out</em>. The first and last lines encase these connections inside an instrument called <em>Sine</em>. That's it.<br />
</p>
<p>But it is often difficult to find up to date resources that explain all of the things that are possible with Csound. Documentation and tutorials produced by many experienced users tend to be scattered across many different locations. This was one of the main motivations in producing this manual: to facilitate a flow between the knowledge of contemporary Csound users and those wishing to learn more about Csound.</p>
<p>Ten years after the milestone of Richard Boulanger's <a href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid=3349">Csound Book</a> the Csound FLOSS Manual is intended to offer an easy-to-understand introduction and to provide a centre of up to date information about the many features of Csound - not as detailed and in depth as the Csound Book, but including new information and sharing this knowledge with the wider Csound community.</p>
<p>Throughout this manual we will attempt a difficult balancing act: we want to provide users with nearly everything important there is to know about Csound, but we also want to keep things simple and concise to save you from drowning under the multitude of things that we could say about Csound. Frequently this manual will link to other more detailed resources like the <a href="http://csounds.com/manual/html/index">Canonical Csound Reference Manual</a>, the primary documentation provided by the Csound developers and associated community over the years, and the <a href="http://www.csounds.com/journal/articleIndex.html">Csound Journal</a> (edited by Steven Yi and James Hearon), a quarterly online publication with many great Csound-related articles.</p>
<p>Good luck and happy Csounding!</p>
<p><span id="ch002_how-to-use-this-manual.xhtml"></span></p>
<h1>HOW TO USE THIS MANUAL</h1>
<p>The goal of this manual is to provide a readable introduction to Csound. In no way is it meant as a replacement for the <a href="http://www.csounds.com/manual/html/index.html">Canonical Csound Reference Manual</a>. It is intended as an introduction-tutorial-reference hybrid, gathering the most important information you need for working with Csound in a variety of situations. In many places, links are provided to other resources, such as <a href="http://www.csounds.com/manual/html/index.html">the official manual</a>, the <a href="http://www.csounds.com/journal/articleIndex.html">Csound Journal</a>, example collections, and more.</p>
<p>It is not necessary to read each chapter in sequence, feel free to jump to any chapter that interests you, although bear in mind that occasionally a chapter will make reference to a previous one.</p>
<p>If you are new to Csound, the QUICK START chapter will be the best place to go to get started. BASICS provides a general introduction to key concepts about digital sound vital to understanding how Csound deals with audio. The CSOUND LANGUAGE chapter provides greater detail about how Csound works and how to work with Csound.</p>
<p>SOUND SYNTHESIS introduces various methods of creating sound from scratch and SOUND MODIFICATION describes various methods of transforming sounds that already exist within Csound. SAMPLES outlines ways in which to record and play audio samples in Csound, an area that might be of particular interest to those intent on using Csound as a real-time performance instrument. The MIDI and OPEN SOUND CONTROL  chapters focus on different methods of controlling Csound using external software or hardware. The final chapters introduce various front-ends that can be used to interface with the Csound engine and Csound's communication with other applications.</p>
<p>If you would like to know more about a topic, and in particular about the use of any opcode, refer first to the <a href="http://www.csounds.com/manual/html/index.html">Canonical Csound Reference Manual</a>.</p>
<p>All files - examples and audio files - can be downloaded at <a href="http://www.csound-tutorial.net">www.csound-tutorial.net</a> . If you use CsoundQt, you can find all the examples in CsoundQt's examples menu under &quot;Floss Manual Examples&quot;.</p>
<p>Like other Audio Tools, Csound can produce extreme dynamic range. Be careful when you run the examples! Start with a low volume setting on your amplifier and take special care when using headphones.</p>
<p>You can help to improve this manual, either in reporting bugs or requests, or in joining as a writer. Just contact one of the maintainers (see the list in ON THIS RELEASE).</p>
<p>Thanks to Alex Hofmann, this manual can be ordered as a print-on-demand at <a href="how-to-use-this-manual/www.lulu.com">www.lulu.com</a>. Just use the search utility there and look for &quot;Csound&quot;. Just the links will not work ...<br />
</p>
<p><span id="ch003_on-this-release.xhtml"></span></p>
<h1>ON THIS RELEASE</h1>
<p>We are happy to announce the second release of the Csound Floss Manual. It has been an exciting year for Csound, with many activities and important developments. Thanks to the long and hard work of Steven Yi, John ffitch, Tito Latini and others, a new parser has been written. This opens up many new possibilities for future language adaptations and more flexibility within the Csound syntax. In autumn 2011, the first international <a href="http://www.incontri.hmtm-hannover.de/de/elektronisches-studio/csound-conference/">Csound Conference</a> took place at HMTM Hannover, with many inspiring workshops, concerts, papers and most notably discussions between developers and users. In early 2012, Jim Aikin's <a href="http://www.amazon.com/Csound-Power-Jim-Aikin/dp/1435460049"><em>Csound Power!</em></a> was published and it represents a very well written introduction to Csound. In early spring, Victor Lazzarini and Steven Yi published the first release of Csound on Android devices, and all developers are currently pushing towards Csound6.<br />
</p>
<p>The first edition of the Csound Floss Manual has been a huge success. We are proud and glad to see it used, linked and quoted in many places. It has come to be regarded as a complement to the Csound Manual. We hope we can continue to reflect Csound's development in this manual. The core writers of the Csound Floss manual would like to extend their thanks to Richard Boulanger, John Clements and others for their support, and to all the writers for their various contributions. Thanks also are due to Adam Hyde and the team at flossmanuals.net for maintaining and developing this important platform for free libre open source software.<br />
</p>
<h3>What's new in this Release</h3>
<ul>
<li>
<p>New chapters:</p>
</li>
<ul>
<li>MACROS (Csound Language)<br />
</li>
<li>CABBAGE (Csound Frontends)</li>
<li>BUILDING CSOUND (Appendix) </li>
<li>METHODS OF WRITING CSOUND SCORES (Appendix)<br />
</li>
</ul>
<li>
<p>Chapters now completed:</p>
</li>
<ul>
<li>WAVESHAPING (Sound Synthesis)<br />
</li>
<li>PHYSICAL MODELLING (Sound Synthesis)</li>
<li>CONVOLUTION (Sound Modification)</li>
<li>CSOUND VIA TERMINAL (Csound Frontends)</li>
<li>CSOUND UTILITIES<br />
</li>
</ul>
<li>
<p>Significant amendments and additions to the following chapters:</p>
</li>
<ul>
<li>AM / RM / WAVESHAPING (Sound Modification)</li>
<li>GRANULAR SYNTHESIS (Sound Modification)</li>
<li>CSOUND IN PD (Csound in Other Applications)</li>
<li>LINKS (Appendix)<br />
</li>
</ul>
<li>
<p>New chapters as drafts:</p>
</li>
<ul>
<li>CSOUND IN ABLETON LIVE (Csound in Other Applications)</li>
<li>CSOUND AS A VST PLUGIN (Csound in Other Applications)</li>
<li>PYTHON IN CSOUNDQT</li>
<li>LUA IN CSOUND<br />
</li>
</ul>
<li>
<p>Slight changes in the structure (the TERMINAL is now considered as a frontend, and THE CSOUND API chapter is now part of the section Csound and other Programming Languages)<br />
</p>
</li>
</ul>
<h3>Still on the To-Do-List:<br />
</h3>
<ul>
<li>More and better illustrations </li>
<li>Adding examples for VBAP, Ambisonics etc in PANNING AND SPATIALIZATION (Sound Modification)</li>
<li>Adding examples and explanations in METHODS OF WRITING CSOUND SCORES (Appendix)</li>
<li>Update OPCODE GUIDE (and more eyes on it at all)</li>
<li>Much more should be written in the GLOSSARY<br />
</li>
<li>Except the new drafted chapters PYTHON INSIDE CSOUND and EXTENDING CSOUND are still to write.<br />
</li>
</ul>
<p>Last summer Alex Hofmann put a lot of work into making this manual available as a book on <a href="on-this-release/www.lulu.com">www.lulu.com</a>. Just use the search utility there and look for &quot;Csound&quot;, if you would like to obtain a printed version. This second release will be available soon.</p>
<p>Surround Wunderbar Studios, Berlin, 30th March, 2012</p>
<p>Joachim Heintz &amp; Iain McCurdy</p>
<p><img src="static/JoachimAndIain.png" /></p>
<p> </p>
<h3>Foreword on the First Release<br />
</h3>
<p>In spring 2010 a group of Csounders decided to start this project. The chapter outline was suggested by Joachim Heintz with suggestions and improvements provided by Richard Boulanger, Oeyvind Brandtsegg, Andrés Cabrera, Alex Hofmann, Jacob Joaquin, Iain McCurdy, Rory Walsh and others. Rory also pointed us to the FLOSS Manuals platform as a possible environment for writing and publishing. Stefano Bonetti, François Pinot, Davis Pyon and Steven Yi joined later and wrote chapters.<br />
</p>
<p>In a volunteer project like this, it is not always easy to sustain momentum so in the spring of 2011 some members of the team met in Berlin for a 'book sprint' to achieve a level of completion, and publish a first release.</p>
<p>With heads spinning and square eyes we are happy and proud to offer this manual to you. At the same time we realize that this is a first release with much potential for further improvement. Several chapters have yet to be written, others are not yet complete and the differences between the various authors in terms of the level at which they aim and their degree of detail are perhaps larger than they should be.</p>
<p>This is therefore a beginning. Everyone is invited to improve this book. You can begin to write for one of the empty chapters, contribute to an existing one or insert new examples where you feel they are of benefit. You just need to create an account at <span>http://booki.flossmanuals.net</span> or to let us know of your suggestions.</p>
<p>We hope you enjoy using this manual, we had fun writing it!</p>
<p>Berlin, 31st March, 2011</p>
<p>Joachim Heintz Alex Hofmann Iain McCurdy<br />
</p>
<p><img src="static/Csnd_team.png" /></p>
<p>jh at joachimheintz.de alex at boomclicks.de i_mccurdy at hotmail.com</p>
<p> </p>
<p>You can order a printed version here:<br />
<br />
http://www.lulu.com/product/paperback/csound---floss-manual/16265055<br />
</p>
<p><span id="ch004_credits.xhtml"></span></p>
<h1><span id="ch004_credits.xhtml#License"></span> License</h1>
<p>All chapters copyright of the authors (see below). Unless otherwise stated all chapters in this manual licensed with <strong>GNU General Public License version 2</strong></p>
<p>This documentation is free documentation; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>
<p>This documentation is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this documentation; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>
<h2><span id="ch004_credits.xhtml#Authors"></span> Authors</h2>
<p>Note that this book is a collective effort, so some of the contributors may not have been quoted correctly. If you are one of them, please contact us, or simply put your name at the right place.<br />
</p>
<hr />
<hr />
<h3>INTRODUCTION</h3>
<p><em>PREFACE</em><br />
Joachim Heintz, Andres Cabrera, Alex Hofmann, Iain McCurdy<br />
</p>
<hr />
<p><em>HOW TO USE THIS MANUAL</em><br />
Joachim Heintz, Andres Cabrera, Iain McCurdy<em></em></p>
<hr />
<hr />
<h3>01 BASICS</h3>
<p><em>A. DIGITAL AUDIO</em><br />
Alex Hofmann, Rory Walsh, Iain McCurdy, Joachim Heintz</p>
<hr />
<p><em>B. PITCH AND FREQUENCY</em><br />
Rory Walsh, Iain McCurdy, Joachim Heintz</p>
<hr />
<p><em>C. INTENSITIES</em><br />
Joachim Heintz<br />
</p>
<hr />
<hr />
<h3>02 QUICK START</h3>
<p><em>A. RUN CSOUND</em><br />
Alex Hofmann, Joachim Heintz, Andres Cabrera, Iain McCurdy<br />
</p>
<hr />
<p><em>B. CSOUND SYNTAX</em><br />
Alex Hofmann, Joachim Heintz, Andres Cabrera, Iain McCurdy<br />
</p>
<hr />
<p><em>C. CONFIGURING MIDI</em><br />
Andres Cabrera, Joachim Heintz, Iain McCurdy<br />
</p>
<hr />
<p><em>D. LIVE AUDIO</em><br />
Alex Hofmann, Andres Cabrera, Iain McCurdy, Joachim Heintz<br />
</p>
<hr />
<p><em>E. RENDERING TO FILE</em><br />
Joachim Heintz, Alex Hofmann, Andres Cabrera, Iain McCurdy<br />
</p>
<hr />
<hr />
<h3>03 CSOUND LANGUAGE</h3>
<p><em>A. INITIALIZATION AND PERFORMANCE PASS</em><br />
Joachim Heintz<br />
</p>
<hr />
<p><em>B. LOCAL AND GLOBAL VARIABLES</em><br />
Joachim Heintz, Andres Cabrera, Iain McCurdy<br />
</p>
<hr />
<p><em>C. CONTROL STRUCTURES</em><br />
Joachim Heintz<br />
</p>
<hr />
<p><em>D. FUNCTION TABLES</em><br />
Joachim Heintz, Iain McCurdy<br />
</p>
<hr />
<p><em>E. TRIGGERING INSTRUMENT EVENTS</em><br />
Joachim Heintz, Iain McCurdy<br />
</p>
<hr />
<p><em>F. USER DEFINED OPCODES</em><br />
Joachim Heintz<br />
</p>
<hr />
<p><em>G. MACROS</em><br />
Iain McCurdy<br />
</p>
<hr />
<hr />
<h3>04 SOUND SYNTHESIS</h3>
<p><em>A. ADDITIVE SYNTHESIS</em><br />
Andres Cabrera, Joachim Heintz</p>
<hr />
<p><em>B. SUBTRACTIVE SYNTHESIS</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>C. AMPLITUDE AND RINGMODULATION</em><br />
Alex Hofman</p>
<hr />
<p><em>D. FREQUENCY MODULATION</em><br />
Alex Hofmann, Bjorn Houdorf<br />
</p>
<hr />
<p><em>E. WAVESHAPING</em><br />
Joachim Heintz<br />
</p>
<hr />
<p><em>F. GRANULAR SYNTHESIS</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>G. PHYSICAL MODELLING</em><br />
Joachim Heintz, Iain McCurdy<br />
</p>
<hr />
<hr />
<h3>05 SOUND MODIFICATION</h3>
<p><em>A. ENVELOPES</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>B. PANNING AND SPATIALIZATION</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>C. FILTERS</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>D. DELAY AND FEEDBACK</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>E. REVERBERATION</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>F. AM / RM / WAVESHAPING</em><br />
Alex Hofmann, Joachim Heintz<br />
</p>
<hr />
<p><em>G. GRANULAR SYNTHESIS</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>H. CONVOLUTION</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>I. FOURIER ANALYSIS / SPECTRAL PROCESSING</em><br />
Joachim Heintz</p>
<hr />
<hr />
<h3>06 SAMPLES</h3>
<p><em>A. RECORD AND PLAY SOUNDFILES</em><br />
Iain McCurdy, Joachim Heintz<br />
</p>
<hr />
<p><em>B. RECORD AND PLAY BUFFERS</em><br />
Iain McCurdy, Joachim Heintz, Andres Cabrera<br />
</p>
<hr />
<hr />
<h3>07 MIDI</h3>
<p><em>A. RECEIVING EVENTS BY MIDIIN</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>B. TRIGGERING INSTRUMENT INSTANCES</em><br />
Joachim Heintz, Iain McCurdy<br />
</p>
<hr />
<p><em>C. WORKING WITH CONTROLLERS</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>D. READING MIDI FILES</em><br />
Iain McCurdy<br />
</p>
<hr />
<p><em>E. MIDI OUTPUT</em><br />
Iain McCurdy<br />
</p>
<hr />
<hr />
<h3>08 OSC AND WII</h3>
<p><em>OSC AND WII</em><br />
Alex Hofmann<br />
</p>
<hr />
<hr />
<h3>09 CSOUND IN OTHER APPLICATIONS</h3>
<p><em>A. CSOUND IN PD</em><br />
Joachim Heintz, Jim Aikin<br />
</p>
<hr />
<p><em>B. CSOUND IN MAXMSP</em><br />
Davis Pyon<br />
</p>
<hr />
<p><em>C. CSOUND IN ABLETON LIVE</em><br />
Rory Walsh<br />
</p>
<hr />
<p><em>D. CSOUND AS A VST PLUGIN</em><br />
Rory Walsh</p>
<hr />
<hr />
<h3>10 CSOUND FRONTENDS</h3>
<p><em>CSOUNDQT</em><br />
Andrés Cabrera<br />
</p>
<hr />
<p><em>WINXOUND</em><br />
Stefano Bonetti<br />
</p>
<hr />
<p><em>BLUE</em><br />
Steven Yi<br />
</p>
<hr />
<p><em>CABBAGE</em><br />
Rory Walsh<br />
</p>
<hr />
<p><em>CSOUND VIA TERMINAL</em><br />
Iain McCurdy<br />
</p>
<hr />
<hr />
<h3>11 CSOUND UTILITIES</h3>
<p><em>CSOUND UTILITIES</em><br />
Iain McCurdy</p>
<hr />
<hr />
<h3>12 CSOUND AND OTHER PROGRAMMING LANGUAGES</h3>
<p><em>A. THE CSOUND API</em><br />
François Pinot, Rory Walsh<br />
</p>
<hr />
<p><em>B.</em> <em>PYTHON INSIDE CSOUND</em><br />
</p>
<hr />
<p><em>C.</em> <em>PYTHON IN CSOUNDQT</em><br />
</p>
<hr />
<p><em>D. LUA</em> <em>IN CSOUND</em></p>
<hr />
<hr />
<h3>13 EXTENDING CSOUND</h3>
<p><em>EXTENDING CSOUND</em><br />
</p>
<hr />
<hr />
<h3>OPCODE GUIDE</h3>
<p><em>OVERVIEW</em><br />
Joachim Heintz</p>
<hr />
<p><em>SIGNAL PROCESSING I</em><br />
Joachim Heintz</p>
<hr />
<p><em>SIGNAL PROCESSING II</em><br />
Joachim Heintz</p>
<hr />
<p><em>DATA</em><br />
Joachim Heintz</p>
<hr />
<p><em>REALTIME INTERACTION</em><br />
Joachim Heintz</p>
<hr />
<p><em>INSTRUMENT CONTROL</em><br />
Joachim Heintz</p>
<hr />
<p><em>MATH, PYTHON/SYSTEM, PLUGINS</em><br />
Joachim Heintz</p>
<hr />
<hr />
<h3>APPENDIX</h3>
<p><em>GLOSSARY</em><br />
Joachim Heintz</p>
<hr />
<p><em>LINKS</em><br />
Joachim Heintz, Stefano Bonetti</p>
<hr />
<p><em>BUILDING CSOUND</em><br />
Ernesto Illescas, Menno Knevel, Joachim Heintz<br />
</p>
<hr />
<p><em>METHODS OF WRITING CSOUND SCORES</em><br />
Iain McCurdy, Joachim Heintz</p>
<hr />
<hr />
<p>V.1 - Final Editing Team in March 2011:</p>
<p>Joachim Heintz, Alex Hofmann, Iain McCurdy</p>
<p>V.2 - Final Editing Team in March 2012:</p>
<p>Joachim Heintz, Iain McCurdy<br />
</p>
<p><a href="http://www.flossmanuals.net/"><img src="static/Floss-100-en.gif" alt="100.gif" width="110" height="54" /></a><br />
</p>
<p><sub>Free manuals for free software</sub></p>
<p><span id="ch006_a-digital-audio.xhtml"></span></p>
<h1>DIGITAL AUDIO</h1>
<p>At a purely physical level, sound is simply a mechanical disturbance of a medium. The medium in question may be air, solid, liquid, gas or a mixture of several of these. This disturbance to the medium causes molecules to move to and fro in a spring-like manner. As one molecule hits the next, the disturbance moves through the medium causing sound to travel. These so called compressions and rarefactions in the medium can be described as sound waves. The simplest type of waveform, describing what is referred to as 'simple harmonic motion', is a sine wave.</p>
<p><img src="static/Csound-Picts-01_Basics-SineWave-en.png" title="SineWave" alt="SineWave" width="502" height="307" /></p>
<p>Each time the waveform signal goes above 0 the molecules are in a state of compression meaning they are pushing towards each other. Every time the waveform signal drops below 0 the molecules are in a state of rarefaction meaning they are pulling away from each other. When a waveform shows a clear repeating pattern, as in the case above, it is said to be periodic. Periodic sounds give rise to the sensation of pitch.</p>
<h2>Elements of a sound wave<br />
</h2>
<p>Periodic waves have four common parameters, and each of the four parameters affects the way we perceive sound.</p>
<ul>
<li><p><strong>Period</strong>: This is the length of time it takes for a waveform to complete one cycle. This amount of time is referred to as <em>t</em></p></li>
<li><p><strong>Wavelength(<em>)</em></strong>: the distance it takes for a wave to complete one full period. This is usually measured in meters.</p></li>
<li><p><strong>Frequency</strong>: the number of cycles or periods per second. Frequency is measured in Hertz. If a sound has a frequency of 440Hz it completes 440 cycles every second. Given a frequency, one can easily calculate the period of any sound. Mathematically, the period is the reciprocal of the frequency (and vice versa). In equation form, this is expressed as follows.</p>
<pre data-align="justify"><code> Frequency = 1/Period         Period = 1/Frequency</code></pre></li>
</ul>
<div>
<p>Therefore the frequency is the inverse of the period, so a wave of 100 Hz frequency has a period of 1/100 or 0.01 secs, likewise a frequency of 256Hz has a period of 1/256, or 0.004 secs. To calculate the wavelength of a sound in any given medium we can use the following equation:</p>
</div>
<pre data-align="justify"><code> Wavelength = Velocity/Frequency</code></pre>
<p>Humans can hear frequencies from 20Hz to 20000Hz (although this can differ dramatically from individual to individual). You can read more about frequency in the <a href="http://en.flossmanuals.net/csound/ch007_b-pitch-and-frequency/">next chapter</a>.</p>
<ul>
<li><p><strong>Phase:</strong> This is the starting point of a waveform. The starting point along the Y-axis of our plotted waveform is not always 0. This can be expressed in degrees or in radians. A complete cycle of a waveform will cover 360 degrees or (2 x pi) radians.</p></li>
<li><p><strong>Amplitude:</strong> Amplitude is represented by the y-axis of a plotted pressure wave. The strength at which the molecules pull or push away from each other will determine how far above and below 0 the wave fluctuates. The greater the y-value the greater the amplitude of our wave. The greater the compressions and rarefactions the greater the amplitude.</p></li>
</ul>
<h2>Transduction</h2>
<p>The analogue sound waves we hear in the world around us need to be converted into an electrical signal in order to be amplified or sent to a soundcard for recording. The process of converting acoustical energy in the form of pressure waves into an electrical signal is carried out by a device known as a a transducer.</p>
<p>A transducer, which is usually found in microphones, produces a changing electrical voltage that mirrors the changing compression and rarefaction of the air molecules caused by the sound wave. The continuous variation of pressure is therefore 'transduced' into continuous variation of voltage. The greater the variation of pressure the greater the variation of voltage that is sent to the computer.<br />
</p>
<p>Ideally, the transduction process should be as transparent and clean as possible: i.e., whatever goes in comes out as a perfect voltage representation. In the real world however this is never the case. Noise and distortion are always incorporated into the signal. Every time sound passes through a transducer or is transmitted electrically a change in signal quality will result. When we talk of 'noise' we are talking specifically about any unwanted signal captured during the transduction process. This normally manifests itself as an unwanted 'hiss'.<br />
</p>
<h2>Sampling</h2>
<p>The analogue voltage that corresponds to an acoustic signal changes continuously so that at each instant in time it will have a different value. It is not possible for a computer to receive the value of the voltage for every instant because of the physical limitations of both the computer and the data converters (remember also that there are an infinite number of instances between every two instances!).</p>
<p>What the soundcard can do however is to measure the power of the analogue voltage at intervals of equal duration. This is how all digital recording works and is known as 'sampling'. The result of this sampling process is a discrete or digital signal which is no more than a sequence of numbers corresponding to the voltage at each successive sample time.</p>
<p>Below left is a diagram showing a sinusoidal waveform. The vertical lines that run through the diagram represents the points in time when a snapshot is taken of the signal. After the sampling has taken place we are left with what is known as a discrete signal consisting of a collection of audio samples, as illustrated in the diagram on the right hand side below. If one is recording using a typical audio editor the incoming samples will be stored in the computer RAM (Random Access Memory). In Csound one can process the incoming audio samples in real time and output a new stream of samples, or write them to disk in the form of a sound file.<br />
</p>
<p><img src="static/Csound-Picts-01_Basics-waveFormSampling-en.png" alt="waveFormSampling.png" width="484" height="159" /></p>
<p>It is important to remember that each sample represents the amount of voltage, positive or negative, that was present in the signal at the point in time the sample or snapshot was taken.</p>
<p>The same principle applies to recording of live video. A video camera takes a sequence of pictures of something in motion for example. Most video cameras will take between 30 and 60 still pictures a second. Each picture is called a frame. When these frames are played we no longer perceive them as individual pictures. We perceive them instead as a continuous moving image.</p>
<h2>Analogue versus Digital</h2>
<p>In general, analogue systems can be quite unreliable when it comes to noise and distortion. Each time something is copied or transmitted, some noise and distortion is introduced into the process. If this is done many times, the cumulative effect can deteriorate a signal quite considerably. It is because of this, the music industry has turned to digital technology, which so far offers the best solution to this problem. As we saw above, in digital systems sound is stored as numbers, so a signal can be effectively &quot;cloned&quot;. Mathematical routines can be applied to prevent errors in transmission, which could otherwise introduce noise into the signal.<br />
</p>
<h2>Sample Rate and the Sampling Theorem</h2>
<p>The sample rate describes the number of samples (pictures/snapshots) taken each second. To sample an audio signal correctly it is important to pay attention to the sampling theorem:</p>
<pre><code>&quot;To represent digitally a signal containing frequencies up to X Hz, it is 
necessary to use a sampling rate of at least 2X samples per second&quot;  </code></pre>
<p>According to this theorem, a soundcard or any other digital recording device will not be able to represent any frequency above 1/2 the sampling rate. Half the sampling rate is also referred to as the Nyquist frequency, after the Swedish physicist Harry Nyquist who formalized the theory in the 1920s. What it all means is that any signal with frequencies above the Nyquist frequency will be misrepresented. Furthermore it will result in a frequency lower than the one being sampled. When this happens it results in what is known as aliasing or foldover.</p>
<h2>Aliasing</h2>
<p>Here is a graphical representation of aliasing.</p>
<p><img src="static/Csound-Picts-01_Basics-Aliasing-en.png" alt="Aliasing.png" width="371" height="101" /><br />
The sinusoidal wave form in blue is being sampled at each arrow. The line that joins the red circles together is the captured waveform. As you can see the captured wave form and the original waveform have different frequencies. Here is another example:</p>
<p><img src="static/Csound-Picts-01_Basics-Aliasing2-en.png" alt="Aliasing2.png" width="410" height="376" /></p>
<p>We can see that if the sample rate is 40,000 there is no problem sampling a signal that is 10KHz. On the other hand, in the second example it can be seen that a 30kHz waveform is not going to be correctly sampled. In fact we end up with a waveform that is 10kHz, rather than 30kHz.</p>
<p>The following Csound instrument plays a 1000 Hz tone first directly, and then because the frequency is 1000 Hz lower than the sample rate of 44100 Hz:</p>
<p><em><strong>EXAMPLE 01A01.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
asig    oscils  .2, p4, 0
        outs    asig, asig
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 2 1000 ;1000 Hz tone
i 1 3 2 43100 ;43100 Hz tone sounds like 1000 Hz because of aliasing
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The same phenomenon takes places in film and video too. You may recall having seen wagon wheels apparently move backwards in old Westerns. Let us say for example that a camera is taking 60 frames per second of a wheel moving. If the wheel is completing one rotation in exactly 1/60th of a second, then every picture looks the same. - as a result the wheel appears to stand still. If the wheel speeds up, i.e., increases frequency, it will appear as if the wheel is slowly turning backwards. This is because the wheel will complete more than a full rotation between each snapshot. This is the most ugly side-effect of aliasing - wrong information.</p>
<p>As an aside, it is worth observing that a lot of modern 'glitch' music intentionally makes a feature of the spectral distortion that aliasing induces in digital audio.<br />
</p>
<p>Audio-CD Quality uses a sample rate of 44100Kz (44.1 kHz). This means that CD quality can only represent frequencies up to 22050Hz. Humans typically have an absolute upper limit of hearing of about 20Khz thus making 44.1KHz a reasonable standard sampling rate.</p>
<h2>Bits, Bytes and Words. Understanding binary.<br />
</h2>
<p>All digital computers represent data as a collection of bits (short for binary digit). A bit is the smallest possible unit of information. One bit can only be one of two states - off or on, 0 or 1. The meaning of the bit, which can represent almost anything, is unimportant at this point. The thing to remember is that all computer data - a text file on disk, a program in memory, a packet on a network - is ultimately a collection of bits.</p>
<p>Bits in groups of eight are called bytes, and one byte usually represents a single character of data in the computer. It's a little used term, but you might be interested in knowing that a nibble is half a byte (usually 4 bits).</p>
<p><br />
</p>
<h2>The Binary System</h2>
<p>All digital computers work in a environment that has only two variables, 0 and 1. All numbers in our decimal system therefore must be translated into 0's and 1's in the binary system. If you think of<br />
binary numbers in terms of switches. With one switch you can represent up to two different numbers.</p>
<p>0 (OFF) = Decimal 0<br />
1 (ON) = Decimal 1<br />
</p>
<p>Thus, a single bit represents 2 numbers, two bits can represent 4 numbers, three bits represent 8 numbers, four bits represent 16 numbers, and so on up to a byte, or eight bits, which represents 256 numbers. Therefore each added bit doubles the amount of possible numbers that can be represented. Put simply, the more bits you have at your disposal the more information you can store.</p>
<p><br />
</p>
<h2>Bit-depth Resolution</h2>
<p>Apart from the sample rate, another important parameter which can affect the fidelity of a digital signal is the accuracy with which each sample is known, in other words knowing how strong each voltage is. Every sample obtained is set to a specific amplitude (the measure of strength for each voltage) level. The number of levels depends on the precision of the measurement in bits, i.e., how many binary digits are used to store the samples. The number of bits that a system can use is normally referred to as the bit-depth resolution.</p>
<p>If the bit-depth resolution is 3 then there are 8 possible levels of amplitude that we can use for each sample. We can see this in the diagram below. At each sampling period the soundcard plots an amplitude. As we are only using a 3-bit system the resolution is not good enough to plot the correct amplitude of each sample. We can see in the diagram that some vertical lines stop above or below the real signal. This is because our bit-depth is not high enough to plot the amplitude levels with sufficient accuracy at each sampling period.</p>
<p><img src="static/Csound-Picts-01_Basics-bitdepth-en.png" alt="bitdepth.png" width="198" height="139" /></p>
<pre><code>example here for 4, 6, 8, 12, 16 bit of a sine signal ...
... coming in the next release</code></pre>
<p>The standard resolution for CDs is 16 bit, which allows for 65536 different possible amplitude levels, 32767 either side of the zero axis. Using bit rates lower than 16 is not a good idea as it will result in noise being added to the signal. This is referred to as quantization noise and is a result of amplitude values being excessively rounded up or down when being digitized. Quantization noise becomes most apparent when trying to represent low amplitude (quiet) sounds. Frequently a tiny amount of noise, known as a dither signal, will be added to digital audio before conversion back into an analogue signal. Adding this dither signal will actually reduce the more noticeable noise created by quantization. As higher bit depth resolutions are employed in the digitizing process the need for dithering is reduced. A general rule is to use the highest bit rate available.</p>
<p>Many electronic musicians make use of deliberately low bit depth quantization in order to add noise to a signal. The effect is commonly known as 'bit-crunching' and is relatively easy to do in Csound.</p>
<h2>ADC / DAC</h2>
<p>The entire process, as described above, of taking an analogue signal and converting it into a digital signal is referred to as analogue to digital conversion or ADC. Of course digital to analogue conversion, DAC, is also possible. This is how we get to hear our music through our PC's headphones or speakers. For example, if one plays a sound from Media Player or iTunes the software will send a series of numbers to the computer soundcard. In fact it will most likely send 44100 numbers a second. If the audio that is playing is 16 bit then these numbers will range from -32768 to +32767.</p>
<p>When the sound card receives these numbers from the audio stream it will output corresponding voltages to a loudspeaker. When the voltages reach the loudspeaker they cause the loudspeakers magnet to move inwards and outwards. This causes a disturbance in the air around the speaker resulting in what we perceive as sound.</p>
<p><span id="ch007_b-pitch-and-frequency.xhtml"></span></p>
<h1>FREQUENCIES</h1>
<p>As mentioned in the previous section frequency is defined as the number of cycles or periods per second. Frequency is measured in Hertz. If a tone has a frequency of 440Hz it completes 440 cycles every second. Given a tone's frequency, one can easily calculate the period of any sound. Mathematically, the period is the reciprocal of the frequency and vice versa. In equation form, this is expressed as follows.</p>
<pre data-align="JUSTIFY"><code> Frequency = 1/Period         Period = 1/Frequency </code></pre>
<p>Therefore the frequency is the inverse of the period, so a wave of 100 Hz frequency has a period of 1/100 or 0.01 seconds, likewise a frequency of 256Hz has a period of 1/256, or 0.004 seconds. To calculate the wavelength of a sound in any given medium we can use the following equation:</p>
<pre data-align="JUSTIFY"><code>λ = Velocity/Frequency</code></pre>
<p>For instance, a wave of 1000 Hz in air (velocity of diffusion about 340 m/s) has a length of approximately 340/1000 m = 34 cm.<br />
</p>
<h2>Lower And Higher Borders For Hearing</h2>
<p>The human ear can generally hear sounds in the range 20 Hz to 20,000 Hz (20 kHz). This upper limit tends to decrease with age due to a condition known as presbyacusis, or age related hearing loss. Most adults can hear to about 16 kHz while most children can hear beyond this. At the lower end of the spectrum the human ear does not respond to frequencies below 20 Hz, with 40 of 50 Hz being the lowest most people can perceive. </p>
<p>So, in the following example, you will not hear the first (10 Hz) tone, and probably not the last (20 kHz) one, but hopefully the other ones (100 Hz, 1000 Hz, 10000 Hz):</p>
<p><em><strong>EXAMPLE 01B01.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by joachim heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
        prints  &quot;Playing %d Hertz!\n&quot;, p4
asig    oscils  .2, p4, 0
        outs    asig, asig
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 2 10
i . + . 100
i . + . 1000
i . + . 10000
i . + . 20000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Logarithms, Frequency Ratios and Intervals</h2>
<p>A lot of basic maths is about simplification of complex equations. Shortcuts are taken all the time to make things easier to read and equate. Multiplication can be seen as a shorthand of addition, for example, 5x10 = 5+5+5+5+5+5+5+5+5+5. Exponents are shorthand for multiplication, 3<sup>5</sup> = 3x3x3x3x3. Logarithms are shorthand for exponents and are used in many areas of science and engineering in which quantities vary over a large range. Examples of logarithmic scales include the decibel scale, the Richter scale for measuring earthquake magnitudes and the astronomical scale of stellar brightnesses. Musical frequencies also work on a logarithmic scale, more on this later.<br />
</p>
<p>Intervals in music describe the distance between two notes. When dealing with standard musical notation it is easy to determine an interval between two adjacent notes. For example a perfect 5th is always made up of 7 semitones. When dealing with Hz values things are different. A difference of say 100Hz does not always equate to the same musical interval. This is because musical intervals as we hear them are represented in Hz as frequency ratios. An octave for example is always 2:1. That is to say every time you double a Hz value you will jump up by a musical interval of an octave.</p>
<p>Consider the following. A flute can play the note A at 440 Hz. If the player plays another A an octave above it at 880 Hz the difference in Hz is 440. Now consider the piccolo, the highest pitched instrument of the orchestra. It can play a frequency of 2000 Hz but it can also play an octave above this at 4000 Hz (2 x 2000 Hz). While the difference in Hertz between the two notes on the flute is only 440 Hz, the difference between the two high pitched notes on a piccolo is 1000 Hz yet they are both only playing notes one octave apart.</p>
<p>What all this demonstrates is that the higher two pitches become the greater the difference in Hertz needs to be for us to recognize the difference as the same musical interval. The most common ratios found in the equal temperament scale are the unison: (1:1), the octave: (2:1), the perfect fifth (3:2), the perfect fourth (4:3), the major third (5:4) and the minor third (6:5).</p>
<p>The following example shows the difference between adding a certain frequency and applying a ratio. First, the frequencies of 100, 400 and 800 Hz all get an addition of 100 Hz. This sounds very different, though the added frequency is the same. Second, the ratio 3/2 (perfect fifth) is applied to the same frequencies. This sounds always the same, though the frequency displacement is different each time.</p>
<p><em><strong>EXAMPLE 01B02.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by joachim heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
        prints  &quot;Playing %d Hertz!\n&quot;, p4
asig    oscils  .2, p4, 0
        outs    asig, asig
endin

instr 2
        prints  &quot;Adding %d Hertz to %d Hertz!\n&quot;, p5, p4
asig    oscils  .2, p4+p5, 0
        outs    asig, asig
endin

instr 3
        prints  &quot;Applying the ratio of %f (adding %d Hertz)
                 to %d Hertz!\n&quot;, p5, p4*p5, p4
asig    oscils  .2, p4*p5, 0
        outs    asig, asig
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;adding a certain frequency (instr 2)
i 1 0 1 100
i 2 1 1 100 100
i 1 3 1 400
i 2 4 1 400 100
i 1 6 1 800
i 2 7 1 800 100
;applying a certain ratio (instr 3)
i 1 10 1 100
i 3 11 1 100 [3/2]
i 1 13 1 400
i 3 14 1 400 [3/2]
i 1 16 1 800
i 3 17 1 800 [3/2]
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>So what of the algorithms mentioned above. As some readers will know the current preferred method of tuning western instruments is based on equal temperament. Essentially this means that all octaves are split into 12 equal intervals. Therefore a semitone has a ratio of 2<sup>(1/12)</sup>, which is approximately 1.059463.</p>
<p>So what about the reference to logarithms in the heading above? As stated previously, logarithms are shorthand for exponents. 2<sup>(1/12)</sup>= 1.059463 can also be written as log2(1.059463)= 1/12. Therefore musical frequency works on a logarithmic scale. </p>
<h2>MIDI Notes</h2>
<p>Csound can easily deal with MIDI notes and comes with functions that will convert MIDI notes to Hertz values and back again. In MIDI speak A440 is equal to A4. You can think of A4 as being the fourth A from the lowest A we can hear, well almost hear.</p>
<p><em>Caution: like many 'standards' there is occasional disagreement about the mapping between frequency and octave number. You may occasionally encounter A440 being described as A3.</em></p>
<p><span id="ch008_c-intensities.xhtml"></span></p>
<h1>INTENSITIES</h1>
<h2>Real World Intensities and Amplitudes</h2>
<p>There are many ways to describe a sound physically. One of the most common is the Sound Intensity Level (SIL). It describes the amount of power on a certain surface, so its unit is Watt per square meter ( <span class="AM" title="&lt;img title=&quot;W//m^2&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BW%7D%5C//%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BW%7D%5C/%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D" title="W//m^2" /></span> ). The range of human hearing is about  <span class="AM" title="&lt;img title=&quot;10^-12 W//m^2&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B10%7D%7D%5E%7B%7B-%7B%7B12%7D%7D%7D%7D%7BW%7D%5C//%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B10%7D%7D%5E%7B%7B-%7B%7B12%7D%7D%7D%7D%7BW%7D%5C/%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D" title="10^-12 W//m^2" /></span> at the threshold of hearing to <span class="AM" title="`10^0 W//m^2`"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B10%7D%7D%5E%7B%7B0%7D%7D%7BW%7D%5C/%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D" title="10^0 W//m^2" /></span> <span class="AM" title="&lt;math title=&quot;10^0 W//m^2&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;msup&gt;&lt;mn&gt;&lt;/mn&gt;&lt;/msup&gt;&lt;/mstyle&gt;&lt;/math&gt;"></span>at the threshold of pain. For ordering this immense range, and to facilitate the measurement of one sound intensity based upon its ratio with another, a logarithmic scale is used. The unit <em>Bel</em> describes the relation of one intensity <span class="AM" title="&lt;math title=&quot;I&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;">I</span> to a reference intensity <span class="AM" title="&lt;math title=&quot;I_0&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;msub&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/math&gt;">I0</span> as follows:</p>
<p><span class="AM" title="&lt;img title=&quot;log_(10)I/I_0&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%5Clog%7D_%7B%7B%7B10%7D%7D%7D%5Cfrac%7B%7BI%7D%7D%7B%7BI%7D_%7B%7B0%7D%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%5Clog%7D_%7B%7B%7B10%7D%7D%7D%5Cfrac%7B%7BI%7D%7D%7B%7BI%7D_%7B%7B0%7D%7D%7D" title="log_(10)I/I_0" /></span>   <em>Sound Intensity Level in Bel</em></p>
<p>If, for instance, the ratio  <span class="AM" title="&lt;img title=&quot;I/I_0&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%5Cfrac%7B%7BI%7D%7D%7B%7BI%7D_%7B%7B0%7D%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%5Cfrac%7B%7BI%7D%7D%7B%7BI%7D_%7B%7B0%7D%7D%7D" title="I/I_0" /></span> <span class="AM" title="&lt;math title=&quot;I/I_0&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;mfrac&gt;&lt;mi&gt;&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mstyle&gt;&lt;/math&gt;"></span> is 10, this is 1 Bel. If the ratio is 100, this is 2 Bel.</p>
<p>For real world sounds, it makes sense to set the reference value  <span class="AM" title="&lt;img title=&quot;I_0&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D_%7B%7B0%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D_%7B%7B0%7D%7D" title="I_0" /></span> to the threshold of hearing which has been fixed as  <span class="AM" title="&lt;img title=&quot;10^-12 W//m^2&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B10%7D%7D%5E%7B%7B-%7B%7B12%7D%7D%7D%7D%7BW%7D%5C//%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B10%7D%7D%5E%7B%7B-%7B%7B12%7D%7D%7D%7D%7BW%7D%5C/%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D" title="10^-12 W//m^2" /></span> at 1000 Hertz. So the range of hearing covers about 12 Bel. Usually 1 Bel is divided into 10 deci Bel, so the common formula for measuring a sound intensity is:</p>
<p> </p>
<p><span class="AM" title="&lt;img title=&quot;10*log_10 I/I_0&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B10%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7BI%7D%7D%7B%7BI%7D_%7B%7B0%7D%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B10%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7BI%7D%7D%7B%7BI%7D_%7B%7B0%7D%7D%7D" title="10*log_10 I/I_0" /></span>   <em><strong>Sound Intensity Level (SIL) in Decibel (dB)</strong></em> with  <span class="AM" title="&lt;img title=&quot;I_0=10^-12 W//m^2&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D_%7B%7B0%7D%7D=%7B%7B10%7D%7D%5E%7B%7B-%7B%7B12%7D%7D%7D%7D%7BW%7D%5C//%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D_%7B%7B0%7D%7D=%7B%7B10%7D%7D%5E%7B%7B-%7B%7B12%7D%7D%7D%7D%7BW%7D%5C/%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D" title="I_0=10^-12 W//m^2" /></span></p>
<p> </p>
<p>While the sound intensity level is useful to describe the way in which the human hearing works, the <em>measurement</em> of sound is more closely related to the sound pressure deviations. Sound waves compress and expand the air particles and by this they increase and decrease the localized air pressure. These deviations are measured and transformed by a microphone. So the question arises: what is the relationship between the sound pressure deviations and the sound intensity? The answer is: sound intensity changes <span class="AM" title="&lt;img title=&quot;I&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D" title="I" /></span> are proportional to the <em>square</em> of the sound pressure changes <span class="AM" title="&lt;img title=&quot;P&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BP%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BP%7D" title="P" /></span> . As a formula:</p>
<p><span class="AM" title=" &lt;math title=&quot;I ~~ P^2&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;mi&gt;&lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;"> </span> <span class="AM" title="&lt;img title=&quot;I~~P^2&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D%5Capprox%7B%7BP%7D%7D%5E%7B%7B2%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D%5Capprox%7B%7BP%7D%7D%5E%7B%7B2%7D%7D" title="I~~P^2" /></span>   <em>Relation between Sound Intensity and Sound Pressure</em><br />
</p>
<p>Let us take an example to see what this means. The sound pressure at the threshold of hearing can be fixed at  <span class="AM" title="&lt;img title=&quot;2*10^-5 Pa&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B-%7B%7B5%7D%7D%7D%7D%7BP%7D%7Ba%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B-%7B%7B5%7D%7D%7D%7D%7BP%7D%7Ba%7D" title="2*10^-5 Pa" /></span>  . This value is the reference value of the Sound Pressure Level (SPL). If we have now a value of  <span class="AM" title="&lt;img title=&quot;2*10^-4 Pa&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B-%7B%7B4%7D%7D%7D%7D%7BP%7D%7Ba%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B-%7B%7B4%7D%7D%7D%7D%7BP%7D%7Ba%7D" title="2*10^-4 Pa" /></span>   , the corresponding sound intensity relation can be calculated as:</p>
<p><span class="AM" title="&lt;img title=&quot;((2*10^4)/(2*10^5))^2 = 10^2 = 100&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B%5Cleft%28%5Cfrac%7B%7B%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B4%7D%7D%7D%7D%7B%7B%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B5%7D%7D%7D%7D%5Cright%29%7D%7D%5E%7B%7B2%7D%7D=%7B%7B10%7D%7D%5E%7B%7B2%7D%7D=%7B100%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B%5Cleft(%5Cfrac%7B%7B%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B4%7D%7D%7D%7D%7B%7B%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B5%7D%7D%7D%7D%5Cright)%7D%7D%5E%7B%7B2%7D%7D=%7B%7B10%7D%7D%5E%7B%7B2%7D%7D=%7B100%7D" title="((2*10^4)/(2*10^5))^2 = 10^2 = 100" /></span><br />
</p>
<p><span class="AM" title="&lt;math title=&quot;(10^-4 / 10^-5)^2 = 10^2 = 100&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mo&gt;&lt;/mo&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mstyle&gt;&lt;/math&gt;"></span>So, a factor of 10 at the pressure relation yields a factor of 100 at the intensity relation. In general, the dB scale for the pressure <span class="AM" title="&lt;math title=&quot;P&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mstyle&gt;&lt;/math&gt;">P</span> related to the pressure <span class="AM" title="&lt;math title=&quot;P_0&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;msub&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/mstyle&gt;&lt;/math&gt;">P0</span> is:</p>
<p> </p>
<p><span class="AM" title="&lt;img title=&quot;10 * log_10 (P/P_0)^2 = 2 * 10 * log_10 P/P_0 = 20 * log_10 P/P_0&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B10%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%7B%7B%5Cleft%28%5Cfrac%7B%7BP%7D%7D%7B%7BP%7D_%7B%7B0%7D%7D%7D%5Cright%29%7D%7D%5E%7B%7B2%7D%7D=%7B2%7D%5Ccdot%7B10%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7BP%7D%7D%7B%7BP%7D_%7B%7B0%7D%7D%7D=%7B20%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7BP%7D%7D%7B%7BP%7D_%7B%7B0%7D%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B10%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%7B%7B%5Cleft(%5Cfrac%7B%7BP%7D%7D%7B%7BP%7D_%7B%7B0%7D%7D%7D%5Cright)%7D%7D%5E%7B%7B2%7D%7D=%7B2%7D%5Ccdot%7B10%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7BP%7D%7D%7B%7BP%7D_%7B%7B0%7D%7D%7D=%7B20%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7BP%7D%7D%7B%7BP%7D_%7B%7B0%7D%7D%7D" title="10 * log_10 (P/P_0)^2 = 2 * 10 * log_10 P/P_0 = 20 * log_10 P/P_0" /></span></p>
<p><em><strong>Sound Pressure Level (SPL) in Decibel (dB)</strong></em> with <span class="AM" title="&lt;img title=&quot;P_0=2*10^-5 Pa&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BP%7D_%7B%7B0%7D%7D=%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B-%7B%7B5%7D%7D%7D%7D%7BP%7D%7Ba%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BP%7D_%7B%7B0%7D%7D=%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B-%7B%7B5%7D%7D%7D%7D%7BP%7D%7Ba%7D" title="P_0=2*10^-5 Pa" /></span><br />
</p>
<p> </p>
<p>Working with Digital Audio basically means working with <em>amplitudes</em>. What we are dealing with microphones are amplitudes. Any audio file is a sequence of amplitudes. What you generate in Csound and write either to the DAC in realtime or to a sound file, are again nothing but a sequence of amplitudes. As amplitudes are directly related to the sound pressure deviations, all the relations between sound intensity and sound pressure can be transferred to relations between sound intensity and amplitudes:</p>
<p> </p>
<p><span class="AM" title="&lt;img title=&quot;I~~A^2&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D%5Capprox%7B%7BA%7D%7D%5E%7B%7B2%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BI%7D%5Capprox%7B%7BA%7D%7D%5E%7B%7B2%7D%7D" title="I~~A^2" /></span>   <em><strong>Relation between Intensity and Ampltitudes</strong></em></p>
<p><span class="AM" title="&lt;img title=&quot;20*log_10 A/A_0&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B20%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7BA%7D%7D%7B%7BA%7D_%7B%7B0%7D%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B20%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7BA%7D%7D%7B%7BA%7D_%7B%7B0%7D%7D%7D" title="20*log_10 A/A_0" /></span>   <em><strong>Decibel (dB) Scale of Amplitudes</strong></em> with any amplitude  <span class="AM" title="&lt;img title=&quot;A&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BA%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BA%7D" title="A" /></span> related to an other amplitude <span class="AM" title="&lt;img title=&quot;A_0&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BA%7D_%7B%7B0%7D%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7BA%7D_%7B%7B0%7D%7D" title="A_0" /></span><br />
</p>
<p> </p>
<p>If you drive an oscillator with the amplitude 1, and another oscillator with the amplitude 0.5, and you want to know the difference in dB, you calculate:</p>
<p><span class="AM" title="&lt;img title=&quot;20*log_10 1/0.5 = 20 * log_10 2 = 20 * 0.30103 = 6.0206 dB&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B20%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7B1%7D%7D%7B%7B0.5%7D%7D=%7B20%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%7B2%7D=%7B20%7D%5Ccdot%7B0.30103%7D=%7B6.0206%7D%7Bd%7D%7BB%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B20%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%5Cfrac%7B%7B1%7D%7D%7B%7B0.5%7D%7D=%7B20%7D%5Ccdot%7B%5Clog%7D_%7B%7B10%7D%7D%7B2%7D=%7B20%7D%5Ccdot%7B0.30103%7D=%7B6.0206%7D%7Bd%7D%7BB%7D" title="20*log_10 1/0.5 = 20 * log_10 2 = 20 * 0.30103 = 6.0206 dB" /></span>  </p>
<p>So, the most useful thing to keep in mind is: when you double the amplitude, you get +6 dB; when you have half of the amplitude as before, you get -6 dB.</p>
<p><br />
</p>
<h2>What is 0 dB?</h2>
<p>As described in the last section, any dB scale - for intensities, pressures or amplitudes - is just a way to describe a <em>relationship</em>. To have any sort of quantitative measurement you will need to know the reference value referred to as &quot;0 dB&quot;. For real world sounds, it makes sense to set this level to the threshold of hearing. This is done, as we saw, by setting the SIL to  <span class="AM" title="&lt;img title=&quot;10^-12 W//m^2&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B10%7D%7D%5E%7B%7B-%7B%7B12%7D%7D%7D%7D%7BW%7D%5C//%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D&quot;&gt;&amp;nbsp;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B%7B10%7D%7D%5E%7B%7B-%7B%7B12%7D%7D%7D%7D%7BW%7D%5C/%7B%7Bm%7D%7D%5E%7B%7B2%7D%7D" title="10^-12 W//m^2" /> </span> and the SPL to  <span class="AM" title="&lt;img title=&quot;2*10^-5 Pa&quot; style=&quot;vertical-align: middle;&quot; src=&quot;http://www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B-%7B%7B5%7D%7D%7D%7D%7BP%7D%7Ba%7D&quot;&gt;"><embed src="http:/www.imathas.com/cgi-bin/mimetex.cgi?%5Cdisplaystyle%5Cblack%7B2%7D%5Ccdot%7B%7B10%7D%7D%5E%7B%7B-%7B%7B5%7D%7D%7D%7D%7BP%7D%7Ba%7D" title="2*10^-5 Pa" /></span><span class="AM" title="&lt;math title=&quot;20^-5 Pa&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;msup&gt;&lt;mn&gt;&lt;/mn&gt;&lt;/msup&gt;&lt;/mstyle&gt;&lt;/math&gt;"></span>.</p>
<p>But for working with digital sound in the computer, this does not make any sense. What you will hear from the sound you produce in the computer, just depends on the amplification, the speakers, and so on. It has nothing, per se, to do with the level in your audio editor or in Csound. Nevertheless, there <em>is</em> a rational reference level for the amplitudes. In a digital system, there is a strict limit for the maximum number you can store as amplitude. This maximum possible level is called 0 dB.</p>
<p>Each program connects this maximum possible amplitude with a number. Usually it is '1' which is a good choice, because you know that everything above 1 is clipping, and you have a handy relation for lower values. But actually this value is nothing but a setting, and in Csound you are free to set it to any value you like via the <a href="http://www.csounds.com/manual/html/Zerodbfs.html">0dbfs</a> opcode. Usually you should use this statement in the orchestra header:</p>
<pre><code>0dbfs = 1</code></pre>
<p>This means: &quot;Set the level for zero dB as full scale to 1 as reference value.&quot; Note that because of historical reasons the default value in Csound is not 1 but 32768. So you must have this <em>0dbfs = 1</em> statement in your header if you want to set Csound to the value probably all other audio applications have.</p>
<p><br />
</p>
<h2>dB Scale Versus Linear Amplitude</h2>
<p>Let's see some practical consequences now of what we have discussed so far. One major point is: for getting smooth transitions between intensity levels you must not use a simple linear transition of the amplitudes, but a linear transition of the dB equivalent. The following example shows a linear rise of the amplitudes from 0 to 1, and then a linear rise of the dB's from -80 to 0 dB, both over 10 seconds.<br />
</p>
<p>   <em><strong>EXAMPLE 01C01.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by joachim heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1 ;linear amplitude rise
kamp      line    0, p3, 1 ;amp rise 0-&gt;1
asig      oscils  1, 1000, 0 ;1000 Hz sine
aout      =       asig * kamp
          outs    aout, aout
endin

instr 2 ;linear rise of dB
kdb       line    -80, p3, 0 ;dB rise -60 -&gt; 0
asig      oscils  1, 1000, 0 ;1000 Hz sine
kamp      =       ampdb(kdb) ;transformation db -&gt; amp
aout      =       asig * kamp
          outs    aout, aout
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
i 2 11 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>You will hear how fast the sound intensity increases at the first note with direct amplitude rise, and then stays nearly constant. At the second note you should hear a very smooth and constant increment of intensity.</p>
<p><br />
</p>
<h2>RMS Measurement</h2>
<p>Sound intensity depends on many factors. One of the most important is the effective mean of the amplitudes in a certain time span. This is called the Root Mean Square (RMS) value. To calculate it, you have (1) to calculate the squared amplitudes of number N samples. Then you (2) divide the result by N to calculate the mean of it. Finally (3) take the square root.</p>
<p>Let's see a simple example, and then have a look how getting the rms value works in Csound. Assumeing we have a sine wave which consists of 16 samples, we get these amplitudes:</p>
<p><img src="static/Sine_16points_v2.png" /> </p>
<p>These are the squared amplitudes:</p>
<p><img src="static/Sine_16points_RMS_v2.png" /><br />
</p>
<p>The mean of these values is:</p>
<p><span class="AM" title="&lt;math title=&quot;(0 + 0.146 + 0.5 + 0.854 + 1 + 0.854 + 0.5 + 0.146 + 0 + 0.146 + 0.5 + 0.854 + 1 + 0.854 + 0.5 + 0.146) // 16 = 8 // 16 = 0.5&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.146&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.854&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.854&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.146&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.146&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.854&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.854&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0.146&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;8&lt;/mn&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;mn&gt;16&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;/mstyle&gt;&lt;/math&gt;">(0+0.146+0.5+0.854+1+0.854+0.5+0.146+0+0.146+0.5+0.854+1+0.854+0.5+0.146)/16=8/16=0.5</span><br />
</p>
<p>And the resulting RMS value is <span class="AM" title="&lt;math title=&quot;sqrt(0.5) = 0.707&quot;&gt;&lt;mstyle displaystyle=&quot;true&quot; fontfamily=&quot;serif&quot; mathcolor=&quot;black&quot;&gt;&lt;msqrt&gt;&lt;mrow&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;/mrow&gt;&lt;/msqrt&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0.707&lt;/mn&gt;&lt;/mstyle&gt;&lt;/math&gt;">0.5=0.707</span> . </p>
<p>The <a href="http://www.csounds.com/manual/html/rms.html">rms</a> opcode in Csound calculates the RMS power in a certain time span, and smoothes the values in time according to the <em>ihp</em> parameter: the higher this value (the default is 10 Hz), the snappier the measurement, and vice versa. This opcode can be used to implement a self-regulating system, in which the rms opcode prevents the system from exploding. Each time the rms value exceeds a certain value, the amount of feedback is reduced. This is an example<span id="ch008_c-intensities.xhtml#InsertNoteID_6_marker7" class="InsertNoteMarker"><sup><a href="c-intensities#InsertNoteID_6">1</a></sup></span> :</p>
<p>   <em><strong>EXAMPLE 01C02.csd</strong></em>  <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by Martin Neukom, adapted by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1 ;table with a sine wave

instr 1
a3        init      0
kamp      linseg    0, 1.5, 0.2, 1.5, 0 ;envelope for initial input
asnd      poscil    kamp, 440, giSine ;initial input
 if p4 == 1 then ;choose between two sines ...
adel1     poscil    0.0523, 0.023, giSine
adel2     poscil    0.073, 0.023, giSine,.5
 else ;or a random movement for the delay lines
adel1     randi     0.05, 0.1, 2
adel2     randi     0.08, 0.2, 2
 endif
a0        delayr    1 ;delay line of 1 second
a1        deltapi   adel1 + 0.1 ;first reading
a2        deltapi   adel2 + 0.1 ;second reading
krms      rms       a3 ;rms measurement
          delayw    asnd + exp(-krms) * a3 ;feedback depending on rms
a3        reson     -(a1+a2), 3000, 7000, 2 ;calculate a3
aout      linen     a1/3, 1, p3, 1 ;apply fade in and fade out
          outs      aout, aout
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 60 1 ;two sine movements of delay with feedback
i 1 61 . 2 ;two random movements of delay with feedback
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p> </p>
<p> </p>
<h2>Fletcher-Munson Curves</h2>
<p>Human hearing is roughly in a range between 20 and 20000 Hz. But inside this range, the hearing is not equally sensitive. The most sensitive region is around 3000 Hz. If you come to the upper or lower border of the range, you need more intensity to perceive a sound as &quot;equally loud&quot;. </p>
<p>These curves of equal loudness are mostly called &quot;Fletcher-Munson Curves&quot; because of the paper of H. Fletcher and W. A. Munson in 1933. They look like this:</p>
<p><img src="static/Fletcher-Munson.png" /> </p>
<p>Try the following test. In the first 5 seconds you will hear a tone of 3000 Hz. Adjust the level of your amplifier to the lowest possible point at which you still can hear the tone. - Then you hear a tone whose frequency starts at 20 Hertz and ends at 20000 Hertz, over 20 seconds. Try to move the fader or knob of your amplification exactly in a way that you still can hear anything, but as soft as possible. The movement of your fader should roughly be similar to the lowest Fletcher-Munson-Curve: starting relatively high, going down and down until 3000 Hertz, and then up again. (As always, this test depends on your speaker hardware. If your speaker do not provide proper lower frequencies, you will not hear anything in the bass region.)</p>
<p>   <em><strong>EXAMPLE 01C03.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1 ;table with a sine wave

instr 1
kfreq     expseg    p4, p3, p5
          printk    1, kfreq ;prints the frequencies once a second
asin      poscil    .2, kfreq, giSine
aout      linen     asin, .01, p3, .01
          outs      aout, aout
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5 1000 1000
i 1 6 20 20  20000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>It is very important to bear in mind that the perceived loudness depends much on the frequencies. You must know that putting out a sine of 30 Hz with a certain amplitude is totally different from a sine of 3000 Hz with the same amplitude - the latter will sound much louder.  </p>
<p><br />
</p>
<ol>
<li><span id="ch008_c-intensities.xhtml#InsertNoteID_6">cf Martin Neukom, Signale Systeme Klangsynthese, Zürich 2003, p. 383<span id="ch008_c-intensities.xhtml#InsertNoteID_6_LinkBacks"><sup><a href="c-intensities#InsertNoteID_6_marker7">^</a></sup></span></span></li>
</ol>
<p><span id="ch010_a-make-csound-run.xhtml"></span></p>
<h1>MAKE CSOUND RUN</h1>
<h2></h2>
<h2>Csound and Frontends</h2>
<p>The core element of Csound is an audio engine for the Csound language. It has no graphical elements and it is designed to take Csound text files (like &quot;.csd&quot; files) and produce audio, either in realtime, or by writing to a file. It can still be used in this way, but most users nowadays prefer to use Csound via a frontend. A frontend is an application which assists you in writing code and running Csound. Beyond the functions of a simple text editor, a frontend environment will offer colour coded highlighting of language specific keywords and quick access to an integrated help system. A frontend can also expand possibilities by providing tools to build interactive interfaces as well, sometimes, as advanced compositional tools.</p>
<p>In 2009 the Csound developers decided to include <a href="http://qutecsound.sourceforge.net">QuteCsound</a> as the standard frontend to be included with the Csound distribution, so you will already have this frontend if you have installed any of the recent pre-built versions of Csound. Conversely if you install a frontend you will require a separate installation of Csound in order for it to function. If you experience any problems with QuteCsound, or simply prefer another frontend design, try <a href="http://winxound.codeplex.com">WinXound</a> as alternative.<br />
</p>
<h2>How to Download and Install Csound</h2>
<p>To get Csound you first need to download the package for your system from the SourceForge page: <a href="http://sourceforge.net/projects/csound/files/csound5/" class="uri">http://sourceforge.net/projects/csound/files/csound5/</a></p>
<p>There are many files here, so here are some guidelines to help you choose the appropriate version.</p>
<h3>Windows</h3>
<p>Windows installers are the ones ending in <em>.exe</em>. Look for the latest version of Csound, and find a file which should be called something like: <em>Csound5.17-gnu-win32-d.exe</em>. The important thing to note is the final letter of the installer name, which can be &quot;d&quot; or &quot;f&quot;. This specifies the computation precision of the Csound engine. Float precision (32-bit float) is marked with &quot;f&quot; and double precision (64-bit float) is marked &quot;d&quot;. This is important to bear in mind, as a frontend which works with the &quot;floats&quot; version, will not run if you have the &quot;doubles&quot; version installed. <em><span></span></em>More recent versions of the pre-built Windows installer have only been released in the 'doubles' version.<em><br />
</em></p>
<p>After you have downloaded the installer, just run it and follow the instructions. When you are finished, you will find a Csound folder in your start menu containing Csound utilities and the CsoundQt (QuteCsound) frontend.<br />
</p>
<h3>Mac OS X</h3>
<p>The Mac OS X installers are the files ending in <em>.dmg</em>. Look for the latest version of Csound for your particular system, for example a Universal binary for 10.7 will be called something like: <em>csound5.17.3-OSX10.7-Universal.dmg</em>. When you double click the downloaded file, you will have a disk image on your desktop, with the Csound installer, CsoundQt and a readme file. Double-click the installer and follow the instructions. Csound and the basic Csound utilities will be installed. To install the CsoundQt frontend, you only need to move it to your Applications folder.</p>
<h3>Linux and others</h3>
<p>Csound is available from the official package repositories for many distributions like Debian, Ubuntu, Fedora, Archlinux and Gentoo. If there are no binary packages for your platform, or you need a more recent version, you can get the source package from the SourceForge page and build from source. Some build instructions can be find in the chapter BUILDING CSOUND in the appendix, and in the <a href="http://sourceforge.net/apps/mediawiki/csound/index.php?title=Main_Page">Csound Wiki on Sourceforge</a>. Detailed information can also be found in the <a href="http://www.csounds.com/manual/html/BuildingCsound.html">Building Csound Manual Page</a>.</p>
<p>Note that the Csound repository has moved from cvs to git. After installing git, you can use this command to clone the Csound5 repository, if you like to have access to the latest (perhaps unstable) sources:<br />
</p>
<pre><code>git clone git://csound.git.sourceforge.net/gitroot/csound/csound5</code></pre>
<h3>Android and iOS<br />
</h3>
<p>Recently Csound has been ported to Android and iOS. At the time of writing this release, it is too early for a description. If you are interested, you may have a look at <a href="http://sourceforge.net/projects/csound/files/csound5" class="uri">http://sourceforge.net/projects/csound/files/csound5</a> or at the paper from Victor Lazzarini and Steven Yi at the <a href="http://lac.linuxaudio.org/2012/">2012 Linux Audio Conference</a>.<br />
</p>
<h2>Install Problems?</h2>
<p>If, for any reason, you can't find the CsoundQt (formerly QuteCsound) frontend on your system after install, or if you want to install the most recent version of CsoundQt, or if you prefer another frontend altogether: see the CSOUND FRONTENDS section of this manual for further information. If you have any install problems, consider joining the <a href="http://www.csounds.com/community">Csound Mailing List</a> to report your issues, or write a mail to one of the maintainers (see ON THIS RELEASE).<br />
</p>
<h2>The Csound Reference Manual</h2>
<p>The Csound Reference Manual is an indispensable companion to Csound. It is available in various formats from the same place as the Csound installers, and it is installed with the packages for OS X and Windows. It can also be browsed online at <a href="http://www.csounds.com/manual/html/index.html">The Csound Manual Section at Csounds.com</a>. Many frontends will provide you with direct and easy access to it.</p>
<h2>How to Execute a Simple Example</h2>
<h3><strong>Using CsoundQt</strong></h3>
<p>Run CsoundQt. Go into the CsoundQt menubar and choose: Examples-&gt;Getting started...-&gt; Basics-&gt; HelloWorld</p>
<p>You will see a very basic Csound file (.csd) with a lot of comments in green.</p>
<p>Click on the &quot;RUN&quot; icon in the CsoundQt control bar to start the realtime Csound engine. You should hear a 440 Hz sine wave.</p>
<p>You can also run the Csound engine in the terminal from within QuteCsound. Just click on &quot;Run in Term&quot;. A console will pop up and Csound will be executed as an independent process. The result should be the same - the 440 Hz &quot;beep&quot;.</p>
<h3><strong>Using the Terminal / Console</strong></h3>
<p>1. Save the following code in any plain text editor as HelloWorld.csd.</p>
<p>   <em><strong>EXAMPLE 02A01.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Alex Hofmann
instr 1
aSin      oscils    0dbfs/4, 440, 0
          out       aSin
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>2. Open the Terminal / Prompt / Console</p>
<p>3. Type: <em>csound /full/path/HelloWorld.csd</em></p>
<p>where <em>/full/path/HelloWorld.csd</em> is the complete path to your file. You also execute this file by just typing <em>csound</em> then dragging the file into the terminal window and then hitting return.<br />
</p>
<p>You should hear a 440 Hz tone.<br />
</p>
<h2></h2>
<p><span id="ch011_b-csound-syntax.xhtml"></span></p>
<h1>CSOUND SYNTAX</h1>
<h2>Orchestra and Score<br />
</h2>
<p>In Csound, you must define &quot;instruments&quot;, which are units which &quot;do things&quot;, for instance playing a sine wave. These instruments must be called or &quot;turned on&quot; by a &quot;score&quot;. The Csound &quot;score&quot; is a list of events which describe how the instruments are to be played in time. It can be thought of as a timeline in text.</p>
<p>A Csound instrument is contained within an Instrument Block, which starts with the keyword <a href="http://www.csounds.com/manual/html/instr.html">instr</a> and ends with the keyword <a href="http://www.csounds.com/manual/html/endin.html">endin</a>. All instruments are given a number (or a name) to identify them.<br />
</p>
<pre><code>instr 1
... instrument instructions come here...
endin</code></pre>
<p>Score events in Csound are individual text lines, which can turn on instruments for a certain time. For example, to turn on instrument 1, at time 0, for 2 seconds you will use:</p>
<pre><code>i 1 0 2</code></pre>
<h2>The Csound Document Structure<br />
</h2>
<p>A Csound document is structured into three main sections:</p>
<ul>
<li><strong>CsOptions</strong>: Contains the configuration options for Csound. For example using &quot;-o dac&quot; in this section will make Csound run in real-time instead of writing a sound file.<br />
</li>
<li><strong>CsInstruments</strong>: Contains the instrument definitions and optionally some global settings and definitions like sample rate, etc.<br />
</li>
<li><strong>CsScore</strong>: Contains the score events which trigger the instruments.<br />
</li>
</ul>
<p>Each of these sections is opened with a &lt;xyz&gt; tag and closed with a &lt;/xyz&gt; tag. Every Csound file starts with the &lt;CsoundSynthesizer&gt; tag, and ends with &lt;/CsoundSynthesizer&gt;. Only the text in-between will be used by Csound.</p>
<p>   <em><strong>EXAMPLE 02B01.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;; START OF A CSOUND FILE

&lt;CsOptions&gt; ; CSOUND CONFIGURATION
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt; ; INSTRUMENT DEFINITIONS GO HERE

; Set the audio sample rate to 44100 Hz
sr = 44100

instr 1
; a 440 Hz Sine Wave
aSin      oscils    0dbfs/4, 440, 0
          out       aSin
endin
&lt;/CsInstruments&gt;

&lt;CsScore&gt; ; SCORE EVENTS GO HERE
i 1 0 1
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt; ; END OF THE CSOUND FILE
; Anything after is ignored by Csound</code></pre>
<p>Comments, which are lines of text that Csound will ignore, are started with the &quot;;&quot; character. Multi-line comments can be made by encasing them between &quot;/*&quot; and  &quot;*/&quot;.</p>
<h2>Opcodes</h2>
<p>&quot;Opcodes&quot; or &quot;Unit generators&quot; are the basic building blocks of Csound. Opcodes can do many things like produce oscillating signals, filter signals, perform mathematical functions or even turn on and off instruments. Opcodes, depending on their function, will take inputs and outputs. Each input or output is called, in programming terms, an &quot;argument&quot;. Opcodes always take input arguments on the right and output their results on the left, like this:<br />
</p>
<pre><code>output    OPCODE    input1, input2, input3, .., inputN</code></pre>
<p>For example the <a href="http://www.csounds.com/manual/html/oscils.html">oscils</a> opcode has three inputs: amplitude, frequency and phase, and produces a sine wave signal:</p>
<pre><code>aSin      oscils    0dbfs/4, 440, 0</code></pre>
<p>In this case, a 440 Hertz oscillation starting at phase 0 radians, with an amplitude of <em>0dbfs/4</em> (a quarter of 0 dB as full scale) will be created and its output will be stored in a container called <em>aSin</em>. The order of the arguments is important: the first input to <em>oscils</em> will always be amplitude, the second, frequency and the third, phase.</p>
<p>Many opcodes include optional input arguments and occasionally optional output arguments. These will always be placed after the essential arguments. In the Csound Manual documentation they are indicated using square brackets &quot;[]&quot;. If optional input arguments are omitted they are replaced with the default values indicated in the Csound Manual. The addition of optional output arguments normally initiates a different mode of that opcode: for example, a stereo as opposed to mono version of the opcode.<br />
</p>
<h2>Variables</h2>
<p>A &quot;variable&quot; is a named container. It is a place to store things like signals or values from where they can be recalled by using their name. In Csound there are various types of variables. The easiest way to deal with variables when getting to know Csound is to imagine them as cables.</p>
<p>If you want to patch this together: Oscillator-&gt;Filter-&gt;Output,</p>
<p>you need two cables, one going out from the oscillator into the filter and one from the filter to the output. The cables carry audio signals, which are variables beginning with the letter &quot;a&quot;.<br />
</p>
<pre><code>aSource    buzz       0.8, 200, 10, 1
aFiltered  moogladder aSource, 400, 0.8
           out        aFiltered</code></pre>
<p>In the example above, the <a href="http://www.csounds.com/manual/html/buzz.html">buzz</a> opcode produces a complex waveform as signal <em>aSource</em>. This signal is fed into the <a href="http://www.csounds.com/manual/html/moogladder.html">moogladder</a> opcode, which in turn produces the signal <em>aFiltered</em>. The <a href="http://www.csounds.com/manual/html/out.html">out</a> opcode takes this signal, and sends it to the output whether that be to the speakers or to a rendered file.</p>
<p>Other common variable types are &quot;k&quot; variables which store control signals, which are updated less frequently than audio signals, and &quot;i&quot; variables which are constants within each instrument note.</p>
<p>You can find more information about variable types <a href="http://en.flossmanuals.net/bin/view/Csound/LOCALANDGLOBALVARIABLES">here</a> in this manual, or <a href="http://www.csounds.com/journal/issue10/CsoundRates.html">here</a> in the Csound Journal.<br />
</p>
<h2>Using The Manual</h2>
<p>The <a href="http://www.csounds.com/manual/html/indexframes.html">Csound Reference Manual</a> is a comprehensive source regarding Csound's syntax and opcodes. All opcodes have their own manual entry describing their syntax and behavior, and the manual contains a detailed reference on the Csound language and options.</p>
<p>In <a href="http://qutecsound.sourceforge.net">CsoundQt</a> you can find the Csound Manual in the Help Menu. You can quickly go to a particular opcode entry in the manual by putting the cursor on the opcode and pressing Shift+F1. <a href="http://winxound.codeplex.com">WinXsound</a> and <a href="http://blue.kunstmusik.com/">Blue</a> also provide easy access to the manual.<br />
</p>
<p><span id="ch012_c-configuring-midi.xhtml"></span></p>
<h1>CONFIGURING MIDI</h1>
<p>Csound can receive MIDI events (like MIDI notes and MIDI control changes) from an external MIDI interface or from another program via a virtual MIDI cable. This information can be used to control any aspect of synthesis or performance.</p>
<p>Csound receives MIDI data through MIDI Realtime Modules. These are special Csound plugins which enable MIDI input using different methods according to platform. They are enabled using the <em>-+rtmidi</em> <a href="http://www.csounds.com/manual/html/CommandFlagsCategory.html">command line flag</a> in the <em>&lt;CsOptions&gt;</em> section of your .csd file, but can also be set interactively on some front-ends via the configure dialog setups.<br />
</p>
<p>There is the universal &quot;portmidi&quot; module. <a href="http://portmedia.sourceforge.net/">PortMidi</a> is a cross-platform module for MIDI I/O and should be available on all platforms. To enable the &quot;portmidi&quot; module, you can use the flag:</p>
<pre><code>-+rtmidi=portmidi</code></pre>
<p>After selecting the RT MIDI module from a front-end or the command line, you need to select the MIDI devices for input and output. These are set using the flags -M and -Q respectively followed by the number of the interface. You can usually use:</p>
<pre><code>-M999</code></pre>
<p>To get a performance error with a listing of available interfaces.</p>
<p>For the PortMidi module (and others like ALSA), you can specify no number to use the default MIDI interface or the 'a' character to use all devices. This will even work when no MIDI devices are present.</p>
<pre><code>-Ma</code></pre>
<p>So if you want MIDI input using the portmidi module, using device 2 for input and device 1 for output, your <em>&lt;CsOptions&gt;</em> section should contain:</p>
<pre><code>-+rtmidi=portmidi -M2 -Q1</code></pre>
<p>There is a special &quot;virtual&quot; RT MIDI module which enables MIDI input from a <a href="http://www.csounds.com/manual/html/MidiTop.html#MidiVirtual">virtual keyboard</a>. To enable it, you can use:</p>
<pre><code> -+rtmidi=virtual -M0</code></pre>
<h2>Platform Specific Modules</h2>
<p>If the &quot;portmidi&quot; module is not working properly for some reason, you can try other platform specific modules.<br />
</p>
<h3>Linux<br />
</h3>
<p>On Linux systems, you might also have an &quot;alsa&quot; module to use the alsa raw MIDI interface. This is different from the more common alsa sequencer interface and will typically require the snd-virmidi module to be loaded.</p>
<h3>OS X</h3>
<p>On OS X you may have a &quot;coremidi&quot; module available.</p>
<h3>Windows</h3>
<p>On Windows, you may have a &quot;winmme&quot; MIDI module.</p>
<h2>MIDI I/O in CsoundQt</h2>
<p>As with Audio I/O, you can set the MIDI preferences in the configuration dialog. In it you will find a selection box for the RT MIDI module, and text boxes for MIDI input and output devices.</p>
<p><img src="static/QuteCsoundMidiConfiguration.png" /> <br />
</p>
<h2>How to Use a MIDI Keyboard</h2>
<p>Once you've set up the hardware, you are ready to receive MIDI information and interpret it in Csound. By default, when a MIDI note is received, it turns on the Csound instrument corresponding to its channel number, so if a note is received on channel 3, it will turn on instrument 3, if it is received on channel 10, it will turn on instrument 10 and so on.</p>
<p>If you want to change this routing of MIDI channels to instruments, you can use the <a href="http://www.csounds.com/manual/html/massign.html">massign</a> opcode. For instance, this statement lets you route your MIDI channel 1 to instrument 10:</p>
<pre><code> massign 1, 10</code></pre>
<p>On the following example, a simple instrument, which plays a sine wave, is defined in instrument 1. There are no score note events, so no sound will be produced unless a MIDI note is received on channel 1.</p>
<p>   <em><strong>EXAMPLE 02C01.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-+rtmidi=portmidi -Ma -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Andrés Cabrera

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

        massign   0, 1 ;assign all MIDI channels to instrument 1
giSine  ftgen     0,0,2^10,10,1 ;a function table with a sine wave

instr 1
iCps    cpsmidi   ;get the frequency from the key pressed
iAmp    ampmidi   0dbfs * 0.3 ;get the amplitude
aOut    poscil    iAmp, iCps, giSine ;generate a sine tone
        outs      aOut, aOut ;write it to the output
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
e 3600
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Note that Csound has an unlimited polyphony in this way: each key pressed starts a new instance of instrument 1, and you can have any number of instrument instances at the same time.<br />
</p>
<h2>How to Use a MIDI Controller</h2>
<p>To receive MIDI controller events, opcodes like <a href="http://www.csounds.com/manual/html/ctrl7.html">ctrl7</a> <em></em> can be used.  In the following example instrument 1 is turned on for 60 seconds. It will receive controller #1 (modulation wheel) on channel 1 and convert MIDI range (0-127) to a range between 220 and 440. This value is used to set the frequency of a simple sine oscillator.</p>
<p>   <em><strong>EXAMPLE 02C02.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-+rtmidi=virtual -M1 -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Andrés Cabrera

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine ftgen 0,0,2^10,10,1

instr 1
; --- receive controller number 1 on channel 1 and scale from 220 to 440
kFreq ctrl7  1, 1, 220, 440
; --- use this value as varying frequency for a sine wave
aOut  poscil 0.2, kFreq, giSine
      outs   aOut, aOut
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 60
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Other Type of MIDI Data</h2>
<p>Csound can receive other type of MIDI, like pitch bend, and aftertouch through the usage of specific opcodes. Generic MIDI Data can be received using the <a href="http://www.csounds.com/manual/html/midiin.html">midiin</a> opcode. The example below prints to the console the data received via MIDI.</p>
<p>   <em><strong>EXAMPLE 02C03.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-+rtmidi=portmidi -Ma -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Andrés Cabrera

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
kStatus, kChan, kData1, kData2 midiin

if kStatus != 0 then ;print if any new MIDI message has been received
    printk 0, kStatus
    printk 0, kChan
    printk 0, kData1
    printk 0, kData2
endif

endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i1 0 3600
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span id="ch013_d-live-audio.xhtml"></span></p>
<h1>LIVE AUDIO</h1>
<h2>Configuring Audio &amp; Tuning Audio Performance</h2>
<h3>Selecting Audio Devices and Drivers<br />
</h3>
<p>Csound relates to the various inputs and outputs of sound devices installed on your computer as a numbered list. If you are using a multichannel interface then each stereo pair will most likely be assigned a different number. If you wish to send or receive audio to or from a specific audio connection you will need to know the number by which Csound knows it. If you are not sure of what that is you can trick Csound into providing you with a list of available devices by trying to run Csound using an obviously out of range device number, like this:</p>
<p>   <em><strong>EXAMPLE 02D01.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-iadc999 -odac999
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Andrés Cabrera
instr 1
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The input and output devices will be listed seperately. Specify your input device with the <strong>-iadc</strong> flag and the number of your input device, and your output device with the <strong>-odac</strong> flag and the number of your output device. For instance, if you select the &quot;XYZ&quot; device from the list above both, for input and output, you may include something like</p>
<pre><code> -iadc2 -odac3</code></pre>
<p>in the &lt;CsOptions&gt; section of you .csd file.<br />
</p>
<p>The RT (= real-time) output module can be set with the <strong>-+rtaudio</strong> flag. If you don't use this flag, the PortAudio driver will be used. Other possible drivers are jack and alsa (Linux), mme (Windows) or CoreAudio (Mac). So, this sets your audio driver to mme instead of Port Audio:<br />
</p>
<pre><code>-+rtaudio=mme</code></pre>
<h3>Tuning Performance and Latency<br />
</h3>
<p>Live performance and latency depend mainly on the sizes of the software and the hardware buffers. They can be set in the &lt;CsOptions&gt; using the -B flag for the hardware buffer, and the -b flag for the software buffer. For instance, this statement sets the hardware buffer size to 512 samples and the software buffer size to 128 sample:<br />
</p>
<pre><code>-B512 -b128</code></pre>
<p>The other factor which affects Csound's live performance is the <a href="http://www.csounds.com/manual/html/ksmps.html">ksmps</a> value which is set in the header of the &lt;CsInstruments&gt; section. By this value, you define how many samples are processed every Csound control cycle.<br />
</p>
<p>Try your realtime performance with -B512, -b128 and ksmps=32. With a software buffer of 128 samples, a hardware buffer of 512 and a sample rate of 44100 you will have around 12ms latency, which is usable for live keyboard playing. If you have problems with either the latency or the performance, tweak the values as described <a href="http://www.csounds.com/manual/html/UsingOptimizing.html">here</a>.<br />
<br />
</p>
<h3><strong>CsoundQt</strong></h3>
<p>To define the audio hardware used for realtime performance, open the configuration dialog. In the &quot;Run&quot; Tab, you can choose your audio interface, and the preferred driver. You can select input and output devices from a list if you press the buttons to the right of the text boxes for input and output names. Software and hardware buffer sizes can be set at the top of this dialogue box.<br />
<br />
</p>
<p>  <img src="static/Csound-Picts-02_QuickStart-Screenshot_QuteCsound_Configuration-en.png" alt="Screenshot_QuteCsound_Configuration.png" width="600" height="523" /><br />
</p>
<h2>Csound Can Produce Extreme Dynamic Range!</h2>
<p>Csound can <strong>produce extreme dynamic range</strong>, so keep an eye on the level you are sending to your output. The number which describes the level of 0 dB, can be set in Csound by the <a href="http://www.csounds.com/manual/html/Zerodbfs.html">0dbfs</a> assignment in the &lt;CsInstruments&gt; header. There is no limitation, if you set 0dbfs = 1 and send a value of 32000, <em>this can damage your ears and speakers!</em><br />
</p>
<h2>Using Live Audio Input and Output</h2>
<p>To process audio from an external source (for example a microphone), use the <a href="http://www.csounds.com/manual/html/inch.html">inch</a> opcode to access any of the inputs of your audio input device. For the output, <a href="http://www.csounds.com/manual/html/outch.html">outch</a> gives you all necessary flexibility. The following example takes a live audio input and transforms its sound using ring modulation. The Csound Console should output five times per second the input amplitude level.</p>
<p>   <em><strong>EXAMPLE 02D02.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
;CHANGE YOUR INPUT AND OUTPUT DEVICE NUMBER HERE IF NECESSARY!
-iadc0 -odac0 -B512 -b128
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100 ;set sample rate to 44100 Hz
ksmps = 32 ;number of samples per control cycle
nchnls = 2 ;use two audio channels
0dbfs = 1 ;set maximum level as 1

giSine    ftgen     0, 0, 2^10, 10, 1 ;table with sine wave

instr 1
aIn       inch      1   ;take input from channel 1
kInLev    downsamp  aIn ;convert audio input to control signal
          printk    .2, abs(kInLev)
;make modulator frequency oscillate 200 to 1000 Hz
kModFreq  poscil    400, 1/2, giSine
kModFreq  =         kModFreq+600
aMod      poscil    1, kModFreq, giSine ;modulator signal
aRM       =         aIn * aMod ;ring modulation
          outch     1, aRM, 2, aRM ;output to channel 1 and 2
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3600
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Live Audio is frequently used with live devices like widgets or MIDI. In CsoundQt, you can find several examples in Examples -&gt; Getting Started -&gt; Realtime Interaction.<br />
</p>
<p><span id="ch014_e-rendering-to-file.xhtml"></span></p>
<h1>RENDERING TO FILE</h1>
<h2>When to Render to File</h2>
<p>Csound can also render audio straight to a sound file stored on your hard drive instead of as live audio sent to the audio hardware. This gives you the possibility to hear the results of very complex processes which your computer can't produce in realtime.</p>
<p>Csound can render to formats like wav, aiff or ogg (and other less popular ones), but not mp3 due to its patent and licencing problems.</p>
<h2>Rendering to File</h2>
<p>Save the following code as Render.csd:</p>
<p>   <em><strong>EXAMPLE 02E01.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o Render.wav
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Alex Hofmann
instr 1
aSin      oscils    0dbfs/4, 440, 0
          out       aSin
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Open the Terminal / Prompt / Console and type:</p>
<pre><code>csound /path/to/Render.csd</code></pre>
<p>Now, because you changed the <strong>-o</strong> flag in the &lt;CsOptions&gt; from &quot;-o dac&quot; to &quot;-o <em>filename</em>&quot;, the audio output is no longer written in realtime to your audio device, but instead to a file. The file will be rendered to the default directory (usually the user home directory). This file can be opened and played in any audio player or editor, e.g. Audacity. (By default, csound is a non-realtime program. So if no command line options are given, it will always render the csd to a file called <em>test.wav</em>, and you will hear nothing in realtime.)<br />
</p>
<p>The <strong>-o</strong> flag can also be used to write the output file to a certain directory. Something like this for Windows ...<br />
</p>
<pre><code>&lt;CsOptions&gt;
-o c:/music/samples/Render.wav
&lt;/CsOptions&gt;</code></pre>
<p>... and this for Linux or Mac OSX:</p>
<pre><code>&lt;CsOptions&gt;
-o /Users/JSB/organ/tatata.wav
&lt;/CsOptions&gt;  </code></pre>
<h3>Rendering Options</h3>
<p>The internal rendering of audio data in Csound is done with 32-bit floating point numbers (or even with 64-bit numbers for the &quot;double&quot; version). Depending on your needs, you should decide the precision of your rendered output file:</p>
<ul>
<li>If you want to render 32-bit floats, use the option flag <strong>-f</strong>.</li>
<li>If you want to render 24-bit, use the flag <strong>-3</strong>.</li>
<li>If you want to render 16-bit, use the flag <strong>-s</strong> (or nothing, because this is also the default in Csound).</li>
</ul>
<p>For making sure that the header of your soundfile will be written correctly, you should use the <strong>-W</strong> flag for a WAV file, or the <strong>-A</strong> flag for a AIFF file. So these options will render the file &quot;Wow.wav&quot; as WAV file with 24-bit accuracy:</p>
<pre><code>&lt;CsOptions&gt;
-o Wow.wav -W -3
&lt;/CsOptions&gt;  </code></pre>
<h3>Realtime and Render-To-File at the Same Time<br />
</h3>
<p>Sometimes you may want to simultaneously have realtime output and file rendering to disk, like recording your live performance. This can be achieved by using the <a href="http://www.csounds.com/manual/html/fout.html">fout</a> opcode. You just have to specify your output file name. File type and format are given by a number, for instance 18 specifies &quot;wav 24 bit&quot; (see the manual page for more information). The following example creates a random frequency and panning movement of a sine wave, and writes it to the file &quot;live_record.wav&quot; (in the same directory as your .csd file):</p>
<p>   <em><strong>EXAMPLE 02E02.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0 ;each time different seed for random
giSine    ftgen     0, 0, 2^10, 10, 1 ;a sine wave

  instr 1
kFreq     randomi   400, 800, 1 ;random frequency
aSig      poscil    .2, kFreq, giSine ;sine with this frequency
kPan      randomi   0, 1, 1 ;random panning
aL, aR    pan2      aSig, kPan ;stereo output signal
          outs      aL, aR ;live output
          fout      &quot;live_record.wav&quot;, 18, aL, aR ;write to soundfile
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3><strong>CsoundQt</strong></h3>
<p>All the options which are described in this chapter can be handled very easily in CsoundQt:<br />
</p>
<ul>
<li>Rendering to file is simply done by clicking the &quot;Render&quot; button, or choosing &quot;Control-&gt;Render to File&quot; in the Menu.</li>
</ul>
<ul>
<li>To set file-destination and file-type, you can make your own settings in &quot;CsoundQt Configuration&quot; under the tab &quot;Run -&gt; File (offline render)&quot;. The default is a 16-Bit .wav-file.</li>
<li>To record a live performance, just click the &quot;Record&quot; button. You will find a file with the same name as your .csd file, and a number appended for each record task, in the same folder as your .csd file.<br />
</li>
</ul>
<p><span id="ch016_a-initialization-and-performance-pass.xhtml"></span></p>
<h1>INITIALIZATION AND PERFORMANCE PASS</h1>
<h2>What's The Difference</h2>
<p>A Csound instrument is defined in the &lt;CsInstruments&gt; section of a .csd file. An instrument definition starts with the keyword <a href="http://www.csounds.com/manual/html/instr.html">instr</a> (followed by a number or name to identify the instrument), and ends with the line <a href="http://www.csounds.com/manual/html/endin.html">endin</a>. Each instrument can be called by a score event which starts with the character &quot;i&quot;. For instance, this score line</p>
<pre><code>i 1 0 3</code></pre>
<p>calls instrument 1, starting at time 0, for 3 seconds. It is very important to understand that such a call consists of two different stages: the initialization and the performance pass.<br />
</p>
<p>At first, Csound initializes all the variables which begin with a <strong>i</strong> or a <strong>gi</strong>. This initialization pass is done just once.</p>
<p>After this, the actual performance begins. During this performance, Csound calculates all the time-varying values in the orchestra again and again. This is called the performance pass, and each of these calculations is called a control cycle (also abbreviated as k-cycle or k-loop). The time for each control cycle depends on the <a href="http://www.csounds.com/manual/html/ksmps.html">ksmps</a> constant in the orchestra header. If ksmps=10 (which is the default), the performance pass consists of 10 samples. If your sample rate is 44100, with ksmps=10 you will have 4410 control cycles per second (kr=4410), and each of them has a duration of 1/4410 = 0.000227 seconds. On each control cycle, all the variables starting with <strong>k</strong>, <strong>gk</strong>, <strong>a</strong> and <strong>ga</strong> are updated (see the next chapter about variables for more explanations).</p>
<p>This is an example instrument, containing i-, k- and a-variables:</p>
<p>   <em><strong>EXAMPLE 03A01.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 441
nchnls = 2
0dbfs = 1
instr 1
iAmp      =       p4 ;amplitude taken from the 4th parameter of the score line
iFreq     =       p5 ;frequency taken from the 5th parameter
; --- move from 0 to 1 in the duration of this instrument call (p3)
kPan      line      0, p3, 1
aNote     oscils  iAmp, iFreq, 0 ;create an audio signal
aL, aR    pan2    aNote, kPan ;let the signal move from left to right
          outs    aL, aR ;write it to the output
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3 0.2 443
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>As ksmps=441, each control cycle is 0.01 seconds long (441/44100). So this happens when the instrument call is performed:</p>
<p><img src="static/Csound-Picts-03_CsLanguage-InitAndPerfPass3-en.png" title="InitAndPerfPass3" alt="InitAndPerfPass3" /> <br />
</p>
<p>Here is another simple example which shows the internal loop at each k-cycle. As we print out the value at each control cycle, ksmps is very high here, so that each k-pass takes 0.1 seconds. The <a href="http://www.csounds.com/manual/html/init.html">init</a> opcode can be used to set a k-variable to a certain value first (at the init-pass), otherwise it will have the default value of zero until it is assigned something else during the first k-cycle.</p>
<p>   <em><strong>EXAMPLE 03A02.csd</strong></em>  <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410

instr 1
kcount    init      0; set kcount to 0 first
kcount    =         kcount + 1; increase at each k-pass
          printk    0, kcount; print the value
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Your output should contain the lines:</p>
<p>i   1 time     0.10000:     1.00000<br />
i   1 time     0.20000:     2.00000<br />
i   1 time     0.30000:     3.00000<br />
i   1 time     0.40000:     4.00000<br />
i   1 time     0.50000:     5.00000<br />
i   1 time     0.60000:     6.00000<br />
i   1 time     0.70000:     7.00000<br />
i   1 time     0.80000:     8.00000<br />
i   1 time     0.90000:     9.00000<br />
i   1 time     1.00000:    10.00000<br />
</p>
<p>Try changing the ksmps value from 4410 to 44100 and to 2205 and observe the difference.<br />
</p>
<h2>Reinitialization</h2>
<p>If you try the example above with i-variables, you will have no success, because the i-variable is calculated just once:</p>
<p>   <em><strong>EXAMPLE 03A03.csd</strong></em>  <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410

instr 1
icount    init      0          ;set icount to 0 first
icount    =         icount + 1 ;increase
          print     icount     ;print the value
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The printout is:</p>
<p>instr 1:  icount = 1.000<br />
</p>
<p>Nevertheless it is possible to refresh even an i-rate variable in Csound. This is done with the <a href="http://www.csounds.com/manual/html/reinit.html">reinit</a> opcode. You must mark a section by a label (any name followed by a colon). Then the reinit statement will cause the i-variable to refresh. Use <a href="http://www.csounds.com/manual/html/rireturn.html">rireturn</a> to end the reinit section.</p>
<p>   <em><strong>EXAMPLE 03A04.csd</strong></em>  <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410

instr 1
icount    init      0          ; set icount to 0 first
new:
icount    =         icount + 1 ; increase
          print     icount     ; print the value
          reinit    new        ; reinit the section each k-pass
          rireturn
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This prints now:</p>
<p>instr 1:  icount = 1.000<br />
instr 1:  icount = 2.000<br />
instr 1:  icount = 3.000<br />
instr 1:  icount = 4.000<br />
instr 1:  icount = 5.000<br />
instr 1:  icount = 6.000<br />
instr 1:  icount = 7.000<br />
instr 1:  icount = 8.000<br />
instr 1:  icount = 9.000<br />
instr 1:  icount = 10.000<br />
instr 1:  icount = 11.000<br />
</p>
<h2>Order Of Calculation</h2>
<p>Sometimes it is very important to observe the order in which the instruments of a Csound orchestra are evaluated. This order is given by the instrument numbers. So, if you want to use during the same performance pass a value in instrument 10 which is generated by another instrument, you must not give this instrument the number 11 or higher. In the following example, first instrument 10 uses a value of instrument 1, then a value of instrument 100.</p>
<p>   <em><strong>EXAMPLE 03A05.csd</strong></em>  </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410

instr 1
gkcount   init      0 ;set gkcount to 0 first
gkcount   =         gkcount + 1 ;increase
endin

instr 10
          printk    0, gkcount ;print the value
endin

instr 100
gkcount   init      0 ;set gkcount to 0 first
gkcount   =         gkcount + 1 ;increase
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;first i1 and i10
i 1 0 1
i 10 0 1
;then i100 and i10
i 100 1 1
i 10 1 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The output shows the difference:</p>
<p>new alloc for instr 1:<br />
new alloc for instr 10:<br />
 i  10 time     0.10000:     1.00000<br />
 i  10 time     0.20000:     2.00000<br />
 i  10 time     0.30000:     3.00000<br />
 i  10 time     0.40000:     4.00000<br />
 i  10 time     0.50000:     5.00000<br />
 i  10 time     0.60000:     6.00000<br />
 i  10 time     0.70000:     7.00000<br />
 i  10 time     0.80000:     8.00000<br />
 i  10 time     0.90000:     9.00000<br />
 i  10 time     1.00000:    10.00000<br />
B  0.000 ..  1.000 T  1.000 TT  1.000 M:      0.0<br />
new alloc for instr 100:<br />
 i  10 time     1.10000:     0.00000<br />
 i  10 time     1.20000:     1.00000<br />
 i  10 time     1.30000:     2.00000<br />
 i  10 time     1.50000:     4.00000<br />
 i  10 time     1.60000:     5.00000<br />
 i  10 time     1.70000:     6.00000<br />
 i  10 time     1.80000:     7.00000<br />
 i  10 time     1.90000:     8.00000<br />
 i  10 time     2.00000:     9.00000<br />
B  1.000 ..  2.000 T  2.000 TT  2.000 M:      0.0<br />
</p>
<h2>About &quot;i-time&quot; And &quot;k-rate&quot; Opcodes</h2>
<p>It is often confusing for the beginner that there are some opcodes which only work at &quot;i-time&quot; or &quot;i-rate&quot;, and others which only work at &quot;k-rate&quot; or &quot;k-time&quot;. For instance, if the user wants to print the value of any variable, he thinks: &quot;OK - print it out.&quot; But Csound replies: &quot;Please, tell me first if you want to print an i- or a k-variable&quot; (see the following section about the variable types).</p>
<p>For instance, the <a href="http://csounds.com/manual/html/print.html">print</a> opcode just prints variables which are updated at each initialization pass (&quot;i-time&quot; or &quot;i-rate&quot;). If you want to print a variable which is updated at each control cycle (&quot;k-rate&quot; or &quot;k-time&quot;), you need its counterpart <a href="http://csounds.com/manual/html/printk.html">printk</a>. (As the performance pass is usually updated some thousands times per second, you have an additional parameter in printk, telling Csound how often you want to print out the k-values.)</p>
<p>So, some opcodes are just for i-rate variables, like <a href="http://csounds.com/manual/html/filelen.html">filelen</a> or <a href="http://csounds.com/manual/html/ftgen.html">ftgen</a>. Others are just for k-rate variables like <a href="http://csounds.com/manual/html/metro.html">metro</a> or <a href="http://csounds.com/manual/html/max_k.html">max_k</a>. Many opcodes have variants for either i-rate-variables or k-rate-variables, like <a href="http://csounds.com/manual/html/printf.html">printf_i</a> and <a href="http://csounds.com/manual/html/printf.html">printf</a>, <a href="http://csounds.com/manual/html/sprintf.html">sprintf</a> and <a href="http://csounds.com/manual/html/sprintf.html">sprintfk</a>, <a href="http://csounds.com/manual/html/strindex.html">strindex</a> and <a href="http://csounds.com/manual/html/strindexk.html">strindexk</a>.</p>
<p>Most of the Csound opcodes are able to work either at i-time or at k-time or at audio-rate, but you have to think carefully what you need, as the behaviour will be very different if you choose the i-, k- or a-variante of an opcode. For example, the <a href="http://csounds.com/manual/html/random.html">random</a> opcode can work at all three rates:</p>
<pre><code>ires      random    imin, imax : works at &quot;i-time&quot;
kres      random    kmin, kmax : works at &quot;k-rate&quot;
ares      random    kmin, kmax : works at &quot;audio-rate&quot;</code></pre>
<p>If you use the i-rate random generator, you will get one value for each note. For instance, if you want to have a different pitch for each note you are generating, you will use this one.</p>
<p>If you use the k-rate random generator, you will get one new value on every control cycle. If your sample rate is 44100 and your ksmps=10, you will get 4410 new values per second! If you take this as pitch value for a note, you will hear nothing but a noisy jumping. If you want to have a moving pitch, you can use the <a href="http://csounds.com/manual/html/randomi.html">randomi</a> variant of the k-rate random generator, which can reduce the number of new values per second, and interpolate between them.</p>
<p>If you use the a-rate random generator, you will get as many new values per second as your sample rate is. If you use it in the range of your 0 dB amplitude, you produce white noise.</p>
<p>   <em><strong>EXAMPLE 03A06.csd</strong></em>  </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
0dbfs = 1
nchnls = 2

          seed      0 ;each time different seed
giSine    ftgen     0, 0, 2^10, 10, 1 ;sine table

instr 1 ;i-rate random
iPch      random    300, 600
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, iPch, giSine
          outs      aSine, aSine
endin

instr 2 ;k-rate random: noisy
kPch      random    300, 600
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, kPch, giSine
          outs      aSine, aSine
endin

instr 3 ;k-rate random with interpolation: sliding pitch
kPch      randomi   300, 600, 3
aAmp      linseg    .5, p3, 0
aSine     poscil    aAmp, kPch, giSine
          outs      aSine, aSine
endin

instr 4 ;a-rate random: white noise
aNoise    random    -.1, .1
          outs      aNoise, aNoise
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0   .5
i 1 .25 .5
i 1 .5  .5
i 1 .75 .5
i 2 2   1
i 3 4   2
i 3 5   2
i 3 6   2
i 4 9   1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Timelessness And Tick Size In Csound<br />
</h2>
<p>In a way it is confusing to speak from &quot;i-time&quot;. For Csound, &quot;time&quot; actually begins with the first performance pass. The initalization time is actually the &quot;time zero&quot;. Regardless how much human time or CPU time is needed for the initialization pass, the Csound clock does not move at all. This is the reason why you can use any i-time opcode with a zero duration (p3) in the score:</p>
<p>   <em><strong>EXAMPLE 03A07.csd</strong></em>  <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
instr 1
prints &quot;%nHello Eternity!%n%n&quot;
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0 ;let instrument 1 play for zero seconds ...
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Csound's clock is the control cycle. The number of samples in one control cycle - given by the <a href="http://www.csounds.com/manual/html/ksmps.html">ksmps</a> value - is the smallest possible &quot;tick&quot; in Csound at k-rate. If your sample rate is 44100, and you have 4410 samples in one control cycle (ksmps=4410), you will not be able to start a k-event faster than each 1/10 second, because there is no k-time for Csound &quot;between&quot; two control cycles. Try the following example with larger and smaller ksmps values:</p>
<p>   <em><strong>EXAMPLE 03A08.csd</strong></em>   <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410; try 44100 or 2205 instead

instr 1; prints the time once in each control cycle
kTimek   timek
kTimes   times
         printks    &quot;Number of control cycles = %d%n&quot;, 0, kTimek
         printks    &quot;Time = %f%n%n&quot;, 0, kTimes
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Consider typical size of 32 for ksmps. When sample rate is 44100, a single tick will be less than a millisecond. This should be sufficient for in most situations. If you need a more accurate time resolution, just decrease the ksmps value. The cost of this smaller tick size is a smaller computational efficiency. So your choice depends on the situation, and usually a ksmps of 32 represents a good tradeoff.</p>
<p>Of course the precision of writing samples (at a-rate) is in no way affected by the size of the internal k-ticks. Samples are indeed written &quot;in between&quot; control cycles, because they are vectors. So it can be necessary to use a-time variables instead of k-time variables in certain situations. In the following example, the ksmps value is rather high (128). If you use a k-rate variable for a fast moving envelope, you will hear a certain roughness (instrument 1) sometime referred to as 'zipper' noise. If you use an a-rate variable instead, you will have a much cleaner sound (instr 2).</p>
<p>   <em><strong>EXAMPLE 03A09.csd</strong></em>   <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
;--- increase or decrease to hear the difference more or less evident
ksmps = 128
nchnls = 2
0dbfs = 1

instr 1 ;envelope at k-time
aSine     oscils    .5, 800, 0
kEnv      transeg   0, .1, 5, 1, .1, -5, 0
aOut      =         aSine * kEnv
          outs      aOut, aOut
endin

instr 2 ;envelope at a-time
aSine     oscils    .5, 800, 0
aEnv      transeg   0, .1, 5, 1, .1, -5, 0
aOut      =         aSine * aEnv
          outs      aOut, aOut
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
r 5 ;repeat the following line 5 times
i 1 0 1
s ;end of section
r 5
i 2 0 1
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span></span></p>
<p><span id="ch017_b-local-and-global-variables.xhtml"></span></p>
<h1>LOCAL AND GLOBAL VARIABLES</h1>
<h2>Variable Types</h2>
<p>In Csound, there are several types of variables. It is important to understand the differences of these types. There are</p>
<ul>
<li><strong>initialization</strong> variables, which are updated at each initialization pass, i.e. at the beginning of each note or score event. They start with the character <strong>i</strong>. To this group count also the score parameter fields, which always starts with a <strong>p</strong>, followed by any number: <em>p1</em> refers to the first parameter field in the score, <em>p2</em> to the second one, and so on. </li>
<li><strong>control</strong> variables, which are updated at each control cycle (performance pass). They start with the character <strong>k</strong>.</li>
<li><strong>audio</strong> variables, which are also updated at each control cycle, but instead of a single number (like control variables) they consist of a vector (a collection of numbers), having in this way one number for each sample. They start with the character <strong>a</strong>.</li>
<li><strong>string</strong> variables, which are updated either at i-time or at k-time (depending on the opcode which produces a string). They start with the character <strong>S</strong>.</li>
</ul>
<p>Except these four standard types, there are two other variable types which are used for spectral processing:</p>
<ul>
<li><strong>f</strong>-variables are used for the streaming phase vocoder opcodes (all starting with the characters <strong>pvs</strong>), which are very important for doing realtime FFT (Fast Fourier Transformation) in Csound. They are updated at k-time, but their values depend also on the FFT parameters like frame size and overlap.<br />
</li>
<li><strong>w</strong>-variables are used in some older spectral processing opcodes.</li>
</ul>
<p>The following example exemplifies all the variable types (except the w-type):</p>
<p>   <em><strong>EXAMPLE 03B01.csd</strong></em>   <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
0dbfs = 1
nchnls = 2

          seed      0; random seed each time different

  instr 1; i-time variables
iVar1     =         p2; second parameter in the score
iVar2     random    0, 10; random value between 0 and 10
iVar      =         iVar1 + iVar2; do any math at i-rate
          print     iVar1, iVar2, iVar
  endin

  instr 2; k-time variables
kVar1     line       0, p3, 10; moves from 0 to 10 in p3
kVar2     random     0, 10; new random value each control-cycle
kVar      =          kVar1 + kVar2; do any math at k-rate
; --- print each 0.1 seconds
printks   &quot;kVar1 = %.3f, kVar2 = %.3f, kVar = %.3f%n&quot;, 0.1, kVar1, kVar2, kVar
  endin

  instr 3; a-variables
aVar1     oscils     .2, 400, 0; first audio signal: sine
aVar2     rand       1; second audio signal: noise
aVar3     butbp      aVar2, 1200, 12; third audio signal: noise filtered
aVar      =          aVar1 + aVar3; audio variables can also be added
          outs       aVar, aVar; write to sound card
  endin

  instr 4; S-variables
iMyVar    random     0, 10; one random value per note
kMyVar    random     0, 10; one random value per each control-cycle
 ;S-variable updated just at init-time
SMyVar1   sprintf   &quot;This string is updated just at init-time:
                     kMyVar = %d\n&quot;, iMyVar
          printf_i  &quot;%s&quot;, 1, SMyVar1
 ;S-variable updates at each control-cycle
          printks   &quot;This string is updated at k-time:
                     kMyVar = %.3f\n&quot;, .1, kMyVar
  endin

  instr 5; f-variables
aSig      rand       .2; audio signal (noise)
; f-signal by FFT-analyzing the audio-signal
fSig1     pvsanal    aSig, 1024, 256, 1024, 1
; second f-signal (spectral bandpass filter)
fSig2     pvsbandp   fSig1, 350, 400, 400, 450
aOut      pvsynth    fSig2; change back to audio signal
          outs       aOut*20, aOut*20
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; p1    p2    p3
i 1     0     0.1
i 1     0.1   0.1
i 2     1     1
i 3     2     1
i 4     3     1
i 5     4     1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>You can think of variables as named connectors between opcodes. You can connect the output from an opcode to the input of another. The type of connector (audio, control, etc.) can be known from the first letter of its name.</p>
<p>For a more detailed discussion, see the article <a href="http://www.csounds.com/journal/issue10/CsoundRates.html"><em>An overview Of Csound Variable Types</em></a> by Andrés Cabrera in the <a href="http://www.csounds.com/journal/articleIndex.html"><em>Csound Journal</em></a>, and the page about <a href="http://www.csounds.com/manual/html/OrchKvar.html"><em>Types, Constants and Variables</em></a> in the <a href="http://www.csounds.com/manual/html/index.html"><em>Canonical Csound Manual</em></a>.<br />
</p>
<h2>Local Scope<br />
</h2>
<p>The <strong>scope</strong> of these variables is usually the <strong>instrument</strong> in which they are defined. They are <strong>local</strong> variables. In the following example, the variables in instrument 1 and instrument 2 have the same names, but different values.</p>
<p>   <em><strong>EXAMPLE 03B02.csd</strong></em>    <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410; very high because of printing
nchnls = 2
0dbfs = 1

  instr 1
;i-variable
iMyVar    init      0
iMyVar    =         iMyVar + 1
          print     iMyVar
;k-variable
kMyVar    init      0
kMyVar    =         kMyVar + 1
          printk    0, kMyVar
;a-variable
aMyVar    oscils    .2, 400, 0
          outs      aMyVar, aMyVar
;S-variable updated just at init-time
SMyVar1   sprintf   &quot;This string is updated just at init-time:
                     kMyVar = %d\n&quot;, i(kMyVar)
          printf    &quot;%s&quot;, kMyVar, SMyVar1
;S-variable updated at each control-cycle
SMyVar2   sprintfk  &quot;This string is updated at k-time:
                     kMyVar = %d\n&quot;, kMyVar
          printf    &quot;%s&quot;, kMyVar, SMyVar2
  endin

  instr 2
;i-variable
iMyVar    init      100
iMyVar    =         iMyVar + 1
          print     iMyVar
;k-variable
kMyVar    init      100
kMyVar    =         kMyVar + 1
          printk    0, kMyVar
;a-variable
aMyVar    oscils    .3, 600, 0
          outs      aMyVar, aMyVar
;S-variable updated just at init-time
SMyVar1   sprintf   &quot;This string is updated just at init-time:
                     kMyVar = %d\n&quot;, i(kMyVar)
          printf    &quot;%s&quot;, kMyVar, SMyVar1
;S-variable updated at each control-cycle
SMyVar2   sprintfk  &quot;This string is updated at k-time:
                     kMyVar = %d\n&quot;, kMyVar
          printf    &quot;%s&quot;, kMyVar, SMyVar2
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 .3
i 2 1 .3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p> This is the output (first the output at init-time by the print opcode, then at each k-cycle the output of printk and the two printf opcodes):<br />
<br />
new alloc for instr 1:<br />
instr 1:  iMyVar = 1.000<br />
 i   1 time     0.10000:     1.00000<br />
This string is updated just at init-time: kMyVar = 0<br />
This string is updated at k-time: kMyVar = 1<br />
 i   1 time     0.20000:     2.00000<br />
This string is updated just at init-time: kMyVar = 0<br />
This string is updated at k-time: kMyVar = 2<br />
 i   1 time     0.30000:     3.00000<br />
This string is updated just at init-time: kMyVar = 0<br />
This string is updated at k-time: kMyVar = 3<br />
 B  0.000 ..  1.000 T  1.000 TT  1.000 M:  0.20000  0.20000<br />
new alloc for instr 2:<br />
instr 2:  iMyVar = 101.000<br />
 i   2 time     1.10000:   101.00000<br />
This string is updated just at init-time: kMyVar = 100<br />
This string is updated at k-time: kMyVar = 101<br />
 i   2 time     1.20000:   102.00000<br />
This string is updated just at init-time: kMyVar = 100<br />
This string is updated at k-time: kMyVar = 102<br />
 i   2 time     1.30000:   103.00000<br />
This string is updated just at init-time: kMyVar = 100<br />
This string is updated at k-time: kMyVar = 103<br />
B  1.000 ..  1.300 T  1.300 TT  1.300 M:  0.29998  0.29998</p>
<p><br />
</p>
<h2>Global Scope</h2>
<p>If you need variables which are recognized beyond the scope of an instrument, you must define them as <strong>global</strong>. This is done by prefixing the character <strong>g</strong> before the types i, k, a or S. See the following example:</p>
<p>   <em><strong>EXAMPLE 03B03.csd</strong></em>    <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410; very high because of printing
nchnls = 2
0dbfs = 1

 ;global scalar variables can now be inititalized in the header
giMyVar   init      0
gkMyVar   init      0

  instr 1
 ;global i-variable
giMyVar   =         giMyVar + 1
          print     giMyVar
 ;global k-variable
gkMyVar   =         gkMyVar + 1
          printk    0, gkMyVar
 ;global S-variable updated just at init-time
gSMyVar1  sprintf   &quot;This string is updated just at init-time:
                     gkMyVar = %d\n&quot;, i(gkMyVar)
          printf    &quot;%s&quot;, gkMyVar, gSMyVar1
 ;global S-variable updated at each control-cycle
gSMyVar2  sprintfk  &quot;This string is updated at k-time:
                     gkMyVar = %d\n&quot;, gkMyVar
          printf    &quot;%s&quot;, gkMyVar, gSMyVar2
  endin

  instr 2
 ;global i-variable, gets value from instr 1
giMyVar   =         giMyVar + 1
          print     giMyVar
 ;global k-variable, gets value from instr 1
gkMyVar   =         gkMyVar + 1
          printk    0, gkMyVar
 ;global S-variable updated just at init-time, gets value from instr 1
          printf    &quot;Instr 1 tells: &#39;%s&#39;\n&quot;, gkMyVar, gSMyVar1
 ;global S-variable updated at each control-cycle, gets value from instr 1
          printf    &quot;Instr 1 tells: &#39;%s&#39;\n\n&quot;, gkMyVar, gSMyVar2
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 .3
i 2 0 .3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2></h2>
<p>The output shows the global scope, as instrument 2 uses the values which have been changed by instrument 1 in the same control cycle:</p>
<p>new alloc for instr 1:<br />
instr 1:  giMyVar = 1.000<br />
new alloc for instr 2:<br />
instr 2:  giMyVar = 2.000<br />
 i   1 time     0.10000:     1.00000<br />
This string is updated just at init-time: gkMyVar = 0<br />
This string is updated at k-time: gkMyVar = 1<br />
 i   2 time     0.10000:     2.00000<br />
Instr 1 tells: 'This string is updated just at init-time: gkMyVar = 0'<br />
Instr 1 tells: 'This string is updated at k-time: gkMyVar = 1'<br />
<br />
 i   1 time     0.20000:     3.00000<br />
This string is updated just at init-time: gkMyVar = 0<br />
This string is updated at k-time: gkMyVar = 3<br />
 i   2 time     0.20000:     4.00000<br />
Instr 1 tells: 'This string is updated just at init-time: gkMyVar = 0'<br />
Instr 1 tells: 'This string is updated at k-time: gkMyVar = 3'<br />
<br />
 i   1 time     0.30000:     5.00000<br />
This string is updated just at init-time: gkMyVar = 0<br />
This string is updated at k-time: gkMyVar = 5<br />
 i   2 time     0.30000:     6.00000<br />
Instr 1 tells: 'This string is updated just at init-time: gkMyVar = 0'<br />
Instr 1 tells: 'This string is updated at k-time: gkMyVar = 5'<br />
<br />
</p>
<h2>How To Work With Global Audio Variables</h2>
<p>Some special considerations must be taken if you work with global audio variables. Actually, Csound behaves basically the same whether you work with a local or a global audio variable. But usually you work with global audio variables if you want to <strong>add</strong> several audio signals to a global signal, and that makes a difference.</p>
<p>The next few examples are going into a bit more detail. If you just want to see the result (= global audio usually must be cleared), you can skip the next examples and just go to the last one of this section.</p>
<p>It should be understood first that a global audio variable is treated the same by Csound if it is applied like a local audio signal:</p>
<p>   <em><strong>EXAMPLE 03B04.csd</strong></em>     <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1; produces a 400 Hz sine
gaSig     oscils    .1, 400, 0
  endin

  instr 2; outputs gaSig
          outs      gaSig, gaSig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 2 0 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Of course, there is absolutely no need to use a global variable in this case. If you do it, you risk that your audio will be overwritten by an instrument with a higher number that uses the same variable name. In the following example, you will just hear a 600 Hz sine tone, because the 400 Hz sine of instrument 1 is overwritten by the 600 Hz sine of instrument 2:</p>
<p>   <em><strong>EXAMPLE 03B05.csd</strong></em>      <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1; produces a 400 Hz sine
gaSig     oscils    .1, 400, 0
  endin

  instr 2; overwrites gaSig with 600 Hz sine
gaSig     oscils    .1, 600, 0
  endin

  instr 3; outputs gaSig
          outs      gaSig, gaSig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 2 0 3
i 3 0 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>In general, you will use a global audio variable like a bus to which several local audio signal can be <strong>added</strong>. It's this addition of a global audio signal to its previous state which can cause some trouble. Let's first see a simple example of a control signal to understand what is happening:</p>
<p>   <em><strong>EXAMPLE 03B06.csd</strong></em>       <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410; very high because of printing
nchnls = 2
0dbfs = 1

  instr 1
kSum      init      0; sum is zero at init pass
kAdd      =         1; control signal to add
kSum      =         kSum + kAdd; new sum in each k-cycle
          printk    0, kSum; print the sum
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>In this case, the &quot;sum bus&quot; kSum increases at each control cycle by 1, because it adds the kAdd signal (which is always 1) in each k-pass to its previous state. It is no different if this is done by a local k-signal, like here, or by a global k-signal, like in the next example:</p>
<p>   <em><strong>EXAMPLE 03B07.csd</strong></em>        <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410; very high because of printing
nchnls = 2
0dbfs = 1

gkSum     init      0; sum is zero at init

  instr 1
gkAdd     =         1; control signal to add
  endin

  instr 2
gkSum     =         gkSum + gkAdd; new sum in each k-cycle
          printk    0, gkSum; print the sum
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
i 2 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>What is happening now when we work with audio signals instead of control signals in this way, repeatedly adding a signal to its previous state? Audio signals in Csound are a collection of numbers (a vector). The size of this vector is given by the ksmps constant. If your sample rate is 44100, and ksmps=100, you will calculate 441 times in one second a vector which consists of 100 numbers, indicating the amplitude of each sample.</p>
<p>So, if you add an audio signal to its previous state, different things can happen, depending on what is the present state of the vector and what was its previous state. If the previous state (with ksmps=9) has been [0 0.1 0.2 0.1 0 -0.1 -0.2 -0.1 0], and the present state is the same, you will get a signal which is twice as strong: [0 0.2 0.4 0.2 0 -0.2 -0.4 -0.2 0]. But if the present state is [0 -0.1 -0.2 -0.1 0 0.1 0.2 0.1 0], you wil just get zero's if you add it. This is shown in the next example with a local audio variable, and then in the following example with a global audio variable.</p>
<p>   <em><strong>EXAMPLE 03B08.csd</strong></em>         <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410; very high because of printing
            ;(change to 441 to see the difference)
nchnls = 2
0dbfs = 1

  instr 1
 ;initialize a general audio variable
aSum      init      0
 ;produce a sine signal (change frequency to 401 to see the difference)
aAdd      oscils    .1, 400, 0
 ;add it to the general audio (= the previous vector)
aSum      =         aSum + aAdd
kmax      max_k     aSum, 1, 1; calculate maximum
          printk    0, kmax; print it out
          outs      aSum, aSum
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>   <em><strong>EXAMPLE 03B09.csd</strong></em>         </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 4410; very high because of printing
            ;(change to 441 to see the difference)
nchnls = 2
0dbfs = 1

 ;initialize a general audio variable
gaSum     init      0

  instr 1
 ;produce a sine signal (change frequency to 401 to see the difference)
aAdd      oscils    .1, 400, 0
 ;add it to the general audio (= the previous vector)
gaSum     =         gaSum + aAdd
  endin

  instr 2
kmax      max_k     gaSum, 1, 1; calculate maximum
          printk    0, kmax; print it out
          outs      gaSum, gaSum
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
i 2 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>In both cases, you get a signal which increases each 1/10 second, because you have 10 control cycles per second (ksmps=4410), and the frequency of 400 Hz can evenly be divided by this. If you change the ksmps value to 441, you will get a signal which increases much faster and is out of range after 1/10 second. If you change the frequency to 401 Hz, you will get a signal which increases first, and then decreases, because each audio vector has 40.1 cycles of the sine wave. So the phases are shifting; first getting stronger and then weaker. If you change the frequency to 10 Hz, and then to 15 Hz (at ksmps=44100), you cannot hear anything, but if you render to file, you can see the whole process of either enforcing or erasing quite clear:</p>
<p><img src="static/Csound-Picts-03_CsLanguage-Add_Freq10Hz_1-en.png" title="Add_Freq10Hz_1" alt="Add_Freq10Hz_1" width="771" height="299" /></p>
<p><em>Self-reinforcing global audio signal on account of its state in one control cycle being the same as in the previous one</em> <br />
</p>
<p><br />
<img src="static/Csound-Picts-03_CsLanguage-Add_Freq15Hz_1-en.png" title="Add_Freq15Hz_1" alt="Add_Freq15Hz_1" width="771" height="298" /> </p>
<div data-align="center">
<em>Partly self-erasing global audio signal because of phase inversions in two subsequent control cycles</em>
</div>
<p><br />
So the result of all is: If you work with global audio variables in a way that you add several local audio signals to a global audio variable (which works like a bus), you must <strong>clear</strong> this global bus at each control cycle. As in Csound all the instruments are calculated in ascending order, it should be done either at the beginning of the <strong>first</strong>, or at the end of the <strong>last</strong> instrument. Perhaps it is the best idea to declare all global audio variables in the orchestra header first, and then clear them in an &quot;always on&quot; instrument with the highest number of all the instruments used. This is an example of a typical situation:</p>
<p>   <em><strong>EXAMPLE 03B10.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

 ;initialize the global audio variables
gaBusL    init      0
gaBusR    init      0
 ;make the seed for random values each time different
          seed      0

  instr 1; produces short signals
 loop:
iDur      random    .3, 1.5
          timout    0, iDur, makenote
          reinit    loop
 makenote:
iFreq     random    300, 1000
iVol      random    -12, -3; dB
iPan      random    0, 1; random panning for each signal
aSin      oscil3    ampdb(iVol), iFreq, 1
aEnv      transeg   1, iDur, -10, 0; env in a-rate is cleaner
aAdd      =         aSin * aEnv
aL, aR    pan2      aAdd, iPan
gaBusL    =         gaBusL + aL; add to the global audio signals
gaBusR    =         gaBusR + aR
  endin

  instr 2; produces short filtered noise signals (4 partials)
 loop:
iDur      random    .1, .7
          timout    0, iDur, makenote
          reinit    loop
 makenote:
iFreq     random    100, 500
iVol      random    -24, -12; dB
iPan      random    0, 1
aNois     rand      ampdb(iVol)
aFilt     reson     aNois, iFreq, iFreq/10
aRes      balance   aFilt, aNois
aEnv      transeg   1, iDur, -10, 0
aAdd      =         aRes * aEnv
aL, aR    pan2      aAdd, iPan
gaBusL    =         gaBusL + aL; add to the global audio signals
gaBusR    =         gaBusR + aR
  endin

  instr 3; reverb of gaBus and output
aL, aR    freeverb  gaBusL, gaBusR, .8, .5
          outs      aL, aR
  endin

  instr 100; clear global audios at the end
          clear     gaBusL, gaBusR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 .5 .3 .1
i 1 0 20
i 2 0 20
i 3 0 20
i 100 0 20
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2><strong>The chn Opcodes For</strong> Global Variables</h2>
<p>Instead of using the traditional g-variables for any values or signals which are to transfer between several instruments, it is also possible to use the <a href="http://www.csounds.com/manual/html/chn.html">chn</a> opcodes. An i-, k-, a- or S-value or signal can be set by <a href="http://www.csounds.com/manual/html/chnset.html">chnset</a> and received by <a href="http://www.csounds.com/manual/html/chnget.html">chnget</a>. One advantage is to have strings as names, so that you can choose intuitive names.</p>
<p>For audio variables, instead of performing an addition, you can use the <a href="http://www.csounds.com/manual/html/chnmix.html">chnmix</a> opcode. For clearing an audio variable, the <a href="http://www.csounds.com/manual/html/chnclear.html">chnclear</a> opcode can be used.</p>
<p>   <em><strong>EXAMPLE 03B11.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1; send i-values
          chnset    1, &quot;sio&quot;
          chnset    -1, &quot;non&quot;
  endin

  instr 2; send k-values
kfreq     randomi   100, 300, 1
          chnset    kfreq, &quot;cntrfreq&quot;
kbw       =         kfreq/10
          chnset    kbw, &quot;bandw&quot;
  endin

  instr 3; send a-values
anois     rand      .1
          chnset    anois, &quot;noise&quot;
 loop:
idur      random    .3, 1.5
          timout    0, idur, do
          reinit    loop
 do:
ifreq     random    400, 1200
iamp      random    .1, .3
asig      oscils    iamp, ifreq, 0
aenv      transeg   1, idur, -10, 0
asine     =         asig * aenv
          chnset    asine, &quot;sine&quot;
  endin

  instr 11; receive some chn values and send again
ival1     chnget    &quot;sio&quot;
ival2     chnget    &quot;non&quot;
          print     ival1, ival2
kcntfreq  chnget    &quot;cntrfreq&quot;
kbandw    chnget    &quot;bandw&quot;
anoise    chnget    &quot;noise&quot;
afilt     reson     anoise, kcntfreq, kbandw
afilt     balance   afilt, anoise
          chnset    afilt, &quot;filtered&quot;
  endin

  instr 12; mix the two audio signals
amix1     chnget     &quot;sine&quot;
amix2     chnget     &quot;filtered&quot;
          chnmix     amix1, &quot;mix&quot;
          chnmix     amix2, &quot;mix&quot;
  endin

  instr 20; receive and reverb
amix      chnget     &quot;mix&quot;
aL, aR    freeverb   amix, amix, .8, .5
          outs       aL, aR
  endin

  instr 100; clear
          chnclear   &quot;mix&quot;
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 20
i 2 0 20
i 3 0 20
i 11 0 20
i 12 0 20
i 20 0 20
i 100 0 20
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</code></pre>
<p><span id="ch018_c-control-structures.xhtml"></span></p>
<h1>CONTROL STRUCTURES</h1>
<p>In a way, control structures are the core of a programming language. The fundamental element in each language is the conditional <strong>if</strong> branch. Actually all other control structures like for-, until- or while-loops can be traced back to if-statements.</p>
<p>So, Csound provides mainly the if-statement; either in the usual <em>if-then-else</em> form, or in the older way of an <em>if-goto</em> statement. These ones will be covered first. Though all necessary loops can be built just by if-statements, Csound's <em>loop</em> facility offers a more comfortable way of performing loops. They will be introduced in the Loop section of this chapter. At least, time loops are shown, which are particulary important in audio programming languages.</p>
<h2>If i-Time Then Not k-Time!</h2>
<p>The fundamental difference in Csound between i-time and k-time which has been explained in a <a href="http://en.flossmanuals.net/bin/view/Csound/InitAndPerfPass">previous chapter</a>, must be regarded very carefully when you work with control structures. If you make a conditional branch at <strong>i-time</strong>, the condition will be tested <strong>just once for each note</strong>, at the initialization pass. If you make a conditional branch at <strong>k-time</strong>, the condition will be tested <strong>again and again in each control-cycle</strong>.</p>
<p>For instance, if you test a soundfile whether it is mono or stereo, this is done at init-time. If you test an amplitude value to be below a certain threshold, it is done at performance time (k-time). If you get user-input by a scroll number, this is also a k-value, so you need a k-condition.</p>
<p>Thus, all <a href="http://www.csounds.com/manual/html/if.html">if</a> and <a href="http://www.csounds.com/manual/html/loop_lt.html">loop</a> opcodes have an &quot;i&quot; and a &quot;k&quot; descendant. In the next few sections, a general introduction into the different control tools is given, followed by examples both at i-time and at k-time for each tool.</p>
<h2>If - then - [elseif - then -] else</h2>
<p>The use of the if-then-else statement is very similar to other programming languages. Note that in Csound, &quot;then&quot; must be written in the same line as &quot;if&quot; and the expression to be tested, and that you must close the if-block with an &quot;endif&quot; statement on a new line:</p>
<pre><code>if &lt;condition&gt; then
...
else
...
endif</code></pre>
<p>It is also possible to have no &quot;else&quot; statement:</p>
<pre><code>if &lt;condition&gt; then
...
endif</code></pre>
<p>Or you can have one or more &quot;elseif-then&quot; statements in between:</p>
<pre><code>if &lt;condition1&gt; then
...
elseif &lt;condition2&gt; then
...
else
...
endif</code></pre>
<p>If statements can also be nested. Each level must be closed with an &quot;endif&quot;. This is an example with three levels:</p>
<pre><code>if &lt;condition1&gt; then; first condition opened
 if &lt;condition2&gt; then; second condition openend
  if &lt;condition3&gt; then; third condition openend
  ...
  else
  ...
  endif; third condition closed
 elseif &lt;condition2a&gt; then
 ...
 endif; second condition closed
else
...
endif; first condition closed</code></pre>
<h3>i-Rate Examples</h3>
<p>A typical problem in Csound: You have either mono or stereo files, and want to read both with a stereo output. For the real stereo ones that means: use soundin (diskin / diskin2) with two output arguments. For the mono ones it means: use <a href="http://www.csounds.com/manual/html/soundin.html">soundin</a> / <a href="http://www.csounds.com/manual/html/diskin.html">diskin</a> / <a href="http://www.csounds.com/manual/html/diskin2.html">diskin2</a> with one output argument, and throw it to both output channels:</p>
<p>   <em><strong>EXAMPLE 03C01.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1
Sfile     =          &quot;/my/file.wav&quot; ;your soundfile path here
ifilchnls filenchnls Sfile
 if ifilchnls == 1 then ;mono
aL        soundin    Sfile
aR        =          aL
 else	;stereo
aL, aR    soundin    Sfile
 endif
          outs       aL, aR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>If you use QuteCsound, you can browse in the widget panel for the soundfile. See the corresponding example in the QuteCsound Example menu.</p>
<h3>k-Rate Examples</h3>
<p>The following example establishes a moving gate between 0 and 1. If the gate is above 0.5, the gate opens and you hear a tone.  If the gate is equal or below 0.5, the gate closes, and you hear nothing.</p>
<p>   <em><strong>EXAMPLE 03C02.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random values each time different
giTone    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1
kGate     randomi   0, 1, 3; moves between 0 and 1 (3 new values per second)
kFreq     randomi   300, 800, 1; moves between 300 and 800 hz (1 new value per sec)
kdB       randomi   -12, 0, 5; moves between -12 and 0 dB
                            ;(5 new values per sec)
aSig      oscil3    1, kFreq, giTone
kVol      init      0
 if kGate &gt; 0.5 then; if kGate is larger than 0.5
kVol      =         ampdb(kdB); open gate
 else
kVol      =         0; otherwise close gate
 endif
kVol      port      kVol, .02; smooth volume curve to avoid clicks
aOut      =         aSig * kVol
          outs      aOut, aOut
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>Short Form: (a v b ? x : y)</h3>
<p>If you need an if-statement to give a value to an (i- or k-) variable, you can also use a traditional short form in parentheses: <a href="http://www.csounds.com/manual/html/equals.html">(a v b ? x : y)</a>. It asks whether the condition a or b is true. If a, the value is set to x; if b, to y. For instance, the last example could be written in this way:</p>
<p>   <em><strong>EXAMPLE 03C03.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0
giTone    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1
kGate     randomi   0, 1, 3; moves between 0 and 1 (3 new values per second)
kFreq     randomi   300, 800, 1; moves between 300 and 800 hz
                               ;(1 new value per sec)
kdB       randomi   -12, 0, 5; moves between -12 and 0 dB
                             ;(5 new values per sec)
aSig      oscil3    1, kFreq, giTone
kVol      init      0
kVol      =         (kGate &gt; 0.5 ? ampdb(kdB) : 0); short form of condition
kVol      port      kVol, .02; smooth volume curve to avoid clicks
aOut      =         aSig * kVol
          outs      aOut, aOut
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 20
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>If - goto</h2>
<p>An older way of performing a conditional branch - but still useful in certain cases - is an &quot;if&quot; statement which is not followed by a &quot;then&quot;, but by a label name. The &quot;else&quot; construction follows (or doesn't follow) in the next line. Like the if-then-else statement, the if-goto works either at i-time or at k-time. You should declare the type by either using <strong>i</strong>goto or <strong>k</strong>goto. Usually you need an additional igoto/kgoto statement for omitting the &quot;else&quot; block if the first condition is true. This is the general syntax:</p>
<p>i-time</p>
<pre><code>if &lt;condition&gt; igoto this; same as if-then
 igoto that; same as else
this: ;the label &quot;this&quot; ...
...
igoto continue ;skip the &quot;that&quot; block
that: ; ... and the label &quot;that&quot; must be found
...
continue: ;go on after the conditional branch
...</code></pre>
<p>k-time</p>
<pre><code>if &lt;condition&gt; kgoto this; same as if-then
 kgoto that; same as else
this: ;the label &quot;this&quot; ...
...
kgoto continue ;skip the &quot;that&quot; block
that: ; ... and the label &quot;that&quot; must be found
...
continue: ;go on after the conditional branch
...</code></pre>
<h3>i-Rate Examples</h3>
<p>This is the same example as above in the if-then-else syntax for a branch depending on a mono or stereo file. If you just want to know whether a file is mono or stereo, you can use the &quot;pure&quot; if-igoto statement:</p>
<p>   <em><strong>EXAMPLE 03C04.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1
Sfile     = &quot;/Joachim/Materialien/SamplesKlangbearbeitung/Kontrabass.aif&quot;
ifilchnls filenchnls Sfile
if ifilchnls == 1 igoto mono; condition if true
 igoto stereo; else condition
mono:
          prints     &quot;The file is mono!%n&quot;
          igoto      continue
stereo:
          prints     &quot;The file is stereo!%n&quot;
continue:
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>But if you want to play the file, you must also use a k-rate if-kgoto, because you have not just an action at i-time (initializing the soundin opcode) but also at k-time (producing an audio signal). So the code in this case is much more cumbersome than with the if-then-else facility shown previously.</p>
<p>   <em><strong>EXAMPLE 03C05.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1
Sfile     =          &quot;my/file.wav&quot;
ifilchnls filenchnls Sfile
 if ifilchnls == 1 kgoto mono
  kgoto stereo
 if ifilchnls == 1 igoto mono; condition if true
  igoto stereo; else condition
mono:
aL        soundin    Sfile
aR        =          aL
          igoto      continue
          kgoto      continue
stereo:
aL, aR    soundin    Sfile
continue:
          outs       aL, aR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>k-Rate Examples</h3>
<p>This is the same example as above in the if-then-else syntax for a moving gate between 0 and 1:</p>
<p>   <em><strong>EXAMPLE 03C06.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0
giTone    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1
kGate     randomi   0, 1, 3; moves between 0 and 1 (3 new values per second)
kFreq     randomi   300, 800, 1; moves between 300 and 800 hz
                              ;(1 new value per sec)
kdB       randomi   -12, 0, 5; moves between -12 and 0 dB
                             ;(5 new values per sec)
aSig      oscil3    1, kFreq, giTone
kVol      init      0
 if kGate &gt; 0.5 kgoto open; if condition is true
  kgoto close; &quot;else&quot; condition
open:
kVol      =         ampdb(kdB)
kgoto continue
close:
kVol      =         0
continue:
kVol      port      kVol, .02; smooth volume curve to avoid clicks
aOut      =         aSig * kVol
          outs      aOut, aOut
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Loops</h2>
<p>Loops can be built either at i-time or at k-time just with the &quot;if&quot; facility. The following example shows an i-rate and a k-rate loop created using the if-i/kgoto facility:</p>
<p>   <em><strong>EXAMPLE 03C07.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

  instr 1 ;i-time loop: counts from 1 until 10 has been reached
icount    =         1
count:
          print     icount
icount    =         icount + 1
 if icount &lt; 11 igoto count
          prints    &quot;i-END!%n&quot;
  endin

  instr 2 ;k-rate loop: counts in the 100th k-cycle from 1 to 11
kcount    init      0
ktimek    timeinstk ;counts k-cycle from the start of this instrument
 if ktimek == 100 kgoto loop
  kgoto noloop
loop:
          printks   &quot;k-cycle %d reached!%n&quot;, 0, ktimek
kcount    =         kcount + 1
          printk2   kcount
 if kcount &lt; 11 kgoto loop
          printks   &quot;k-END!%n&quot;, 0
noloop:
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>But Csound offers a slightly simpler syntax for this kind of i-rate or k-rate loops. There are four variants of the loop opcode. All four refer to a <em>label</em> as the starting point of the loop, an <em>index variable</em> as a counter, an <em>increment</em> or <em>decrement</em>, and finally a <em>reference value</em> (maximum or minimum) as comparision:</p>
<ul>
<li><a href="http://www.csounds.com/manual/html/loop_lt.html">loop_lt</a> counts upwards and looks if the index variable is <strong>lower than</strong> the reference value;</li>
<li><a href="http://www.csounds.com/manual/html/loop_le.html">loop_le</a> also counts upwards and looks if the index is <strong>lower than or equal to</strong> the reference value;</li>
<li><a href="http://www.csounds.com/manual/html/loop_gt.html">loop_gt</a> counts downwards and looks if the index is <strong>greater than</strong> the reference value;</li>
<li><a href="http://www.csounds.com/manual/html/loop_ge.html">loop_ge</a> also counts downwards and looks if the index is <strong>greater than or equal to</strong> the reference value.</li>
</ul>
<p>As always, all four opcodes can be applied either at i-time or at k-time. Here are some examples, first for i-time loops, and then for k-time loops.</p>
<h3>i-Rate Examples</h3>
<p>The following .csd provides a simple example for all four loop opcodes:</p>
<p>   <em><strong>EXAMPLE 03C08.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

  instr 1 ;loop_lt: counts from 1 upwards and checks if &lt; 10
icount    =         1
loop:
          print     icount
          loop_lt   icount, 1, 10, loop
          prints    &quot;Instr 1 terminated!%n&quot;
  endin

  instr 2 ;loop_le: counts from 1 upwards and checks if &lt;= 10
icount    =         1
loop:
          print     icount
          loop_le   icount, 1, 10, loop
          prints    &quot;Instr 2 terminated!%n&quot;
  endin

  instr 3 ;loop_gt: counts from 10 downwards and checks if &gt; 0
icount    =         10
loop:
          print     icount
          loop_gt   icount, 1, 0, loop
          prints    &quot;Instr 3 terminated!%n&quot;
  endin

  instr 4 ;loop_ge: counts from 10 downwards and checks if &gt;= 0
icount    =         10
loop:
          print     icount
          loop_ge   icount, 1, 0, loop
          prints    &quot;Instr 4 terminated!%n&quot;
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
i 3 0 0
i 4 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The next example produces a random string of 10 characters and prints it out:</p>
<p>   <em><strong>EXAMPLE 03C09.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

  instr 1
icount    =         0
Sname     =         &quot;&quot;; starts with an empty string
loop:
ichar     random    65, 90.999
Schar     sprintf   &quot;%c&quot;, int(ichar); new character
Sname     strcat    Sname, Schar; append to Sname
          loop_lt   icount, 1, 10, loop; loop construction
          printf_i  &quot;My name is &#39;%s&#39;!\n&quot;, 1, Sname; print result
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; call instr 1 ten times
r 10
i 1 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>You can also use an i-rate loop to fill a function table (= buffer) with any kind of values. In the next example, a function table with 20 positions (indices) is filled with random integers between 0 and 10 by instrument 1. Nearly the same loop construction is used afterwards to read these values by instrument 2.</p>
<p>   <em><strong>EXAMPLE 03C10.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

giTable   ftgen     0, 0, -20, -2, 0; empty function table with 20 points
          seed      0; each time different seed

  instr 1 ; writes in the table
icount    =         0
loop:
ival      random    0, 10.999 ;random value
; --- write in giTable at first, second, third ... position
          tableiw   int(ival), icount, giTable
          loop_lt   icount, 1, 20, loop; loop construction
  endin

  instr 2; reads from the table
icount    =         0
loop:
; --- read from giTable at first, second, third ... position
ival      tablei    icount, giTable
          print     ival; prints the content
          loop_lt   icount, 1, 20, loop; loop construction
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>k-Rate Examples</h3>
<p>The next example performs a loop at k-time. Once per second, every value of an existing function table is changed by a random deviation of 10%. Though there are special opcodes for this task, it can also be done by a k-rate loop like the one shown here:</p>
<p>   <em><strong>EXAMPLE 03C11.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 441
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 256, 10, 1; sine wave
          seed      0; each time different seed

  instr 1
ktiminstk timeinstk ;time in control-cycles
kcount    init      1
 if ktiminstk == kcount * kr then; once per second table values manipulation:
kndx      =         0
loop:
krand     random    -.1, .1;random factor for deviations
kval      table     kndx, giSine; read old value
knewval   =         kval + (kval * krand); calculate new value
          tablew    knewval, kndx, giSine; write new value
          loop_lt   kndx, 1, 256, loop; loop construction
kcount    =         kcount + 1; increase counter
 endif
asig      poscil    .2, 400, giSine
          outs      asig, asig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3></h3>
<h2>Time Loops</h2>
<p>Until now, we have just discussed loops which are executed &quot;as fast as possible&quot;, either at i-time or at k-time. But, in an audio programming language, time loops are of particular interest and importance. A time loop means, repeating any action after a certain amount of time. This amount of time can be equal to or different to the previous time loop. The action can be, for instance: playing a tone, or triggering an instrument, or calculating a new value for the movement of an envelope.</p>
<p>In Csound, the usual way of performing time loops, is the <a href="http://www.csounds.com/manual/html/timout.html">timout</a> facility. The use of timout is a bit intricate, so some examples are given, starting from very simple to more complex ones.</p>
<p>Another way of performing time loops is by using a measurement of time or k-cycles. This method is also discussed and similar examples to those used for the timout opcode are given so that both methods can be compared.</p>
<h3>timout Basics</h3>
<p>The <a href="http://www.csounds.com/manual/html/timout.html">timout</a> opcode refers to the fact that in the traditional way of working with Csound, each &quot;note&quot; (an &quot;i&quot; score event) has its own time. This is the duration of the note, given in the score by the duration parameter, abbreviated as &quot;p3&quot;. A timout statement says: &quot;I am now jumping out of this p3 duration and establishing my own time.&quot; This time will be repeated as long as the duration of the note allows it.</p>
<p>Let's see an example. This is a sine tone with a moving frequency, starting at 400 Hz and ending at 600 Hz. The duration of this movement is 3 seconds for the first note, and 5 seconds for the second note:</p>
<p>   <em><strong>EXAMPLE 03C12.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
kFreq     expseg    400, p3, 600
aTone     poscil    .2, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 1 4 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Now we perform a time loop with timout which is 1 second long. So, for the first note, it will be repeated three times, and for the second note five times:</p>
<p>   <em><strong>EXAMPLE 03C13.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
          timout    0, 1, play
          reinit    loop
play:
kFreq     expseg    400, 1, 600
aTone     poscil    .2, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 1 4 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This is the general syntax of timout:</p>
<pre><code>first_label:
          timout    istart, idur, second_label
          reinit    first_label
second_label:
... &lt;any action you want to have here&gt;</code></pre>
<p>The <strong>first_label</strong> is an arbitrary word (followed by a colon) for marking the beginning of the time loop section. The <strong>istart</strong> argument for timout tells Csound, when the <strong>second_label</strong> section is to be executed. Usually istart is zero, telling Csound: execute the second_label section immediately, without any delay. The <strong>idur</strong> argument for timout defines how many seconds the second_label section is to be executed before the time loop begins again. Note that the &quot;reinit first_label&quot; is necessary to start the second loop after idur seconds with a resetting of all the values. (See the explanations about reinitialization in the chapter <a href="http://en.flossmanuals.net/bin/view/Csound/InitAndPerfPass">Initilalization And Performance Pass</a>.)</p>
<p>As usual when you work with the <a href="http://www.csounds.com/manual/html/reinit.html">reinit</a> opcode, you can use a <a href="http://www.csounds.com/manual/html/rireturn.html">rireturn</a> statement to constrain the reinit-pass. In this way you can have both, the timeloop section and the non-timeloop section in the body of an instrument:</p>
<p>   <em><strong>EXAMPLE 03C14.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
          timout    0, 1, play
          reinit    loop
play:
kFreq1    expseg    400, 1, 600
aTone1    oscil3    .2, kFreq1, giSine
          rireturn  ;end of the time loop
kFreq2    expseg    400, p3, 600
aTone2    poscil    .2, kFreq2, giSine

          outs      aTone1+aTone2, aTone1+aTone2
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 1 4 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>timout Applications</h3>
<p>In a time loop, it is very important to change the duration of the loop. This can be done either by referring to the duration of this note (p3) ...</p>
<p>   <em><strong>EXAMPLE 03C15.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
          timout    0, p3/5, play
          reinit    loop
play:
kFreq     expseg    400, p3/5, 600
aTone     poscil    .2, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 1 4 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>... or by calculating new values for the loop duration on each reinit pass, for instance by random values:</p>
<p>   <em><strong>EXAMPLE 03C16.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
idur      random    .5, 3 ;new value between 0.5 and 3 seconds each time
          timout    0, idur, play
          reinit    loop
play:
kFreq     expseg    400, idur, 600
aTone     poscil    .2, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 20
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The applications discussed so far have the disadvantage that all the signals inside the time loop must definitely be finished or interrupted, when the next loop begins. In this way it is not possible to have any overlapping of events. For achieving this, the time loop can be used just to <strong>trigger an event</strong>. This can be done with <a href="http://www.csounds.com/manual/html/event_i.html">event_i</a> or <a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a>. In the following example, the time loop in instrument 1 triggers each half to two seconds an instance of instrument 2 for a duration of 1 to 5 seconds. So usually the previous instance of instrument 2 will still play when the new instance is triggered. In instrument 2, some random calculations are executed to make each note different, though having a descending pitch (glissando):</p>
<p>   <em><strong>EXAMPLE 03C17.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

  instr 1
loop:
idurloop  random    .5, 2 ;duration of each loop
          timout    0, idurloop, play
          reinit    loop
play:
idurins   random    1, 5 ;duration of the triggered instrument
          event_i   &quot;i&quot;, 2, 0, idurins ;triggers instrument 2
  endin

  instr 2
ifreq1    random    600, 1000 ;starting frequency
idiff     random    100, 300 ;difference to final frequency
ifreq2    =         ifreq1 - idiff ;final frequency
kFreq     expseg    ifreq1, p3, ifreq2 ;glissando
iMaxdb    random    -12, 0 ;peak randomly between -12 and 0 dB
kAmp      transeg   ampdb(iMaxdb), p3, -10, 0 ;envelope
aTone     poscil    kAmp, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The last application of a time loop with the <em>timout</em> opcode which is shown here, is a <strong>randomly moving envelope</strong>. If you want to create an envelope in Csound which moves between a lower and an upper limit, and has one new random value in a certain time span (for instance, once a second), the time loop with <em>timout</em> is one way to achieve it. A line movement must be performed in each time loop, from a given starting value to a new evaluated final value. Then, in the next loop, the previous final value must be set as the new starting value, and so on. This is a possible solution:</p>
<p>   <em><strong>EXAMPLE 03C18.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  instr 1
iupper    =         0; upper and ...
ilower    =         -24; ... lower limit in dB
ival1     random    ilower, iupper; starting value
loop:
idurloop  random    .5, 2; duration of each loop
          timout    0, idurloop, play
          reinit    loop
play:
ival2     random    ilower, iupper; final value
kdb       linseg    ival1, idurloop, ival2
ival1     =         ival2; let ival2 be ival1 for next loop
          rireturn  ;end reinit section
aTone     poscil    ampdb(kdb), 400, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Note that in this case the oscillator has been put after the time loop section (which is terminated by the <em>rireturn</em> statement. Otherwise the oscillator would start afresh with zero phase in each time loop, thus producing clicks.</p>
<h3>Time Loops by using the <em>metro</em> Opcode</h3>
<p>The <a href="http://www.csounds.com/manual/html/metro.html">metro</a> opcode outputs a &quot;1&quot; at distinct times, otherwise it outputs a &quot;0&quot;. The frequency of this &quot;banging&quot; (which is in some way similar to the metro objects in PD or Max) is given by the <em>kfreq</em> input argument. So the output of <em>metro</em> offers a simple and intuitive method for controlling time loops, if you use it to trigger a separate instrument which then carries out another job. Below is a simple example for calling a subinstrument twice a second:</p>
<p>   <em><strong>EXAMPLE 03C19.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1; triggering instrument
kTrig     metro     2; outputs &quot;1&quot; twice a second
 if kTrig == 1 then
          event     &quot;i&quot;, 2, 0, 1
 endif
  endin

  instr 2; triggered instrument
aSig      oscils    .2, 400, 0
aEnv      transeg   1, p3, -10, 0
          outs      aSig*aEnv, aSig*aEnv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The example which is given above (03C17.csd) as a flexible time loop by <em>timout</em>, can be done with the <em>metro</em> opcode in this way:</p>
<p>   <em><strong>EXAMPLE 03C20.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  instr 1
kfreq     init      1; give a start value for the trigger frequency
kTrig     metro     kfreq
 if kTrig == 1 then ;if trigger impulse:
kdur      random    1, 5; random duration for instr 2
          event     &quot;i&quot;, 2, 0, kdur; call instr 2
kfreq     random    .5, 2; set new value for trigger frequency
 endif
  endin

  instr 2
ifreq1    random    600, 1000; starting frequency
idiff     random    100, 300; difference to final frequency
ifreq2    =         ifreq1 - idiff; final frequency
kFreq     expseg    ifreq1, p3, ifreq2; glissando
iMaxdb    random    -12, 0; peak randomly between -12 and 0 dB
kAmp      transeg   ampdb(iMaxdb), p3, -10, 0; envelope
aTone     poscil    kAmp, kFreq, giSine
          outs      aTone, aTone
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;  </code></pre>
<p>Note the differences in working with the <em>metro</em> opcode compared to the <em>timout</em> feature:</p>
<ul>
<li>As <em>metro</em> works at k-time, you must use the k-variants of <a href="http://www.csounds.com/manual/html/event.html">event</a> or <a href="http://www.csounds.com/manual/html/scoreline.html">scoreline</a> to call the subinstrument. With <em>timout</em> you must use the i-variants of <em>event</em> or <em>scoreline</em> (<a href="http://www.csounds.com/manual/html/event_i.html">event_i</a> and <a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a>), because it uses reinitialization for performing the time loops.</li>
<li>You must select the one k-cycle where the metro opcode sends a &quot;1&quot;. This is done with an if-statement. The rest of the instrument is not affected. If you use <em>timout</em>, you usually must seperate the reinitialized from the not reinitialized section by a <em>rireturn</em> statement.</li>
</ul>
<h2>Links</h2>
<p>Steven Yi: Control Flow (<a href="http://www.csounds.com/journal/2006spring/controlFlow.html">Part I</a> = Csound Journal Spring 2006, <a href="http://www.csounds.com/journal/2006summer/controlFlow_part2.html">Part 2</a> = Csound Journal Summer 2006)</p>
<p><br />
</p>
<p><span id="ch019_d-function-tables.xhtml"></span></p>
<h1>FUNCTION TABLES</h1>
<p>A function table is essentially the same as what other audio programming languages call a buffer, a table, a list or an array. It is a place where data can be stored in an ordered way. Each function table has a <strong>size</strong>: how much data (in Csound just numbers) can be stored in it. Each value in the table can be accessed by an <strong>index</strong>, counting from 0 to size-1. For instance, if you have a function table with a size of 10, and the numbers [1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89] in it, this is the relation of value and index:</p>
<table>
<tbody>
<tr class="odd">
<td> VALUE</td>
<td> 1.1</td>
<td> 2.2</td>
<td> 3.3</td>
<td> 5.5</td>
<td> 8.8</td>
<td> 13.13</td>
<td> 21.21</td>
<td> 34.34</td>
<td> 55.55</td>
<td> 89.89</td>
</tr>
<tr class="even">
<td> INDEX</td>
<td> 0</td>
<td> 1</td>
<td> 2</td>
<td> 3</td>
<td> 4</td>
<td> 5</td>
<td> 6</td>
<td> 7</td>
<td> 8</td>
<td> 9</td>
</tr>
</tbody>
</table>
<p>So, if you want to retrieve the value 13.13, you must point to the value stored under index 5.</p>
<p>The use of function tables is manifold. A function table can contain pitch values to which you may refer using the input of a MIDI keyboard. A function table can contain a model of a waveform which is read periodically by an oscillator. You can record live audio input in a function table, and then play it back. There are many more applications, all using the fast access (because a function table is part of the RAM) and flexible use of function tables.<br />
</p>
<h2>How to Generate a Function Table</h2>
<p>Each function table must be created <strong>before</strong> it can be used. Even if you want to write values later, you must first create an empty table, because you must initially reserve some space in memory for it.</p>
<p>Each creation of a function table in Csound is performed by one of the so-called <strong>GEN Routines</strong>. Each GEN Routine generates a function table in a particular way: GEN01 transfers audio samples from a soundfile into a table, with GEN02 we can write values in &quot;by hand&quot; one by one, GEN10 calculates a waveform using information determining a sum of sinusoids, GEN20 generates window functions typically used for granular synthesis, and so on. There is a good <a href="http://www.csounds.com/manual/html/ScoreGenRef.html">overview</a> in the <a href="http://www.csounds.com/manual/html/index.html">Csound Manual</a> of all existing GEN Routines. Here we will explain the general use and give simple examples for some frequent cases.</p>
<h3>GEN02 And General Parameters For GEN Routines</h3>
<p>Let's start with our example above and write the 10 numbers into a function table of the same size. For this, use of a <a href="http://www.csounds.com/manual/html/GEN02.html">GEN02</a> function table<a href="http://www.csounds.com/manual/html/GEN02.html"></a> is required. A short <a href="http://www.csounds.com/manual/html/GEN02.html">description</a> of GEN02 from the manual reads as follows:</p>
<pre><code>f # time size 2 v1 v2 v3 ...</code></pre>
<p>This is the traditional way of creating a function table by an &quot;<strong>f statement</strong>&quot; or an &quot;<strong>f score event</strong>&quot; (in comparision for instance to &quot;i score events&quot; which call instrument instances). The input parameters after the &quot;f&quot; are the following:</p>
<ul>
<li><strong>#</strong>: a number (as positive integer) for this function table;</li>
<li><strong>time</strong>: at which time to be the function table available (usually 0 = from the beginning);</li>
<li><strong>size</strong>: the size of the function table. This is a bit tricky, because in the early days of Csound just power-of-two sizes for function tables were possible (2, 4, 8, 16, ...). Nowadays nearly every GEN Routine accepts other sizes, but these <strong>non-power-of-two sizes must be declared as a negative number</strong>!<br />
</li>
<li><strong>2</strong>: the number of the GEN Routine which is used to generate the table. And here is another important point which must be regarded. <strong>By default, Csound normalizes the table values.</strong> This means that the maximum is scaled to +1 if positive, and to -1 if negative. To <strong>prevent</strong> Csound from normalizing, a <strong>negative</strong> number must be given as GEN number (here -2 instead of 2).</li>
<li><strong>v1 v2 v3 ...</strong>: the values which are written into the function table.</li>
</ul>
<p>So this is the way to put the values [1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89] in a function table with the number 1:</p>
<p>   <em><strong>EXAMPLE 03D01.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
  instr 1 ;prints the values of table 1 or 2
          prints    &quot;%nFunction Table %d:%n&quot;, p4
indx      init      0
loop:
ival      table     indx, p4
          prints    &quot;Index %d = %f%n&quot;, indx, ival
          loop_lt   indx, 1, 10, loop
  endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 -10 -2 1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89; not normalized
f 2 0 -10 2 1.1 2.2 3.3 5.5 8.8 13.13 21.21 34.34 55.55 89.89; normalized
i 1 0 0 1; prints function table 1
i 1 0 0 2; prints function table 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Instrument 1 just serves to print the values of the table (the <em>tablei</em> opcode will be explained later). See the difference whether the table is normalized (positive GEN number) or not normalized (negative GEN number). </p>
<p>Using the <a href="http://www.csounds.com/manual/html/ftgen.html">ftgen</a> opcode is a more modern way of creating a function table, which is in some ways preferable to the old way of writing an f-statement in the score. The syntax is explained below:</p>
<pre><code>giVar     ftgen     ifn, itime, isize, igen, iarg1 [, iarg2 [, ...]]</code></pre>
<ul>
<li><strong>giVar</strong>: a variable name. Each function is stored in an i-variable. Usually you want to have access to it from every instrument, so a gi-variable (global initialization variable) is given.</li>
<li><strong>ifn</strong>: a number for the function table. If you type in 0, you give Csound the job to choose a number, which is mostly preferable.</li>
</ul>
<p>The other parameters (size, GEN number, individual arguments) are the same as in the f-statement in the score. As this GEN call is now a part of the orchestra, each argument is separated from the next by a comma (not by a space or tab like in the score).</p>
<p>So this is the same example as above, but now with the function tables being generated in the orchestra header:</p>
<p>   <em><strong>EXAMPLE 03D02.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

giFt1 ftgen 1, 0, -10, -2, 1.1, 2.2, 3.3, 5.5, 8.8, 13.13, 21.21, 34.34, 55.55, 89.89
giFt2 ftgen 2, 0, -10, 2, 1.1, 2.2, 3.3, 5.5, 8.8, 13.13, 21.21, 34.34, 55.55, 89.89

  instr 1; prints the values of table 1 or 2
          prints    &quot;%nFunction Table %d:%n&quot;, p4
indx      init      0
loop:
ival      table     indx, p4
          prints    &quot;Index %d = %f%n&quot;, indx, ival
          loop_lt   indx, 1, 10, loop
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0 1; prints function table 1
i 1 0 0 2; prints function table 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>GEN01: Importing a Soundfile</h3>
<p><a href="http://www.csounds.com/manual/html/GEN01.html">GEN01</a> is used for importing soundfiles stored on disk into the computer's RAM, ready for for use by a number of Csound's opcodes in the orchestra. A typical <a href="http://www.csounds.com/manual/html/ftgen.html">ftgen</a> statement for this import might be the following:</p>
<pre><code>varname             ifn itime isize igen Sfilnam       iskip iformat ichn
giFile    ftgen     0,  0,    0,    1,   &quot;myfile.wav&quot;, 0,    0,      0</code></pre>
<ul>
<li><strong>varname</strong>, <strong>ifn</strong>, <strong>itime</strong>: These arguments have the same meaning as explained above in reference to GEN02.</li>
<li><strong>isize</strong>: Usually you won't know the length of your soundfile in samples, and want to have a table length which includes exactly all the samples. This is done by setting <strong>isize=0</strong>. (Note that some opcodes may need a power-of-two table. In this case you can not use this option, but must calculate the next larger power-of-two value as size for the function table.)</li>
<li><strong>igen</strong>: As explained in the previous subchapter, this is always the place for indicating the number of the GEN Routine which must be used. As always, a positive number means normalizing, which is usually convenient for audio samples.</li>
<li><strong>Sfilnam</strong>: The name of the soundfile in double quotes. Similar to other audio programming languages, Csound recognizes just the name if your .csd and the soundfile are in the same folder. Otherwise, give the full path. (You can also include the folder via the &quot;SSDIR&quot; variable, or add the folder via the &quot;<span class="term">--env:NAME+=VALUE&quot; option.)</span></li>
<li><span class="term"><strong>iskip</strong>: The time in seconds you want to skip at the beginning of the soundfile. 0 means reading from the beginning of the file.</span></li>
<li><span class="term"><strong>iformat</strong>: Usually 0, which means: read the sample format from the soundfile header.</span></li>
<li><span class="term"><strong>ichn</strong>: 1 = read the first channel of the soundfile into the table, 2 = read the second channel, etc. 0 means that all channels are read.</span><br />
</li>
</ul>
<p>The next example plays a short sample. You can download it <a href="http://www.csounds.com/manual/html/examples/fox.wav">here</a>. Copy the text below, save it to the same location as the &quot;fox.wav&quot; soundfile, and it should work. Reading the function table is done here with the <a href="http://www.csounds.com/manual/html/poscil3.html">poscil3</a> opcode which can deal with non-power-of-two tables.</p>
<p>   <em><strong>EXAMPLE 03D03.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSample  ftgen     0, 0, 0, 1, &quot;fox.wav&quot;, 0, 0, 1

  instr 1
itablen   =         ftlen(giSample) ;length of the table
idur      =         itablen / sr ;duration
aSamp     poscil3   .5, 1/idur, giSample
          outs      aSamp, aSamp
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 2.757
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>GEN10: Creating a Waveform</h3>
<p>The third example for generating a function table covers one classical case: building a function table which stores one cycle of a waveform. This waveform is then read by an oscillator to produce a sound.</p>
<p>There are many GEN Routines to achieve this. The simplest one is <a href="http://www.csounds.com/manual/html/GEN10.html">GEN10</a>. It produces a waveform by adding sine waves which have the &quot;harmonic&quot; frequency relations 1 : 2 : 3  : 4 ... After the usual arguments for function table number, start, size and gen routine number, which are the first four arguments in <a href="http://www.csounds.com/manual/html/ftgen.html">ftgen</a> for all GEN Routines, you must specify for GEN10 the relative strengths of the harmonics. So, if you just provide one argument, you will end up with a sine wave (1st harmonic). The next argument is the strength of the 2nd harmonic, then the 3rd, and so on. In this way, you can build the standard harmonic waveforms by sums of sinoids. This is done in the next example by instruments 1-5. Instrument 6 uses the sine wavetable twice: for generating both the sound and the envelope.</p>
<p>   <em><strong>EXAMPLE 03D04.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
giSaw     ftgen     0, 0, 2^10, 10, 1, 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9
giSquare  ftgen     0, 0, 2^10, 10, 1, 0, 1/3, 0, 1/5, 0, 1/7, 0, 1/9
giTri     ftgen     0, 0, 2^10, 10, 1, 0, -1/9, 0, 1/25, 0, -1/49, 0, 1/81
giImp     ftgen     0, 0, 2^10, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1

  instr 1 ;plays the sine wavetable
aSine     poscil    .2, 400, giSine
aEnv      linen     aSine, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 2 ;plays the saw wavetable
aSaw      poscil    .2, 400, giSaw
aEnv      linen     aSaw, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 3 ;plays the square wavetable
aSqu      poscil    .2, 400, giSquare
aEnv      linen     aSqu, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 4 ;plays the triangular wavetable
aTri      poscil    .2, 400, giTri
aEnv      linen     aTri, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 5 ;plays the impulse wavetable
aImp      poscil    .2, 400, giImp
aEnv      linen     aImp, .01, p3, .05
          outs      aEnv, aEnv
  endin

  instr 6 ;plays a sine and uses the first half of its shape as envelope
aEnv      poscil    .2, 1/6, giSine
aSine     poscil    aEnv, 400, giSine
          outs      aSine, aSine
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 2 4 3
i 3 8 3
i 4 12 3
i 5 16 3
i 6 20 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>How to Write Values to a Function Table</h2>
<p>As we saw, each GEN Routine generates a function table, and by doing this, it writes values into it. But in certain cases you might first want to create an empty table, and then write the values into it later. This section is about how to do this.</p>
<p>Actually it is not correct to speak of an &quot;empty table&quot;. If Csound creates an &quot;empty&quot; table, in fact it writes zeros to the indices which are not specified. This is perhaps the easiest method of creating an &quot;empty&quot; table for 100 values:</p>
<pre><code>giEmpty   ftgen     0, 0, -100, 2, 0</code></pre>
<p>The basic opcode which writes values to existing function tables is <a href="http://www.csounds.com/manual/html/tablew.html">tablew</a> and its i-time descendant <a href="http://www.csounds.com/manual/html/tableiw.html">tableiw</a>. Note that you may have problems with some features if your table is not a power-of-two size . In this case, you can also use <a href="http://www.csounds.com/manual/html/tab.html">tabw</a> / <a href="http://www.csounds.com/manual/html/tab.html">tabw_i</a>, but they don't have the offset- and the wraparound-feature. As usual, you must differentiate if your signal (variable) is i-rate, k-rate or a-rate. The usage is simple and differs just in the class of values you want to write to the table (i-, k- or a-variables):</p>
<pre><code>          tableiw   isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]
          tablew    ksig, kndx, ifn [, ixmode] [, ixoff] [, iwgmode]
          tablew    asig, andx, ifn [, ixmode] [, ixoff] [, iwgmode]</code></pre>
<ul>
<li><strong>isig</strong>, <strong>ksig</strong>, <strong>asig</strong> is the value (variable) you want to write into specified locations of the table;</li>
<li><strong>indx</strong>, <strong>kndx</strong>, <strong>andx</strong> is the location (index) where you write the value;</li>
<li><strong>ifn</strong> is the function table you want to write in;</li>
<li><strong>ixmode</strong> gives the choice to write by raw indices (counting from 0 to size-1), or by a normalized writing mode in which the start and end of each table are always referred as 0 and 1 (not depending on the length of the table). The default is ixmode=0 which means the raw index mode. A value not equal to zero for ixmode changes to the normalized index mode.</li>
<li><strong>ixoff</strong> (default=0) gives an index offset. So, if indx=0 and ixoff=5, you will write at index 5.</li>
<li><strong>iwgmode</strong> tells what you want to do if your index is larger than the size of the table. If iwgmode=0 (default), any index larger than possible is written at the last possible index. If iwgmode=1, the indices are wrapped around. For instance, if your table size is 8, and your index is 10, in the wraparound mode the value will be written at index 2.</li>
</ul>
<p>Here are some examples for i-, k- and a-rate values.</p>
<h3>i-Rate Example</h3>
<p>The following example calculates the first 12 values of a Fibonacci series and writes it to a table. This table has been created first in the header (filled with zeros). Then instrument 1 calculates the values in an i-time loop and writes them to the table with tableiw. Instrument 2 just serves to print the values.</p>
<p>   <em><strong>EXAMPLE 03D05.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

giFt      ftgen     0, 0, -12, -2, 0

  instr 1; calculates first 12 fibonacci values and writes them to giFt
istart    =         1
inext     =         2
indx      =         0
loop:
          tableiw   istart, indx, giFt ;writes istart to table
istartold =         istart ;keep previous value of istart
istart    =         inext ;reset istart for next loop
inext     =         istartold + inext ;reset inext for next loop
          loop_lt   indx, 1, 12, loop
  endin

  instr 2; prints the values of the table
          prints    &quot;%nContent of Function Table:%n&quot;
indx      init      0
loop:
ival      table     indx, giFt
          prints    &quot;Index %d = %f%n&quot;, indx, ival
          loop_lt   indx, 1, ftlen(giFt), loop
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>k-Rate Example</h3>
<p>The next example writes a k-signal continuously into a table. This can be used to record any kind of user input, for instance by MIDI or widgets. It can also be used to record random movements of k-signals, like here:</p>
<p>   <em><strong>EXAMPLE 03D06.csd</strong></em>  <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giFt      ftgen     0, 0, -5*kr, 2, 0; size for 5 seconds of recording
giWave    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1; waveform for oscillator
          seed      0

; - recording of a random frequency movement for 5 seconds, and playing it
  instr 1
kFreq     randomi   400, 1000, 1 ;random frequency
aSnd      poscil    .2, kFreq, giWave ;play it
          outs      aSnd, aSnd
;;record the k-signal
          prints    &quot;RECORDING!%n&quot;
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
kindx     linseg    0, 5, ftlen(giFt)
 ;write the k-signal
          tablew    kFreq, kindx, giFt
  endin

  instr 2; read the values of the table and play it again
;;read the k-signal
          prints    &quot;PLAYING!%n&quot;
 ;create a reading pointer in the table,
 ;moving in 5 seconds from index 0 to the end
kindx     linseg    0, 5, ftlen(giFt)
 ;read the k-signal
kFreq     table     kindx, giFt
aSnd      oscil3    .2, kFreq, giWave; play it
          outs      aSnd, aSnd
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
i 2 6 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>As you see, in this typical case of writing k-values to a table you need a moving signal for the index. This can be done using the <a href="http://www.csounds.com/manual/html/line.html">line</a> or <a href="http://www.csounds.com/manual/html/linseg.html">linseg</a> opcode like here, or by using a <a href="http://www.csounds.com/manual/html/phasor.html">phasor</a>. The <em>phasor</em> always moves from 0 to 1 in a certain frequency. So, if you want the <em>phasor</em> to move from 0 to 1 in 5 seconds, you must set the frequency to 1/5. By setting the <em>ixmode</em> argument of <em>tablew</em> to 1, you can use the <em>phasor</em> output directly as writing pointer. So this is an alternative version of instrument 1 taken from the previous example:</p>
<pre><code>instr 1; recording of a random frequency movement for 5 seconds, and playing it
kFreq     randomi   400, 1000, 1; random frequency
aSnd      oscil3    .2, kFreq, giWave; play it
          outs      aSnd, aSnd
;;record the k-signal with a phasor as index
          prints    &quot;RECORDING!%n&quot;
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
kindx     phasor    1/5
 ;write the k-signal
          tablew    kFreq, kindx, giFt, 1
endin</code></pre>
<h3>a-Rate Example</h3>
<p>Recording an audio signal is quite similar to recording a control signal. You just need an a-signal as input and also as index. The first example shows first the recording of a random audio signal. If you have live audio input, you can then record your input for 5 seconds.</p>
<p>   <em><strong>EXAMPLE 03D07.csd</strong></em>   <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-iadc -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giFt      ftgen     0, 0, -5*sr, 2, 0; size for 5 seconds of recording audio
          seed      0

  instr 1 ;generating a band filtered noise for 5 seconds, and recording it
aNois     rand      .2
kCfreq    randomi   200, 2000, 3; random center frequency
aFilt     butbp     aNois, kCfreq, kCfreq/10; filtered noise
aBal      balance   aFilt, aNois, 1; balance amplitude
          outs      aBal, aBal
;;record the audiosignal with a phasor as index
          prints    &quot;RECORDING FILTERED NOISE!%n&quot;
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
aindx     phasor    1/5
 ;write the k-signal
          tablew    aBal, aindx, giFt, 1
  endin

  instr 2 ;read the values of the table and play it
          prints    &quot;PLAYING FILTERED NOISE!%n&quot;
aindx     phasor    1/5
aSnd      table3    aindx, giFt, 1
          outs      aSnd, aSnd
  endin

  instr 3 ;record live input
ktim      timeinsts ; playing time of the instrument in seconds
          prints    &quot;PLEASE GIVE YOUR LIVE INPUT AFTER THE BEEP!%n&quot;
kBeepEnv  linseg    0, 1, 0, .01, 1, .5, 1, .01, 0
aBeep     oscils    .2, 600, 0
          outs      aBeep*kBeepEnv, aBeep*kBeepEnv
;;record the audiosignal after 2 seconds
 if ktim &gt; 2 then
ain       inch      1
          printks   &quot;RECORDING LIVE INPUT!%n&quot;, 10
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
aindx     phasor    1/5
 ;write the k-signal
          tablew    ain, aindx, giFt, 1
 endif
  endin

  instr 4 ;read the values from the table and play it
          prints    &quot;PLAYING LIVE INPUT!%n&quot;
aindx     phasor    1/5
aSnd      table3    aindx, giFt, 1
          outs      aSnd, aSnd
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
i 2 6 5
i 3 12 7
i 4 20 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>How to Retreive Values from a Function Table</h2>
<p>There are two methods of reading table values. You can either use the <a href="http://www.csounds.com/manual/html/table.html">table</a> / <a href="http://www.csounds.com/manual/html/tab.html">tab</a> opcodes, which are universally usable, but need an index; or you can use an oscillator for reading a table at k-rate or a-rate.<br />
</p>
<h3>The table Opcode</h3>
<p>The <em>table</em> opcode is quite similar in syntax to the <em>tableiw</em>/<em>tablew</em> opcode (which are explained above). It's just its counterpart in reading values from a function table (instead of writing values to it). So its output is either an i-, k- or a-signal. The main input is an index of the appropriate rate (i-index for i-output, k-index for k-output, a-index for a-output). The other arguments are as explained above for tableiw/tablew:<br />
</p>
<pre><code>ires      table    indx, ifn [, ixmode] [, ixoff] [, iwrap]
kres      table    kndx, ifn [, ixmode] [, ixoff] [, iwrap]
ares      table    andx, ifn [, ixmode] [, ixoff] [, iwrap]</code></pre>
<p>As table reading often requires interpolation between the table values - for instance if you read k or a-values faster or slower than they have been written in the table - Csound offers two descendants of table for interpolation: <a href="http://www.csounds.com/manual/html/tablei.html">tablei</a> interpolates linearly, whilst <a href="http://www.csounds.com/manual/html/table3.html">table3</a> performs cubic interpolation (which is generally preferable but is computationally slightly more expensive).<br />
Another variant is the <a href="http://www.csounds.com/manual/html/tab.html">tab_i</a> / <a href="http://www.csounds.com/manual/html/tab.html">tab</a> opcode which misses some features but may be preferable in some situations. If you have any problems in reading non-power-of-two tables, give them a try. They should also be faster than the table opcode, but you must take care: they include fewer built-in protection measures than <em>table</em>, <em>table</em>i and <em>table3</em> and if they are given index values that exceed the table size Csound will stop and report a performance error.<br />
Examples of the use of the <em>table</em> opcodes can be found in the earlier examples in the How-To-Write-Values... section.<br />
</p>
<h3>Oscillators</h3>
<p>Reading table values using an oscillator is standard if you read tables which contain one cycle of a waveform at audio-rate. But actually you can read any table using an oscillator, either at a- or at k-rate. The advantage is that you needn't create an index signal. You can simply specify the frequency of the oscillator.<br />
You should bear in mind that many of the oscillators in Csound will work only with power-of-two table sizes. The <a href="http://www.csounds.com/manual/html/poscil.html">poscil</a>/<a href="http://www.csounds.com/manual/html/poscil3.html">poscil3</a> opcodes do not have this restriction and offer a high precision, because they work with floating point indices, so in general it is recommended to use them. Below is an example that demonstrates both reading a k-rate and an a-rate signal from a buffer with poscil3 (an oscillator with a cubic interpolation):</p>
<p>   <em><strong>EXAMPLE 03D08.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-iadc -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
; -- size for 5 seconds of recording control data
giControl ftgen     0, 0, -5*kr, 2, 0
; -- size for 5 seconds of recording audio data
giAudio   ftgen     0, 0, -5*sr, 2, 0
giWave    ftgen     0, 0, 2^10, 10, 1, .5, .3, .1; waveform for oscillator
          seed      0

; -- ;recording of a random frequency movement for 5 seconds, and playing it
  instr 1
kFreq     randomi   400, 1000, 1; random frequency
aSnd      poscil    .2, kFreq, giWave; play it
          outs      aSnd, aSnd
;;record the k-signal with a phasor as index
          prints    &quot;RECORDING RANDOM CONTROL SIGNAL!%n&quot;
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
kindx     phasor    1/5
 ;write the k-signal
          tablew    kFreq, kindx, giControl, 1
  endin

  instr 2; read the values of the table and play it with poscil
          prints    &quot;PLAYING CONTROL SIGNAL!%n&quot;
kFreq     poscil    1, 1/5, giControl
aSnd      poscil    .2, kFreq, giWave; play it
          outs      aSnd, aSnd
  endin

  instr 3; record live input
ktim      timeinsts ; playing time of the instrument in seconds
          prints    &quot;PLEASE GIVE YOUR LIVE INPUT AFTER THE BEEP!%n&quot;
kBeepEnv  linseg    0, 1, 0, .01, 1, .5, 1, .01, 0
aBeep     oscils    .2, 600, 0
          outs      aBeep*kBeepEnv, aBeep*kBeepEnv
;;record the audiosignal after 2 seconds
 if ktim &gt; 2 then
ain       inch      1
          printks   &quot;RECORDING LIVE INPUT!%n&quot;, 10
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
aindx     phasor    1/5
 ;write the k-signal
          tablew    ain, aindx, giAudio, 1
 endif
  endin

  instr 4; read the values from the table and play it with poscil
          prints    &quot;PLAYING LIVE INPUT!%n&quot;
aSnd      poscil    .5, 1/5, giAudio
          outs      aSnd, aSnd
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 5
i 2 6 5
i 3 12 7
i 4 20 5
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Saving the Contents of a Function Table to a File<br />
</h2>
<p>A function table exists just as long as you run the Csound instance which has created it. If Csound terminates, all the data is lost. If you want to save the data for later use, you must write them to a file. There are several cases, depending on firstly whether you write at i-time or at k-time and secondly on what kind of file you want to write to.<br />
</p>
<h3>Writing a File in Csound's ftsave Format at i-Time or k-Time<br />
</h3>
<p>Any function table in Csound can easily be written to a file by the <a href="http://www.csounds.com/manual/html/ftsave.html">ftsave</a> (i-time) or <a href="http://www.csounds.com/manual/html/ftsavek.html">ftsavek</a> (k-time) opcode. The use is very simple. The first argument specifies the filename (in double quotes), the second argument chooses between a text format (non zero) or a binary format (zero) to write, then you just give the number of the function table(s) to save.<br />
For the following example you should end up with two textfiles in the same folder as your .csd: &quot;i-time_save.txt&quot; saves function table 1 (a sine wave) at i-time; &quot;k-time_save.txt&quot; saves function table 2 (a linear increment produced during the performance) at k-time.</p>
<p>   <em><strong>EXAMPLE 03D09.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giWave    ftgen     1, 0, 2^7, 10, 1; sine with 128 points
giControl ftgen     2, 0, -kr, 2, 0; size for 1 second of recording control data
          seed      0

  instr 1; saving giWave at i-time
          ftsave    &quot;i-time_save.txt&quot;, 1, 1
  endin

  instr 2; recording of a line transition between 0 and 1 for one second
kline     linseg    0, 1, 1
          tabw      kline, kline, giControl, 1
  endin

  instr 3; saving giWave at k-time
          ftsave    &quot;k-time_save.txt&quot;, 1, 2
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 1
i 3 1 .1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The counterpart to ftsave/ftsavek are the opcodes <a href="http://www.csounds.com/manual/html/ftload.html">ftload</a>/<a href="http://www.csounds.com/manual/html/ftloadk.html">ftloadk</a>. Using them you can load the saved files into function tables.<br />
<br />
</p>
<h3>Writing a Soundfile from a Recorded Function Table<br />
</h3>
<p>If you have recorded your live-input to a buffer, you may want to save your buffer as a soundfile. There is no opcode in Csound which does that, but it can be done by using a k-rate loop and the fout opcode. This is shown in the next example, in instrument 2. First instrument 1 records your live input. Then instrument 2 writes the file &quot;testwrite.wav&quot; into the same folder as your .csd. This is done at the first k-cycle of instrument 2, by reading again and again the table values and writing them as an audio signal to disk. After this is done, the instrument is turned off by executing the <a href="http://www.csounds.com/manual/html/turnoff.html">turnoff</a> statement.</p>
<p>   <em><strong>EXAMPLE 03D10.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1
; --  size for 5 seconds of recording audio data
giAudio   ftgen     0, 0, -5*sr, 2, 0

  instr 1 ;record live input
ktim      timeinsts ; playing time of the instrument in seconds
          prints    &quot;PLEASE GIVE YOUR LIVE INPUT AFTER THE BEEP!%n&quot;
kBeepEnv  linseg    0, 1, 0, .01, 1, .5, 1, .01, 0
aBeep     oscils    .2, 600, 0
          outs      aBeep*kBeepEnv, aBeep*kBeepEnv
;;record the audiosignal after 2 seconds
 if ktim &gt; 2 then
ain       inch      1
          printks   &quot;RECORDING LIVE INPUT!%n&quot;, 10
 ;create a writing pointer in the table,
 ;moving in 5 seconds from index 0 to the end
aindx     phasor    1/5
 ;write the k-signal
          tablew    ain, aindx, giAudio, 1
 endif
  endin

  instr 2; write the giAudio table to a soundfile
Soutname  =         &quot;testwrite.wav&quot;; name of the output file
iformat   =         14; write as 16 bit wav file
itablen   =         ftlen(giAudio); length of the table in samples

kcnt      init      0; set the counter to 0 at start
loop:
kcnt      =         kcnt+ksmps; next value (e.g. 10 if ksmps=10)
andx      interp    kcnt-1; calculate audio index (e.g. from 0 to 9)
asig      tab       andx, giAudio; read the table values as audio signal
          fout      Soutname, iformat, asig; write asig to a file
 if kcnt &lt;= itablen-ksmps kgoto loop; go back as long there is something to do
          turnoff   ; terminate the instrument
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7
i 2 7 .1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This code can also be transformed in a <a href="http://www.csounds.com/manual/html/OrchUDO.html">User Defined Opcode</a>. It can be found <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=122">here</a>.</p>
<p><br />
</p>
<h3>Related Opcodes</h3>
<p><a href="http://www.csounds.com/manual/html/ftgen.html">ftgen</a>: Creates a function table in the orchestra using any GEN Routine.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/table.html">table</a> / <a href="http://www.csounds.com/manual/html/tablei.html">tablei</a> / <a href="http://www.csounds.com/manual/html/table3.html">table3</a>: Read values from a function table at any rate, either by direct indexing (table), or by linear (tablei) or cubic (table3) interpolation. These opcodes provide many options and are safe because of boundary check, but you may have problems with non-power-of-two tables.</p>
<p><a href="http://www.csounds.com/manual/html/tab.html">tab_i</a> / <a href="http://www.csounds.com/manual/html/tab.html">tab</a>: Read values from a function table at i-rate (tab_i), k-rate or a-rate (tab). Offer no interpolation and less options than the table opcodes, but they work also for non-power-of-two tables. They do not provide a boundary check, which makes them fast but also give the user the resposability not reading any value off the table boundaries.</p>
<p><a href="http://www.csounds.com/manual/html/tableiw.html">tableiw</a> / <a href="http://www.csounds.com/manual/html/tablew.html">tablew</a>: Write values to a function table at i-rate (tableiw), k-rate and a-rate (tablew). These opcodes provide many options and are safe because of boundary check, but you may have problems with non-power-of-two tables.</p>
<p><a href="http://www.csounds.com/manual/html/tab.html">tabw_i</a> / <a href="http://www.csounds.com/manual/html/tab.html">tabw</a>: Write values to a function table at i-rate (tabw_i), k-rate or a-rate (tabw). Offer less options than the tableiw/tablew opcodes, but work also for non-power-of-two tables. They do not provide a boundary check, which makes them fast but also give the user the resposability not writing any value off the table boundaries.</p>
<p><a href="http://www.csounds.com/manual/html/poscil.html">poscil</a> / <a href="http://www.csounds.com/manual/html/poscil3.html">poscil3</a>: Precise oscillators for reading function tables at k- or a-rate, with linear (poscil) or cubic (poscil3) interpolation. They support also non-power-of-two tables, so it's usually recommended to use them instead of the older oscili/oscil3 opcodes. Poscil has also a-rate input for amplitude and frequency, while poscil3 has just k-rate input. </p>
<p><a href="http://www.csounds.com/manual/html/oscili.html">oscili</a> / <a href="http://www.csounds.com/manual/html/oscil3.html">oscil3</a>: The standard oscillators in Csound for reading function tables at k- or a-rate, with linear (oscili) or cubic (oscil3) interpolation. They support all rates for the amplitude and frequency input, but are restricted to power-of-two tables. Particularily for long tables and low frequencies they are not as precise as the poscil/poscil3 oscillators.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/ftsave.html">ftsave</a> / <a href="http://www.csounds.com/manual/html/ftsavek.html">ftsavek</a>: Save a function table as a file, at i-time (ftsave) or k-time (ftsavek). This can be a text file or a binary file, but not a soundfile. If you want to save a soundfile, use the User Defined Opcode <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=122">TableToSF</a>.</p>
<p><a href="http://www.csounds.com/manual/html/ftload.html">ftload</a> / <a href="http://www.csounds.com/manual/html/ftloadk.html">ftloadk</a>: Load a function table which has been written by ftsave/ftsavek.</p>
<p><a href="http://www.csounds.com/manual/html/line.html">line</a> / <a href="http://www.csounds.com/manual/html/linseg.html">linseg</a> / <a href="http://www.csounds.com/manual/html/phasor.html">phasor</a>: Can be used to create index values which are needed to read/write k- or a-signals with the table/tablew or tab/tabw opcodes.<br />
</p>
<p><br />
</p>
<p><span id="ch020_e-triggering-instrument-events.xhtml"></span></p>
<h1>TRIGGERING INSTRUMENT EVENTS</h1>
<p>The basic concept of Csound from the early days of the program is still valent and fertile because it is a familiar musical one. You create a set of instruments and instruct them to play at various times. These calls of instrument instances, and their execution, are called &quot;instrument events&quot;.</p>
<p>This scheme of instruments and events can be instigated in a number of ways. In the classical approach you think of an &quot;orchestra&quot; with a number of musicians playing from a &quot;score&quot;, but you can also trigger instruments using any kind of live input: from MIDI, from OSC, from the command line, from a GUI (such as Csound's FLTK widgets or QuteCsound's widgets), from the API (also used in QuteCsound's Live Event Sheet). Or you can create a kind of &quot;master instrument&quot;, which is always on, and triggers other instruments using opcodes designed for this task, perhaps under certain conditions: if the live audio input from a singer has been detected to have a base frequency greater than 1043 Hz, then start an instrument which plays a soundfile of broken glass...</p>
<p>This chapter is about the various ways to trigger instrument events whether that be from the score, by using MIDI, by using widgets, through using conditionals or by using loops.</p>
<h2>Order Of Execution</h2>
<p>Whatever you do in Csound with instrument events, you must bear in mind the order of execution that has been explained in the first chapter of this section about the <em>Initialization and Performance Pass</em>: instruments are executed one by one, both in the initialization pass and in each control cycle, and the order is determined <strong>by the instrument number</strong>. So if you have an instrument which triggers another instrument, it should usually have the lower number. If, for instance, instrument 10 calls instrument 20 in a certain control cycle, instrument 20 will execute the event in the same control cycle. But if instrument 20 calls instrument 10, then instrument 10 will execute the event only in the next control cycle.</p>
<h2>Instrument Events From The Score</h2>
<p>This is the classical way of triggering instrument events: you write a list in the score section of a .csd file. Each line which begins with an &quot;i&quot;, is an instrument event. As this is very simple, and examples can be found easily, let us focus instead on some additional features which can be useful when you work in this way. Documentation for these features can be found in the <a href="http://www.csounds.com/manual/html/ScoreStatements.html">Score Statements</a> section of the Canonical Csound Reference Manual. Here are some examples:</p>
<p>   <em><strong>EXAMPLE 03E01.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giWav     ftgen     0, 0, 2^10, 10, 1, .5, .3, .1

  instr 1
kFadout   init      1
krel      release   ;returns &quot;1&quot; if last k-cycle
 if krel == 1 &amp;&amp; p3 &lt; 0 then ;if so, and negative p3:
          xtratim   .5       ;give 0.5 extra seconds
kFadout   linseg    1, .5, 0 ;and make fade out
 endif
kEnv      linseg    0, .01, p4, abs(p3)-.1, p4, .09, 0; normal fade out
aSig      poscil    kEnv*kFadout, p5, giWav
          outs      aSig, aSig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
t 0 120                      ;set tempo to 120 beats per minute
i    1    0    1    .2   400 ;play instr 1 for one second
i    1    2   -10   .5   500 ;play instr 1 indefinetely (negative p3)
i   -1    5    0             ;turn it off (negative p1)
; -- turn on instance 1 of instr 1 one sec after the previous start
i    1.1  ^+1  -10  .2   600
i    1.2  ^+2  -10  .2   700 ;another instance of instr 1
i   -1.2  ^+2  0             ;turn off 1.2
; -- turn off 1.1 (dot = same as the same p-field above)
i   -1.1  ^+1  .
s                            ;end of a section, so time begins from new at zero
i    1    1    1    .2   800
r 5                          ;repeats the following line (until the next &quot;s&quot;)
i    1   .25  .25   .2   900
s
v 2                          ;lets time be double as long
i    1    0    2    .2   1000
i    1    1    1    .2   1100
s
v 0.5                        ;lets time be half as long
i    1    0    2    .2   1200
i    1    1    1    .2   1300
s                            ;time is normal now again
i    1    0    2    .2   1000
i    1    1    1    .2   900
s
; -- make a score loop (4 times) with the variable &quot;LOOP&quot;{4 LOOP
i    1    [0 + 4 * $LOOP.]    3    .2   [1200 - $LOOP. * 100]
i    1    [1 + 4 * $LOOP.]    2    .    [1200 - $LOOP. * 200]
i    1    [2 + 4 * $LOOP.]    1    .    [1200 - $LOOP. * 300]
}
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Triggering an instrument with an indefinite duration by setting p3 to any negative value, and stopping it by a negative p1 value, can be an important feature for live events. If you turn instruments off in this way you may have to add a fade out segment. One method of doing this is shown in the instrument above with a combination of the <a href="http://www.csounds.com/manual/html/release.html">release</a> and the <a href="http://www.csounds.com/manual/html/xtratim.html">xtratim</a> opcodes. Also note that you can start and stop certain instances of an instrument with a floating point number as p1.</p>
<h2>Using MIDI Noteon Events</h2>
<p>Csound has a particular feature which makes it very simple to trigger instrument events from a MIDI keyboard. Each MIDI Note-On event can trigger an instrument, and the related Note-Off event of the same key stops the related instrument instance. This is explained more in detail in the chapter <em>Triggering Instrument Instances</em> in the MIDI section of this manual. Here, just a small example is shown. Simply connect your MIDI keyboard and it should work.</p>
<p>   <em><strong>EXAMPLE 03E02.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-Ma -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          massign   0, 1; assigns all midi channels to instr 1

  instr 1
iFreq     cpsmidi   ;gets frequency of a pressed key
iAmp      ampmidi   8 ;gets amplitude and scales 0-8
iRatio    random    .9, 1.1 ;ratio randomly between 0.9 and 1.1
aTone     foscili   .1, iFreq, 1, iRatio/5, iAmp+1, giSine ;fm
aEnv      linenr    aTone, 0, .01, .01 ; avoiding clicks at the note-end
          outs      aEnv, aEnv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000; play for 10 hours
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Using Widgets</h2>
<p>If you want to trigger an instrument event in realtime with a Graphical User Interface, it is usually a &quot;Button&quot; widget which will do this job. We will see here a simple example; first implemented using Csound's FLTK widgets, and then using QuteCsound's widgets.</p>
<h3>FLTK Button</h3>
<p>This is a very simple example demonstrating how to trigger an instrument using an <a href="http://www.csounds.com/manual/html/FLbutton.html">FLTK button</a>. A more extended example can be found <a href="http://www.csounds.com/manual/html/examples/FLbutton.csd">here</a>.</p>
<p>   <em><strong>EXAMPLE 03E03.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

      ; -- create a FLTK panel --
          FLpanel   &quot;Trigger By FLTK Button&quot;, 300, 100, 100, 100
      ; -- trigger instr 1 (equivalent to the score line &quot;i 1 0 1&quot;)k1, ih1   FLbutton  &quot;Push me!&quot;, 0, 0, 1, 150, 40, 10, 25, 0, 1, 0, 1
      ; -- trigger instr 2
k2, ih2   FLbutton  &quot;Quit&quot;, 0, 0, 1, 80, 40, 200, 25, 0, 2, 0, 1
          FLpanelEnd; end of the FLTK panel section
          FLrun     ; run FLTK
          seed      0; random seed different each time

  instr 1
idur      random    .5, 3; recalculate instrument duration
p3        =         idur; reset instrument duration
ioct      random    8, 11; random values between 8th and 11th octave
idb       random    -18, -6; random values between -6 and -18 dB
aSig      oscils    ampdb(idb), cpsoct(ioct), 0
aEnv      transeg   1, p3, -10, 0
          outs      aSig*aEnv, aSig*aEnv
  endin

instr 2
          exitnow
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Note that in this example the duration of an instrument event is recalculated when the instrument is inititalized. This is done using the statement &quot;p3 = i...&quot;. This can be a useful technique if you want the duration that an instrument plays for to be different each time it is called. In this example duration is the result of a random function'. The duration defined by the FLTK button will be overwriten by any other calculation within the instrument itself at i-time.</p>
<h3>QuteCsound Button</h3>
<p>In QuteCsound, a button can be created easily from the submenu in a widget panel:</p>
<p><img src="/csound/_v/1.0/http:/en.flossmanuals.net/floss/pub/Csound" width="0" height="0" /><img src="static/Csound-Picts-03_CsLanguage-qcbutton1-en.png" title="qcbutton1" alt="qcbutton1" /> </p>
<p>In the Properties Dialog of the button widget, make sure you have selected &quot;event&quot; as Type. Insert a Channel name, and at the bottom type in the event you want to trigger - as you would if writing a line in the score.</p>
<p><img src="static/Csound-Picts-03_CsLanguage-qcbutton3-en.png" title="qcbutton3" alt="qcbutton3" /></p>
<p>In your Csound code, you need nothing more than the instrument you want to trigger:</p>
<p><img src="static/Csound-Picts-03_CsLanguage-qcbutton4-en.png" title="qcbutton4" alt="qcbutton4" /> </p>
<p>For more information about QuteCsound, read the QuteCsound chapter in the 'Frontends' section of this manual.</p>
<h2>Using A Realtime Score (Live Event Sheet)</h2>
<h3>Command Line With The -L stdin Option</h3>
<p>If you use any .csd with the option &quot;-L stdin&quot; (and the -odac option for realtime output), you can type any score line in realtime (sorry, this does not work for Windows). For instance, save this .csd anywhere and run it from the command line:</p>
<p>   <em><strong>EXAMPLE 03E04.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-L stdin -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1
idur      random    .5, 3; calculate instrument duration
p3        =         idur; reset instrument duration
ioct      random    8, 11; random values between 8th and 11th octave
idb       random    -18, -6; random values between -6 and -18 dB
aSig      oscils    ampdb(idb), cpsoct(ioct), 0
aEnv      transeg   1, p3, -10, 0
          outs      aSig*aEnv, aSig*aEnv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>If you run it by typing and returning a commandline like this ...</p>
<p><img src="static/Csound-Picts-03_CsLanguage-cmdline-en.png" title="cmdline" alt="cmdline" /></p>
<p>... you should get a prompt at the end of the Csound messages:</p>
<p><img src="static/Csound-Picts-03_CsLanguage-_L1-en.png" title="_L1" alt="_L1" /> </p>
<p>If you now type the line &quot;i 1 0 1&quot; and press return, you should hear that instrument 1 has been executed. After three times your messages may look like this:</p>
<p><img src="static/Csound-Picts-03_CsLanguage-_L2-en.png" title="_L2" alt="_L2" /> </p>
<h3>QuteCsound's Live Event Sheet</h3>
<p>In general, this is the method that QuteCsound uses and it is made available to the user in a flexible environment called the Live Event Sheet. This is just a screenshot of the current (QuteCsound 0.6.0) example of the Live Event Sheet in QuteCsound:</p>
<p><img src="static/Csound-Picts-03_CsLanguage-qcs_lesheet-en.png" title="qcs_lesheet" alt="qcs_lesheet" /> </p>
<p>Have a look in the QuteCsound frontend to see more of the possibilities of &quot;firing&quot; live instrument events using the Live Event Sheet.</p>
<h2>By Conditions</h2>
<p>We have discussed first the classical method of triggering instrument events from the score section of a .csd file, then we went on to look at different methods of triggering real time events using MIDI, by using widgets, and by using score lines inserted live. We will now look at the Csound orchestra itself and to some methods by which an instrument can internally trigger another instrument. The pattern of triggering could be governed by conditionals, or by different kinds of loops. As this &quot;master&quot; instrument can itself be triggered by a realtime event, you have unlimited options available for combining the different methods.</p>
<p>Let's start with conditionals. If we have a realtime input, we may want to define a threshold, and trigger an event</p>
<ol>
<li>if we cross the threshold from below to above;</li>
<li>if we cross the threshold from above to below.</li>
</ol>
<p>In Csound, this could be implemented using an orchestra of three instruments. The first instrument is the master instrument. It receives the input signal and investigates whether that signal is crossing the threshold and if it does whether it is crossing from low to high or from high to low. If it crosses the threshold from low ot high the second instrument is triggered, if it crosses from high to low the third instrument is triggered.</p>
<p>   <em><strong>EXAMPLE 03E05.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-iadc -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1; master instrument
ichoose   =         p4; 1 = real time audio, 2 = random amplitude movement
ithresh   =         -12; threshold in dB
kstat     init      1; 1 = under the threshold, 2 = over the threshold
;;CHOOSE INPUT SIGNAL
 if ichoose == 1 then
ain       inch      1
 else
kdB       randomi   -18, -6, 1
ain       pinkish   ampdb(kdB)
 endif
;;MEASURE AMPLITUDE AND TRIGGER SUBINSTRUMENTS IF THRESHOLD IS CROSSED
afoll     follow    ain, .1; measure mean amplitude each 1/10 second
kfoll     downsamp  afoll
 if kstat == 1 &amp;&amp; dbamp(kfoll) &gt; ithresh then; transition down-&gt;up
          event     &quot;i&quot;, 2, 0, 1; call instr 2
          printks   &quot;Amplitude = %.3f dB%n&quot;, 0, dbamp(kfoll)
kstat     =         2; change status to &quot;up&quot;
 elseif kstat == 2 &amp;&amp; dbamp(kfoll) &lt; ithresh then; transition up-&gt;down
          event     &quot;i&quot;, 3, 0, 1; call instr 3
          printks   &quot;Amplitude = %.3f dB%n&quot;, 0, dbamp(kfoll)
kstat     =         1; change status to &quot;down&quot;
 endif
  endin

  instr 2; triggered if threshold has been crossed from down to up
asig      oscils    .2, 500, 0
aenv      transeg   1, p3, -10, 0
          outs      asig*aenv, asig*aenv
  endin

  instr 3; triggered if threshold has been crossed from up to down
asig      oscils    .2, 400, 0
aenv      transeg   1, p3, -10, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000 2 ;change p4 to &quot;1&quot; for live input
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Using i-Rate Loops For Calculating A Pool Of Instrument Events</h2>
<p>You can perform a number of calculations at init-time which lead to a list of instrument events. In this way you are producing a score, but inside an instrument. The score events are then executed later.</p>
<p>Using this opportunity we can introduce the <a href="http://www.csounds.com/manual/html/scoreline.html">scoreline</a> / <a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a> opcode. It is quite similar to the <a href="http://www.csounds.com/manual/html/event.html">event</a> / <a href="http://www.csounds.com/manual/html/event_i.html">event_i</a> opcode but has two major benefits:</p>
<ul>
<li>You can write more than one scoreline by using &quot;{{&quot; at the beginning and &quot;}}&quot; at the end.</li>
<li>You can send a string to the subinstrument (which is not possible with the event opcode).</li>
</ul>
<p>Let's look at a simple example for executing score events from an instrument using the scoreline opcode:</p>
<p>   <em><strong>EXAMPLE 03E06.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

          seed      0; random seed different each time

  instr 1 ;master instrument with event pool
          scoreline_i {{i 2 0 2 7.09
                        i 2 2 2 8.04
                        i 2 4 2 8.03
                        i 2 6 1 8.04}}
  endin

  instr 2 ;plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>With good right, you might say: &quot;OK, that's nice, but I can also write scorelines in the score itself!&quot; That's right, but the advantage with the <em>scoreline_i</em> method is that you can <strong>render</strong> the score events in an instrument, and <strong>then</strong> send them out to one or more instruments to execute them. This can be done with the <a href="http://www.csounds.com/manual/html/sprintf.html">sprintf</a> opcode, which produces the string for scoreline in an i-time loop (see the chapter about control structures).</p>
<p>   <em><strong>EXAMPLE 03E07.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giPch     ftgen     0, 0, 4, -2, 7.09, 8.04, 8.03, 8.04
          seed      0; random seed different each time

  instr 1 ; master instrument with event pool
itimes    =         7 ;number of events to produce
icnt      =         0 ;counter
istart    =         0
Slines    =         &quot;&quot;
loop:               ;start of the i-time loop
idur      random    1, 2.9999 ;duration of each note:
idur      =         int(idur) ;either 1 or 2
itabndx   random    0, 3.9999 ;index for the giPch table:
itabndx   =         int(itabndx) ;0-3
ipch      table     itabndx, giPch ;random pitch value from the table
Sline     sprintf   &quot;i 2 %d %d %.2f\n&quot;, istart, idur, ipch ;new scoreline
Slines    strcat    Slines, Sline ;append to previous scorelines
istart    =         istart + idur ;recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop ;end of the i-time loop
          puts      Slines, 1 ;print the scorelines
          scoreline_i Slines ;execute them
iend      =         istart + idur ;calculate the total duration
p3        =         iend ;set p3 to the sum of all durations
          print     p3 ;print it
  endin

  instr 2 ;plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1 ;p3 is automatically set to the total duration
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>In this example, seven events have been rendered in an i-time loop in instrument 1. The result is stored in the string variable <em>Slines</em>. This string is given at i-time to scoreline_i, which executes them then one by one according to their starting times (p2), durations (p3) and other parameters.</p>
<p>If you have many scorelines which are added in this way, you may run to Csound's maximal string length. By default, it is 255 characters. It can be extended by adding the option &quot;-+max_str_len=10000&quot; to Csound's maximum string length of 9999 characters. Instead of collecting all score lines in a single string, you can also execute them inside the i-time loop. Also in this way all the single score lines are added to Csound's event pool. The next example shows an alternative version of the previous one by adding the instrument events one by one in the i-time loop, either with event_i (instr 1) or with scoreline_i (instr 2):<br />
</p>
<p>   <em><strong>EXAMPLE 03E08.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giPch     ftgen     0, 0, 4, -2, 7.09, 8.04, 8.03, 8.04
          seed      0; random seed different each time

  instr 1; master instrument with event_i
itimes    =         7; number of events to produce
icnt      =         0; counter
istart    =         0
loop:               ;start of the i-time loop
idur      random    1, 2.9999; duration of each note:
idur      =         int(idur); either 1 or 2
itabndx   random    0, 3.9999; index for the giPch table:
itabndx   =         int(itabndx); 0-3
ipch      table     itabndx, giPch; random pitch value from the table
          event_i   &quot;i&quot;, 3, istart, idur, ipch; new instrument event
istart    =         istart + idur; recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop; end of the i-time loop
iend      =         istart + idur; calculate the total duration
p3        =         iend; set p3 to the sum of all durations
          print     p3; print it
  endin

  instr 2; master instrument with scoreline_i
itimes    =         7; number of events to produce
icnt      =         0; counter
istart    =         0
loop:               ;start of the i-time loop
idur      random    1, 2.9999; duration of each note:
idur      =         int(idur); either 1 or 2
itabndx   random    0, 3.9999; index for the giPch table:
itabndx   =         int(itabndx); 0-3
ipch      table     itabndx, giPch; random pitch value from the table
Sline     sprintf   &quot;i 3 %d %d %.2f&quot;, istart, idur, ipch; new scoreline
          scoreline_i Sline; execute it
          puts      Sline, 1; print it
istart    =         istart + idur; recalculate start for next scoreline
          loop_lt   icnt, 1, itimes, loop; end of the i-time loop
iend      =         istart + idur; calculate the total duration
p3        =         iend; set p3 to the sum of all durations
          print     p3; print it
  endin

  instr 3; plays the notes
asig      pluck     .2, cpspch(p4), cpspch(p4), 0, 1
aenv      transeg   1, p3, 0, 0
          outs      asig*aenv, asig*aenv
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
i 2 14 1
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Using Time Loops</h2>
<p>As discussed above in the chapter about control structures, a time loop can be built in Csound either with the <a href="http://www.csounds.com/manual/html/timout.html">timout</a> opcode or with the <a href="http://www.csounds.com/manual/html/metro.html">metro</a> opcode. There were also simple examples for triggering instrument events using both methods. Here, a more complex example is given: A master instrument performs a time loop (choose either instr 1 for the timout method or instr 2 for the metro method) and triggers once in a loop a subinstrument. The subinstrument itself (instr 10) performs an i-time loop and triggers several instances of a sub-subinstrument (instr 100). Each instance performs a partial with an independent envelope for a bell-like additive synthesis.</p>
<p>   <em><strong>EXAMPLE 03E09.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  instr 1; time loop with timout. events are triggered by event_i (i-rate)
loop:
idurloop  random    1, 4; duration of each loop
          timout    0, idurloop, play
          reinit    loop
play:
idurins   random    1, 5; duration of the triggered instrument
          event_i   &quot;i&quot;, 10, 0, idurins; triggers instrument 10
  endin

  instr 2; time loop with metro. events are triggered by event (k-rate)
kfreq     init      1; give a start value for the trigger frequency
kTrig     metro     kfreq
 if kTrig == 1 then ;if trigger impulse:
kdur      random    1, 5; random duration for instr 10
          event     &quot;i&quot;, 10, 0, kdur; call instr 10
kfreq     random    .25, 1; set new value for trigger frequency
 endif
  endin

  instr 10; triggers 8-13 partials
inumparts random    8, 14
inumparts =         int(inumparts); 8-13 as integer
ibasoct   random    5, 10; base pitch in octave values
ibasfreq  =         cpsoct(ibasoct)
ipan      random    .2, .8; random panning between left (0) and right (1)
icnt      =         0; counter
loop:
          event_i   &quot;i&quot;, 100, 0, p3, ibasfreq, icnt+1, inumparts, ipan
          loop_lt   icnt, 1, inumparts, loop
  endin

  instr 100; plays one partial
ibasfreq  =         p4; base frequency of sound mixture
ipartnum  =         p5; which partial is this (1 - N)
inumparts =         p6; total number of partials
ipan      =         p7; panning
ifreqgen  =         ibasfreq * ipartnum; general frequency of this partial
ifreqdev  random    -10, 10; frequency deviation between -10% and +10%
; -- real frequency regarding deviation
ifreq     =         ifreqgen + (ifreqdev*ifreqgen)/100
ixtratim  random    0, p3; calculate additional time for this partial
p3        =         p3 + ixtratim; new duration of this partial
imaxamp   =         1/inumparts; maximum amplitude
idbdev    random    -6, 0; random deviation in dB for this partial
iamp      =   imaxamp * ampdb(idbdev-ipartnum); higher partials are softer
ipandev   random    -.1, .1; panning deviation
ipan      =         ipan + ipandev
aEnv      transeg   0, .005, 0, iamp, p3-.005, -10, 0
aSine     poscil    aEnv, ifreq, giSine
aL, aR    pan2      aSine, ipan
          outs      aL, aR
          prints    &quot;ibasfreq = %d, ipartial = %d, ifreq = %d%n&quot;,
                     ibasfreq, ipartnum, ifreq
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 300 ;try this, or the next line (or both)
;i 2 0 300
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
  </code></pre>
<h2>Links And Related Opcodes</h2>
<h3>Links</h3>
<p>A great collection of interactive examples with FLTK widgets by Iain McCurdy can be found <a href="http://iainmccurdy.org/csound.html">here</a>. See particularily the &quot;Realtime Score Generation&quot; section. Recently, the collection has been ported to QuteCsound by René Jopi, and is part of QuteCsound's example menu.<br />
</p>
<p>An extended example for calculating score events at i-time can be found in the <a href="http://www.joachimheintz.de/soft/popsoft.html">Re-Generation of Stockhausen's &quot;Studie II&quot;</a> by Joachim Heintz (also included in the QuteCsound Examples menu).</p>
<h3>Related Opcodes</h3>
<p><a href="http://www.csounds.com/manual/html/event_i.html">event_i</a> / <a href="http://www.csounds.com/manual/html/event.html">event</a>: Generate an instrument event at i-time (event_i) or at k-time (event). Easy to use, but you cannot send a string to the subinstrument.</p>
<p><a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a> / <a href="http://www.csounds.com/manual/html/scoreline.html">scoreline</a>: Generate an instrument at i-time (scoreline_i) or at k-time (scoreline). Like event_i/event, but you can send to more than one instrument but unlike event_i/event you can send strings. On the other hand, you must usually preformat your scoreline-string using sprintf.</p>
<p><a href="http://www.csounds.com/manual/html/sprintf.html">sprintf</a> / <a href="http://www.csounds.com/manual/html/sprintfk.html">sprintfk</a>: Generate a formatted string at i-time (sprintf) or k-time (sprintfk), and store it as a string-variable.</p>
<p><a href="http://www.csounds.com/manual/html/CommandFlags.html">-+max_str_len=10000</a>: Option in the &quot;CsOptions&quot; tag of a .csd file which extend the maximum string length to 9999 characters.</p>
<p><a href="http://www.csounds.com/manual/html/massign.html">massign</a>: Assigns the incoming MIDI events to a particular instrument. It is also possible to prevent any assigment by this opcode.</p>
<p><a href="http://www.csounds.com/manual/html/cpsmidi.html">cpsmidi</a> / <a href="http://www.csounds.com/manual/html/ampmidi.html">ampmidi</a>: Returns the frequency / velocity of a pressed MIDI key.</p>
<p><a href="http://www.csounds.com/manual/html/release.html">release</a>: Returns &quot;1&quot; if the last k-cycle of an instrument has begun.</p>
<p><a href="http://www.csounds.com/manual/html/xtratim.html">xtratim</a>: Adds an additional time to the duration (p3) of an instrument.</p>
<p><a href="http://www.csounds.com/manual/html/turnoff.html">turnoff</a> / <a href="http://www.csounds.com/manual/html/turnoff2.html">turnoff2</a>: Turns an instrument off; either by the instrument itself (turnoff), or from another instrument and with several options (turnoff2).</p>
<p><a href="http://www.csounds.com/manual/html/i.html">-p3 / -p</a><span class="Apple-style-span">1</span>: A negative duration (p3) turns an instrument on &quot;indefinitely&quot;; a negative instrument number (p1) turns this instrument off. See the examples at the beginning of this chapter.</p>
<p><a href="http://www.csounds.com/manual/html/CommandFlags.html">-L stdin</a>: Option in the &quot;CsOptions&quot; tag of a .csd file which lets you type in realtime score events.</p>
<p><a href="http://www.csounds.com/manual/html/timout.html">timout</a>: Allows you to perform time loops at i-time with reinitalization passes.</p>
<p><a href="http://www.csounds.com/manual/html/metro.html">metro</a>: Outputs momentary 1s with a definable (and variable) frequency. Can be used to perform a time loop at k-rate.</p>
<p><a href="http://www.csounds.com/manual/html/follow.html">follow</a>: Envelope follower.</p>
<p><span id="ch021_f-user-defined-opcodes.xhtml"></span></p>
<h1>USER DEFINED OPCODES</h1>
<p>Opcodes are the core units of everything that Csound does. They are like little machines that do a job, and programming is akin to connecting these little machines to perform a larger job. An opcode usually has something which goes into it: the inputs or arguments, and usually it has something which comes out of it: the output which is stored in one or more variables. Opcodes are written in the programming language C (that is where the name &quot;Csound&quot; comes from). If you want to create a new opcode in Csound, you must write it in C. How to do this is described in the <a href="http://en.flossmanuals.net/bin/view/Csound/EXTENDINGCSOUND">Extending Csound</a> chapter of this manual, and is also described in the relevant <a href="http://www.csounds.com/manual/html/csound5extending.html">chapter</a> of the <a href="http://www.csounds.com/manual/html/index.html">Canonical Csound Reference Manual</a>.</p>
<p>There is, however, a way of writing your own opcodes in the Csound Language itself. The opcodes which are written in this way, are called User Defined Opcodes or &quot;UDO&quot;s. A UDO behaves in the same way as a standard opcode: it has input arguments, and usually one or more output variables. They run at i-time or at k-time. You use them as part of the Csound Language after you have defined and loaded them.</p>
<p>User Defined Opcodes have many valuable properties. They make your instrument code clearer because they allow you to create abstractions of  blocks of code. Once a UDO has been defined it can be recalled and repeated many times within an orchestra, each repetition requiring only a single line of code. UDOs allow you to build up your own library of functions you need and return to frequently in your work. In this way, you build your own Csound dialect within the Csound Language. UDOs also represent a convenient format with which to share your work in Csound with other users.</p>
<p>This chapter explains, initially with a very basic example, how you can build your own UDOs, and what options they offer. Following this, the practice of loading UDOs in your .csd file is shown, followed by some tips in regard to some unique capabilities of UDOs. Before the &quot;Links And Related Opcodes&quot; section at the end, some examples are shown for different User Defined Opcode definitions and applications.<br />
</p>
<h2>Transforming Csound Instrument Code To A User Defined Opcode<br />
</h2>
<p>Writing a User Defined Opcode is actually very easy and straightforward. It mainly means to extract a portion of usual Csound instrument code, and put it in the frame of a UDO. Let's start with the instrument code:</p>
<p>   <em><strong>EXAMPLE 03F01.csd</strong></em>   <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  instr 1
aDel      init      0; initialize delay signal
iFb       =         .7; feedback multiplier
aSnd      rand      .2; white noise
kdB       randomi   -18, -6, .4; random movement between -18 and -6
aSnd      =         aSnd * ampdb(kdB); applied as dB to noise
kFiltFq   randomi   100, 1000, 1; random movement between 100 and 1000
aFilt     reson    aSnd, kFiltFq, kFiltFq/5; applied as filter center frequency
aFilt     balance   aFilt, aSnd; bring aFilt to the volume of aSnd
aDelTm    randomi   .1, .8, .2; random movement between .1 and .8 as delay time
aDel      vdelayx   aFilt + iFb*aDel, aDelTm, 1, 128; variable delay
kdbFilt   randomi   -12, 0, 1; two random movements between -12 and 0 (dB) ...
kdbDel    randomi   -12, 0, 1; ... for the filtered and the delayed signal
aOut      =         aFilt*ampdb(kdbFilt) + aDel*ampdb(kdbDel); mix it
          outs      aOut, aOut
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 60
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This is a filtered noise, and its delay, which is fed back again into the delay line at a certain ratio iFb. The filter is moving as kFiltFq randomly between 100 and 1000 Hz. The volume of the filtered noise is moving as kdB randomly between -18 dB and -6 dB. The delay time moves between 0.1 and 0.8 seconds, and then both signals are mixed together.</p>
<h3>Basic Example<br />
</h3>
<p>If this signal processing unit is to be transformed into a User Defined Opcode, the first question is about the extend of the code that will be encapsulated: where the UDO code will begin and end? The first solution could be a radical, and possibly bad, approach: to transform the whole instrument into a UDO.</p>
<p>   <em><strong>EXAMPLE 03F02.csd</strong></em>    <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  opcode FiltFb, 0, 0
aDel      init      0; initialize delay signal
iFb       =         .7; feedback multiplier
aSnd      rand      .2; white noise
kdB       randomi   -18, -6, .4; random movement between -18 and -6
aSnd      =         aSnd * ampdb(kdB); applied as dB to noise
kFiltFq   randomi   100, 1000, 1; random movement between 100 and 1000
aFilt     reson    aSnd, kFiltFq, kFiltFq/5; applied as filter center frequency
aFilt     balance   aFilt, aSnd; bring aFilt to the volume of aSnd
aDelTm    randomi   .1, .8, .2; random movement between .1 and .8 as delay time
aDel      vdelayx   aFilt + iFb*aDel, aDelTm, 1, 128; variable delay
kdbFilt   randomi   -12, 0, 1; two random movements between -12 and 0 (dB) ...
kdbDel    randomi   -12, 0, 1; ... for the filtered and the delayed signal
aOut      =         aFilt*ampdb(kdbFilt) + aDel*ampdb(kdbDel); mix it
          outs      aOut, aOut
  endop

instr 1
          FiltFb
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 60
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt; </code></pre>
<p>Before we continue the discussion about the quality of this transormation, we should have a look at the syntax first. The general syntax for a User Defined Opcode is:</p>
<pre><code>opcode name, outtypes, intypes
...
endop</code></pre>
<p>Here, the <strong>name</strong> of the UDO is <strong>FiltFb</strong>. You are free to use any name, but it is suggested that you begin the name with a capital letter. By doing this, you avoid duplicating the name of most of the pre-existing opcodes (<a href="http://www.csounds.com/manual/html/ControlFltkIntro.html">FLTK</a>and STK opcodes begin with capital letters) which normally start with a lower case letter. As we have no input arguments and no output arguments for this first version of FiltFb, both <strong>outtypes</strong> and <strong>intypes</strong> are set to zero. Similar to the <a href="http://www.csounds.com/manual/html/instr.html">instr</a> ... <a href="http://www.csounds.com/manual/html/endin.html">endin</a> block of a normal instrument definition, for a UDO the <strong>opcode ... endop</strong> keywords begin and end the UDO definition block. In the instrument, the UDO is called like a normal opcode by using its name, and in the same line the input arguments are listed on the right and the output arguments on the left. In the previous a example, 'FiltFb' has no input and output arguments so it is called by just using its name:</p>
<pre><code>instr 1
          FiltFb
endin</code></pre>
<p>Now - why is this UDO more or less useless? It achieves nothing, when compared to the original non UDO version, and in fact loses some of the advantages of the instrument defined version. Firstly, it is not advisable to include this line in the UDO:<br />
</p>
<pre><code>          outs      aOut, aOut</code></pre>
<p>This statement writes the audio signal aOut from inside the UDO to the output device. Imagine you want to change the output channels, or you want to add any signal modifier after the opcode. This would be impossible with this statement. So instead of including the 'outs' opcode, we give the FiltFb UDO an audio output:</p>
<pre><code>          xout      aOut</code></pre>
<p>The <a href="http://www.csounds.com/manual/html/xout.html">xout</a> statement of a UDO definition works like the &quot;outlets&quot; in PD or Max, sending the result(s) of an opcode back to the caller instrument. </p>
<p>Now let us consider the UDO's input arguments, choose which processes should be carried out within the FiltFb unit, and what aspects would offer greater flexibility if controllable from outside the UDO. First, the <strong>aSnd</strong> parameter should not be restricted to a white noise with amplitude 0.2, but should be an input (like a &quot;signal inlet&quot; in PD/Max). This is implemented using the line:</p>
<pre><code>aSnd      xin</code></pre>
<p>Both the output and the input type must be declared in the first line of the UDO definition, whether they are i-, k- or a-variables. So instead of &quot;opcode FiltFb, 0, 0&quot; the statement has changed now to &quot;opcode FiltFb, a, a&quot;, because we have both input and output as a-variable.</p>
<p>The UDO is now much more flexible and logical: it takes any audio input, it performs the filtered delay and feedback processing, and returns the result as another audio signal. In the next example, instrument 1 does exactly the same as before. Instrument 2 has live input instead.<br />
</p>
<p>   <em><strong>EXAMPLE 03F03.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  opcode FiltFb, a, a
aSnd      xin
aDel      init      0; initialize delay signal
iFb       =         .7; feedback multiplier
kdB       randomi   -18, -6, .4; random movement between -18 and -6
aSnd      =         aSnd * ampdb(kdB); applied as dB to noise
kFiltFq   randomi   100, 1000, 1; random movement between 100 and 1000
aFilt     reson    aSnd, kFiltFq, kFiltFq/5; applied as filter center frequency
aFilt     balance   aFilt, aSnd; bring aFilt to the volume of aSnd
aDelTm    randomi   .1, .8, .2; random movement between .1 and .8 as delay time
aDel      vdelayx   aFilt + iFb*aDel, aDelTm, 1, 128; variable delay
kdbFilt   randomi   -12, 0, 1; two random movements between -12 and 0 (dB) ...
kdbDel    randomi   -12, 0, 1; ... for the filtered and the delayed signal
aOut      =         aFilt*ampdb(kdbFilt) + aDel*ampdb(kdbDel); mix it
          xout      aOut
  endop

  instr 1; white noise input
aSnd      rand      .2
aOut      FiltFb    aSnd
          outs      aOut, aOut
  endin

  instr 2; live audio input
aSnd      inch      1; input from channel 1
aOut      FiltFb    aSnd
          outs      aOut, aOut
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 60 ;change to i 2 for live audio input
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>Is There An Optimal Design For A User Defined Opcode?</h3>
<p>Is this now the optimal version of the <em>FiltFb</em> User Defined Opcode? Obviously there are other parts of the opcode definiton which could be controllable from outside: the feedback multiplier <strong>iFb</strong>, the random movement of the input signal <strong>kdB</strong>, the random movement of the filter frequency <strong>kFiltFq</strong>, and the random movements of the output mix <strong>kdbSnd</strong> and <strong>kdbDel</strong>. Is it better to put them outside of the opcode definition, or is it better to leave them inside?</p>
<p>There is no general answer. It depends on the degree of abstraction you desire or you prefer to relinquish. If you are working on a piece for which all of the parameters settings are already defined as required in the UDO, then control from the caller instrument may not be necessary . The advantage of minimizing the number of input and output arguments is the simplification in using the UDO. The more flexibility you require from your UDO however, the greater the number of input arguments that will be required. Providing more control is better for a later reusability, but may be unnecessarily complicated.</p>
<p>Perhaps it is the best solution to have one abstract definition which performs one task, and to create a derivative - also as UDO - fine tuned for the particular project you are working on. The final example demonstrates the definition of a general and more abstract UDO <em>FiltFb</em>, and its various applications: instrument 1 defines the specifications in the instrument itself; instrument 2 uses a second UDO <em>Opus123_FiltFb</em> for this purpose; instrument 3 sets the general <em>FiltFb</em> in a new context of two varying delay lines with a buzz sound as input signal.</p>
<p>   <em><strong>EXAMPLE 03F04.csd</strong></em>   </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  opcode FiltFb, aa, akkkia
; -- DELAY AND FEEDBACK OF A BAND FILTERED INPUT SIGNAL --
;input: aSnd = input sound
; kFb = feedback multiplier (0-1)
; kFiltFq: center frequency for the reson band filter (Hz)
; kQ = band width of reson filter as kFiltFq/kQ
; iMaxDel = maximum delay time in seconds
; aDelTm = delay time
;output: aFilt = filtered and balanced aSnd
; aDel = delay and feedback of aFilt

aSnd, kFb, kFiltFq, kQ, iMaxDel, aDelTm xin
aDel      init      0
aFilt     reson     aSnd, kFiltFq, kFiltFq/kQ
aFilt     balance   aFilt, aSnd
aDel      vdelayx   aFilt + kFb*aDel, aDelTm, iMaxDel, 128; variable delay
          xout      aFilt, aDel
  endop

  opcode Opus123_FiltFb, a, a
;;the udo FiltFb here in my opus 123 :)
;input = aSnd
;output = filtered and delayed aSnd in different mixtures
aSnd      xin
kdB       randomi   -18, -6, .4; random movement between -18 and -6
aSnd      =         aSnd * ampdb(kdB); applied as dB to noise
kFiltFq   randomi   100, 1000, 1; random movement between 100 and 1000
iQ        =         5
iFb       =         .7; feedback multiplier
aDelTm    randomi   .1, .8, .2; random movement between .1 and .8 as delay time
aFilt, aDel FiltFb    aSnd, iFb, kFiltFq, iQ, 1, aDelTm
kdbFilt   randomi   -12, 0, 1; two random movements between -12 and 0 (dB) ...
kdbDel    randomi   -12, 0, 1; ... for the noise and the delay signal
aOut      =         aFilt*ampdb(kdbFilt) + aDel*ampdb(kdbDel); mix it
          xout      aOut
  endop

  instr 1; well known context as instrument
aSnd      rand      .2
kdB       randomi   -18, -6, .4; random movement between -18 and -6
aSnd      =         aSnd * ampdb(kdB); applied as dB to noise
kFiltFq   randomi   100, 1000, 1; random movement between 100 and 1000
iQ        =         5
iFb       =         .7; feedback multiplier
aDelTm    randomi   .1, .8, .2; random movement between .1 and .8 as delay time
aFilt, aDel FiltFb    aSnd, iFb, kFiltFq, iQ, 1, aDelTm
kdbFilt   randomi   -12, 0, 1; two random movements between -12 and 0 (dB) ...
kdbDel    randomi   -12, 0, 1; ... for the noise and the delay signal
aOut      =         aFilt*ampdb(kdbFilt) + aDel*ampdb(kdbDel); mix it
aOut      linen     aOut, .1, p3, 3
          outs      aOut, aOut
  endin

  instr 2; well known context UDO which embeds another UDO
aSnd      rand      .2
aOut      Opus123_FiltFb aSnd
aOut      linen     aOut, .1, p3, 3
          outs      aOut, aOut
  endin

  instr 3; other context: two delay lines with buzz
kFreq     randomh   200, 400, .08; frequency for buzzer
aSnd      buzz      .2, kFreq, 100, giSine; buzzer as aSnd
kFiltFq   randomi   100, 1000, .2; center frequency
aDelTm1   randomi   .1, .8, .2; time for first delay line
aDelTm2   randomi   .1, .8, .2; time for second delay line
kFb1      randomi   .8, 1, .1; feedback for first delay line
kFb2      randomi   .8, 1, .1; feedback for second delay line
a0, aDel1 FiltFb    aSnd, kFb1, kFiltFq, 1, 1, aDelTm1; delay signal 1
a0, aDel2 FiltFb    aSnd, kFb2, kFiltFq, 1, 1, aDelTm2; delay signal 2
aDel1     linen     aDel1, .1, p3, 3
aDel2     linen     aDel2, .1, p3, 3
          outs      aDel1, aDel2
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
i 2 31 30
i 3 62 120
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The good thing about the different possibilities of writing a more specified UDO, or a more generalized: You needn't decide this at the beginning of your work. Just start with any formulation you find useful in a certain situation. If you continue and see that you should have some more parameters accessible, it should be easy to rewrite the UDO. Just be careful not to confuse the different versions you create. Use names like Faulty1, Faulty2 etc. instead of overwriting Faulty. Making use of extensive commenting when you initially create the UDO will make it easier to adapt the UDO at a later time. What are the inputs (including the measurement units they use such as Hertz or seconds)? What are the outputs? - How you do this, is up to you and depends on your style and your preference.<br />
</p>
<h2>How To Use The User Defined Opcode Facility In Practice</h2>
<p>In this section, we will address the main points of using UDOs: what you must bear in mind when loading them, what special features they offer, what restrictions you must be aware of and how you can build your own language with them.<br />
</p>
<h3>Loading User Defined Opcodes In The Orchestra Header</h3>
<p>As can be seen from the examples above, User Defined Opcodes must be defined in the orchestra header (which is sometimes called &quot;instrument 0&quot;). Note that your opcode definitions must be the <strong>last</strong> part of all your orchestra header statements. The following usage results in an error, even though it is probably fair to regard Csound as intolerant in doing so - this intolerance may be removed in future versions of Csound.</p>
<p>   <em><strong>EXAMPLE 03F05.csd</strong></em>   </p>
<pre><code>&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  opcode FiltFb, aa, akkkia
; -- DELAY AND FEEDBACK OF A BAND FILTERED INPUT SIGNAL --
;input: aSnd = input sound
; kFb = feedback multiplier (0-1)
; kFiltFq: center frequency for the reson band filter (Hz)
; kQ = band width of reson filter as kFiltFq/kQ
; iMaxDel = maximum delay time in seconds
; aDelTm = delay time
;output: aFilt = filtered and balanced aSnd
; aDel = delay and feedback of aFilt

aSnd, kFb, kFiltFq, kQ, iMaxDel, aDelTm xin
aDel      init      0
aFilt     reson     aSnd, kFiltFq, kFiltFq/kQ
aFilt     balance   aFilt, aSnd
aDel      vdelayx   aFilt + kFb*aDel, aDelTm, iMaxDel, 128; variable delay
          xout      aFilt, aDel
  endop

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

instr 1
...</code></pre>
<p>Csound will complain about &quot;misplaced opcodes&quot;, which means that the <em>ftgen</em> and the <em>seed</em> statement must be <strong>before</strong> the opcode definitions.<br />
</p>
<h3>Loading A Set Of User Defined Opcodes</h3>
<p>You can load as many User Defined Opcodes into a Csound orchestra as you wish. As long as they do not depend on each other, their order is arbitrarily. If UDO <em>Opus123_FiltFb</em> uses the UDO <em>FiltFb</em> for its definition (see the example above), you must first load <em>FiltFb</em>, and then <em>Opus123_FiltFb</em>. If not, you will get an error like this:</p>
<pre><code>orch compiler:
	opcode	Opus123_FiltFb	a	a	
error:  no legal opcode, line 25:
aFilt, aDel FiltFb    aSnd, iFb, kFiltFq, iQ, 1, aDelTm</code></pre>
<h3>Loading By An #include File</h3>
<p>Definitions of User Defined Opcodes can also be loaded into a .csd file by an &quot;#include&quot; statement. What you must do is the following:</p>
<ol>
<li>Save your opcode definitions in a plain text file, for instance &quot;MyOpcodes.txt&quot;.</li>
<li><p>If this file is in the same directory as your .csd file, you can just call it by the statement:</p>
<pre><code>#include &quot;MyOpcodes.txt&quot;</code></pre></li>
<li><p>If &quot;MyOpcodes.txt&quot; is in a different directory, you must call it by the full path name, for instance:</p>
<pre><code>#include &quot;/Users/me/Documents/Csound/UDO/MyOpcodes.txt&quot;</code></pre></li>
</ol>
<p>As always, make sure that the &quot;#include&quot; statement is the last one in the orchestra header, and that the logical order is accepted if one opcode depends on another.</p>
<p>If you work with User Defined Opcodes a lot, and build up a collection of them, the #include feature allows you easily import several or all of them to your .csd file.<br />
</p>
<h3>The setksmps Feature</h3>
<p>The <a href="http://www.csounds.com/manual/html/ksmps.html">ksmps</a> assignment in the orchestra header cannot be changed during the performance of a .csd file. But in a User Defined Opcode you have the unique possibility of changing this value by a local assignment. If you use a <a href="http://www.csounds.com/manual/html/setksmps.html">setksmps</a> statement in your UDO, you can have a locally smaller value for the number of samples per control cycle in the UDO. In the following example, the print statement in the UDO prints ten times compared to one time in the instrument, because ksmps in the UDO is 10 times smaller:</p>
<p>   <em><strong>EXAMPLE 03F06.csd</strong></em>   <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 44100 ;very high because of printing

  opcode Faster, 0, 0
setksmps 4410 ;local ksmps is 1/10 of global ksmps
printks &quot;UDO print!%n&quot;, 0
  endop

  instr 1
printks &quot;Instr print!%n&quot;, 0 ;print each control period (once per second)
Faster ;print 10 times per second because of local ksmps
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>Default Arguments<br />
</h3>
<p>For i-time arguments, you can use a simple feature to set default values:</p>
<ul>
<li>&quot;o&quot; (instead of &quot;i&quot;) defaults to 0</li>
<li>&quot;p&quot; (instead of &quot;i&quot;) defaults to 1</li>
<li>&quot;j&quot; (instead of &quot;i&quot;) defaults to -1<br />
</li>
</ul>
<p>So you can omit these arguments - in this case the default values will be used. If you give an input argument instead, the default value will be overwritten:</p>
<p>   <em><strong>EXAMPLE 03F07.csd</strong></em>    <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

  opcode Defaults, iii, opj
ia, ib, ic xin
xout ia, ib, ic
  endop

instr 1
ia, ib, ic Defaults
           print     ia, ib, ic
ia, ib, ic Defaults  10
           print     ia, ib, ic
ia, ib, ic Defaults  10, 100
           print     ia, ib, ic
ia, ib, ic Defaults  10, 100, 1000
           print     ia, ib, ic
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>Recursive User Defined Opcodes</h3>
<p>Recursion means that a function can call itself. This is a feature which can be useful in many situations. Also User Defined Opcodes can be recursive. You can do many things with a recursive UDO which you cannot do in any other way; at least not in a simliarly simple way. This is an example of generating eight partials by a recursive UDO. See the last example in the next section for a more musical application of a recursive UDO.</p>
<p>   <em><strong>EXAMPLE 03F08.csd</strong></em>    <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  opcode Recursion, a, iip
;input: frequency, number of partials, first partial (default=1)
ifreq, inparts, istart xin
iamp      =         1/inparts/istart ;decreasing amplitudes for higher partials
 if istart &lt; inparts then ;if inparts have not yet reached
acall     Recursion ifreq, inparts, istart+1 ;call another instance of this UDO
 endif
aout      oscils    iamp, ifreq*istart, 0 ;execute this partial
aout      =         aout + acall ;add the audio signals
          xout      aout
  endop

  instr 1
amix      Recursion 400, 8 ;8 partials with a base frequency of 400 Hz
aout      linen     amix, .01, p3, .1
          outs      aout, aout
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Examples</h2>
<p>We will focus here on some examples which will hopefully show the wide range of User Defined Opcodes. Some of them are adaptions of examples from previous chapters about the Csound Syntax. Much more examples can be found in the <a href="http://www.csounds.com/udo/">User-Defined Opcode Database</a>, editied by Steven Yi.</p>
<h3>Play A Mono Or Stereo Soundfile</h3>
<p>Csound is often very strict and gives errors where other applications might 'turn a blind eye'. This is also the case if you read a soundfile using one of Csound's opcodes: <a href="http://www.csounds.com/manual/html/soundin.html">soundin</a>, <a href="http://www.csounds.com/manual/html/diskin.html">diskin</a> or <a href="http://www.csounds.com/manual/html/diskin2.html">diskin2</a>. If your soundfile is mono, you must use the mono version, which has one audio signal as output. If your soundfile is stereo, you must use the stereo version, which outputs two audio signals. If you want a stereo output, but you happen to have a mono soundfile as input, you will get the error message:</p>
<pre><code>INIT ERROR in ...: number of output args inconsistent with number
of file channels</code></pre>
<p>It may be more useful to have an opcode which works for both, mono and stereo files as input. This is a ideal job for a UDO. Two versions are possible: FilePlay1 returns always one audio signal (if the file is stereo it uses just the first channel), FilePlay2 returns always two audio signals (if the file is mono it duplicates this to both channels). We can use the default arguments to make this opcode behave exactly as diskin2:</p>
<p>   <em><strong>EXAMPLE 03F09.csd</strong></em>     <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  opcode FilePlay1, a, Skoooooo
;gives mono output regardless your soundfile is mono or stereo
;(if stereo, just the first channel is used)
;see diskin2 page of the csound manual for information about the input arguments
Sfil, kspeed, iskip, iloop, iformat, iwsize, ibufsize, iskipinit xin
ichn      filenchnls Sfil
 if ichn == 1 then
aout      diskin2   Sfil, kspeed, iskip, iloop, iformat, iwsize,
                    ibufsize, iskipinit
 else
aout, a0  diskin2   Sfil, kspeed, iskip, iloop, iformat, iwsize,
                    ibufsize, iskipinit
 endif
          xout      aout
  endop

  opcode FilePlay2, aa, Skoooooo
;gives stereo output regardless your soundfile is mono or stereo
;see diskin2 page of the csound manual for information about the input arguments
Sfil, kspeed, iskip, iloop, iformat, iwsize, ibufsize, iskipinit xin
ichn      filenchnls Sfil
 if ichn == 1 then
aL        diskin2    Sfil, kspeed, iskip, iloop, iformat, iwsize,
                     ibufsize, iskipinit
aR        =          aL
 else
aL, aR	    diskin2    Sfil, kspeed, iskip, iloop, iformat, iwsize,
                      ibufsize, iskipinit
 endif
          xout       aL, aR
  endop

  instr 1
aMono     FilePlay1  &quot;fox.wav&quot;, 1
          outs       aMono, aMono
  endin

  instr 2
aL, aR    FilePlay2  &quot;fox.wav&quot;, 1
          outs       aL, aR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 4
i 2 4 4
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>Change The Content Of A Function Table<br />
</h3>
<p>In example <em>03C11.csd</em>, a function table has been changed at performance time, once a second, by random deviations. This can be easily transformed to a User Defined Opcode. It takes the function table variable, a trigger signal, and the random deviation in percent as input. In each control cycle where the trigger signal is &quot;1&quot;, the table values are read. The random deviation is applied, and the changed values are written again into the table. Here, the <a href="http://www.csounds.com/manual/html/tab.html">tab/tabw</a> opcodes are used to make sure that also non-power-of-two tables can be used.</p>
<p>   <em><strong>EXAMPLE 03F10.csd</strong></em>     <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 441
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 256, 10, 1; sine wave
          seed      0; each time different seed

  opcode TabDirtk, 0, ikk
;&quot;dirties&quot; a function table by applying random deviations at a k-rate trigger
;input: function table, trigger (1 = perform manipulation),
;deviation as percentage
ift, ktrig, kperc xin
 if ktrig == 1 then ;just work if you get a trigger signal
kndx      =         0
loop:
krand     random    -kperc/100, kperc/100
kval      tab       kndx, ift; read old value
knewval   =         kval + (kval * krand); calculate new value
          tabw      knewval, kndx, giSine; write new value
          loop_lt   kndx, 1, ftlen(ift), loop; loop construction
 endif
  endop

  instr 1
kTrig     metro     1, .00001 ;trigger signal once per second
          TabDirtk  giSine, kTrig, 10
aSig      poscil    .2, 400, giSine
          outs      aSig, aSig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Of course you can also change the content of a function table at init-time. The next example permutes a series of numbers randomly each time it is called. For this purpose, first the input function table <strong>iTabin</strong> is copied as <strong>iCopy</strong>. This is necessary because we do not want to change iTabin in any way. Next a random index in iCopy is created and the value at this location in iTabin is written at the beginning of <strong>iTabout</strong>, which contains the permuted results. At the end of this cycle, each value in iCopy which has a larger index than the one which has just been read, is shifted one position to the left. So now iCopy has become one position smaller - not in table size but in the number of values to read. This procedure is continued until all values from iCopy are reflected in iTabout:</p>
<p>   <em><strong>EXAMPLE 03F11.csd</strong></em>     </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

giVals    ftgen     0, 0, -12, -2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
          seed      0; each time different seed

  opcode TabPermRand_i, i, i
;permuts randomly the values of the input table
;and creates an output table for the result
iTabin    xin
itablen   =         ftlen(iTabin)
iTabout   ftgen     0, 0, -itablen, 2, 0 ;create empty output table
iCopy     ftgen     0, 0, -itablen, 2, 0 ;create empty copy of input table
          tableicopy iCopy, iTabin ;write values of iTabin into iCopy
icplen    init      itablen ;number of values in iCopy
indxwt    init      0 ;index of writing in iTabout
loop:
indxrd    random    0, icplen - .0001; random read index in iCopy
indxrd    =         int(indxrd)
ival      tab_i     indxrd, iCopy; read the value
          tabw_i    ival, indxwt, iTabout; write it to iTabout
; -- shift values in iCopy larger than indxrd one position to the left
 shift:
 if indxrd &lt; icplen-1 then ;if indxrd has not been the last table value
ivalshft  tab_i     indxrd+1, iCopy ;take the value to the right ...
          tabw_i    ivalshft, indxrd, iCopy ;...and write it to indxrd position
indxrd    =         indxrd + 1 ;then go to the next position
          igoto     shift ;return to shift and see if there is anything left to do
 endif
indxwt    =         indxwt + 1 ;increase the index of writing in iTabout
          loop_gt   icplen, 1, 0, loop ;loop as long as there is ;
                                       ;a value in iCopy
          ftfree    iCopy, 0 ;delete the copy table
          xout      iTabout ;return the number of iTabout
  endop

instr 1
iPerm     TabPermRand_i giVals ;perform permutation
;print the result
indx      =         0
Sres      =         &quot;Result:&quot;
print:
ival      tab_i     indx, iPerm
Sprint    sprintf   &quot;%s %d&quot;, Sres, ival
Sres      =         Sprint
          loop_lt   indx, 1, 12, print
          puts      Sres, 1
endin

instr 2; the same but performed ten times
icnt      =         0
loop:
iPerm     TabPermRand_i giVals ;perform permutation
;print the result
indx      =         0
Sres      =         &quot;Result:&quot;
print:
ival      tab_i     indx, iPerm
Sprint    sprintf   &quot;%s %d&quot;, Sres, ival
Sres      =         Sprint
          loop_lt   indx, 1, 12, print
          puts      Sres, 1
          loop_lt   icnt, 1, 10, loop
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 0
i 2 0 0
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>Print The Content Of A Function Table</h3>
<p>There is no opcode in Csound for printing the contents of a function table, but one can be created as a UDO. Again a loop is needed for checking the values and putting them into a string which can then be printed. In addition, some options can be given for the print precision and for the number of elements in a line.</p>
<p>   <em><strong>EXAMPLE 03F12.csd</strong></em>     <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-ndm0 -+max_str_len=10000
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

gitab     ftgen     1, 0, -7, -2, 0, 1, 2, 3, 4, 5, 6
gisin     ftgen     2, 0, 128, 10, 1


  opcode TableDumpSimp, 0, ijo
;prints the content of a table in a simple way
;input: function table, float precision while printing (default = 3),
;parameters per row (default = 10, maximum = 32)
ifn, iprec, ippr xin
iprec     =         (iprec == -1 ? 3 : iprec)
ippr      =         (ippr == 0 ? 10 : ippr)
iend      =         ftlen(ifn)
indx      =         0
Sformat   sprintf   &quot;%%.%df\t&quot;, iprec
Sdump     =         &quot;&quot;
loop:
ival      tab_i     indx, ifn
Snew      sprintf   Sformat, ival
Sdump     strcat    Sdump, Snew
indx      =         indx + 1
imod      =         indx % ippr
 if imod == 0 then
          puts      Sdump, 1
Sdump     =         &quot;&quot;
 endif
 if indx &lt; iend igoto loop
          puts      Sdump, 1
  endop
	
	
instr 1
          TableDumpSimp p4, p5, p6
          prints    &quot;%n&quot;
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;i1   st   dur   ftab   prec   ppr
i1    0    0     1      -1
i1    .    .     1       0
i1    .    .     2       3     10	
i1    .    .     2       6     32
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>A Recursive User Defined Opcode For Additive Synthesis</h3>
<p>In the last example of the chapter about <a href="http://en.flossmanuals.net/bin/view/Csound/TriggeringInstrumentEvents">Triggering Instrument Events</a> a number of partials were synthesized, each with a random frequency deviation of up to 10% compared to precise harmonic spectrum frequencies and a unique duration for each partial. This can also be written as a recursive UDO. Each UDO generates one partial, and calls the UDO again until the last partial is generated. Now the code can be reduced to two instruments: instrument 1 performs the time loop, calculates the basic values for one note, and triggers the event. Then instrument 11 is called which feeds the UDO with the values and passes the audio signals to the output.</p>
<p>   <em><strong>EXAMPLE 03F13.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

  opcode PlayPartials, aa, iiipo
;plays inumparts partials with frequency deviation and own envelopes and
;durations for each partial
ibasfreq  \ ; base frequency of sound mixture
inumparts \ ; total number of partials
ipan      \ ; panning
ipartnum  \ ; which partial is this (1 - N, default=1)
ixtratim  \ ; extra time in addition to p3 needed for this partial (default=0)
          xin
ifreqgen  =         ibasfreq * ipartnum; general frequency of this partial
ifreqdev  random    -10, 10; frequency deviation between -10% and +10%
ifreq     =         ifreqgen + (ifreqdev*ifreqgen)/100; real frequency
ixtratim1 random    0, p3; calculate additional time for this partial
imaxamp   =         1/inumparts; maximum amplitude
idbdev    random    -6, 0; random deviation in dB for this partial
iamp      =        imaxamp * ampdb(idbdev-ipartnum); higher partials are softer
ipandev   random    -.1, .1; panning deviation
ipan      =         ipan + ipandev
aEnv      transeg   0, .005, 0, iamp, p3+ixtratim1-.005, -10, 0; envelope
aSine     poscil    aEnv, ifreq, giSine
aL1, aR1  pan2      aSine, ipan
 if ixtratim1 &gt; ixtratim then
ixtratim  =  ixtratim1 ;set ixtratim to the ixtratim1 if the latter is larger
 endif
 if ipartnum &lt; inumparts then ;if this is not the last partial
; -- call the next one
aL2, aR2  PlayPartials ibasfreq, inumparts, ipan, ipartnum+1, ixtratim
 else               ;if this is the last partial
p3        =         p3 + ixtratim; reset p3 to the longest ixtratim value
 endif
          xout      aL1+aL2, aR1+aR2
  endop

  instr 1; time loop with metro
kfreq     init      1; give a start value for the trigger frequency
kTrig     metro     kfreq
 if kTrig == 1 then ;if trigger impulse:
kdur      random    1, 5; random duration for instr 10
knumparts random    8, 14
knumparts =         int(knumparts); 8-13 partials
kbasoct   random    5, 10; base pitch in octave values
kbasfreq  =         cpsoct(kbasoct) ;base frequency
kpan      random    .2, .8; random panning between left (0) and right (1)
          event     &quot;i&quot;, 11, 0, kdur, kbasfreq, knumparts, kpan; call instr 11
kfreq     random    .25, 1; set new value for trigger frequency
 endif
  endin

  instr 11; plays one mixture with 8-13 partials
aL, aR    PlayPartials p4, p5, p6
          outs      aL, aR
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 300
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h3>Using Strings as Arrays</h3>
<p>For some situations it can be very useful to use strings in Csound as a collection of single strings or numbers. This is what programming languages call a list or an array. Csound does not provide opcodes for this purpose, but you can define these opcodes as UDOs. A set of these UDOs can then be used like this:</p>
<pre><code>ilen       StrayLen     &quot;a b c d e&quot;
 ilen -&gt; 5
Sel        StrayGetEl   &quot;a b c d e&quot;, 0
 Sel -&gt; &quot;a&quot;
inum       StrayGetNum  &quot;1 2 3 4 5&quot;, 0
 inum -&gt; 1
ipos       StrayElMem   &quot;a b c d e&quot;, &quot;c&quot;
 ipos -&gt; 2
ipos       StrayNumMem  &quot;1 2 3 4 5&quot;, 3
 ipos -&gt; 2
Sres       StraySetEl   &quot;a b c d e&quot;, &quot;go&quot;, 0
 Sres -&gt; &quot;go a b c d e&quot;
Sres       StraySetNum  &quot;1 2 3 4 5&quot;, 0, 0
 Sres -&gt; &quot;0 1 2 3 4 5&quot;
Srev       StrayRev     &quot;a b c d e&quot;
 Srev -&gt; &quot;e d c b a&quot;
Sub        StraySub     &quot;a b c d e&quot;, 1, 3
 Sub -&gt; &quot;b c&quot;
Sout       StrayRmv     &quot;a b c d e&quot;, &quot;b d&quot;
 Sout -&gt; &quot;a c e&quot;
Srem       StrayRemDup  &quot;a b a c c d e e&quot;
 Srem -&gt; &quot;a b c d e&quot;
ift,iftlen StrayNumToFt &quot;1 2 3 4 5&quot;, 1
 ift -&gt; 1 (same as f 1 0 -5 -2 1 2 3 4 5)
 iftlen -&gt; 5</code></pre>
<p>You can find an article about defining such a sub-language <a href="http://www.csounds.com/journal/issue13/index.html">here</a>, and the up to date UDO code <a href="http://joachimheintz.de/soft/Strays.zip">here</a> (or at the <a href="http://www.csounds.com/udo/">UDO repository</a>).<br />
</p>
<h2>Links And Related Opcodes</h2>
<h3>Links<br />
</h3>
<p><a href="http://www.csounds.com/manual/html/opcode.html">This</a> is the page in the Canonical Csound Reference Manual about the definition of UDOs.</p>
<p>The most important resource of User Defined Opcodes is the <a href="http://www.csounds.com/udo/">User-Defined Opcode Database</a>, editied by Steven Yi.</p>
<p>Also by Steven Yi, read the second part of his article about control flow in Csound in the <a href="http://www.csounds.com/journal/2006summer/controlFlow_part2.html">Csound Journal</a> (summer 2006).</p>
<h3>Related Opcodes</h3>
<p><a href="http://www.csounds.com/manual/html/opcode.html">opcode</a>: The opcode used to begin a User Defined Opcode definition.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/include.html">#include</a>: Useful to include any loadable Csound code, in this case definitions of User Defined Opcodes.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/setksmps.html">setksmps</a>: Lets you set a smaller ksmps value locally in a User Defined Opcode.<br />
</p>
<p><br />
</p>
<p><span id="ch022_macros.xhtml"></span></p>
<h1>MACROS</h1>
<p>Macros within Csound is a mechanism whereby a line or a block of text can be referenced using a macro codeword. Whenever the codeword is subsequently encountered in a Csound orchestra or score it will be replaced by the code text contained within the macro. This mechanism can be useful in situations where a line or a block of code will be repeated many times - if a change is required in the code that will be repeated, it need only be altered once in the macro definition rather than having to be edited in each of the repetitions.</p>
<p>Csound utilises a subtly different mechanism for orchestra and score macros so each will be considered in turn. There are also additional features offered by the macro system such as the ability to create a macro that accepts arguments - a little like the main macro containing sub-macros that can be repeated several times within the main macro - the inclusion of a block of text contained within a completely separate file and other macro refinements.</p>
<p>It is important to realise that a macro can contain any text, including carriage returns, and that Csound will be ignorant to its use of syntax until the macro is actually used and expanded elsewhere in the orchestra or score.</p>
<h2>Orchestra Macros</h2>
<p>Macros are defined using the syntax:</p>
<pre><code>#define NAME # replacement text #</code></pre>
<p> 'NAME' is the user-defined name that will be used to call the macro at some point later in the orchestra; it must begin with a letter but can then contain any combination of numbers and letters. 'replacement text', bounded by hash symbols will be the text that will replace the macro name when later called. Remember that the replacement text can stretch over several lines. One syntactical aspect to note is that '#define' needs to be right at the beginning of a line, i.e. the Csound parser will be intolerant toward the initial '#' being preceded by any white space, whether that be spaces or tabs. A macro can be defined anywhere within the &lt;CsInstruments&gt; &lt;/CsInstruments&gt; sections of a .csd file.</p>
<p>When it is desired to use and expand the macro later in the orchestra the macro name needs to be preceded with a '$' symbol thus:</p>
<pre><code>  $NAME</code></pre>
<p>The following example illustrates the basic syntax needed to employ macros. The name of a sound file is referenced twice in the score so it is defined as a macro just after the header statements. Instrument 1 derives the duration of the sound file and instructs instrument 2 to play a note for this duration. instrument 2 plays the sound file. The score as defined in the &lt;CsScore&gt; &lt;/CsScore&gt; section only lasts for 0.01 seconds but the event_i statement in instrument 1 will extend this for the required duration. The sound file is a mono file so you can replace it with any other mono file or use the <a href="http://www.iainmccurdy.org/CsoundRealtimeExamples/SourceMaterials/loop.wav">original one</a>.</p>
<h4><em>EXAMPLE 03G01.csd</em><br />
</h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
sr 	= 	44100
ksmps 	= 	16
nchnls 	= 	1
0dbfs	=	1

; define the macro
#define SOUNDFILE # &quot;loop.wav&quot; #

 instr  1
; use an expansion of the macro in deriving the duration of the sound file
idur  filelen   $SOUNDFILE
      event_i   &quot;i&quot;,2,0,idur
 endin

 instr  2
; use another expansion of the macro in playing the sound file
a1  diskin2  $SOUNDFILE,1
    out      a1
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 0.01
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; example written by Iain McCurdy</code></pre>
<p>In more complex situations where we require slight variations, such as different constant values or different sound files in each reuse of the macro, we can use a macro with arguments. A macro's argument are defined as a list of sub-macro names within brackets after the name of the primary macro and each macro argument is separated by an apostrophe as shown below.</p>
<pre><code>#define NAME(Arg1&#39;Arg2&#39;Arg3...) # replacement text #</code></pre>
<p>Arguments can be any text string permitted as Csound code, they should not be likened to opcode arguments where each must conform to a certain type such as i, k, a etc. Macro arguments are subsequently referenced in the macro text using their names preceded by a '$' symbol. When the main macro is called later in the orchestra its arguments are then replaced with the values or strings required. The Csound Reference Manual states that up to five arguments are permitted but this still refers to an earlier implementation and in fact many more are actually permitted.<br />
</p>
<p>In the following example a 6 partial additive synthesis engine with a percussive character is defined within a macro. Its fundamental frequency and the ratios of its six partials to this fundamental frequency are prescribed as macro arguments. The macro is reused within the orchestra twice to create two different timbres, it could be reused many more times however. The fundamental frequency argument is passed to the macro as p4 from the score.<br />
</p>
<h4><em>EXAMPLE 03G02.csd</em><br />
</h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
sr 	= 	44100
ksmps 	= 	16
nchnls 	= 	1
0dbfs	=	1

gisine  ftgen  0,0,2^10,10,1

; define the macro
#define ADDITIVE_TONE(Frq&#39;Ratio1&#39;Ratio2&#39;Ratio3&#39;Ratio4&#39;Ratio5&#39;Ratio6) #
iamp =      0.1
aenv expseg  1,p3*(1/$Ratio1),0.001,1,0.001
a1  poscil  iamp*aenv,$Frq*$Ratio1,gisine
aenv expseg  1,p3*(1/$Ratio2),0.001,1,0.001
a2  poscil  iamp*aenv,$Frq*$Ratio2,gisine
aenv expseg  1,p3*(1/$Ratio3),0.001,1,0.001
a3  poscil  iamp*aenv,$Frq*$Ratio3,gisine
aenv expseg  1,p3*(1/$Ratio4),0.001,1,0.001
a4  poscil  iamp*aenv,$Frq*$Ratio4,gisine
aenv expseg  1,p3*(1/$Ratio5),0.001,1,0.001
a5  poscil  iamp*aenv,$Frq*$Ratio5,gisine
aenv expseg  1,p3*(1/$Ratio6),0.001,1,0.001
a6  poscil  iamp*aenv,$Frq*$Ratio6,gisine
a7  sum     a1,a2,a3,a4,a5,a6
    out     a7
#

 instr  1 ; xylophone
; expand the macro with partial ratios that reflect those of a xylophone
; the fundemental frequency macro argument (the first argument -
; - is passed as p4 from the score
$ADDITIVE_TONE(p4&#39;1&#39;3.932&#39;9.538&#39;16.688&#39;24.566&#39;31.147)
 endin

 instr  2 ; vibraphone
$ADDITIVE_TONE(p4&#39;1&#39;3.997&#39;9.469&#39;15.566&#39;20.863&#39;29.440)
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0  1 200
i 1 1  2 150
i 1 2  4 100
i 2 3  7 800
i 2 4  4 700
i 2 5  7 600
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; example written by Iain McCurdy
</code></pre>
<h2>Score Macros</h2>
<p>Score macros employ a similar syntax. Macros in the score can be used in situations where a long string of p-fields are likely to be repeated or, as in the next example, to define a palette of score patterns than repeat but with some variation such as transposition. In this example two 'riffs' are defined which each employ two macro arguments: the first to define when the riff will begin and the second to define a transposition factor in semitones. These riffs are played back using a bass guitar-like instrument using the <a href="http://www.csounds.com/manual/html/wgpluck2.html">wgpluck2</a> opcode. Remember that mathematical expressions within the Csound score must be bound within square brackets [].<br />
</p>
<h4><em>EXAMPLE 03G02.csd</em></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
sr 	= 	44100
ksmps 	= 	16
nchnls 	= 	1
0dbfs	=	1


 instr  1 ; bass guitar
a1   wgpluck2 0.98, 0.4, cpsmidinn(p4), 0.1, 0.6
aenv linseg   1,p3-0.1,1,0.1,0
 out	a1*aenv
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; p4 = pitch as a midi note number
#define RIFF_1(Start&#39;Trans)
#
i 1 [$Start     ]  1     [36+$Trans]
i 1 [$Start+1   ]  0.25  [43+$Trans]
i 1 [$Start+1.25]  0.25  [43+$Trans]
i 1 [$Start+1.75]  0.25  [41+$Trans]
i 1 [$Start+2.5 ]  1     [46+$Trans]
i 1 [$Start+3.25]  1     [48+$Trans]
#
#define RIFF_2(Start&#39;Trans)
#
i 1 [$Start     ]  1     [34+$Trans]
i 1 [$Start+1.25]  0.25  [41+$Trans]
i 1 [$Start+1.5 ]  0.25  [43+$Trans]
i 1 [$Start+1.75]  0.25  [46+$Trans]
i 1 [$Start+2.25]  0.25  [43+$Trans]
i 1 [$Start+2.75]  0.25  [41+$Trans]
i 1 [$Start+3   ]  0.5   [43+$Trans]
i 1 [$Start+3.5 ]  0.25  [46+$Trans]
#
t 0 90
$RIFF_1(0 &#39; 0)
$RIFF_1(4 &#39; 0)
$RIFF_2(8 &#39; 0)
$RIFF_2(12&#39;-5)
$RIFF_1(16&#39;-5)
$RIFF_2(20&#39;-7)
$RIFF_2(24&#39; 0)
$RIFF_2(28&#39; 5)
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; example written by Iain McCurdy</code></pre>
<p>Score macros can themselves contain macros so that, for example, the above example could be further expanded so that a verse, chorus structure could be employed where verses and choruses, defined using macros, were themselves constructed from a series of riff macros. <br />
</p>
<p>UDOs and macros can both be used to reduce code repetition and there are many situations where either could be used but each offers its own strengths. UDOs strengths lies in their ability to be used just like an opcode with inputs and output, the ease with which they can be shared - between Csound projects and between Csound users - their ability to operate at a different k-rate to the rest of the orchestra and in how they facilitate recursion. The fact that macro arguments are merely blocks of text, however, offers up new possibilities and unlike UDOs, macros can span several instruments. Of course UDOs have no use in the Csound score unlike macros. Macros can also be used to simplify the creation of complex FLTK GUI where panel sections might be repeated with variations of output variable names and location.<br />
</p>
<p>Csound's orchestra and score macro system offers many additional refinements and this chapter serves merely as an introduction to their basic use. To learn more it is recommended to refer to the relevant sections of the <a href="http://www.csounds.com/manual/html/OrchMacros.html">Csound Reference Manual</a>.</p>
<p><br />
</p>
<p><span id="ch024_a-additive-synthesis.xhtml"></span></p>
<h1>ADDITIVE SYNTHESIS</h1>
<p>Jean Baptiste Joseph Fourier demonstrated around 1800 that any continuous function can be perfectly described as a sum of sine waves. This in fact means that you can create any sound, no matter how complex, if you know which sine waves to add together.</p>
<p>This concept really excited the early pioneers of electronic music, who imagined that sine waves would give them the power to create any sound imaginable and previously unimagined. Unfortunately, they soon realized that while adding sine waves is easy, interesting sounds must have a large number of sine waves which are constantly varying in frequency and amplitude, which turns out to be a hugely impractical task.</p>
<p>However, additive synthesis can provide unusual and interesting sounds. Moreover both, the power of modern computers, and the ability of managing data in a programming language offer new dimensions of working with this old tool. As with most things in Csound there are several ways to go about it. We will try to show some of them, and see how they are connected with different programming paradigms.<br />
</p>
<h2>What are the main parameters of Additive Synthesis?</h2>
<p>Before going into different ways of implementing additive synthesis in Csound, we shall think about the parameters to consider. As additive synthesis is the addition of several sine generators, the parameters are on two different levels:</p>
<ul>
<li>
<p><strong>For each sine</strong>, there is a frequency and an amplitude with an envelope.</p>
</li>
<ul>
<li>The <strong>frequency</strong> is usually a constant value. But it can be varied, though. Natural sounds usually have very slight changes of partial frequencies.</li>
<li>The <strong>amplitude</strong> must at least have a simple envelope like the well-known ADSR. But more complex ways of continuously altering the amplitude will make the sound much more lively.<br />
</li>
</ul>
<li>
<p><strong>For the sound as a whole</strong>, these are the relevant parameters:</p>
</li>
<ul>
<li>The total <strong>number of sinusoids</strong>. A sound which consists of just three sinusoids is of course &quot;poorer&quot; than a sound which consists of 100 sinusoids.<br />
</li>
<li>The <strong>frequency ratios</strong> of the sine generators. For a classical harmonic spectrum, the multipliers of the sinusoids are 1, 2, 3, ... (If your first sine is 100 Hz, the others are 200, 300, 400, ... Hz.) For an inharmonic or noisy spectrum, there are probably no simple integer ratios. This frequency ratio is mainly responsible for our perception of timbre.</li>
<li>The <strong>base frequency</strong> is the frequency of the first partial. If the partials are showing an harmonic ratio, this frequency (in the example given 100 Hz) is also the overall perceived pitch.<br />
</li>
<li>The <strong>amplitude ratios</strong> of the sinusoids. This is also very important for the resulting timbre of a sound. If the higher partials are relatively strong, the sound appears more brilliant; if the higher partials are soft, the sound appears dark and soft.</li>
<li>The <strong>duration ratios</strong> of the sinusoids. In simple additive synthesis, all single sines have the same duration, but they may also differ. This usually relates to the envelopes: if the envelopes of different partials vary, some partials may die away faster than others.</li>
</ul>
</ul>
<p>It is not always the aim of additive synthesis to imitate natural sounds, but it can definitely be  learned a lot through the task of first analyzing and then attempting to imitate a sound using additive synthesis techniques. This is what a guitar note looks like when spectrally analyzed:</p>
<p><img src="static/wf_v2.png" /> </p>
<p><em>Spectral analysis of a guitar tone in time (courtesy of W. Fohl, Hamburg) </em><br />
</p>
<p>Each partial has its own movement and duration. We may or may not be able to achieve this successfully in additive synthesis. Let us begin with some simple sounds and consider ways of programming this with Csound; later we will look at some more complex sounds and advanced ways of programming this.<br />
</p>
<h2>Simple Additions of Sinusoids inside an Instrument<br />
</h2>
<p>If additive synthesis amounts to the adding sine generators, it is straightforward to create multiple oscillators in a single instrument and to add the resulting audio signals together. In the following example, instrument 1 shows a harmonic spectrum, and instrument 2 an inharmonic one. Both instruments share the same amplitude multipliers: 1, 1/2, 1/3, 1/4, ... and receive the base frequency in Csound's pitch notation (octave.semitone) and the main amplitude in dB.<br />
</p>
<p><em><strong>EXAMPLE 04A01.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by Andrés Cabrera
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

    instr 1 ;harmonic additive synthesis
;receive general pitch and volume from the score
ibasefrq  =         cpspch(p4) ;convert pitch values to frequency
ibaseamp  =         ampdbfs(p5) ;convert dB to amplitude
;create 8 harmonic partials
aOsc1     poscil    ibaseamp, ibasefrq, giSine
aOsc2     poscil    ibaseamp/2, ibasefrq*2, giSine
aOsc3     poscil    ibaseamp/3, ibasefrq*3, giSine
aOsc4     poscil    ibaseamp/4, ibasefrq*4, giSine
aOsc5     poscil    ibaseamp/5, ibasefrq*5, giSine
aOsc6     poscil    ibaseamp/6, ibasefrq*6, giSine
aOsc7     poscil    ibaseamp/7, ibasefrq*7, giSine
aOsc8     poscil    ibaseamp/8, ibasefrq*8, giSine
;apply simple envelope
kenv      linen     1, p3/4, p3, p3/4
;add partials and write to output
aOut = aOsc1 + aOsc2 + aOsc3 + aOsc4 + aOsc5 + aOsc6 + aOsc7 + aOsc8
          outs      aOut*kenv, aOut*kenv
    endin

    instr 2 ;inharmonic additive synthesis
ibasefrq  =         cpspch(p4)
ibaseamp  =         ampdbfs(p5)
;create 8 inharmonic partials
aOsc1     poscil    ibaseamp, ibasefrq, giSine
aOsc2     poscil    ibaseamp/2, ibasefrq*1.02, giSine
aOsc3     poscil    ibaseamp/3, ibasefrq*1.1, giSine
aOsc4     poscil    ibaseamp/4, ibasefrq*1.23, giSine
aOsc5     poscil    ibaseamp/5, ibasefrq*1.26, giSine
aOsc6     poscil    ibaseamp/6, ibasefrq*1.31, giSine
aOsc7     poscil    ibaseamp/7, ibasefrq*1.39, giSine
aOsc8     poscil    ibaseamp/8, ibasefrq*1.41, giSine
kenv      linen     1, p3/4, p3, p3/4
aOut = aOsc1 + aOsc2 + aOsc3 + aOsc4 + aOsc5 + aOsc6 + aOsc7 + aOsc8
          outs aOut*kenv, aOut*kenv
    endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;          pch       amp
i 1 0 5    8.00      -10
i 1 3 5    9.00      -14
i 1 5 8    9.02      -12
i 1 6 9    7.01      -12
i 1 7 10   6.00      -10
s
i 2 0 5    8.00      -10
i 2 3 5    9.00      -14
i 2 5 8    9.02      -12
i 2 6 9    7.01      -12
i 2 7 10   6.00      -10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Simple Additions of Sinusoids via the Score<br />
</h2>
<p>A typical paradigm in programming: If you find some almost identical lines in your code, consider to abstract it. For the Csound Language this can mean, to move parameter control to the score. In our case, the lines</p>
<pre><code>aOsc1     poscil    ibaseamp, ibasefrq, giSine
aOsc2     poscil    ibaseamp/2, ibasefrq*2, giSine
aOsc3     poscil    ibaseamp/3, ibasefrq*3, giSine
aOsc4     poscil    ibaseamp/4, ibasefrq*4, giSine
aOsc5     poscil    ibaseamp/5, ibasefrq*5, giSine
aOsc6     poscil    ibaseamp/6, ibasefrq*6, giSine
aOsc7     poscil    ibaseamp/7, ibasefrq*7, giSine
aOsc8     poscil    ibaseamp/8, ibasefrq*8, giSine</code></pre>
<p>can be abstracted to the form</p>
<pre><code>aOsc     poscil    ibaseamp*iampfactor, ibasefrq*ifreqfactor, giSine</code></pre>
<p>with the parameters <em>iampfactor</em> (the relative amplitude of a partial) and <em>ifreqfactor</em> (the frequency multiplier) transferred to the score.<br />
</p>
<p>The next version simplifies the instrument code and defines the variable values as score parameters:</p>
<p><em><strong>EXAMPLE 04A02.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by Andrés Cabrera and Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

    instr 1
iBaseFreq =         cpspch(p4)
iFreqMult =         p5 ;frequency multiplier
iBaseAmp  =         ampdbfs(p6)
iAmpMult  =         p7 ;amplitude multiplier
iFreq     =         iBaseFreq * iFreqMult
iAmp      =         iBaseAmp * iAmpMult
kEnv      linen     iAmp, p3/4, p3, p3/4
aOsc      poscil    kEnv, iFreq, giSine
          outs      aOsc, aOsc
    endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;          freq      freqmult  amp       ampmult
i 1 0 7    8.09      1         -10       1
i . . 6    .         2         .         [1/2]
i . . 5    .         3         .         [1/3]
i . . 4    .         4         .         [1/4]
i . . 3    .         5         .         [1/5]
i . . 3    .         6         .         [1/6]
i . . 3    .         7         .         [1/7]
s
i 1 0 6    8.09      1.5       -10       1
i . . 4    .         3.1       .         [1/3]
i . . 3    .         3.4       .         [1/6]
i . . 4    .         4.2       .         [1/9]
i . . 5    .         6.1       .         [1/12]
i . . 6    .         6.3       .         [1/15]
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>You might say: Okay, where is the simplification? There are even more lines than before! - This is true, and this is certainly just a step on the way to a better code. The main benefit now is <em>flexibility</em>. Now our code is capable of realizing any number of partials, with any amplitude, frequency and duration ratios. Using the Csound score abbreviations (for instance a dot for repeating the previous value in the same p-field), you can do a lot of copy-and-paste, and focus on what is changing from line to line.</p>
<p>Note also that you are now calling <strong>one instrument in multiple instances</strong> at the same time for performing additive synthesis. In fact, each instance of the instrument contributes just one partial for the additive synthesis. This call of multiple and simultaneous instances of one instrument is also a typical procedure for situations like this, and for writing clean and effective Csound code. We will discuss later how this can be done in a more elegant way than in the last example.<br />
</p>
<h2>Creating Function Tables for Additive Synthesis<br />
</h2>
<p>Before we continue on this road, let us go back to the first example and discuss a classical and abbreviated method of playing a number of partials. As we mentioned at the beginning, Fourier stated that any periodic oscillation can be described as a sum of simple sinusoids. If the single sinusoids are static (no individual envelope or duration), the resulting waveform will always be the same.</p>
<p><br />
</p>
<div data-align="center">

</div>
<p><img src="static/teiltoene_bild3.png" /></p>
<p><br />
</p>
<p>You see four sine generators, each with fixed frequency and amplitude relations, and mixed together. At the bottom of the illustration you see the composite waveform which repeats itself at each period. So - why not just calculate this composite waveform first, and then read it with just one oscillator?</p>
<p>This is what some Csound GEN routines do. They compose the resulting shape of the periodic wave, and store the values in a function table. GEN10 can be used for creating a waveform consisting of harmonically related partials. After the common GEN routine p-fields</p>
<pre><code>&lt;table number&gt;, &lt;creation time&gt;, &lt;size in points&gt;, &lt;GEN number&gt;</code></pre>
<p>you have just to determine the relative strength of the harmonics. GEN09 is more complex and allows you to also control the frequency multiplier and the phase (0-360°) of each partial. We are able to reproduce the first example in a shorter (and computational faster) form:</p>
<p><em><strong>EXAMPLE 04A03.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by Andrés Cabrera and Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
giHarm    ftgen     1, 0, 2^12, 10, 1, 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8
giNois    ftgen     2, 0, 2^12, 9, 100,1,0,  102,1/2,0,  110,1/3,0,
                 123,1/4,0,  126,1/5,0,  131,1/6,0,  139,1/7,0,  141,1/8,0

    instr 1
iBasFreq  =         cpspch(p4)
iTabFreq  =         p7 ;base frequency of the table
iBasFreq  =         iBasFreq / iTabFreq
iBaseAmp  =         ampdb(p5)
iFtNum    =         p6
aOsc      poscil    iBaseAmp, iBasFreq, iFtNum
aEnv      linen     aOsc, p3/4, p3, p3/4
          outs      aEnv, aEnv
    endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;          pch       amp       table      table base (Hz)
i 1 0 5    8.00      -10       1          1
i . 3 5    9.00      -14       .          .
i . 5 8    9.02      -12       .          .
i . 6 9    7.01      -12       .          .
i . 7 10   6.00      -10       .          .
s
i 1 0 5    8.00      -10       2          100
i . 3 5    9.00      -14       .          .
i . 5 8    9.02      -12       .          .
i . 6 9    7.01      -12       .          .
i . 7 10   6.00      -10       .          .
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>As you can see, for non-harmonically related partials, the construction of a table must be done with a special care. If the frequency multipliers in our first example started with 1 and 1.02, the resulting period is acually very long. For a base frequency of 100 Hz, you will have the frequencies of 100 Hz and 102 Hz overlapping each other. So you need 100 cycles from the 1.00 multiplier and 102 cycles from the 1.02 multiplier to complete one period and to start again both together from zero. In other words, we have to create a table which contains 100 respectively 102 periods, instead of 1 and 1.02. Then the table values are not related to 1 - as usual - but to 100. That is the reason we have to introduce a new parameter <em>iTabFreq</em> for this purpose.<br />
</p>
<p>This method of composing waveforms can also be used for generating the four standard historical shapes used in a synthesizer. An <strong>impulse</strong> wave can be created by adding a number of harmonics of the same strength. A <strong>sawtooth</strong> has the amplitude multipliers 1, 1/2, 1/3, ... for the harmonics. A <strong>square</strong> has the same multipliers, but just for the odd harmonics. A <strong>triangle</strong> can be calculated as 1 divided by the square of the odd partials, with swaping positive and negative values. The next example creates function tables with just ten partials for each standard form.</p>
<p><em><strong>EXAMPLE 04A04.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giImp  ftgen  1, 0, 4096, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
giSaw  ftgen  2, 0, 4096, 10, 1,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10
giSqu  ftgen  3, 0, 4096, 10, 1, 0, 1/3, 0, 1/5, 0, 1/7, 0, 1/9, 0
giTri  ftgen  4, 0, 4096, 10, 1, 0, -1/9, 0, 1/25, 0, -1/49, 0, 1/81, 0

instr 1
asig   poscil .2, 457, p4
       outs   asig, asig
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3 1
i 1 4 3 2
i 1 8 3 3
i 1 12 3 4
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Triggering Subinstruments for the Partials </h2>
<p>Performing additive synthesis by designing partial strengths into function tables has the disadvantage that once a note has begun there is no way of varying the relative strengths of individual partials. There are various methods to circumvent the inflexibility of table-based additive synthesis such as morphing between several tables (using for example the <a href="http://www.csounds.com/manual/html/ftmorf.html">ftmorf</a> opcode). Next we will consider another approach: triggering one instance of a subinstrument for each partial, and exploring the possibilities of creating a spectrally dynamic sound using this technique.</p>
<p>Let us return to the second instrument (05A02.csd) which already made some abstractions and triggered one instrument instance for each partial. This was done in the score; but now we will trigger one complete note in one score line, not just one partial. The first step is to assign the desired number of partials via a score parameter. The next example triggers any number of partials using this one value:</p>
<p><em><strong>EXAMPLE 04A05.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

instr 1 ;master instrument
inumparts =         p4 ;number of partials
ibasfreq  =         200 ;base frequency
ipart     =         1 ;count variable for loop
;loop for inumparts over the ipart variable
;and trigger inumpartss instanes of the subinstrument
loop:
ifreq     =         ibasfreq * ipart
iamp      =         1/ipart/inumparts
          event_i   &quot;i&quot;, 10, 0, p3, ifreq, iamp
          loop_le   ipart, 1, inumparts, loop
endin

instr 10 ;subinstrument for playing one partial
ifreq     =         p4 ;frequency of this partial
iamp      =         p5 ;amplitude of this partial
aenv      transeg   0, .01, 0, iamp, p3-0.1, -10, 0
apart     poscil    aenv, ifreq, giSine
          outs      apart, apart
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;         number of partials
i 1 0 3   10
i 1 3 3   20
i 1 6 3   2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This instrument can easily be transformed to be played via a midi keyboard. The next example connects the number of synthesized partials with the midi velocity. So if you play softly, the sound will have fewer partials than if a key is struck with force.</p>
<p><em><strong>EXAMPLE 04A06.csd</strong></em>  <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1
          massign   0, 1 ;all midi channels to instr 1

instr 1 ;master instrument
ibasfreq  cpsmidi	;base frequency
iampmid   ampmidi   20 ;receive midi-velocity and scale 0-20
inparts   =         int(iampmid)+1 ;exclude zero
ipart     =         1 ;count variable for loop
;loop for inumparts over the ipart variable
;and trigger inumpartss instanes of the subinstrument
loop:
ifreq     =         ibasfreq * ipart
iamp      =         1/ipart/inparts
          event_i   &quot;i&quot;, 10, 0, 1, ifreq, iamp
          loop_le   ipart, 1, inparts, loop
endin

instr 10 ;subinstrument for playing one partial
ifreq     =         p4 ;frequency of this partial
iamp      =         p5 ;amplitude of this partial
aenv      transeg   0, .01, 0, iamp, p3-.01, -3, 0
apart     poscil    aenv, ifreq, giSine
          outs      apart/3, apart/3
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 3600
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Although this instrument is rather primitive it is useful to be able to control the timbre in this using key velocity. Let us continue to explore other methods of creating parameter variations in additive synthesis.</p>
<h2>User-controlled Random Variations in Additive Synthesis<br />
</h2>
<p>In natural sounds, there is movement and change all the time. Even the best player or singer will not be able to play a note in the exact same way twice. And inside a tone, the partials have some unsteadiness all the time: slight excitations of the amplitudes, uneven durations, slight frequency movements. In an audio programming language like Csound, we can achieve these movements with random deviations. It is not so important whether we use randomness or not, rather in which way. The boundaries of random deviations must be adjusted as carefully as with any other parameter in electronic composition. If sounds using random deviations begin to sound like mistakes then it is probably less to do with actually using random functions but instead more to do with some poorly chosen boundaries.</p>
<p>Let us start with some random deviations in our subinstrument. These parameters can be affected:</p>
<ul>
<li>The <strong>frequency</strong> of each partial can be slightly detuned. The range of this possible maximum detuning can be set in cents (100 cent = 1 semitone).</li>
<li>The <strong>amplitude</strong> of each partial can be altered, compared to its standard value. The alteration can be measured in Decibel (dB).</li>
<li>The <strong>duration</strong> of each partial can be shorter or longer than the standard value. Let us define this deviation as a percentage. If the expected duration is five seconds, a maximum deviation of 100% means getting a value between half the duration (2.5 sec) and the double duration (10 sec).</li>
</ul>
<p>The following example shows the effect of these variations. As a base - and as a reference to its author - we take the &quot;bell-like sound&quot; which Jean-Claude Risset created in his Sound Catalogue.<span id="ch024_a-additive-synthesis.xhtml#InsertNoteID_6_marker7" class="InsertNoteMarker"><sup><a href="a-additive-synthesis#InsertNoteID_6">1</a></sup></span>  </p>
<p><em><strong>EXAMPLE 04A07.csd</strong></em>    </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;frequency and amplitude multipliers for 11 partials of Risset&#39;s bell
giFqs     ftgen     0, 0, -11,-2,.56,.563,.92, .923,1.19,1.7,2,2.74,
                     3,3.74,4.07
giAmps    ftgen     0, 0, -11, -2, 1, 2/3, 1, 1.8, 8/3, 1.46, 4/3, 4/3, 1, 4/3
giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0

instr 1 ;master instrument
ibasfreq  =         400
ifqdev    =         p4 ;maximum freq deviation in cents
iampdev   =         p5 ;maximum amp deviation in dB
idurdev   =         p6 ;maximum duration deviation in %
indx      =         0 ;count variable for loop
loop:
ifqmult   tab_i     indx, giFqs ;get frequency multiplier from table
ifreq     =         ibasfreq * ifqmult
iampmult  tab_i     indx, giAmps ;get amp multiplier
iamp      =         iampmult / 20 ;scale
          event_i   &quot;i&quot;, 10, 0, p3, ifreq, iamp, ifqdev, iampdev, idurdev
          loop_lt   indx, 1, 11, loop
endin

instr 10 ;subinstrument for playing one partial
;receive the parameters from the master instrument
ifreqnorm =         p4 ;standard frequency of this partial
iampnorm  =         p5 ;standard amplitude of this partial
ifqdev    =         p6 ;maximum freq deviation in cents
iampdev   =         p7 ;maximum amp deviation in dB
idurdev   =         p8 ;maximum duration deviation in %
;calculate frequency
icent     random    -ifqdev, ifqdev ;cent deviation
ifreq     =         ifreqnorm * cent(icent)
;calculate amplitude
idb       random    -iampdev, iampdev ;dB deviation
iamp      =         iampnorm * ampdb(idb)
;calculate duration
idurperc  random    -idurdev, idurdev ;duration deviation (%)
iptdur    =         p3 * 2^(idurperc/100)
p3        =         iptdur ;set p3 to the calculated value
;play partial
aenv      transeg   0, .01, 0, iamp, p3-.01, -10, 0
apart     poscil    aenv, ifreq, giSine
          outs      apart, apart
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;         frequency   amplitude   duration
;         deviation   deviation   deviation
;         in cent     in dB       in %
;;unchanged sound (twice)
r 2
i 1 0 5   0           0           0
s
;;slight variations in frequency
r 4
i 1 0 5   25          0           0
;;slight variations in amplitude
r 4
i 1 0 5   0           6           0
;;slight variations in duration
r 4
i 1 0 5   0           0           30
;;slight variations combined
r 6
i 1 0 5   25          6           30
;;heavy variations
r 6
i 1 0 5   50          9           100
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt; </code></pre>
<p>For a midi-triggered descendant of the instrument, we can - as one of many possible choices - vary the amount of possible random variation on the key velocity. So a key pressed softly plays the bell-like sound as described by Risset but as a key is struck with increasing force the sound produced will be increasingly altered.</p>
<p><em><strong>EXAMPLE 04A08.csd</strong></em>    </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;frequency and amplitude multipliers for 11 partials of Risset&#39;s bell
giFqs     ftgen     0, 0, -11, -2, .56,.563,.92,.923,1.19,1.7,2,2.74,3,
                    3.74,4.07
giAmps    ftgen     0, 0, -11, -2, 1, 2/3, 1, 1.8, 8/3, 1.46, 4/3, 4/3, 1, 4/3
giSine    ftgen     0, 0, 2^10, 10, 1
          seed      0
          massign   0, 1 ;all midi channels to instr 1

instr 1 ;master instrument
;;scale desired deviations for maximum velocity
;frequency (cent)
imxfqdv   =         100
;amplitude (dB)
imxampdv  =         12
;duration (%)
imxdurdv  =         100
;;get midi values
ibasfreq  cpsmidi	;base frequency
iampmid   ampmidi   1 ;receive midi-velocity and scale 0-1
;;calculate maximum deviations depending on midi-velocity
ifqdev    =         imxfqdv * iampmid
iampdev   =         imxampdv * iampmid
idurdev   =         imxdurdv * iampmid
;;trigger subinstruments
indx      =         0 ;count variable for loop
loop:
ifqmult   tab_i     indx, giFqs ;get frequency multiplier from table
ifreq     =         ibasfreq * ifqmult
iampmult  tab_i     indx, giAmps ;get amp multiplier
iamp      =         iampmult / 20 ;scale
          event_i   &quot;i&quot;, 10, 0, 3, ifreq, iamp, ifqdev, iampdev, idurdev
          loop_lt   indx, 1, 11, loop
endin

instr 10 ;subinstrument for playing one partial
;receive the parameters from the master instrument
ifreqnorm =         p4 ;standard frequency of this partial
iampnorm  =         p5 ;standard amplitude of this partial
ifqdev    =         p6 ;maximum freq deviation in cents
iampdev   =         p7 ;maximum amp deviation in dB
idurdev   =         p8 ;maximum duration deviation in %
;calculate frequency
icent     random    -ifqdev, ifqdev ;cent deviation
ifreq     =         ifreqnorm * cent(icent)
;calculate amplitude
idb       random    -iampdev, iampdev ;dB deviation
iamp      =         iampnorm * ampdb(idb)
;calculate duration
idurperc  random    -idurdev, idurdev ;duration deviation (%)
iptdur    =         p3 * 2^(idurperc/100)
p3        =         iptdur ;set p3 to the calculated value
;play partial
aenv      transeg   0, .01, 0, iamp, p3-.01, -10, 0
apart     poscil    aenv, ifreq, giSine
          outs      apart, apart
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 3600
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt; </code></pre>
<p>It will depend on the power of your computer whether you can play examples like this in realtime. Have a look at chapter 2D (Live Audio) for tips on getting the best possible performance from your Csound orchestra.</p>
<p>Additive synthesis can still be an exciting way of producing sounds. The nowadays computational power and programming structures open the way for new discoverings and ideas. The later examples were intended to show some of these potentials of additive synthesis in Csound. </p>
<ol>
<li><span id="ch024_a-additive-synthesis.xhtml#InsertNoteID_6">Jean-Claude Risset, Introductory Catalogue of Computer Synthesized Sounds (1969), cited after Dodge/Jerse, Computer Music, New York / London 1985, p.94<span id="ch024_a-additive-synthesis.xhtml#InsertNoteID_6_LinkBacks"><sup><a href="a-additive-synthesis#InsertNoteID_6_marker7">^</a></sup></span></span></li>
</ol>
<p><span id="ch025_b-subtractive-synthesis.xhtml"></span></p>
<h1>SUBTRACTIVE SYNTHESIS</h1>
<h2>Introduction</h2>
<p>Subtractive synthesis is, at least conceptually, the inverse of additive synthesis in that instead of building complex sound through the addition of simple cellular materials such as sine waves, subtractive synthesis begins with a complex sound source, such as white noise or a recorded sample, or a rich waveform, such as a sawtooth or pulse, and proceeds to refine that sound by removing partials or entire sections of the frequency spectrum through the use of audio filters.</p>
<p>The creation of dynamic spectra (an arduous task in additive synthesis) is relatively simple in subtractive synthesis as all that will be required will be to modulate a few parameters pertaining to any filters being used. Working with the intricate precision that is possible with additive synthesis may not be as easy with subtractive synthesis but sounds can be created much more instinctively than is possible with additive or FM synthesis.</p>
<h2>A Csound Two-Oscillator Synthesizer</h2>
<p>The first example represents perhaps the classic idea of subtractive synthesis: a simple two oscillator synth filtered using a single resonant lowpass filter. Many of the ideas used in this example have been inspired by the design of the <a href="http://en.wikipedia.org/wiki/Minimoog">Minimoog</a> synthesizer (1970) and other similar instruments.</p>
<p>Each oscillator can describe either a sawtooth, PWM waveform (i.e. square - pulse etc.) or white noise and each oscillator can be transposed in octaves or in cents with respect to a fundamental pitch. The two oscillators are mixed and then passed through a 4-pole / 24dB per octave resonant lowpass filter. The opcode '<a href="http://www.csounds.com/manual/html/moogladder.html">moogladder</a>' is chosen on account of its authentic vintage character. The cutoff frequency of the filter is modulated using an <a href="http://en.wikipedia.org/wiki/Synthesizer">ADSR</a>-style (attack-decay-sustain-release) envelope facilitating the creation of dynamic, evolving spectra. Finally the sound output of the filter is shaped by an ADSR amplitude envelope.</p>
<p>As this instrument is suggestive of a performance instrument controlled via MIDI, this has been partially implemented. Through the use of Csound's MIDI interoperability opcode, <a href="http://www.csounds.com/manual/html/mididefault.html">mididefault</a>, the instrument can be operated from the score or from a MIDI keyboard. If a MIDI note is received, suitable default p-field values are substituted for the missing p-fields. MIDI controller 1 can be used to control the global cutoff frequency for the filter.</p>
<p>A schematic for this instrument is shown below:<br />
</p>
<p><img src="static/2OscSynthFlow.png" /><br />
</p>
<h4>   <em>EXAMPLE 04B01.csd</em></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac -Ma
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
sr = 44100
ksmps = 4
nchnls = 2
0dbfs = 1

initc7 1,1,0.8                 ;set initial controller position

prealloc 1, 10

   instr 1
iNum   notnum                  ;read in midi note number
iCF    ctrl7        1,1,0.1,14 ;read in midi controller 1

; set up default p-field values for midi activated notes
       mididefault  iNum, p4   ;pitch (note number)
       mididefault  0.3, p5    ;amplitude 1
       mididefault  2, p6      ;type 1
       mididefault  0.5, p7    ;pulse width 1
       mididefault  0, p8      ;octave disp. 1
       mididefault  0, p9      ;tuning disp. 1
       mididefault  0.3, p10   ;amplitude 2
       mididefault  1, p11     ;type 2
       mididefault  0.5, p12   ;pulse width 2
       mididefault  -1, p13    ;octave displacement 2
       mididefault  20, p14    ;tuning disp. 2
       mididefault  iCF, p15   ;filter cutoff freq
       mididefault  0.01, p16  ;filter env. attack time
       mididefault  1, p17     ;filter env. decay time
       mididefault  0.01, p18  ;filter env. sustain level
       mididefault  0.1, p19   ;filter release time
       mididefault  0.3, p20   ;filter resonance
       mididefault  0.01, p21  ;amp. env. attack
       mididefault  0.1, p22   ;amp. env. decay.
       mididefault  1, p23     ;amp. env. sustain
       mididefault  0.01, p24  ;amp. env. release

; asign p-fields to variables
iCPS   =            cpsmidinn(p4) ;convert from note number to cps
kAmp1  =            p5
iType1 =            p6
kPW1   =            p7
kOct1  =            octave(p8) ;convert from octave displacement to multiplier
kTune1 =            cent(p9)   ;convert from cents displacement to multiplier
kAmp2  =            p10
iType2 =            p11
kPW2   =            p12
kOct2  =            octave(p13)
kTune2 =            cent(p14)
iCF    =            p15
iFAtt  =            p16
iFDec  =            p17
iFSus  =            p18
iFRel  =            p19
kRes   =            p20
iAAtt  =            p21
iADec  =            p22
iASus  =            p23
iARel  =            p24

;oscillator 1
;if type is sawtooth or square...
if iType1==1||iType1==2 then
 ;...derive vco2 &#39;mode&#39; from waveform type
 iMode1 = (iType1=1?0:2)
 aSig1  vco2   kAmp1,iCPS*kOct1*kTune1,iMode1,kPW1;VCO audio oscillator
else                                   ;otherwise...
 aSig1  noise  kAmp1, 0.5              ;...generate white noise
endif

;oscillator 2 (identical in design to oscillator 1)
if iType2==1||iType2==2 then
 iMode2  =  (iType2=1?0:2)
 aSig2  vco2   kAmp2,iCPS*kOct2*kTune2,iMode2,kPW2
else
  aSig2 noise  kAmp2,0.5
endif

;mix oscillators
aMix       sum          aSig1,aSig2
;lowpass filter
kFiltEnv   expsegr      0.0001,iFAtt,iCPS*iCF,iFDec,iCPS*iCF*iFSus,iFRel,0.0001
aOut       moogladder   aMix, kFiltEnv, kRes

;amplitude envelope
aAmpEnv    expsegr      0.0001,iAAtt,1,iADec,iASus,iARel,0.0001
aOut       =            aOut*aAmpEnv
           outs         aOut,aOut
  endin
&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p4  = oscillator frequency
;oscillator 1
;p5  = amplitude
;p6  = type (1=sawtooth,2=square-PWM,3=noise)
;p7  = PWM (square wave only)
;p8  = octave displacement
;p9  = tuning displacement (cents)
;oscillator 2
;p10 = amplitude
;p11 = type (1=sawtooth,2=square-PWM,3=noise)
;p12 = pwm (square wave only)
;p13 = octave displacement
;p14 = tuning displacement (cents)
;global filter envelope
;p15 = cutoff
;p16 = attack time
;p17 = decay time
;p18 = sustain level (fraction of cutoff)
;p19 = release time
;p20 = resonance
;global amplitude envelope
;p21 = attack time
;p22 = decay time
;p23 = sustain level
;p24 = release time
; p1 p2 p3  p4 p5  p6 p7   p8 p9  p10 p11 p12 p13
;p14 p15 p16  p17  p18  p19 p20 p21  p22 p23 p24
i 1  0  1   50 0   2  .5   0  -5  0   2   0.5 0   \
 5   12  .01  2    .01  .1  0   .005 .01 1   .05
i 1  +  1   50 .2  2  .5   0  -5  .2  2   0.5 0   \
 5   1   .01  1    .1   .1  .5  .005 .01 1   .05
i 1  +  1   50 .2  2  .5   0  -8  .2  2   0.5 0   \
 8   3   .01  1    .1   .1  .5  .005 .01 1   .05
i 1  +  1   50 .2  2  .5   0  -8  .2  2   0.5 -1  \
 8   7  .01   1    .1   .1  .5  .005 .01 1   .05
i 1  +  3   50 .2  1  .5   0  -10 .2  1   0.5 -2  \
 10  40  .01  3    .001 .1  .5  .005 .01 1   .05
i 1  +  10  50 1   2  .01  -2 0   .2  3   0.5 0   \
 0   40  5    5    .001 1.5 .1  .005 .01 1   .05

f 0 3600
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Simulation of Timbres from a Noise Source</h2>
<p>The next example makes extensive use of bandpass filters arranged in parallel to filter white noise. The bandpass filter bandwidths are narrowed to the point where almost pure tones are audible. The crucial difference is that the noise source always induces instability in the amplitude and frequency of tones produced - it is this quality that makes this sort of subtractive synthesis sound much more organic than an additive synthesis equivalent. If the bandwidths are widened then more of the characteristic of the noise source comes through and the tone becomes 'airier' and less distinct; if the bandwidths are narrowed the resonating tones become clearer and steadier. By varying the bandwidths interesting metamorphoses of the resultant sound are possible.</p>
<p>22 <a href="http://www.csounds.com/manual/html/reson.html">reson</a> filters are used for the bandpass filters on account of their ability to ring and resonate as their bandwidth narrows. Another reason for this choice is the relative CPU economy of the reson filter, a not inconsiderable concern as so many of them are used. The frequency ratios between the 22 parallel filters are derived from analysis of a hand bell, the data was found in the appendix of the Csound manual <a href="http://www.csounds.com/manual/html/MiscModalFreq.html">here</a>.<br />
</p>
<p>In addition to the white noise as a source, noise impulses are also used as a sound source (via the '<a href="http://www.csounds.com/manual/html/mpulse.html">mpulse</a>' opcode). The instrument will automatically and randomly slowly crossfade between these two sound sources.</p>
<p>A lowpass and highpass filter are inserted in series before the parallel bandpass filters to shape the frequency spectrum of the source sound. Csound's butterworth filters <a href="http://www.csounds.com/manual/html/butterlp.html">butlp</a> and <a href="http://www.csounds.com/manual/html/butterhp.html">buthp</a> are chosen for this task on account of their steep cutoff slopes and lack of ripple at the cutoff point.</p>
<p>The outputs of the reson filters are sent alternately to the left and right outputs in order to create a broad stereo effect.<br />
</p>
<p>This example makes extensive use of the '<a href="http://www.csounds.com/manual/html/rspline.html">rspline</a>' opcode, a generator of random spline functions, to slowly undulate the many input parameters. The orchestra is self generative in that instrument 1 repeatedly triggers note events in instrument 2 and the extensive use of random functions means that the results will continually evolve as the orchestra is allowed to perform.</p>
<p>A flow diagram for this instrument is shown below:</p>
<p><img src="static/22reson.png" /><br />
</p>
<h4>   <em>EXAMPLE 04B02.csd</em></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example written by Iain McCurdy

sr = 44100
ksmps = 16
nchnls = 2
0dbfs = 1

  instr 1 ; triggers notes in instrument 2 with randomised p-fields
krate  randomi 0.2,0.4,0.1   ;rate of note generation
ktrig  metro  krate          ;triggers used by schedkwhen
koct   random 5,12           ;fundemental pitch of synth note
kdur   random 15,30          ;duration of note
schedkwhen ktrig,0,0,2,0,kdur,cpsoct(koct) ;trigger a note in instrument 2
  endin

  instr 2 ; subtractive synthesis instrument
aNoise  pinkish  1                  ;a noise source sound: pink noise
kGap    rspline  0.3,0.05,0.2,2     ;time gap between impulses
aPulse  mpulse   15, kGap           ;a train of impulses
kCFade  rspline  0,1,0.1,1          ;crossfade point between noise and impulses
aInput  ntrpol   aPulse,aNoise,kCFade;implement crossfade

; cutoff frequencies for low and highpass filters
kLPF_CF  rspline  13,8,0.1,0.4
kHPF_CF  rspline  5,10,0.1,0.4
; filter input sound with low and highpass filters in series -
; - done twice per filter in order to sharpen cutoff slopes
aInput    butlp    aInput, cpsoct(kLPF_CF)
aInput    butlp    aInput, cpsoct(kLPF_CF)
aInput    buthp    aInput, cpsoct(kHPF_CF)
aInput    buthp    aInput, cpsoct(kHPF_CF)

kcf     rspline  p4*1.05,p4*0.95,0.01,0.1 ; fundemental
; bandwidth for each filter is created individually as a random spline function
kbw1    rspline  0.00001,10,0.2,1
kbw2    rspline  0.00001,10,0.2,1
kbw3    rspline  0.00001,10,0.2,1
kbw4    rspline  0.00001,10,0.2,1
kbw5    rspline  0.00001,10,0.2,1
kbw6    rspline  0.00001,10,0.2,1
kbw7    rspline  0.00001,10,0.2,1
kbw8    rspline  0.00001,10,0.2,1
kbw9    rspline  0.00001,10,0.2,1
kbw10   rspline  0.00001,10,0.2,1
kbw11   rspline  0.00001,10,0.2,1
kbw12   rspline  0.00001,10,0.2,1
kbw13   rspline  0.00001,10,0.2,1
kbw14   rspline  0.00001,10,0.2,1
kbw15   rspline  0.00001,10,0.2,1
kbw16   rspline  0.00001,10,0.2,1
kbw17   rspline  0.00001,10,0.2,1
kbw18   rspline  0.00001,10,0.2,1
kbw19   rspline  0.00001,10,0.2,1
kbw20   rspline  0.00001,10,0.2,1
kbw21   rspline  0.00001,10,0.2,1
kbw22   rspline  0.00001,10,0.2,1

imode   =        0 ; amplitude balancing method used by the reson filters
a1      reson    aInput, kcf*1,               kbw1, imode
a2      reson    aInput, kcf*1.0019054878049, kbw2, imode
a3      reson    aInput, kcf*1.7936737804878, kbw3, imode
a4      reson    aInput, kcf*1.8009908536585, kbw4, imode
a5      reson    aInput, kcf*2.5201981707317, kbw5, imode
a6      reson    aInput, kcf*2.5224085365854, kbw6, imode
a7      reson    aInput, kcf*2.9907012195122, kbw7, imode
a8      reson    aInput, kcf*2.9940548780488, kbw8, imode
a9      reson    aInput, kcf*3.7855182926829, kbw9, imode
a10     reson    aInput, kcf*3.8061737804878, kbw10,imode
a11     reson    aInput, kcf*4.5689024390244, kbw11,imode
a12     reson    aInput, kcf*4.5754573170732, kbw12,imode
a13     reson    aInput, kcf*5.0296493902439, kbw13,imode
a14     reson    aInput, kcf*5.0455030487805, kbw14,imode
a15     reson    aInput, kcf*6.0759908536585, kbw15,imode
a16     reson    aInput, kcf*5.9094512195122, kbw16,imode
a17     reson    aInput, kcf*6.4124237804878, kbw17,imode
a18     reson    aInput, kcf*6.4430640243902, kbw18,imode
a19     reson    aInput, kcf*7.0826219512195, kbw19,imode
a20     reson    aInput, kcf*7.0923780487805, kbw20,imode
a21     reson    aInput, kcf*7.3188262195122, kbw21,imode
a22     reson    aInput, kcf*7.5551829268293, kbw22,imode

; amplitude control for each filter output
kAmp1    rspline  0, 1, 0.3, 1
kAmp2    rspline  0, 1, 0.3, 1
kAmp3    rspline  0, 1, 0.3, 1
kAmp4    rspline  0, 1, 0.3, 1
kAmp5    rspline  0, 1, 0.3, 1
kAmp6    rspline  0, 1, 0.3, 1
kAmp7    rspline  0, 1, 0.3, 1
kAmp8    rspline  0, 1, 0.3, 1
kAmp9    rspline  0, 1, 0.3, 1
kAmp10   rspline  0, 1, 0.3, 1
kAmp11   rspline  0, 1, 0.3, 1
kAmp12   rspline  0, 1, 0.3, 1
kAmp13   rspline  0, 1, 0.3, 1
kAmp14   rspline  0, 1, 0.3, 1
kAmp15   rspline  0, 1, 0.3, 1
kAmp16   rspline  0, 1, 0.3, 1
kAmp17   rspline  0, 1, 0.3, 1
kAmp18   rspline  0, 1, 0.3, 1
kAmp19   rspline  0, 1, 0.3, 1
kAmp20   rspline  0, 1, 0.3, 1
kAmp21   rspline  0, 1, 0.3, 1
kAmp22   rspline  0, 1, 0.3, 1

; left and right channel mixes are created using alternate filter outputs.
; This shall create a stereo effect.
aMixL    sum      a1*kAmp1,a3*kAmp3,a5*kAmp5,a7*kAmp7,a9*kAmp9,a11*kAmp11,\
                        a13*kAmp13,a15*kAmp15,a17*kAmp17,a19*kAmp19,a21*kAmp21
aMixR    sum      a2*kAmp2,a4*kAmp4,a6*kAmp6,a8*kAmp8,a10*kAmp10,a12*kAmp12,\
                        a14*kAmp14,a16*kAmp16,a18*kAmp18,a20*kAmp20,a22*kAmp22

kEnv     linseg   0, p3*0.5, 1,p3*0.5,0,1,0       ; global amplitude envelope
outs   (aMixL*kEnv*0.00008), (aMixR*kEnv*0.00008) ; audio sent to outputs
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 3600  ; instrument 1 (note generator) plays for 1 hour
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Vowel-Sound Emulation Using Bandpass Filtering</h2>
<p>The final example in this section uses precisely tuned bandpass filters, to simulate the sound of the human voice expressing vowel sounds. Spectral resonances in this context are often referred to as '<a href="http://en.wikipedia.org/wiki/Formants">formants</a>'. Five formants are used to simulate the effect of the human mouth and head as a resonating (and therefore filtering) body. The filter data for simulating the vowel sounds A,E,I,O and U as expressed by a bass, tenor, counter-tenor, alto and soprano voice were found in the appendix of the Csound manual <a href="http://www.csounds.com/manual/html/MiscFormants.html">here</a>. Bandwidth and intensity (dB) information is also needed to accurately simulate the various vowel sounds.</p>
<p><a href="http://www.csounds.com/manual/html/reson.html">reson</a> filters are again used but <a href="http://www.csounds.com/manual/html/butterbp.html">butbp</a> and others could be equally valid choices.<br />
</p>
<p>Data is stored in <a href="http://www.csounds.com/manual/html/GEN07.html">GEN07</a> linear break point function tables, as this data is read by k-rate line functions we can interpolate and therefore morph between different vowel sounds during a note.<br />
</p>
<p>The source sound for the filters comes from either a pink noise generator or a pulse waveform. The pink noise source could be used if the emulation is to be that of just the breath whereas the pulse waveform provides a decent approximation of the human vocal chords buzzing. This instrument can however morph continuously between these two sources.</p>
<p>A flow diagram for this instrument is shown below:</p>
<p><img src="static/VowelFilters.png" /><br />
</p>
<h4>   <em>EXAMPLE 04B03.csd</em></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example by Iain McCurdy

sr = 44100
ksmps = 16
nchnls = 2
0dbfs = 1

instr 1
  kFund    expon     p4,p3,p5               ; fundamental
  kVow     line      p6,p3,p7               ; vowel select
  kBW      line      p8,p3,p9               ; bandwidth factor
  iVoice   =         p10                    ; voice select
  kSrc     line      p11,p3,p12             ; source mix

  aNoise   pinkish   3                      ; pink noise
  aVCO     vco2      1.2,kFund,2,0.02       ; pulse tone
  aInput   ntrpol    aVCO,aNoise,kSrc       ; input mix

  ; read formant cutoff frequenies from tables
  kCF1     table     kVow,1+(iVoice*15),1
  kCF2     table     kVow,2+(iVoice*15),1
  kCF3     table     kVow,3+(iVoice*15),1
  kCF4     table     kVow,4+(iVoice*15),1
  kCF5     table     kVow,5+(iVoice*15),1
  ; read formant intensity values from tables
  kDB1     table     kVow,6+(iVoice*15),1
  kDB2     table     kVow,7+(iVoice*15),1
  kDB3     table     kVow,8+(iVoice*15),1
  kDB4     table     kVow,9+(iVoice*15),1
  kDB5     table     kVow,10+(iVoice*15),1
  ; read formant bandwidths from tables
  kBW1     table     kVow,11+(iVoice*15),1
  kBW2     table     kVow,12+(iVoice*15),1
  kBW3     table     kVow,13+(iVoice*15),1
  kBW4     table     kVow,14+(iVoice*15),1
  kBW5     table     kVow,15+(iVoice*15),1
  ; create resonant formants byt filtering source sound
  aForm1   reson     aInput, kCF1, kBW1*kBW, 1     ; formant 1
  aForm2   reson     aInput, kCF2, kBW2*kBW, 1     ; formant 2
  aForm3   reson     aInput, kCF3, kBW3*kBW, 1     ; formant 3
  aForm4   reson     aInput, kCF4, kBW4*kBW, 1     ; formant 4
  aForm5   reson     aInput, kCF5, kBW5*kBW, 1     ; formant 5

  ; formants are mixed and multiplied both by intensity values derived from tables and by the on-screen gain controls for each formant
  aMix     sum       aForm1*ampdbfs(kDB1),aForm2*ampdbfs(kDB2),aForm3*ampdbfs(kDB3),aForm4*ampdbfs(kDB4),aForm5*ampdbfs(kDB5)
  kEnv     linseg    0,3,1,p3-6,1,3,0     ; an amplitude envelope
           outs      aMix*kEnv, aMix*kEnv ; send audio to outputs
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
f 0 3600	;DUMMY SCORE EVENT - PERMITS REALTIME PERFORMANCE FOR UP TO 1 HOUR

;FUNCTION TABLES STORING FORMANT DATA FOR EACH OF THE FIVE VOICE TYPES REPRESENTED
;BASS
f 1  0 32768 -7 600	10922	400	10922	250	10924	350	;FREQ
f 2  0 32768 -7 1040	10922	1620	10922	1750	10924	600	;FREQ
f 3  0 32768 -7	2250	10922	2400	10922	2600	10924	2400	;FREQ
f 4  0 32768 -7	2450	10922	2800	10922	3050	10924	2675	;FREQ
f 5  0 32768 -7	2750	10922	3100	10922	3340	10924	2950	;FREQ
f 6  0 32768 -7	0	10922	0	10922	0	10924	0	;dB
f 7  0 32768 -7	-7	10922	-12	10922	-30	10924	-20	;dB
f 8  0 32768 -7	-9	10922	-9	10922	-16	10924	-32	;dB
f 9  0 32768 -7	-9	10922	-12	10922	-22	10924	-28	;dB
f 10 0 32768 -7	-20	10922	-18	10922	-28	10924	-36	;dB
f 11 0 32768 -7	60	10922	40	10922	60	10924	40	;BAND WIDTH
f 12 0 32768 -7	70	10922	80	10922	90	10924	80	;BAND WIDTH
f 13 0 32768 -7	110	10922	100	10922	100	10924	100	;BAND WIDTH
f 14 0 32768 -7	120	10922	120	10922	120	10924	120	;BAND WIDTH
f 15 0 32768 -7	130	10922	120	10922	120	10924	120	;BAND WIDTH
;TENOR
f 16 0 32768 -7 650 	8192	400 	8192	290	8192	400	8192	350	;FREQ
f 17 0 32768 -7 1080 	8192	1700    8192	1870	8192	800	8192	600	;FREQ
f 18 0 32768 -7	2650	8192	2600    8192	2800	8192	2600	8192	2700	;FREQ
f 19 0 32768 -7	2900	8192	3200    8192	3250	8192	2800	8192	2900	;FREQ
f 20 0 32768 -7	3250	8192	3580    8192	3540	8192	3000	8192	3300	;FREQ
f 21 0 32768 -7	0	8192	0	8192	0	8192	0	8192	0	;dB
f 22 0 32768 -7	-6	8192	-14	8192	-15	8192	-10	8192	-20	;dB
f 23 0 32768 -7	-7	8192	-12	8192	-18	8192	-12	8192	-17	;dB
f 24 0 32768 -7	-8	8192	-14	8192	-20	8192	-12	8192	-14	;dB
f 25 0 32768 -7	-22	8192	-20	8192	-30	8192	-26	8192	-26	;dB
f 26 0 32768 -7	80	8192	70	8192	40	8192	40	8192	40	;BAND WIDTH
f 27 0 32768 -7	90	8192	80	8192	90	8192	80	8192	60	;BAND WIDTH
f 28 0 32768 -7	120	8192	100	8192	100	8192	100	8192	100	;BAND WIDTH
f 29 0 32768 -7	130	8192	120	8192	120	8192	120	8192	120	;BAND WIDTH
f 30 0 32768 -7	140	8192	120	8192	120	8192	120	8192	120	;BAND WIDTH
;COUNTER TENOR
f 31 0 32768 -7 660	8192	440	8192	270	8192	430	8192	370	;FREQ
f 32 0 32768 -7 1120	8192	1800	8192	1850	8192	820	8192	630	;FREQ
f 33 0 32768 -7	2750	8192	2700	8192	2900	8192	2700	8192	2750	;FREQ
f 34 0 32768 -7	3000	8192	3000	8192	3350	8192	3000	8192	3000	;FREQ
f 35 0 32768 -7	3350	8192	3300	8192	3590	8192	3300	8192	3400	;FREQ
f 36 0 32768 -7	0	8192	0	8192	0	8192	0	8192	0	;dB
f 37 0 32768 -7	-6	8192	-14	8192	-24	8192	-10	8192	-20	;dB
f 38 0 32768 -7	-23	8192	-18	8192	-24	8192	-26	8192	-23	;dB
f 39 0 32768 -7	-24	8192	-20	8192	-36	8192	-22	8192	-30	;dB
f 40 0 32768 -7	-38	8192	-20	8192	-36	8192	-34	8192	-30	;dB
f 41 0 32768 -7	80	8192	70	8192	40	8192	40	8192	40	;BAND WIDTH
f 42 0 32768 -7	90	8192	80	8192	90	8192	80	8192	60	;BAND WIDTH
f 43 0 32768 -7	120	8192	100	8192	100	8192	100	8192	100	;BAND WIDTH
f 44 0 32768 -7	130	8192	120	8192	120	8192	120	8192	120	;BAND WIDTH
f 45 0 32768 -7	140	8192	120	8192	120	8192	120	8192	120	;BAND WIDTH
;ALTO
f 46 0 32768 -7	800	8192	400	8192	350	8192	450	8192	325	;FREQ
f 47 0 32768 -7	1150	8192	1600	8192	1700	8192	800	8192	700	;FREQ
f 48 0 32768 -7	2800	8192	2700	8192	2700	8192	2830	8192	2530	;FREQ
f 49 0 32768 -7	3500	8192	3300	8192	3700	8192	3500	8192	2500	;FREQ
f 50 0 32768 -7	4950	8192	4950	8192	4950	8192	4950	8192	4950	;FREQ
f 51 0 32768 -7	0	8192	0	8192	0	8192	0	8192	0	;dB
f 52 0 32768 -7	-4	8192	-24	8192	-20	8192	-9	8192	-12	;dB
f 53 0 32768 -7	-20	8192	-30	8192	-30	8192	-16	8192	-30	;dB
f 54 0 32768 -7	-36	8192	-35	8192	-36	8192	-28	8192	-40	;dB
f 55 0 32768 -7	-60	8192	-60	8192	-60	8192	-55	8192	-64	;dB
f 56 0 32768 -7	50	8192	60	8192	50	8192	70	8192	50	;BAND WIDTH
f 57 0 32768 -7	60	8192	80	8192	100	8192	80	8192	60	;BAND WIDTH
f 58 0 32768 -7	170	8192	120	8192	120	8192	100	8192	170	;BAND WIDTH
f 59 0 32768 -7	180	8192	150	8192	150	8192	130	8192	180	;BAND WIDTH
f 60 0 32768 -7	200	8192	200	8192	200	8192	135	8192	200	;BAND WIDTH
;SOPRANO
f 61 0 32768 -7	800	8192	350	8192	270	8192	450	8192	325	;FREQ
f 62 0 32768 -7	1150	8192	2000	8192	2140	8192	800	8192	700	;FREQ
f 63 0 32768 -7	2900	8192	2800	8192	2950	8192	2830	8192	2700	;FREQ
f 64 0 32768 -7	3900	8192	3600	8192	3900	8192	3800	8192	3800	;FREQ
f 65 0 32768 -7	4950	8192	4950	8192	4950	8192	4950	8192	4950	;FREQ
f 66 0 32768 -7	0	8192	0	8192	0	8192	0	8192	0	;dB
f 67 0 32768 -7	-6	8192	-20	8192	-12	8192	-11	8192	-16	;dB
f 68 0 32768 -7	-32	8192	-15	8192	-26	8192	-22	8192	-35	;dB
f 69 0 32768 -7	-20	8192	-40	8192	-26	8192	-22	8192	-40	;dB
f 70 0 32768 -7	-50	8192	-56	8192	-44	8192	-50	8192	-60	;dB
f 71 0 32768 -7	80	8192	60	8192	60	8192	70	8192	50	;BAND WIDTH
f 72 0 32768 -7	90	8192	90	8192	90	8192	80	8192	60	;BAND WIDTH
f 73 0 32768 -7	120	8192	100	8192	100	8192	100	8192	170	;BAND WIDTH
f 74 0 32768 -7	130	8192	150	8192	120	8192	130	8192	180	;BAND WIDTH
f 75 0 32768 -7	140	8192	200	8192	120	8192	135	8192	200	;BAND WIDTH

; p4 = fundemental begin value (c.p.s.)
; p5 = fundemental end value
; p6 = vowel begin value (0 - 1 : a e i o u)
; p7 = vowel end value
; p8 = bandwidth factor begin (suggested range 0 - 2)
; p9 = bandwidth factor end
; p10 = voice (0=bass; 1=tenor; 2=counter_tenor; 3=alto; 4=soprano)
; p11 = input source begin (0 - 1 : VCO - noise)
; p12 = input source end

;         p4  p5  p6  p7  p8  p9 p10 p11  p12
i 1 0  10 50  100 0   1   2   0  0   0    0
i 1 8  .  78  77  1   0   1   0  1   0    0
i 1 16 .  150 118 0   1   1   0  2   1    1
i 1 24 .  200 220 1   0   0.2 0  3   1    0
i 1 32 .  400 800 0   1   0.2 0  4   0    1
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Conclusion</h2>
<p>These examples have hopefully demonstrated the strengths of subtractive synthesis in its simplicity, intuitive operation and its ability to create organic sounding timbres. Further research could explore Csound's other filter opcodes including <a href="http://www.csounds.com/manual/html/vcomb.html">vcomb</a>, <a href="http://www.csounds.com/manual/html/wguide1.html">wguide1</a>, <a href="http://www.csounds.com/manual/html/wguide2.html">wguide2</a> and the more esoteric <a href="http://www.csounds.com/manual/html/phaser1.html">phaser1</a>, <a href="http://www.csounds.com/manual/html/phaser2.html">phaser2</a> and <a href="http://www.csounds.com/manual/html/resony.html">resony</a>.<br />
</p>
<p><span id="ch026_c-amplitude-and-ringmodulation.xhtml"></span></p>
<h1>AMPLITUDE AND RING MODULATION</h1>
<h2>Introduction</h2>
<p>Amplitude-modulation (AM) means, that one oscillator varies the volume/amplitude of an other. If this modulation is done very slowly (1 Hz to 10 Hz) it is recognised as tremolo. Volume-modulation above 10 Hz leads to the effect, that the sound changes its timbre. So called side-bands appear.</p>
<p><strong><em>Example 04C01.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 48000
ksmps = 32
nchnls = 1
0dbfs = 1

instr 1
aRaise expseg 2, 20, 100
aModSine poscil 0.5, aRaise, 1
aDCOffset = 0.5    ; we want amplitude-modulation
aCarSine poscil 0.3, 440, 1
out aCarSine*(aModSine + aDCOffset)
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1
i 1 0 25
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<h2>Theory, Mathematics and Sidebands</h2>
<p>The side-bands appear on both sides of the main frequency. This means (freq1-freq2) and (freq1+freq2) appear.</p>
<p>The sounding result of the following example can be calculated as this: freq1 = 440Hz, freq2 = 40 Hz -&gt; The result is a sound with [400, 440, 480] Hz.</p>
<p>The amount of the sidebands can be controlled by a DC-offset of the modulator.<br />
</p>
<p><strong><em>Example 04C02.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 48000
ksmps = 32
nchnls = 1
0dbfs = 1

instr 1
aOffset linseg 0, 1, 0, 5, 0.6, 3, 0
aSine1 poscil 0.3, 40 , 1
aSine2 poscil 0.3, 440, 1
out (aSine1+aOffset)*aSine2
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1
i 1 0 10
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<p>Ring-modulation is a special-case of AM, without DC-offset (DC-Offset = 0). That means the modulator varies between -1 and +1 like the carrier. The sounding difference to AM is, that RM doesn't contain the carrier frequency.<br />
</p>
<p>(If the modulator is unipolar (oscillates between 0 and +1) the effect is called AM.)</p>
<h2>More Complex Synthesis using Ring Modulation and Amplitude Modulation<br />
</h2>
<p>If the modulator itself has more harmonics, the result becomes easily more complex.</p>
<p>Carrier freq: 600 Hz<br />
Modulator freqs: 200Hz with 3 harmonics = [200, 400, 600] Hz<br />
Resulting freqs:  [0, 200, 400, &lt;-600-&gt;, 800, 1000, 1200]</p>
<p><strong><em>Example 04C03.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 48000
ksmps = 32
nchnls = 1
0dbfs = 1

instr 1   ; Ring-Modulation (no DC-Offset)
aSine1 poscil 0.3, 200, 2 ; -&gt; [200, 400, 600] Hz
aSine2 poscil 0.3, 600, 1
out aSine1*aSine2
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 ; sine
f 2 0 1024 10 1 1 1; 3 harmonics
i 1 0 5
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<p>Using an inharmonic modulator frequency also makes the result sound inharmonic. Varying the DC-offset makes the sound-spectrum evolve over time.<br />
Modulator freqs: [230, 460, 690]<br />
Resulting freqs:  [ (-)90, 140, 370, &lt;-600-&gt;, 830, 1060, 1290]<br />
(negative frequencies become mirrowed, but phase inverted)</p>
<p><strong><em>Example 04C04.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 48000
ksmps = 32
nchnls = 1
0dbfs = 1

instr 1   ; Amplitude-Modulation
aOffset linseg 0, 1, 0, 5, 1, 3, 0
aSine1 poscil 0.3, 230, 2 ; -&gt; [230, 460, 690] Hz
aSine2 poscil 0.3, 600, 1
out (aSine1+aOffset)*aSine2
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 ; sine
f 2 0 1024 10 1 1 1; 3 harmonics
i 1 0 10
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span id="ch027_d-frequency-modulation.xhtml"></span></p>
<h1>FREQUENCY MODULATION</h1>
<h2>From Vibrato to the Emergence of Sidebands</h2>
<p>A vibrato is a periodical change of pitch, normally less than a halftone and with a slow changing-rate (around 5Hz). Frequency modulation is usually done with sine-wave oscillators.</p>
<p><strong><em>Example 04D01.csd</em></strong> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
aMod poscil 10, 5 , 1  ; 5 Hz vibrato with 10 Hz modulation-width
aCar poscil 0.3, 440+aMod, 1  ; -&gt; vibrato between 430-450 Hz
outs aCar, aCar
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<p>When the modulation-width becomes increased, it becomes harder to describe the base-frequency, but it is still a vibrato.<br />
<br />
<strong><em>Example 04D02.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
aMod poscil 90, 5 , 1 ; modulate 90Hz -&gt;vibrato from 350 to 530 hz
aCar poscil 0.3, 440+aMod, 1
outs aCar, aCar
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)
</code></pre>
<h2>The Simple Modulator-&gt;Carrier Pairing</h2>
<p>Increasing the modulation-rate leads to a different effect. Frequency-modulation with more than 20Hz is no longer recognized as vibrato. The main-oscillator frequency lays in the middle of the sound and sidebands appear above and below. The number of sidebands is related to the modulation amplitude, later this is controlled by the so called <em>modulation-index</em>.</p>
<p><strong><em>Example 04D03.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
aRaise linseg 2, 10, 100    ;increase modulation from 2Hz to 100Hz
aMod poscil 10, aRaise , 1
aCar poscil 0.3, 440+aMod, 1
outs aCar, aCar
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 12
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011</code></pre>
<p>Hereby the main-oscillator is called <em>carrier</em> and the one changing the carriers frequency is the <em>modulator</em>. The <em>modulation-index</em>: <strong>I = mod-amp/mod-freq</strong>. Making changes to the modulation-index, changes the amount of overtones, but not the overall volume. That gives the possibility produce drastic timbre-changes without the risk of distortion.<br />
</p>
<p>When <em>carrier</em> and <em>modulator</em> frequency have integer ratios like 1:1, 2:1, 3:2, 5:4.. the sidebands build a harmonic series, which leads to a sound with clear fundamental pitch.</p>
<p><strong><em>Example 04D04.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
kCarFreq = 660     ; 660:440 = 3:2 -&gt; harmonic spectrum
kModFreq = 440
kIndex = 15        ; high Index.. try lower values like 1, 2, 3..
kIndexM = 0
kMaxDev = kIndex*kModFreq
kMinDev = kIndexM*kModFreq
kVarDev = kMaxDev-kMinDev
kModAmp = kMinDev+kVarDev
aModulator poscil kModAmp, kModFreq, 1
aCarrier poscil 0.3, kCarFreq+aModulator, 1
outs aCarrier, aCarrier
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 15
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<p>Otherwise the spectrum of the sound is inharmonic, which makes it metallic or noisy.<br />
Raising the <em>modulation-index</em>, shifts the energy into the side-bands. The side-bands distance is:  <strong>Distance in Hz = (carrierFreq)-(k*modFreq) | k = {1, 2, 3, 4 ..}</strong></p>
<p>This calculation can result in negative frequencies. Those become reflected at zero, but with inverted phase! So negative frequencies can erase existing ones. Frequencies over Nyquist-frequency (half of samplingrate) &quot;fold over&quot; (aliasing).<br />
</p>
<h2>The John Chowning FM Model of a Trumpet</h2>
<p>Composer and researcher Jown Chowning worked on the first digital implementation of FM in the 1970's.<br />
</p>
<p>Using envelopes to control the <em>modulation index</em> and the overall amplitude gives you the possibility to create evolving sounds with enormous spectral variations. Chowning showed these possibilities in his pieces, where he let the sounds transform. In the piece <em>Sabelithe</em> a drum sound morphes over the time into a trumpet tone.</p>
<p><strong><em>Example 04D05.csd</em></strong> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1  ; simple way to generate a trumpet-like sound
kCarFreq = 440
kModFreq = 440
kIndex = 5
kIndexM = 0
kMaxDev = kIndex*kModFreq
kMinDev = kIndexM * kModFreq
kVarDev = kMaxDev-kMinDev
aEnv expseg .001, 0.2, 1, p3-0.3, 1, 0.2, 0.001
aModAmp = kMinDev+kVarDev*aEnv
aModulator poscil aModAmp, kModFreq, 1
aCarrier poscil 0.3*aEnv, kCarFreq+aModulator, 1
outs aCarrier, aCarrier
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 2
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<p>The following example uses the same instrument, with different settings to generate a bell-like sound:</p>
<p><strong><em>Example 04D06.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1  ; bell-like sound
kCarFreq = 200  ; 200/280 = 5:7 -&gt; inharmonic spectrum
kModFreq = 280
kIndex = 12
kIndexM = 0
kMaxDev = kIndex*kModFreq
kMinDev = kIndexM * kModFreq
kVarDev = kMaxDev-kMinDev
aEnv expseg .001, 0.001, 1, 0.3, 0.5, 8.5, .001
aModAmp = kMinDev+kVarDev*aEnv
aModulator poscil aModAmp, kModFreq, 1
aCarrier poscil 0.3*aEnv, kCarFreq+aModulator, 1
outs aCarrier, aCarrier
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 9
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)
</code></pre>
<h2>More Complex FM Algorithms</h2>
<p>Combining more than two oscillators (operators) is called complex FM synthesis. Operators can be connected in different combinations often 4-6 operators are used. The carrier is always the last operator in the row. Changing it's pitch, shifts the whole sound. All other operators are modulators, changing their pitch alters the sound-spectrum.<br />
</p>
<h4>Two into One: M1+M2 -&gt; C</h4>
<p>The principle here is, that (M1:C) and (M2:C) will be separate modulations and later added together. <br />
</p>
<p><strong><em>Example 04D07.csd</em></strong> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
aMod1 poscil 200, 700, 1
aMod2 poscil 1800, 290, 1
aSig poscil 0.3, 440+aMod1+aMod2, 1
outs aSig, aSig
endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<h4>In series: M1-&gt;M2-&gt;C</h4>
<p>This is much more complicated to calculate and sound-timbre becomes harder to predict, because M1:M2 produces a complex spectrum (W), which then modulates the carrier (W:C).</p>
<p><strong><em>Example 04D08.csd</em></strong> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1
aMod1 poscil 200, 700, 1
aMod2 poscil 1800, 290+aMod1, 1
aSig poscil 0.3, 440+aMod2, 1
outs aSig, aSig
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 3
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<h2>Phase Modulation - the Yamaha DX7 and Feedback FM</h2>
<p>There is a strong relation between frequency modulation and phase modulation, as both techniques influence the oscillator's pitch, and the resulting timbre modifications are the same.</p>
<p>If you'd like to build a feedbacking FM system, it will happen that the self-modulation comes to a zero point, which stops the oscillator forever. To avoid this, it is more practical to modulate the carriers table-lookup phase, instead of its pitch.<br />
</p>
<p>Even the most famous FM-synthesizer Yamaha DX7 is based on the phase-modulation (PM) technique, because this allows feedback. The DX7 provides 7 operators, and offers 32 routing combinations of these. (http://yala.freeservers.com/t2synths.htm#DX7)</p>
<p>To build a PM-synth in Csound <em>tablei</em> opcode needs to be used as oscillator. In order to step through the f-table, a <em>phasor</em> will output the necessary steps.</p>
<p><strong><em>Example 04D09.csd</em></strong> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1  ; simple PM-Synth
kCarFreq = 200
kModFreq = 280
kModFactor = kCarFreq/kModFreq
kIndex = 12/6.28   ;  12/2pi to convert from radians to norm. table index
aEnv expseg .001, 0.001, 1, 0.3, 0.5, 8.5, .001
aModulator poscil kIndex*aEnv, kModFreq, 1
aPhase phasor kCarFreq
aCarrier tablei aPhase+aModulator, 1, 1, 0, 1
outs (aCarrier*aEnv), (aCarrier*aEnv)
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 9
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<p>Let's use the possibilities of self-modulation (feedback-modulation) of the oscillator. So in the following example, the oscillator is both <em>modulator</em> and <em>carrier</em>. To control the amount of modulation, an envelope scales the feedback.</p>
<p><strong><em>Example 04D10.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

instr 1  ; feedback PM
kCarFreq = 200
kFeedbackAmountEnv linseg 0, 2, 0.2, 0.1, 0.3, 0.8, 0.2, 1.5, 0
aAmpEnv expseg .001, 0.001, 1, 0.3, 0.5, 8.5, .001
aPhase phasor kCarFreq
aCarrier init 0 ; init for feedback
aCarrier tablei aPhase+(aCarrier*kFeedbackAmountEnv), 1, 1, 0, 1
outs aCarrier*aAmpEnv, aCarrier*aAmpEnv
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 		;Sine wave for table 1
i 1 0 9
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)</code></pre>
<p>The last example features modulation of the <a href="http://www.csounds.com/manual/html/buzz.html">buzz</a> opcode. The buzz opcode can have a lot of harmonic overtones and frequency modulation of the buzz opcode gives even more overtones. Four different voices play at the same time, forming strange chords that use glissando/portamento to move from one chord to the next. This .csd file is regenerative, everytime you run it, it should show a different performance.<br />
</p>
<p><strong><em>EXAMPLE 04D11.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
; By Bjørn Houdorf, April 2012
sr = 44100
ksmps = 8
nchnls = 2
0dbfs = 1

; Global initializations (&quot;Instrument 0&quot;)
          seed      0;  New pitches, 
gkfreq1   init      0;  every time you
gkfreq2   init      0;  run this file
gkfreq3   init      0
gkfreq4   init      0

gimidia1  init      60; The 4 voices start
gimidib1  init      60; at different
gimidia2  init      64; MIDI frequencies
gimidib2  init      64
gimidia3  init      67
gimidib3  init      67
gimidia4  init      70
gimidib4  init      70

; Function Table
giFt1     ftgen     0, 0, 16384, 10, 1; Sine wave

instr 1; Master control pitch for instrument 2

test:
idurtest  poisson   20; Duration of each test loop
          timout    0, idurtest, execute

          reinit    test

execute:
gimidia1  =         gimidib1
ital1     random    -4, 4
gimidib1  =         gimidib1 + ital1
gimidia2  =         gimidib2
ital2     random    -4, 4
gimidib2  =         gimidib2 + ital2
gimidia3  =         gimidib3
ital3     random    -4, 4
gimidib3  =         gimidib3 + ital3
gimidia4  =         gimidib4
ital4     random    -4, 4
gimidib4  =         gimidib4 + ital4

idiv      poisson   4

idurx     =         0.01; Micro end segment to create
				        ;a held final frequency value

ifreq1a   =         cpsmidinn(gimidia1)
ifreq1b   =         cpsmidinn(gimidib1)
; Portamento frequency ramp:
gkfreq1   linseg    ifreq1a, idurtest/idiv, ifreq1b, idurx, ifreq1b 
ifreq2a   =         cpsmidinn(gimidia2)
ifreq2b   =         cpsmidinn(gimidib2)
gkfreq2   linseg    ifreq2a, idurtest/idiv, ifreq2b, idurx, ifreq2b
ifreq3a   =         cpsmidinn(gimidia3)
ifreq3b   =         cpsmidinn(gimidib3)
gkfreq3   linseg    ifreq3a, idurtest/idiv, ifreq3b, idurx, ifreq3b
ifreq4a   =         cpsmidinn(gimidia4)
ifreq4b   =         cpsmidinn(gimidib4)
gkfreq4   linseg    ifreq4a, idurtest/idiv, ifreq4b, idurx, ifreq4b
endin

instr 2 ; Oscillators
iamp      =         p4
irise     =         p5
idur      =         p3
idec      =         p6
kamp      =         p7
imodfrq   =         p8
iharm     =         p9 ; Number of harmonics

ky        linen     iamp, irise, idur, idec

kampfreq  =         2
kampa     oscili    kamp, kampfreq, giFt1

; Different phase for the 4 voices
klfo1     oscili    kampa, imodfrq, giFt1, 0
klfo2     oscili    kampa, imodfrq, giFt1, 0.25
klfo3     oscili    kampa, imodfrq, giFt1, 0.50
klfo4     oscili    kampa, imodfrq, giFt1, 0.75

kzfrq     =         0.1; Velocity of amplitude oscillation
kampvoice =         0.5; Amplitude of each voice

; Amplitude between -0.5 and 0.5
kx1       oscili    0.5, kzfrq, giFt1, 0
kx2       oscili    0.5, kzfrq, giFt1, 0.25
kx3       oscili    0.5, kzfrq, giFt1, 0.50
kx4       oscili    0.5, kzfrq, giFt1, 0.75

; Add 0.5 so amplitude oscillates between 0 and 1
k1        =         kx1+0.5
k2        =         kx2+0.5
k3        =         kx3+0.5
k4        =         kx4+0.5

; Minimize interference between chorus oscillators
itilf     random    -5, 5

asig11    buzz      ky*k1, (2.02*gkfreq1)+itilf+klfo1, iharm, giFt1
asig12    buzz      ky*k1, gkfreq1 +klfo1, iharm, giFt1; Voice 1
asig13    buzz      ky*k1, (1.51*gkfreq1)+itilf+klfo1, iharm, giFt1
aa1       =         asig11+asig12+asig13

asig21    buzz      ky*k2, (2.01*gkfreq2)+itilf+klfo2, iharm, giFt1
asig22    buzz      ky*k2, gkfreq2 +klfo2, iharm, giFt1; Voice 2
asig23    buzz      ky*k2, (1.51*gkfreq2)+itilf+klfo2, iharm, giFt1
aa2       =         asig21+asig22+asig23

asig31    buzz      ky*k3, (2.01*gkfreq3)+itilf+klfo3, iharm, giFt1
asig32    buzz      ky*k3, gkfreq3 +klfo3, iharm, giFt1; Voice 3
asig33    buzz      ky*k3, (1.51*gkfreq3)+itilf+klfo3, iharm, giFt1
aa3       =         asig31+asig32+asig33

asig41    buzz      ky*k4, (2.01*gkfreq4)+itilf+klfo4, iharm, giFt1
asig42    buzz      ky*k4, gkfreq4 +klfo4, iharm, giFt1; Voice 4
asig43    buzz      ky*k4, (1.51*gkfreq4)+itilf+klfo4, iharm, giFt1
aa4       =         asig41+asig42+asig43

          outs      aa1+aa3, aa2+aa4

endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;

; Master control instrument
; Inst start dur
i1       0   3600

; Oscillators
; inst start idur iamp irise idec kamp imodfrq iharm
i2      0    3600  0.3   4    20  0.10    7     16

&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p><br />
</p>
<p><span id="ch028_e-waveshaping.xhtml"></span></p>
<h1>WAVESHAPING</h1>
<p>Waveshaping can in some ways be thought of as a relation to modulation techniques such as frequency or phase modulation. Waveshaping can achieve quite dramatic sound tranformations through the application of a very simple process. In FM (frequency modulation) synthesis modulation occurs between two oscillators, waveshaping is implemented using a single oscillator (usually a simple sine oscillator) and a so-called 'transfer function'. The transfer function transforms and shapes the incoming amplitude values using a simple lookup process: if the incoming value is x, the outgoing value becomes y. This can be written as a table with two columns. Here is a simple example:</p>
<table>
<tbody>
<tr class="odd">
<td>  <strong>Incoming (x) Value</strong></td>
<td>  <strong>Outgoing (y) Value</strong></td>
</tr>
<tr class="even">
<td>-0.5 or lower<br />
</td>
<td> -1</td>
</tr>
<tr class="odd">
<td> between -0.5 and 0.5<br />
</td>
<td> remain unchanged<br />
</td>
</tr>
<tr class="even">
<td> 0.5 or higher<br />
</td>
<td> 1</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Illustrating this in an x/y coordinate system results in the following image:</p>
<p><img src="static/04Ebild1a.png" width="499" height="500" /><br />
 </p>
<h2>Basic Implementation Model<br />
</h2>
<p>Implementing this as Csound code is pretty straightforward. The x-axis is the amplitude of every single sample, which is in the range of -1 to +1.<span id="ch028_e-waveshaping.xhtml#InsertNoteID_26_marker27" class="InsertNoteMarker"><sup><a href="e-waveshaping#InsertNoteID_26">1</a></sup></span> This number has to be used as index to a table which stores the transfer function. To create a table like the one above, you can use Csound's sub-routine GEN07<span id="ch028_e-waveshaping.xhtml#InsertNoteID_28_marker29" class="InsertNoteMarker"><sup><a href="e-waveshaping#InsertNoteID_28">2</a></sup></span> . This statement will create a table of 4096 points in the desired shape:</p>
<pre><code>giTrnsFnc ftgen 0, 0, 4096, -7, -0.5, 1024, -0.5, 2048, 0.5, 1024, 0.5</code></pre>
<p><img src="static/04E01ftable2.png" /> </p>
<p>Now, two problems must be solved. First, the index of the function table is not -1 to +1. Rather, it is either 0 to 4095 in the raw index mode, or 0 to 1 in the normalized mode. The simplest solution is to use the normalized index and scale the incoming amplitudes, so that an amplitude of -1 becomes an index of 0, and an amplitude of 1 becomes an index of 1:</p>
<pre><code>aIndx = (aAmp + 1) / 2</code></pre>
<p>The other problem stems from the difference in the accuracy of possible values in a sample and in a function table. Every single sample is encoded in a 32-bit floating point number in standard audio applications - or even in a 64-bit float in recent Csound.<span id="ch028_e-waveshaping.xhtml#InsertNoteID_30_marker31" class="InsertNoteMarker"><sup><a href="e-waveshaping#InsertNoteID_30">3</a></sup></span> A table with 4096 points results in a 12-bit number, so you will have a serious loss of accuracy (= sound quality) if you use the table values directly.<span id="ch028_e-waveshaping.xhtml#InsertNoteID_32_marker33" class="InsertNoteMarker"><sup><a href="e-waveshaping#InsertNoteID_32">4</a></sup></span> Here, the solution is to use an interpolating table reader. The opcode <a href="http://www.csounds.com/manual/html/tablei.html">tablei</a> (instead of <a href="http://www.csounds.com/manual/html/table.html">table</a>) does this job. This opcode then needs an extra point in the table for interpolating, so it is wise to use 4097 as size instead of 4096.<span id="ch028_e-waveshaping.xhtml#InsertNoteID_44_marker45" class="InsertNoteMarker"><sup><a href="e-waveshaping#InsertNoteID_44">5</a></sup></span> <br />
</p>
<p>This is the code for the simple waveshaping with the transfer function which has been discussed so far:</p>
<p><em><strong>EXAMPLE 04E01.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giTrnsFnc ftgen 0, 0, 4097, -7, -0.5, 1024, -0.5, 2048, 0.5, 1024, 0.5
giSine    ftgen 0, 0, 1024, 10, 1

instr 1
aAmp      poscil    1, 400, giSine
aIndx     =         (aAmp + 1) / 2
aWavShp   tablei    aIndx, giTrnsFnc, 1
          outs      aWavShp, aWavShp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p><img src="static/04E01audacity.png" width="599" height="336" /> </p>
<h2> Chebychev Polynomials as Transfer Functions<br />
</h2>
<p> </p>
<p> </p>
<p> </p>
<p><br />
</p>
<p><br />
</p>
<p> </p>
<p> </p>
<p><br />
</p>
<ol>
<li><span id="ch028_e-waveshaping.xhtml#InsertNoteID_26">Use the statement 0dbfs=1 in the orchestra header to ensure this.<span id="ch028_e-waveshaping.xhtml#InsertNoteID_26_LinkBacks"><sup><a href="e-waveshaping#InsertNoteID_26_marker27">^</a></sup></span></span></li>
<li><span id="ch028_e-waveshaping.xhtml#InsertNoteID_28">See chapter 03D:FUNCTION TABLES to find more information about creating tables.<span id="ch028_e-waveshaping.xhtml#InsertNoteID_28_LinkBacks"><sup><a href="e-waveshaping#InsertNoteID_28_marker29">^</a></sup></span></span></li>
<li><span id="ch028_e-waveshaping.xhtml#InsertNoteID_30">This is the 'd' in some abbreviations like Csound5.17-gnu-win32-d.exe (d = double precision floats).<span id="ch028_e-waveshaping.xhtml#InsertNoteID_30_LinkBacks"><sup><a href="e-waveshaping#InsertNoteID_30_marker31">^</a></sup></span></span></li>
<li><span id="ch028_e-waveshaping.xhtml#InsertNoteID_32">Of course you can use an even smaller table if your goal is the degradation of the incoming sound (&quot;distortion&quot;). See chapter 05F for some examples.<span id="ch028_e-waveshaping.xhtml#InsertNoteID_32_LinkBacks"><sup><a href="e-waveshaping#InsertNoteID_32_marker33">^</a></sup></span></span></li>
<li><span id="ch028_e-waveshaping.xhtml#InsertNoteID_44">A table size of a power-of-two plus one inserts the &quot;extended guard point&quot; as an extension of the last table value, instead of copying the first index to this location. See http://www.csounds.com/manual/html/f.html for more information.<span id="ch028_e-waveshaping.xhtml#InsertNoteID_44_LinkBacks"><sup><a href="e-waveshaping#InsertNoteID_44_marker45">^</a></sup></span></span></li>
</ol>
<p><span id="ch029_f-granular-synthesis.xhtml"></span></p>
<h1>GRANULAR SYNTHESIS<br />
</h1>
<h2>Concept Behind Granular Synthesis</h2>
<p>Granular synthesis is a technique in which a source sound or waveform is broken into many fragments, often of very short duration, which are then restructured and rearranged according to various patterning and indeterminacy functions.</p>
<p>If we imagine the simplest possible granular synthesis algorithm in which a precise fragment of sound is repeated with regularity, there are two principle attributes of this process that we are most concerned with. Firstly the duration of each sound grain is significant: if the grain duration if very small, typically less than 0.02 seconds, then less of the characteristics of the source sound will be evident. If the grain duration is greater than 0.02 then more of the character of the source sound or waveform will be evident. Secondly the rate at which grains are generated will be significant: if grain generation is below 20 hertz, i.e. less than 20 grains per second, then the stream of grains will be perceived as a rhythmic pulsation; if rate of grain generation increases beyond 20 Hz then individual grains will be harder to distinguish and instead we will begin to perceive a buzzing tone, the fundamental of which will correspond to the frequency of grain generation. Any pitch contained within the source material is not normally perceived as the fundamental of the tone whenever grain generation is periodic, instead the pitch of the source material or waveform will be perceived as a resonance peak (sometimes referred to as a formant); therefore transposition of the source material will result in the shifting of this resonance peak.</p>
<h2>Granular Synthesis Demonstrated Using First Principles<br />
</h2>
<p>The following example exemplifies the concepts discussed above. None of Csound's built-in granular synthesis opcodes are used, instead <a href="http://www.csounds.com/manual/html/schedkwhen.html">schedkwhen</a> in instrument 1 is used to precisely control the triggering of grains in instrument 2. Three notes in instrument 1 are called from the score one after the other which in turn generate three streams of grains in instrument 2. The first note demonstrates the transition from pulsation to the perception of a tone as the rate of grain generation extends beyond 20 Hz. The second note demonstrates the loss of influence of the source material as the grain duration is reduced below 0.02 seconds. The third note demonstrates how shifting the pitch of the source material for the grains results in the shifting of a resonance peak in the output tone. In each case information regarding rate of grain generation, duration and fundamental (source material pitch) is output to the terminal every 1/2 second so that the user can observe the changing parameters.</p>
<p>It should also be noted how the amplitude of each grain is enveloped in instrument 2. If grains were left unenveloped they would likely produce clicks on account of discontinuities in the waveform produced at the beginning and ending of each grain.</p>
<p>Granular synthesis in which grain generation occurs with perceivable periodicity is referred to as synchronous granular synthesis. granular synthesis in which this periodicity is not evident is referred to as asynchronous granular synthesis. <br />
</p>
<h4><em><em>EXAMPLE 04F01.csd</em></em></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac -m0
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 1
nchnls = 1
0dbfs = 1

giSine  ftgen  0,0,4096,10,1

instr 1
  kRate  expon  p4,p3,p5   ; rate of grain generation
  kTrig  metro  kRate      ; a trigger to generate grains
  kDur   expon  p6,p3,p7   ; grain duration
  kForm  expon  p8,p3,p9   ; formant (spectral centroid)
   ;                      p1 p2 p3   p4
  schedkwhen    kTrig,0,0,2, 0, kDur,kForm ;trigger a note(grain) in instr 2
  ;print data to terminal every 1/2 second
  printks &quot;Rate:%5.2F  Dur:%5.2F  Formant:%5.2F%n&quot;, 0.5, kRate , kDur, kForm
endin

instr 2
  iForm =       p4
  aEnv  linseg  0,0.005,0.2,p3-0.01,0.2,0.005,0
  aSig  poscil  aEnv, iForm, giSine
        out     aSig
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p4 = rate begin
;p5 = rate end
;p6 = duration begin
;p7 = duration end
;p8 = formant begin
;p9 = formant end
; p1 p2 p3 p4 p5  p6   p7    p8  p9
i 1  0  30 1  100 0.02 0.02  400 400  ;demo of grain generation rate
i 1  31 10 10 10  0.4  0.01  400 400  ;demo of grain size
i 1  42 20 50 50  0.02 0.02  100 5000 ;demo of changing formant
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Granular Synthesis of Vowels: FOF</h2>
<p>The principles outlined in the previous example can be extended to imitate vowel sounds produced by the human voice. This type of granular synthesis is referred to as FOF (fonction d'onde formatique) synthesis and is based on work by Xavier Rodet on his CHANT program at IRCAM. Typically five synchronous granular synthesis streams will be used to create five different resonant peaks in a fundamental tone in order to imitate different vowel sounds expressible by the human voice. The most crucial element in defining a vowel imitation is the degree to which the source material within each of the five grain streams is transposed. Bandwidth (essentially grain duration) and intensity (loudness) of each grain stream are also important indicators in defining the resultant sound. </p>
<p>Csound has a number of opcodes that make working with FOF synthesis easier. We will be using <a href="http://www.csounds.com/manual/html/fof.html">fof</a>.</p>
<p>Information regarding frequency, bandwidth and intensity values that will produce various vowel sounds for different voice types can be found in the appendix of the Csound manual <a href="http://www.csounds.com/manual/html/MiscFormants.html">here</a>. These values are stored in function tables in the FOF synthesis example. GEN07, which produces linear break point envelopes, is chosen as we will then be able to morph continuously between vowels.</p>
<h4><em><em><em><em>EXAMPLE 04F02.csd</em></em></em></em><br />
</h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example by Iain McCurdy

sr = 44100
ksmps = 16
nchnls = 2
0dbfs = 1

instr 1
  kFund    expon     p4,p3,p5               ; fundemental
  kVow     line      p6,p3,p7               ; vowel select
  kBW      line      p8,p3,p9               ; bandwidth factor
  iVoice   =         p10                    ; voice select

  ; read formant cutoff frequenies from tables
  kForm1     table     kVow,1+(iVoice*15),1
  kForm2     table     kVow,2+(iVoice*15),1
  kForm3     table     kVow,3+(iVoice*15),1
  kForm4     table     kVow,4+(iVoice*15),1
  kForm5     table     kVow,5+(iVoice*15),1
  ; read formant intensity values from tables
  kDB1     table     kVow,6+(iVoice*15),1
  kDB2     table     kVow,7+(iVoice*15),1
  kDB3     table     kVow,8+(iVoice*15),1
  kDB4     table     kVow,9+(iVoice*15),1
  kDB5     table     kVow,10+(iVoice*15),1
  ; read formant bandwidths from tables
  kBW1     table     kVow,11+(iVoice*15),1
  kBW2     table     kVow,12+(iVoice*15),1
  kBW3     table     kVow,13+(iVoice*15),1
  kBW4     table     kVow,14+(iVoice*15),1
  kBW5     table     kVow,15+(iVoice*15),1
  ; create resonant formants by filtering source sound
  koct     =         1	
  aForm1   fof       ampdb(kDB1),kFund,kForm1,0,kBW1,0.003,0.02,0.007,\
                       1000,101,102,3600
  aForm2   fof       ampdb(kDB2),kFund,kForm2,0,kBW2,0.003,0.02,0.007,\
                       1000,101,102,3600
  aForm3   fof       ampdb(kDB3),kFund,kForm3,0,kBW3,0.003,0.02,0.007,\
                       1000,101,102,3600
  aForm4   fof       ampdb(kDB4),kFund,kForm4,0,kBW4,0.003,0.02,0.007,\
                       1000,101,102,3600
  aForm5   fof       ampdb(kDB5),kFund,kForm5,0,kBW5,0.003,0.02,0.007,\
                       1000,101,102,3600

  ; formants are mixed
  aMix     sum       aForm1,aForm2,aForm3,aForm4,aForm5
  kEnv     linseg    0,3,1,p3-6,1,3,0     ; an amplitude envelope
           outs      aMix*kEnv*0.3, aMix*kEnv*0.3 ; send audio to outputs
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;FUNCTION TABLES STORING FORMANT DATA FOR EACH OF THE FIVE VOICE TYPES REPRESENTED
;BASS
f 1  0 32768 -7 600	10922	400	10922	250	10924	350	;FREQ
f 2  0 32768 -7 1040	10922	1620	10922	1750	10924	600	;FREQ
f 3  0 32768 -7	2250	10922	2400	10922	2600	10924	2400	;FREQ
f 4  0 32768 -7	2450	10922	2800	10922	3050	10924	2675	;FREQ
f 5  0 32768 -7	2750	10922	3100	10922	3340	10924	2950	;FREQ
f 6  0 32768 -7	0	10922	0	10922	0	10924	0	;dB
f 7  0 32768 -7	-7	10922	-12	10922	-30	10924	-20	;dB
f 8  0 32768 -7	-9	10922	-9	10922	-16	10924	-32	;dB
f 9  0 32768 -7	-9	10922	-12	10922	-22	10924	-28	;dB
f 10 0 32768 -7	-20	10922	-18	10922	-28	10924	-36	;dB
f 11 0 32768 -7	60	10922	40	10922	60	10924	40	;BAND WIDTH
f 12 0 32768 -7	70	10922	80	10922	90	10924	80	;BAND WIDTH
f 13 0 32768 -7	110	10922	100	10922	100	10924	100	;BAND WIDTH
f 14 0 32768 -7	120	10922	120	10922	120	10924	120	;BAND WIDTH
f 15 0 32768 -7	130	10922	120	10922	120	10924	120	;BAND WIDTH
;TENOR
f 16 0 32768 -7 650 	8192	400 	8192	290	8192	400	8192	350	;FREQ
f 17 0 32768 -7 1080 	8192	1700    8192	1870	8192	800	8192	600	;FREQ
f 18 0 32768 -7	2650	8192	2600    8192	2800	8192	2600	8192	2700	;FREQ
f 19 0 32768 -7	2900	8192	3200    8192	3250	8192	2800	8192	2900	;FREQ
f 20 0 32768 -7	3250	8192	3580    8192	3540	8192	3000	8192	3300	;FREQ
f 21 0 32768 -7	0	8192	0	8192	0	8192	0	8192	0	;dB
f 22 0 32768 -7	-6	8192	-14	8192	-15	8192	-10	8192	-20	;dB
f 23 0 32768 -7	-7	8192	-12	8192	-18	8192	-12	8192	-17	;dB
f 24 0 32768 -7	-8	8192	-14	8192	-20	8192	-12	8192	-14	;dB
f 25 0 32768 -7	-22	8192	-20	8192	-30	8192	-26	8192	-26	;dB
f 26 0 32768 -7	80	8192	70	8192	40	8192	40	8192	40	;BAND WIDTH
f 27 0 32768 -7	90	8192	80	8192	90	8192	80	8192	60	;BAND WIDTH
f 28 0 32768 -7	120	8192	100	8192	100	8192	100	8192	100	;BAND WIDTH
f 29 0 32768 -7	130	8192	120	8192	120	8192	120	8192	120	;BAND WIDTH
f 30 0 32768 -7	140	8192	120	8192	120	8192	120	8192	120	;BAND WIDTH
;COUNTER TENOR
f 31 0 32768 -7 660	8192	440	8192	270	8192	430	8192	370	;FREQ
f 32 0 32768 -7 1120	8192	1800	8192	1850	8192	820	8192	630	;FREQ
f 33 0 32768 -7	2750	8192	2700	8192	2900	8192	2700	8192	2750	;FREQ
f 34 0 32768 -7	3000	8192	3000	8192	3350	8192	3000	8192	3000	;FREQ
f 35 0 32768 -7	3350	8192	3300	8192	3590	8192	3300	8192	3400	;FREQ
f 36 0 32768 -7	0	8192	0	8192	0	8192	0	8192	0	;dB
f 37 0 32768 -7	-6	8192	-14	8192	-24	8192	-10	8192	-20	;dB
f 38 0 32768 -7	-23	8192	-18	8192	-24	8192	-26	8192	-23	;dB
f 39 0 32768 -7	-24	8192	-20	8192	-36	8192	-22	8192	-30	;dB
f 40 0 32768 -7	-38	8192	-20	8192	-36	8192	-34	8192	-30	;dB
f 41 0 32768 -7	80	8192	70	8192	40	8192	40	8192	40	;BAND WIDTH
f 42 0 32768 -7	90	8192	80	8192	90	8192	80	8192	60	;BAND WIDTH
f 43 0 32768 -7	120	8192	100	8192	100	8192	100	8192	100	;BAND WIDTH
f 44 0 32768 -7	130	8192	120	8192	120	8192	120	8192	120	;BAND WIDTH
f 45 0 32768 -7	140	8192	120	8192	120	8192	120	8192	120	;BAND WIDTH
;ALTO
f 46 0 32768 -7	800	8192	400	8192	350	8192	450	8192	325	;FREQ
f 47 0 32768 -7	1150	8192	1600	8192	1700	8192	800	8192	700	;FREQ
f 48 0 32768 -7	2800	8192	2700	8192	2700	8192	2830	8192	2530	;FREQ
f 49 0 32768 -7	3500	8192	3300	8192	3700	8192	3500	8192	2500	;FREQ
f 50 0 32768 -7	4950	8192	4950	8192	4950	8192	4950	8192	4950	;FREQ
f 51 0 32768 -7	0	8192	0	8192	0	8192	0	8192	0	;dB
f 52 0 32768 -7	-4	8192	-24	8192	-20	8192	-9	8192	-12	;dB
f 53 0 32768 -7	-20	8192	-30	8192	-30	8192	-16	8192	-30	;dB
f 54 0 32768 -7	-36	8192	-35	8192	-36	8192	-28	8192	-40	;dB
f 55 0 32768 -7	-60	8192	-60	8192	-60	8192	-55	8192	-64	;dB
f 56 0 32768 -7	50	8192	60	8192	50	8192	70	8192	50	;BAND WIDTH
f 57 0 32768 -7	60	8192	80	8192	100	8192	80	8192	60	;BAND WIDTH
f 58 0 32768 -7	170	8192	120	8192	120	8192	100	8192	170	;BAND WIDTH
f 59 0 32768 -7	180	8192	150	8192	150	8192	130	8192	180	;BAND WIDTH
f 60 0 32768 -7	200	8192	200	8192	200	8192	135	8192	200	;BAND WIDTH
;SOPRANO
f 61 0 32768 -7	800	8192	350	8192	270	8192	450	8192	325	;FREQ
f 62 0 32768 -7	1150	8192	2000	8192	2140	8192	800	8192	700	;FREQ
f 63 0 32768 -7	2900	8192	2800	8192	2950	8192	2830	8192	2700	;FREQ
f 64 0 32768 -7	3900	8192	3600	8192	3900	8192	3800	8192	3800	;FREQ
f 65 0 32768 -7	4950	8192	4950	8192	4950	8192	4950	8192	4950	;FREQ
f 66 0 32768 -7	0	8192	0	8192	0	8192	0	8192	0	;dB
f 67 0 32768 -7	-6	8192	-20	8192	-12	8192	-11	8192	-16	;dB
f 68 0 32768 -7	-32	8192	-15	8192	-26	8192	-22	8192	-35	;dB
f 69 0 32768 -7	-20	8192	-40	8192	-26	8192	-22	8192	-40	;dB
f 70 0 32768 -7	-50	8192	-56	8192	-44	8192	-50	8192	-60	;dB
f 71 0 32768 -7	80	8192	60	8192	60	8192	70	8192	50	;BAND WIDTH
f 72 0 32768 -7	90	8192	90	8192	90	8192	80	8192	60	;BAND WIDTH
f 73 0 32768 -7	120	8192	100	8192	100	8192	100	8192	170	;BAND WIDTH
f 74 0 32768 -7	130	8192	150	8192	120	8192	130	8192	180	;BAND WIDTH
f 75 0 32768 -7	140	8192	200	8192	120	8192	135	8192	200	;BAND WIDTH

f 101 0 4096 10 1			;SINE WAVE
;EXPONENTIAL CURVE USED TO DEFINE THE ENVELOPE SHAPE OF FOF PULSES:
f 102 0 1024 19 0.5 0.5 270 0.5
; p4 = fundamental begin value (c.p.s.)
; p5 = fundamental end value
; p6 = vowel begin value (0 - 1 : a e i o u)
; p7 = vowel end value
; p8 = bandwidth factor begin (suggested range 0 - 2)
; p9 = bandwidth factor end
; p10 = voice (0=bass; 1=tenor; 2=counter_tenor; 3=alto; 4=soprano)

; p1 p2  p3  p4  p5  p6  p7  p8  p9 p10
i 1  0   10  50  100 0   1   2   0  0
i 1  8   .   78  77  1   0   1   0  1
i 1  16  .   150 118 0   1   1   0  2
i 1  24  .   200 220 1   0   0.2 0  3
i 1  32  .   400 800 0   1   0.2 0  4
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Asynchronous Granular Synthesis</h2>
<p>The previous two examples have played psychoacoustic phenomena associated with the perception of granular textures that exhibit periodicity and patterns. If we introduce indeterminacy into some of the parameters of granular synthesis we begin to lose the coherence of some of these harmonic structures.</p>
<p>The next example is based on the design of example 04F01.csd. Two streams of grains are generated. The first stream begins as a synchronous stream but as the note progresses the periodicity of grain generation is eroded through the addition of an increasing degree of <a href="http://en.wikipedia.org/wiki/Normal_distribution">gaussian</a><a href="http://en.wikipedia.org/wiki/Normal_distribution">noise</a>. It will be heard how the tone metamorphosizes from one characterized by steady purity to one of fuzzy airiness. The second the applies a similar process of increasing indeterminacy to the formant parameter (frequency of material within each grain).</p>
<p>Other parameters of granular synthesis such as the amplitude of each grain, grain duration, spatial location etc. can be similarly modulated with random functions to offset the psychoacoustic effects of synchronicity when using constant values.</p>
<h4><em><em><em><em>EXAMPLE 04F03.csd</em></em></em></em><br />
</h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 1
nchnls = 1
0dbfs = 1

giWave  ftgen  0,0,2^10,10,1,1/2,1/4,1/8,1/16,1/32,1/64

instr 1 ;grain generating instrument 1
  kRate         =          p4
  kTrig         metro      kRate      ; a trigger to generate grains
  kDur          =          p5
  kForm         =          p6
  ;note delay time (p2) is defined using a random function -
  ;- beginning with no randomization but then gradually increasing
  kDelayRange   transeg    0,1,0,0,  p3-1,4,0.03
  kDelay        gauss      kDelayRange
  ;                                  p1 p2 p3   p4
                schedkwhen kTrig,0,0,3, abs(kDelay), kDur,kForm ;trigger a note (grain) in instr 3
endin

instr 2 ;grain generating instrument 2
  kRate          =          p4
  kTrig          metro      kRate      ; a trigger to generate grains
  kDur           =          p5
  ;formant frequency (p4) is multiplied by a random function -
  ;- beginning with no randomization but then gradually increasing
  kForm          =          p6
  kFormOSRange  transeg     0,1,0,0,  p3-1,2,12 ;range defined in semitones
  kFormOS       gauss       kFormOSRange
  ;                                   p1 p2 p3   p4
                schedkwhen  kTrig,0,0,3, 0, kDur,kForm*semitone(kFormOS)
endin

instr 3 ;grain sounding instrument
  iForm =       p4
  aEnv  linseg  0,0.005,0.2,p3-0.01,0.2,0.005,0
  aSig  poscil  aEnv, iForm, giWave
        out     aSig
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p4 = rate
;p5 = duration
;p6 = formant
; p1 p2   p3 p4  p5   p6
i 1  0    12 200 0.02 400
i 2  12.5 12 200 0.02 400
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Synthesis of Dynamic Sound Spectra: grain3</h2>
<p>The next example introduces another of Csound's built-in granular synthesis opcodes to demonstrate the range of dynamic sound spectra that are possible with granular synthesis.</p>
<p>Several parameters are modulated slowly using Csound's random spline generator <a href="http://www.csounds.com/manual/html/rspline.html">rspline</a>. These parameters are formant frequency, grain duration and grain density (rate of grain generation). The waveform used in generating the content for each grain is randomly chosen using a slow <a href="http://en.wikipedia.org/wiki/Sample_and_hold">sample and hold</a> random function - a new waveform will be selected every 10 seconds. Five waveforms are provided: a sawtooth, a square wave, a triangle wave, a pulse wave and a band limited buzz-like waveform. Some of these waveforms, particularly the sawtooth, square and pulse waveforms, can generate very high overtones, for this reason a high sample rate is recommended to reduce the risk of aliasing (see chapter 01A).</p>
<p>Current values for formant (cps), grain duration, density and waveform are printed to the terminal every second. The key for waveforms is: 1:sawtooth; 2:square; 3:triangle; 4:pulse; 5:buzz.</p>
<h4><em><em><em><em>EXAMPLE 04F04.csd</em></em></em></em></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example by Iain McCurdy

sr = 96000
ksmps = 16
nchnls = 1
0dbfs = 1

;waveforms used for granulation
giSaw   ftgen 1,0,4096,7,0,4096,1
giSq    ftgen 2,0,4096,7,0,2046,0,0,1,2046,1
giTri   ftgen 3,0,4096,7,0,2046,1,2046,0
giPls   ftgen 4,0,4096,7,1,200,1,0,0,4096-200,0
giBuzz  ftgen 5,0,4096,11,20,1,1

;window function - used as an amplitude envelope for each grain
;(hanning window)
giWFn   ftgen 7,0,16384,20,2,1

instr 1
  ;random spline generates formant values in oct format
  kOct    rspline 4,8,0.1,0.5
  ;oct format values converted to cps format
  kCPS    =       cpsoct(kOct)
  ;phase location is left at 0 (the beginning of the waveform)
  kPhs    =       0
  ;frequency (formant) randomization and phase randomization are not used
  kFmd    =       0
  kPmd    =       0
  ;grain duration and density (rate of grain generation)
  kGDur   rspline 0.01,0.2,0.05,0.2
  kDens   rspline 10,200,0.05,0.5
  ;maximum number of grain overlaps allowed. This is used as a CPU brake
  iMaxOvr =       1000
  ;function table for source waveform for content of the grain
  ;a different waveform chosen once every 10 seconds
  kFn     randomh 1,5.99,0.1
  ;print info. to the terminal
          printks &quot;CPS:%5.2F%TDur:%5.2F%TDensity:%5.2F%TWaveform:%1.0F%n&quot;,1,\
                     kCPS,kGDur,kDens,kFn
  aSig    grain3  kCPS, kPhs, kFmd, kPmd, kGDur, kDens, iMaxOvr, kFn, giWFn, \
                    0, 0
          out     aSig*0.06
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 300
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;
</code></pre>
<p>The final example introduces grain3's two built-in randomizing functions for phase and pitch. Phase refers to the location in the source waveform from which a grain will be read, pitch refers to the pitch of the material within grains. In this example a long note is played, initially no randomization is employed but gradually phase randomization is increased and then reduced back to zero. The same process is applied to the pitch randomization amount parameter. This time grain size is relatively large:0.8 seconds and density correspondingly low: 20 Hz.</p>
<h4><em><em><em><em><em><em><em><em>EXAMPLE 04F05.csd</em></em></em></em></em></em></em></em></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example by Iain McCurdy

sr = 44100
ksmps = 16
nchnls = 1
0dbfs = 1

;waveforms used for granulation
giBuzz  ftgen 1,0,4096,11,40,1,0.9

;window function - used as an amplitude envelope for each grain
;(bartlett window)
giWFn   ftgen 2,0,16384,20,3,1

instr 1
  kCPS    =       100
  kPhs    =       0
  kFmd    transeg 0,21,0,0, 10,4,15, 10,-4,0
  kPmd    transeg 0,1,0,0,  10,4,1,  10,-4,0
  kGDur   =       0.8
  kDens   =       20
  iMaxOvr =       1000
  kFn     =       1
  ;print info. to the terminal
          printks &quot;Random Phase:%5.2F%TPitch Random:%5.2F%n&quot;,1,kPmd,kFmd
  aSig    grain3  kCPS, kPhs, kFmd, kPmd, kGDur, kDens, iMaxOvr, kFn, giWFn, 0, 0
          out     aSig*0.06
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 51
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Conclusion</h2>
<p>This chapter has introduced some of the concepts behind the synthesis of new sounds based on simple waveforms by using granular synthesis techniques. Only two of Csound's built-in opcodes for granular synthesis, <a href="http://www.csounds.com/manual/html/fof.html">fof</a> and <a href="http://www.csounds.com/manual/html/grain3.html">grain3</a>, have been used; it is beyond the scope of this work to cover all of the many opcodes for granulation that Csound provides. This chapter has focused mainly on synchronous granular synthesis; chapter 05G, which introduces granulation of recorded sound files, makes greater use of asynchronous granular synthesis for time-stretching and pitch shifting. This chapter will also introduce some of Csound's other opcodes for granular synthesis.<br />
</p>
<p><span id="ch030_g-physical-modelling.xhtml"></span></p>
<h1>PHYSICAL MODELLING</h1>
<p>With physical modelling we employ a completely different approach to synthesis than we do with all other standard techniques. Unusually the focus is not primarily to produce a sound, but to model a physical process and if this process exhibits certain features such as periodic oscillation within a frequency range of 20 to 20000 Hz, it will produce sound.</p>
<p>Physical modelling synthesis techniques do not build sound using wave tables, oscillators and audio signal generators, instead they attempt to establish a model, as a system in itself, which which can then produce sound because of how the function it producers time varies with time. A physical model usually derives from the real physical world, but could be any time-varying system. Physical modelling is an exciting area for the production of new sounds.</p>
<p>Compared with the complexity of a real-world physically dynamic system a physical model will most likely represent a brutal simplification. Nevertheless, using this technique will demand a lot of formulae, because physical models are described in terms of mathematics. Although designing a model may require some considerable work, once established the results commonly exhibit a lively tone with time-varying partials and a &quot;natural&quot; difference between attack and release by their very design - features that other synthesis techniques will demand more from the end user in order to establish.<br />
</p>
<p>Csound already contains many ready-made physical models as opcodes but you can still build your own from scratch. This chapter will look at how to implement two classical models from first principles and then introduce a number of Csound's ready made physical modelling opcodes.</p>
<h2>The Mass-Spring Model<span id="ch030_g-physical-modelling.xhtml#InsertNoteID_6_marker7" class="InsertNoteMarker"><sup><a href="g-physical-modelling#InsertNoteID_6">1</a></sup></span> <br />
</h2>
<p>Many oscillating processes in nature can be modelled as connections of masses and springs. Imagine one mass-spring unit which has been set into motion. This system can be described as a sequence of states, where every new state results from the two preceding ones. Assumed the first state <em>a0</em> is 0 and the second state <em>a1</em> is 0.5. Without the restricting force of the spring, the mass would continue moving unimpeded following a constant velocity:</p>
<p><img src="static/04G01bild1a.png" width="600" height="556" /> </p>
<p>As the velocity between the first two states can be described as <em>a1-a0</em>, the value of the third state <em>a2</em> will be:</p>
<p><em>a2 = a1 + (a1 - a0) = 0.5 + 0.5 = 1</em><br />
</p>
<p>But, the spring pulls the mass back with a force which increases the further the mass moves away from the point of equilibrium. Therefore the masses movement can be described as the product of a constant factor <em>c</em> and the last position <em>a1</em>. This damps the continuous movement of the mass so that for a factor of c=0.4 the next position will be:</p>
<p><em>a2 = (a1 + (a1 - a0)) - c * a1 = 1 - 0.2 = 0.8</em><br />
</p>
<p><img src="static/04G01bild2a.png" /> </p>
<p>Csound can easily calculate the values by simply applying the formulae. For the first k-cycle<span id="ch030_g-physical-modelling.xhtml#InsertNoteID_18_marker19" class="InsertNoteMarker"><sup><a href="g-physical-modelling#InsertNoteID_18">2</a></sup></span> , they are set via the <a href="http://www.csounds.com/manual/html/init.html">init</a> opcode. After calculating the new state, <em>a1</em> becomes <em>a0</em> and <em>a2</em> becomes <em>a1</em> for the next k-cycle. This is a csd which prints the new values five times per second. (The states are named here as <em>k0/k1/k2</em> instead of <em>a0/a1/a2</em>, because k-rate values are needed here for printing instead of audio samples.)</p>
<p><strong><em>EXAMPLE 04G01.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-n ;no sound
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 8820 ;5 steps per second

instr PrintVals
;initial values
kstep init 0
k0 init 0
k1 init 0.5
kc init 0.4
;calculation of the next value
k2 = k1 + (k1 - k0) - kc * k1
printks &quot;Sample=%d: k0 = %.3f, k1 = %.3f, k2 = %.3f\n&quot;, 0, kstep, k0, k1, k2
;actualize values for the next step
kstep = kstep+1
k0 = k1
k1 = k2
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i &quot;PrintVals&quot; 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</code></pre>
<p>The output starts with:</p>
<pre><code>State=0:  k0 =  0.000,  k1 =  0.500,  k2 =  0.800
State=1:  k0 =  0.500,  k1 =  0.800,  k2 =  0.780
State=2:  k0 =  0.800,  k1 =  0.780,  k2 =  0.448
State=3:  k0 =  0.780,  k1 =  0.448,  k2 = -0.063
State=4:  k0 =  0.448,  k1 = -0.063,  k2 = -0.549
State=5:  k0 = -0.063,  k1 = -0.549,  k2 = -0.815
State=6:  k0 = -0.549,  k1 = -0.815,  k2 = -0.756
State=7:  k0 = -0.815,  k1 = -0.756,  k2 = -0.393
State=8:  k0 = -0.756,  k1 = -0.393,  k2 =  0.126
State=9:  k0 = -0.393,  k1 =  0.126,  k2 =  0.595
State=10: k0 =  0.126,  k1 =  0.595,  k2 =  0.826
State=11: k0 =  0.595,  k1 =  0.826,  k2 =  0.727
State=12: k0 =  0.826,  k1 =  0.727,  k2 =  0.337</code></pre>
<p><img src="static/04G01bild4a.png" /> </p>
<p>So, a sine wave has been created, without the use of any of Csound's oscillators...</p>
<p>Here is the audible proof:</p>
<p><em><strong>EXAMPLE 04G02.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 1
nchnls = 2
0dbfs = 1

instr MassSpring
;initial values
a0        init      0
a1        init      0.05
ic        =         0.01 ;spring constant
;calculation of the next value
a2        =         a1+(a1-a0) - ic*a1
          outs      a0, a0
;actualize values for the next step
a0        =         a1
a1        =         a2
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i &quot;MassSpring&quot; 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz, after martin neukom</code></pre>
<p>As the next sample is calculated in the next control cycle, <a href="http://www.csounds.com/manual/html/ksmps.html">ksmps</a> has to be set to 1.<span id="ch030_g-physical-modelling.xhtml#InsertNoteID_20_marker21" class="InsertNoteMarker"><sup><a href="g-physical-modelling#InsertNoteID_20">3</a></sup></span> The resulting frequency depends on the spring constant: the higher the constant, the higher the frequency. The resulting amplitude depends on both, the starting value and the spring constant.</p>
<p>This simple model shows the basic principle of a physical modelling synthesis: creating a system which produces sound because it varies in time. Certainly it is not the goal of physical modelling synthesis to reinvent the wheel of a sine wave. But modulating the parameters of a model may lead to interesting results. The next example varies the spring constant, which is now no longer a constant:</p>
<p><strong><em>EXAMPLE 04G03.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 1
nchnls = 2
0dbfs = 1

instr MassSpring
;initial values
a0        init      0
a1        init      0.05
kc        randomi   .001, .05, 8, 3
;calculation of the next value
a2        =         a1+(a1-a0) - kc*a1
          outs      a0, a0
;actualize values for the next step
a0        =         a1
a1        =         a2
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i &quot;MassSpring&quot; 0 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</code></pre>
<p>Working with physical modelling demands thought in more physical or mathematical terms: examples of this might be if you were to change the formula when a certain value of <em>c</em> had been reached, or combine more than one spring.<br />
</p>
<h2>The Karplus-Strong Algorithm: Plucked String<br />
</h2>
<p>The Karplus-Strong algorithm provides another simple yet interesting example of how physical modelling can be used to synthesized sound. A buffer is filled with random values of either +1 or -1. At the end of the buffer, the mean of the first and the second value to come out of the buffer is calculated. This value is then put back at the beginning of the buffer, and all the values in the buffer are shifted by one position. </p>
<p>This is what happens for a buffer of five values, for the first five steps:</p>
<table>
<tbody>
<tr class="odd">
<td> initial state<br />
</td>
<td> 1</td>
<td>-1<br />
</td>
<td>1<br />
</td>
<td>1<br />
</td>
<td>-1<br />
</td>
</tr>
<tr class="even">
<td> step 1<br />
</td>
<td> 0<br />
</td>
<td> 1</td>
<td>-1<br />
</td>
<td>1<br />
</td>
<td>1<br />
</td>
</tr>
<tr class="odd">
<td> step 2<br />
</td>
<td> 1</td>
<td> 0</td>
<td>1</td>
<td>-1</td>
<td>1<br />
</td>
</tr>
<tr class="even">
<td> step 3<br />
</td>
<td> 0</td>
<td> 1</td>
<td>0<br />
</td>
<td>1<br />
</td>
<td>-1<br />
</td>
</tr>
<tr class="odd">
<td> step 4<br />
</td>
<td> 0</td>
<td> 0</td>
<td>1<br />
</td>
<td>0<br />
</td>
<td>1<br />
</td>
</tr>
<tr class="even">
<td> step 5<br />
</td>
<td> 0.5</td>
<td> 0</td>
<td>0<br />
</td>
<td>1<br />
</td>
<td>0<br />
</td>
</tr>
</tbody>
</table>
<p><br />
</p>
<p>The next Csound example represents the content of the buffer in a function table, implements and executes the algorithm, and prints the result after each five steps which here is referred to as one cycle:</p>
<p><em><strong>EXAMPLE 04G04.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-n
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

  opcode KS, 0, ii
  ;performs the karplus-strong algorithm
iTab, iTbSiz xin
;calculate the mean of the last two values
iUlt      tab_i     iTbSiz-1, iTab
iPenUlt   tab_i     iTbSiz-2, iTab
iNewVal   =         (iUlt + iPenUlt) / 2
;shift values one position to the right
indx      =         iTbSiz-2
loop:
iVal      tab_i     indx, iTab
          tabw_i    iVal, indx+1, iTab
          loop_ge   indx, 1, 0, loop
;fill the new value at the beginning of the table
          tabw_i    iNewVal, 0, iTab
  endop

  opcode PrintTab, 0, iiS
  ;prints table content, with a starting string
iTab, iTbSiz, Sout xin
indx      =         0
loop:
iVal      tab_i     indx, iTab
Snew      sprintf   &quot;%8.3f&quot;, iVal
Sout      strcat    Sout, Snew
          loop_lt   indx, 1, iTbSiz, loop
          puts      Sout, 1
  endop

instr ShowBuffer
;fill the function table
iTab      ftgen     0, 0, -5, -2, 1, -1, 1, 1, -1
iTbLen    tableng   iTab
;loop cycles (five states)
iCycle    =         0
cycle:
Scycle    sprintf   &quot;Cycle %d:&quot;, iCycle
          PrintTab  iTab, iTbLen, Scycle
;loop states
iState    =         0
state:
          KS        iTab, iTbLen
          loop_lt   iState, 1, iTbLen, state
          loop_lt   iCycle, 1, 10, cycle
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i &quot;ShowBuffer&quot; 0 1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This is the output:<br />
</p>
<pre><code>Cycle 0:   1.000  -1.000   1.000   1.000  -1.000
Cycle 1:   0.500   0.000   0.000   1.000   0.000
Cycle 2:   0.500   0.250   0.000   0.500   0.500
Cycle 3:   0.500   0.375   0.125   0.250   0.500
Cycle 4:   0.438   0.438   0.250   0.188   0.375
Cycle 5:   0.359   0.438   0.344   0.219   0.281
Cycle 6:   0.305   0.398   0.391   0.281   0.250
Cycle 7:   0.285   0.352   0.395   0.336   0.266
Cycle 8:   0.293   0.318   0.373   0.365   0.301
Cycle 9:   0.313   0.306   0.346   0.369   0.333</code></pre>
<p>It can be seen clearly that the values get smoothed more and more from cycle to cycle. As the buffer size is very small here, the values tend to come to a constant level; in this case 0.333. But for larger buffer sizes, after some cycles the buffer content has the effect of a period which is repeated with a slight loss of amplitude. This is how it sounds, if the buffer size is 1/100 second (or 441 samples at sr=44100):  </p>
<p><em><strong>EXAMPLE 04G05.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps =  1
nchnls = 2
0dbfs = 1

instr 1
;delay time
iDelTm    =         0.01
;fill the delay line with either -1 or 1 randomly
kDur      timeinsts
 if kDur &lt; iDelTm then
aFill     rand      1, 2, 1, 1 ;values 0-2
aFill     =         floor(aFill)*2 - 1 ;just -1 or +1
          else
aFill     =         0
 endif
;delay and feedback
aUlt      init      0 ;last sample in the delay line
aUlt1     init      0 ;delayed by one sample
aMean     =         (aUlt+aUlt1)/2 ;mean of these two
aUlt      delay     aFill+aMean, iDelTm
aUlt1     delay1    aUlt
          outs      aUlt, aUlt
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 60
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz, after martin neukom</code></pre>
<p>This sound resembles a plucked string: at the beginning the sound is noisy but after a short period of time it exhibits periodicity. As can be heard, unless a natural string, the steady state is virtually endless, so for practical use it needs some fade-out. The frequency the listener perceives is related to the length of the delay line. If the delay line is 1/100 of a second, the perceived frequency is 100 Hz. Compared with a sine wave of similar frequency, the inherent periodicity can be seen, and also the rich overtone structure:</p>
<p><img src="static/04G05Auda.png" /></p>
<p>Csound also contains over forty opcodes which provide a wide variety of ready-made physical models and emulations. A small number of them will be introduced here to give a brief overview of the sort of things available.</p>
<h2>wgbow - A Waveguide Emulation of a Bowed String by Perry Cook<br />
</h2>
<p>Perry Cook is a prolific author of physical models and a lot of his work has been converted into Csound opcodes. A number of these models <a href="http://www.csounds.com/manual/html/wgbow.html">wgbow</a>, <a href="http://www.csounds.com/manual/html/wgflute.html">wgflute</a>, <a href="http://www.csounds.com/manual/html/wgclar.html">wgclar</a> <a href="http://www.csounds.com/manual/html/wgbowedbar.html">wgbowedbar</a> and <a href="http://www.csounds.com/manual/html/wgbrass.html">wgbrass</a> are based on waveguides. A waveguide, in its broadest sense, is some sort of mechanism that limits the extend of oscillations, such as a vibrating string fixed at both ends or a pipe. In these sorts of physical model a delay is used to emulate these limits. One of these, <a href="http://www.csounds.com/manual/html/wgbow.html">wgbow</a>, implements an emulation of a bowed string. Perhaps the most interesting aspect of many physical models in not specifically whether they emulate the target instrument played in a conventional way accurately but the facilities they provide for extending the physical limits of the instrument and how it is played - there are already vast sample libraries and software samplers for emulating conventional instruments played conventionally. <a href="http://www.csounds.com/manual/html/wgbow.html">wgbow</a> offers several interesting options for experimentation including the ability to modulate the bow pressure and the bowing position at k-rate. Varying bow pressure will change the tone of the sound produced by changing the harmonic emphasis. As bow pressure reduces, the fundamental of the tone becomes weaker and overtones become more prominent. If the bow pressure is reduced further the abilty of the system to produce a resonance at all collapse. This boundary between tone production and the inability to produce a tone can provide some interesting new sound effect. The following example explores this sound area by modulating the bow pressure parameter around this threshold. Some additional features to enhance the example are that 7 different notes are played simultaneously, the bow pressure modulations in the right channel are delayed by a varying amount with respect top the left channel in order to create a stereo effect and a reverb has been added.</p>
<p><em><strong>EXAMPLE 04G06.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;

sr      =       44100
ksmps   =       32
nchnls  =       2
0dbfs   =       1
        seed    0

gisine  ftgen	0,0,4096,10,1

gaSendL,gaSendR init 0

 instr 1 ; wgbow instrument
kamp     =        0.3
kfreq    =        p4
ipres1   =        p5
ipres2   =        p6
; kpres (bow pressure) defined using a random spline
kpres    rspline  p5,p6,0.5,2
krat     =        0.127236
kvibf    =        4.5
kvibamp  =        0
iminfreq =        20
; call the wgbow opcode
aSigL	 wgbow    kamp,kfreq,kpres,krat,kvibf,kvibamp,gisine,iminfreq
; modulating delay time
kdel     rspline  0.01,0.1,0.1,0.5
; bow pressure parameter delayed by a varying time in the right channel
kpres    vdel_k   kpres,kdel,0.2,2
aSigR	 wgbow	  kamp,kfreq,kpres,krat,kvibf,kvibamp,gisine,iminfreq
         outs     aSigL,aSigR
; send some audio to the reverb
gaSendL  =        gaSendL + aSigL/3
gaSendR  =        gaSendR + aSigR/3
 endin

 instr 2 ; reverb
aRvbL,aRvbR reverbsc gaSendL,gaSendR,0.9,7000
            outs     aRvbL,aRvbR
            clear    gaSendL,gaSendR
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; instr. 1
;  p4 = pitch (hz.)
;  p5 = minimum bow pressure
;  p6 = maximum bow pressure
; 7 notes played by the wgbow instrument
i 1  0 480  70 0.03 0.1
i 1  0 480  85 0.03 0.1
i 1  0 480 100 0.03 0.09
i 1  0 480 135 0.03 0.09
i 1  0 480 170 0.02 0.09
i 1  0 480 202 0.04 0.1
i 1  0 480 233 0.05 0.11
; reverb instrument
i 2 0 480
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This time a stack of eight sustaining notes, each separated by an octave, vary their 'bowing position' randomly and independently. You will hear how different bowing positions accentuates and attenuates different partials of the bowing tone. To enhance the sound produced some filtering with <a href="http://www.csounds.com/manual/html/tone.html">tone</a> and <a href="http://www.csounds.com/manual/html/pareq.html">pareq</a> is employed and some reverb is added.</p>
<p><em><strong>EXAMPLE 04G07.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;

sr      =       44100
ksmps   =       32
nchnls  =       2
0dbfs   =       1
        seed    0

gisine  ftgen	0,0,4096,10,1

gaSend init 0

 instr 1 ; wgbow instrument
kamp     =        0.1
kfreq    =        p4
kpres    =        0.2
krat     rspline  0.006,0.988,0.1,0.4
kvibf    =        4.5
kvibamp  =        0
iminfreq =        20
aSig	 wgbow    kamp,kfreq,kpres,krat,kvibf,kvibamp,gisine,iminfreq
aSig     butlp     aSig,2000
aSig     pareq    aSig,80,6,0.707
         outs     aSig,aSig
gaSend   =        gaSend + aSig/3
 endin

 instr 2 ; reverb
aRvbL,aRvbR reverbsc gaSend,gaSend,0.9,7000
            outs     aRvbL,aRvbR
            clear    gaSend
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; instr. 1 (wgbow instrument)
;  p4 = pitch (hertz)
; wgbow instrument
i 1  0 480  20
i 1  0 480  40
i 1  0 480  80
i 1  0 480  160
i 1  0 480  320
i 1  0 480  640
i 1  0 480  1280
i 1  0 480  2460
; reverb instrument
i 2 0 480
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt; </code></pre>
<p>All of the wg- family of opcodes are worth exploring and often the approach taken here - exploring each input parameter in isolation whilst the others retain constant values - sets the path to understanding the model better. Tone production with <a href="http://www.csounds.com/manual/html/wgbrass.html">wgbrass</a> is very much dependent upon the relationship between intended pitch and lip tension, random experimentation with this opcode is as likely to result in silence as it is in sound and in this way is perhaps a reflection of the experience of learning a brass instrument when the student spends most time push air silently through the instrument. With patience it is capable of some interesting sounds however. In its case, I would recommend building a realtime GUI and exploring the interaction of its input arguments that way. <a href="http://www.csounds.com/manual/html/wgbowedbar.html">wgbowedbar</a>, like a number of physical modelling algorithms, is rather unstable. This is not necessary a design flaw in the algorithm but instead perhaps an indication that the algorithm has been left quite open for out experimentation - or abuse. In these situation caution is advised in order to protect ears and loudspeakers. Positive feedback within the model can result in signals of enormous amplitude very quickly. Employment of the <a href="http://www.csounds.com/manual/html/clip.html">clip</a> opcode as a means of some protection is recommended when experimenting in realtime.<br />
</p>
<h2>barmodel - a Model of a Struck Metal Bar by Stefan Bilbao</h2>
<p><a href="http://www.csounds.com/manual/html/barmodel.html">barmodel</a> can also imitate wooden bars, tubular bells, chimes and other resonant inharmonic objects. <a href="http://www.csounds.com/manual/html/barmodel.html">barmodel</a> is a model that can easily be abused to produce ear shreddingly loud sounds therefore precautions are advised when experimenting with it in realtime. We are presented with a wealth of input arguments such as 'stiffness', 'strike position' and 'strike velocity', which relate in an easily understandable way to the physical process we are emulating. Some parameters will evidently have more of a dramatic effect on the sound produced than other and again it is recommended to create a realtime GUI for exploration. Nonetheless, a fixed example is provided below that should offer some insight into the kinds of sounds possible.</p>
<p>Probably the most important parameter for us is the stiffness of the bar. This actually provides us with our pitch control and is not in cycle-per-second so some experimentation will be required to find a desired pitch. There is a relationship between stiffness and the parameter used to define the width of the strike - when the stiffness coefficient is higher a wider strike may be required in order for the note to sound. Strike width also impacts upon the tone produced, narrower strikes generating emphasis upon upper partials (provided a tone is still produced) whilst wider strikes tend to emphasize the fundamental).<br />
</p>
<p>The parameter for strike position also has some impact upon the spectral balance. This effect may be more subtle and may be dependent upon some other parameter settings, for example, when strike width is particularly wide, its effect may be imperceptible. A general rule of thumb here is that is that in order to achieve the greatest effect from strike position, strike width should be as low as will still produce a tone. This kind of interdependency between input parameters is the essence of working with a physical model that can be both intriguing and frustrating.</p>
<p>An important parameter that will vary the impression of the bar from metal to wood is<br />
</p>
<p>An interesting feature incorporated into the model in the ability to modulate the point along the bar at which vibrations are read. This could also be described as pick-up position. Moving this scanning location results in tonal and amplitude variations. We just have control over the frequency at which the scanning location is modulated.</p>
<p><em><strong>EXAMPLE 04G07.csd<span id="ch030_g-physical-modelling.xhtml#InsertNoteID_19_marker20" class="InsertNoteMarker"><sup><a href="g-physical-modelling#InsertNoteID_19">4</a></sup></span> </strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr     = 44100
ksmps  = 32
nchnls = 2
0dbfs  = 1

 instr   1
; boundary conditions 1=fixed 2=pivot 3=free
kbcL    =               1
kbcR    =               1
; stiffness
iK      =               p4
; high freq. loss (damping)
ib      =               p5
; scanning frequency
kscan   rspline         p6,p7,0.2,0.8
; time to reach 30db decay
iT30    =               p3
; strike position
ipos    random          0,1
; strike velocity
ivel    =               1000
; width of strike
iwid    =               0.1156
aSig    barmodel        kbcL,kbcR,iK,ib,kscan,iT30,ipos,ivel,iwid
kPan	rspline	        0.1,0.9,0.5,2
aL,aR   pan2            aSig,kPan
	outs             aL,aR
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;t 0 90 1 30 2 60 5 90 7 30
; p4 = stiffness (pitch)

#define gliss(dur&#39;Kstrt&#39;Kend&#39;b&#39;scan1&#39;scan2)
#
i 1 0     20 $Kstrt $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur &gt;     $b $scan1 $scan2
i 1 ^+0.05 $dur $Kend $b $scan1 $scan2
#
$gliss(15&#39;40&#39;400&#39;0.0755&#39;0.1&#39;2)
b 5
$gliss(2&#39;80&#39;800&#39;0.755&#39;0&#39;0.1)
b 10
$gliss(3&#39;10&#39;100&#39;0.1&#39;0&#39;0)
b 15
$gliss(40&#39;40&#39;433&#39;0&#39;0.2&#39;5)
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; example written by Iain McCurdy</code></pre>
<h2>PhISEM - Physically Inspired Stochastic Event Modeling</h2>
<p>The PhiSEM set of models in Csound, again based on the work of Perry Cook, imitate instruments that rely on collisions between smaller sound producing object to produce their sounds. These models include a <a href="http://www.csounds.com/manual/html/tambourine.html">tambourine</a>, a set of <a href="http://www.csounds.com/manual/html/bamboo.html">bamboo</a> windchimes and <a href="http://www.csounds.com/manual/html/sleighbells.html">sleighbells.</a> These models algorithmically mimic these multiple collisions internally so that we only need to define elements such as the number of internal elements (timbrels, beans, bells etc.) internal damping and resonances. Once again the most interesting aspect of working with a model is to stretch the physical limits so that we can hear the results from, for example, a maraca with an impossible number of beans, a tambourine with so little internal damping that it never decays. In the following example I explore <a href="http://www.csounds.com/manual/html/tambourine.html">tambourine</a>, <a href="http://www.csounds.com/manual/html/bamboo.html">bamboo</a> and <a href="http://www.csounds.com/manual/html/sleighbells.html">sleighbells</a> each in turn, first in a state that mimics the source instrument and then with some more extreme conditions.</p>
<p><em><strong>EXAMPLE 04G08.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;

sr     = 44100
ksmps  = 32
nchnls = 1
0dbfs  = 1

 instr	1 ; tambourine
iAmp      =           p4
iDettack  =           0.01
iNum      =           p5
iDamp     =           p6
iMaxShake =           0
iFreq     =           p7
iFreq1    =           p8
iFreq2    =           p9
aSig      tambourine  iAmp,iDettack,iNum,iDamp,iMaxShake,iFreq,iFreq1,iFreq2
          out         aSig
 endin

 instr	2 ; bamboo
iAmp      =           p4
iDettack  =           0.01
iNum      =           p5
iDamp     =           p6
iMaxShake =           0
iFreq     =           p7
iFreq1    =           p8
iFreq2    =           p9
aSig      bamboo      iAmp,iDettack,iNum,iDamp,iMaxShake,iFreq,iFreq1,iFreq2
          out         aSig
 endin

 instr	3 ; sleighbells
iAmp      =           p4
iDettack  =           0.01
iNum      =           p5
iDamp     =           p6
iMaxShake =           0
iFreq     =           p7
iFreq1    =           p8
iFreq2    =           p9
aSig      sleighbells iAmp,iDettack,iNum,iDamp,iMaxShake,iFreq,iFreq1,iFreq2
          out         aSig
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; p4 = amp.
; p5 = number of timbrels
; p6 = damping
; p7 = freq (main)
; p8 = freq 1
; p9 = freq 2

; tambourine
i 1 0 1 0.1  32 0.47 2300 5600 8100
i 1 + 1 0.1  32 0.47 2300 5600 8100
i 1 + 2 0.1  32 0.75 2300 5600 8100
i 1 + 2 0.05  2 0.75 2300 5600 8100
i 1 + 1 0.1  16 0.65 2000 4000 8000
i 1 + 1 0.1  16 0.65 1000 2000 3000
i 1 8 2 0.01  1 0.75 1257 2653 6245
i 1 8 2 0.01  1 0.75  673 3256 9102
i 1 8 2 0.01  1 0.75  314 1629 4756

b 10

; bamboo
i 2 0 1 0.4 1.25 0.0  2800 2240 3360
i 2 + 1 0.4 1.25 0.0  2800 2240 3360
i 2 + 2 0.4 1.25 0.05 2800 2240 3360
i 2 + 2 0.2   10 0.05 2800 2240 3360
i 2 + 1 0.3   16 0.01 2000 4000 8000
i 2 + 1 0.3   16 0.01 1000 2000 3000
i 2 8 2 0.1    1 0.05 1257 2653 6245
i 2 8 2 0.1    1 0.05 1073 3256 8102
i 2 8 2 0.1    1 0.05  514 6629 9756

b 20

; sleighbells
i 3 0 1 0.7 1.25 0.17 2500 5300 6500
i 3 + 1 0.7 1.25 0.17 2500 5300 6500
i 3 + 2 0.7 1.25 0.3  2500 5300 6500
i 3 + 2 0.4   10 0.3  2500 5300 6500
i 3 + 1 0.5   16 0.2  2000 4000 8000
i 3 + 1 0.5   16 0.2  1000 2000 3000
i 3 8 2 0.3    1 0.3  1257 2653 6245
i 3 8 2 0.3    1 0.3  1073 3256 8102
i 3 8 2 0.3    1 0.3   514 6629 9756
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;
; example written by Iain McCurdy</code></pre>
<p>Physical modelling can produce rich, spectrally dynamic sounds with user manipulation usually abstracted to a small number of descriptive parameters. Csound offers a wealth of other opcodes for physical modelling which cannot all be introduced here so the user is encouraged to explore based on the approaches exemplified here. You can find lists in the chapters <a href="http://www.csounds.com/manual/html/SiggenModels.html">Models and Emulations</a>, <a href="http://www.csounds.com/manual/html/SiggenScanTop.html">Scanned Synthesis</a> and <a href="http://www.csounds.com/manual/html/SiggenWavguide.html">Waveguide Physical Modeling</a> of the Csound Manual.<br />
</p>
<p> </p>
<h2><br />
</h2>
<ol>
<li><span id="ch030_g-physical-modelling.xhtml#InsertNoteID_6">The explanation here follows chapter 8.1.1 of Martin Neukom's <em>Signale Systeme Klangsynthese</em> (Bern 2003)<span id="ch030_g-physical-modelling.xhtml#InsertNoteID_6_LinkBacks"><sup><a href="g-physical-modelling#InsertNoteID_6_marker7">^</a></sup></span></span></li>
<li><span id="ch030_g-physical-modelling.xhtml#InsertNoteID_18">See chapter 03A INITIALIZATION AND PERFORMANCE PASS for more information about Csound's performance loops.<span id="ch030_g-physical-modelling.xhtml#InsertNoteID_18_LinkBacks"><sup><a href="g-physical-modelling#InsertNoteID_18_marker19">^</a></sup></span></span></li>
<li><span id="ch030_g-physical-modelling.xhtml#InsertNoteID_20">If defining this as a UDO, a local ksmps=1 could be set without affecting the general ksmps. See chapter 03F USER DEFINED OPCODES and the Csound Manual for <a href="http://www.csounds.com/manual/html/setksmps.html">setksmps</a> for more information.<span id="ch030_g-physical-modelling.xhtml#InsertNoteID_20_LinkBacks"><sup><a href="g-physical-modelling#InsertNoteID_20_marker21">^</a></sup></span></span></li>
<li><span id="ch030_g-physical-modelling.xhtml#InsertNoteID_19">See chapter 03G MACROS about the use of macros in the score.<span id="ch030_g-physical-modelling.xhtml#InsertNoteID_19_LinkBacks"><sup><a href="g-physical-modelling#InsertNoteID_19_marker20">^</a></sup></span></span></li>
</ol>
<p><span id="ch032_a-envelopes.xhtml"></span></p>
<h1>ENVELOPES</h1>
<p>Envelopes are used to define how a value changes over time. In early synthesizers, envelopes were used to define the changes in amplitude in a sound across its duration thereby imbuing sounds characteristics such as 'percussive', or 'sustaining'. Of course envelopes can be applied to any parameter and not just amplitude.</p>
<p>Csound offers a wide array of opcodes for generating envelopes including ones which emulate the classic ADSR (attack-decay-sustain-release) envelopes found on hardware and commercial software synthesizers. A selection of these opcodes, which represent the basic types, shall be introduced here</p>
<p>The simplest opcode for defining an envelope is <a href="http://www.csounds.com/manual/html/line.html">line</a><span>. </span><em>line</em><span> describes a single envelope segment as a straight line between a start value and an end value which has a given duration.</span></p>
<pre><code>ares line ia, idur, ib
kres line ia, idur, ib</code></pre>
<p><span>In the following example </span><em>line</em><span> is used to create a simple envelope which is then used as the amplitude control of a </span><em>poscil</em><span> oscillator. This envelope starts with a value of 0.5 then over the course of 2 seconds descends in linear fashion to zero.</span></p>
<p><strong>   <em>EXAMPLE 05A01.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1 ; a sine wave

  instr 1
aEnv     line     0.5, 2, 0         ; amplitude envelope
aSig     poscil   aEnv, 500, giSine ; audio oscillator
         out      aSig              ; audio sent to output
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 2 ; instrument 1 plays a note for 2 seconds
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The envelope in the above example assumes that all notes played by this instrument will be 2 seconds long. In practice it is often beneficial to relate the duration of the envelope to the duration of the note (p3) in some way. In the next example the duration of the envelope is replaced with the value of p3 retrieved from the score, whatever that may be. The envelope will be stretched or contracted accordingly.</p>
<p><strong>   <em>EXAMPLE 05A02.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ;activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1 ; a sine wave

  instr 1
; A single segment envelope. Time value defined by note duration.
aEnv     line     0.5, p3, 0
aSig     poscil   aEnv, 500, giSine ; an audio oscillator
         out      aSig              ; audio sent to output
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
; p1 p2  p3
i 1  0    1
i 1  2  0.2
i 1  3    4
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>It may not be disastrous if a envelope's duration does not match p3 and indeed there are many occasions when we want an envelope duration to be independent of p3 but we need to remain aware that if p3 is shorter than an envelope's duration then that envelope will be truncated before it is allowed to complete and if p3 is longer than an envelope's duration then the envelope will complete before the note ends (the consequences of this latter situation will be looked at in more detail later on in this section).</p>
<p><em>line</em> <span>(and most of Csound's envelope generators) can output either k or a-rate variables. k-rate envelopes are computationally cheaper than a-rate envelopes but in envelopes with fast moving segments quantization can occur if they output a k-rate variable, particularly when the control rate is low, which in the case of amplitude envelopes can lead to clicking artefacts or distortion.</span></p>
<p><a href="http://www.csounds.com/manual/html/linseg.html">linseg</a><span> is an elaboration of </span><em>line</em><span> and allows us to add an arbitrary number of segments by adding further pairs of time durations followed envelope values. Provided we always end with a value and not a duration we can make this envelope as long as we like.</span></p>
<p><span>In the next example a more complex amplitude envelope is employed by using the </span><em>linseg</em><span> opcode. This envelope is also note duration (p3) dependent but in a more elaborate way. A attack-decay stage is defined using explicitly declared time durations. A release stage is also defined with an explicitly declared duration. The sustain stage is the p3 dependent stage but to ensure that the duration of the entire envelope still adds up to p3, the explicitly defined durations of the attack, decay and release stages are subtracted from the p3 dependent sustain stage duration. For this envelope to function correctly it is important that p3 is not less than the sum of all explicitly defined envelope segment durations. If necessary, additional code could be employed to circumvent this from happening.</span></p>
<p><strong>   <em>EXAMPLE 05A03.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1 ; a sine wave

  instr 1
; a more complex amplitude envelope:
;                 |-attack-|-decay--|---sustain---|-release-|
aEnv     linseg   0, 0.01, 1, 0.1, 0.1, p3-0.21, 0.1, 0.1, 0
aSig     poscil   aEnv, 500, giSine
         out      aSig
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 1
i 1 2 5
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The next example illustrates an approach that can be taken whenever it is required that more than one envelope segment duration be p3 dependent. This time each segment is a fraction of p3. The sum of all segments still adds up to p3 so the envelope will complete across the duration of each each note regardless of duration.</p>
<p><strong>   <em>EXAMPLE 05A04.csd</em> </strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ;activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1; a sine wave

  instr 1
aEnv     linseg   0, p3*0.5, 1, p3*0.5, 0 ; rising then falling envelope
aSig     poscil   aEnv, 500, giSine
         out      aSig
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; 3 notes of different durations are played
i 1 0   1
i 1 2 0.1
i 1 3   5
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span>The next example highlights an important difference in the behaviours of </span><em>line</em><span> and </span><em>linseg</em><span> when p3 exceeds the duration of an envelope.</span></p>
<p><span>When a note continues beyond the end of the final value of a </span><em>linseg</em><span> defined envelope the final value of that envelope is held. A </span><em>line</em><span> defined envelope behaves differently in that instead of holding its final value it continues in a trajectory defined by the last segment.</span></p>
<p><span>This difference is illustrated in the following example. The </span><em>linseg</em><span> and </span><em>line</em> <span>envelopes of instruments 1 and 2 appear to be the same but the difference in their behaviour as described above when they continue beyond the end of their final segment is clear when listening to the example.</span></p>
<p>Note that information given in the Csound Manual in regard to this matter is incorrect at the time of writing.</p>
<p><strong>   <em>EXAMPLE 05A05.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdysr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1 ; a sine wave

  instr 1 ; linseg envelope
aCps     linseg   300, 1, 600       ; linseg holds its last value
aSig     poscil   0.2, aCps, giSine
         out      aSig
  endin

  instr 2 ; line envelope
aCps     line     300, 1, 600       ; line continues its trajectory
aSig     poscil   0.2, aCps, giSine
         out      aSig
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 5 ; linseg envelope
i 2 6 5 ; line envelope
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt; </code></pre>
<p><a href="http://www.csounds.com/manual/html/expon.html">expon</a><span> and </span><a href="http://www.csounds.com/manual/html/expseg.html">expseg</a><span> are versions of </span><em>line</em><span> and </span><em>linseg</em><span> that instead produce envelope segments with concave exponential rather than linear shapes. </span><em>expon</em><span> and </span><em>expseg</em><span> can often be more musically useful for envelopes that define amplitude or frequency as they will reflect the logarithmic nature of how these parameters are perceived. On account of the mathematics that is used to define these curves, we cannot define a value of zero at any node in the envelope and an envelope cannot cross the zero axis. If we require a value of zero we can instead provide a value very close to zero. If we still really need zero we can always subtract the offset value from the entire envelope in a subsequent line of code.</span></p>
<p><span>The following example illustrates the difference between </span><em>line</em><span> and </span><em>expon</em><span> when applied as amplitude envelopes.</span></p>
<p><strong>   <em>EXAMPLE 05A06.csd</em> </strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1 ; a sine wave

  instr 1 ; line envelope
aEnv     line     1, p3, 0
aSig     poscil   aEnv, 500, giSine
         out      aSig
  endin

  instr 2 ; expon envelope
aEnv     expon    1, p3, 0.0001
aSig     poscil   aEnv, 500, giSine
         out      aSig
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 2 ; line envelope
i 2 2 1 ; expon envelope
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt; </code></pre>
<p>The nearer our 'near-zero' values are to zero the quicker the curve will appear to reach 'zero'. In the next example smaller and smaller envelope end values are passed to the expon opcode using p4 values in the score. The percussive 'ping' sounds are perceived to be increasingly short.</p>
<p><strong>   <em>EXAMPLE 05A07.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1 ; a sine wave

  instr 1; expon envelope
iEndVal  =        p4 ; variable &#39;iEndVal&#39; retrieved from score
aEnv     expon    1, p3, iEndVal
aSig     poscil   aEnv, 500, giSine
         out      aSig
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p1  p2 p3 p4
i 1  0  1  0.001
i 1  1  1  0.000001
i 1  2  1  0.000000000000001
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span>Note that </span><em>expseg</em><span> does not behave like linseg in that it will not hold its last final value if p3 exceeds its entire duration, instead it continues its curving trajectory in a manner similar to </span><em>line</em><span> (and </span><em>expon</em><span>). This could have dangerous results if used as an amplitude envelope.</span></p>
<p><span>When dealing with notes with an indefinite duration at the time of initiation (such as midi activated notes or score activated notes with a negative p3 value), we do not have the option of using p3 in a meaningful way. Instead we can use one of Csound's envelopes that sense the ending of a note when it arrives and adjust their behaviour according to this. The opcodes in question are </span><em>linenr, linsegr, expsegr, madsr, mxadsr</em> and <em>envlpxr.</em> <span>These opcodes wait until a held note is turned off before executing their final envelope segment. To facilitate this mechanism they extend the duration of the note so that this final envelope segment can complete.</span></p>
<p><span>The following example uses midi input (either hardware or virtual) to activate notes. The use of the </span><em>linsegr</em><span> envelope means that after the short attack stage lasting 0.1 seconds, the penultimate value of 1 will be held as long as the note is sustained but as soon as the note is released the note will be extended by 0.5 seconds in order to allow the final envelope segment to decay to zero.</span></p>
<p><strong>   <em>EXAMPLE 05A08.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac -+rtmidi=virtual -M0
; activate real time audio and MIDI (virtual midi device)
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1        ; a sine wave

  instr 1
icps     cpsmidi
;                 attack-|sustain-|-release
aEnv     linsegr  0, 0.01,  0.1,     0.5,0 ; envelope that senses note releases
aSig     poscil   aEnv, icps, giSine       ; audio oscillator
         out      aSig                     ; audio sent to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
f 0 240 ; csound performance for 4 minutes
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Sometimes designing our envelope shape in a function table can provide us with shapes that are not possible using Csound's envelope generating opcodes. In this case the envelope can be read from the function table using an oscillator and if the oscillator is given a frequency of 1/p3 then it will read though the envelope just once across the duration of the note.</p>
<p>The following example generates an amplitude envelope which is the shape of the first half of a sine wave.</p>
<p><strong>   <em>EXAMPLE 05A09.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activate real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0, 0, 2^12, 10, 1        ; a sine wave
giEnv    ftgen    0, 0, 2^12, 9, 0.5, 1, 0 ; envelope shape: a half sine

  instr 1
; read the envelope once during the note&#39;s duration:
aEnv     poscil   1, 1/p3, giEnv
aSig     poscil   aEnv, 500, giSine        ; audio oscillator
         out      aSig                     ; audio sent to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; 7 notes, increasingly short
i 1 0 2
i 1 2 1
i 1 3 0.5
i 1 4 0.25
i 1 5 0.125
i 1 6 0.0625
i 1 7 0.03125
f 0 7.1
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>lpshold, loopseg and looptseg - A Csound TB303<br />
</h2>
<p>The next example introduces three of Csound's looping opcodes, <a href="http://www.csounds.com/manual/html/lpshold.html">lpshold</a>, <a href="http://www.csounds.com/manual/html/loopseg.html">loopseg</a>and <a href="http://www.csounds.com/manual/html/looptseg.html">looptseg</a><em>.</em></p>
<p>These opcodes generate envelopes which are looped at a rate corresponding to a defined frequency. What they each do could also be accomplished using the 'envelope from table' technique outlined in an earlier example but these opcodes provides the added convenience of encapsulating all the required code in one line without the need of any function tables. Furthermore all of the input arguments for these opcodes can be modulated at k-rate.</p>
<p><em>lpshold</em><span> generates an envelope with in which each break point is held constant until a new break point is encountered. The resulting envelope will contain horizontal line segments. In our example this opcode will be used to generate a looping bassline in the fashion of a Roland TB303. Because the duration of the entire envelope is wholly dependent upon the frequency with which the envelope repeats - in fact it is the reciprocal – values for the durations of individual envelope segments are defining times in seconds but represent proportions of the entire envelope duration. The values given for all these segments do not need to add up to any specific value as Csound rescales the proportionality according to the sum of all segment durations. You might find it convenient to contrive to have them all add up to 1, or to 100 – either is equally valid. The other looping envelope opcodes discussed here use the same method for defining segment durations.</span></p>
<p><em>loopseg</em> <span>allows us to define a looping envelope with linear segements. In this example it is used to define the amplitude envelope of each individual note. Take note that whereas the </span><em>lpshold</em><span> envelope used to define the pitches of the melody repeats once per phrase the amplitude envelope repeats once for each note of the melody therefore its frequency is 16 times that of the melody envelope (there are 16 notes in our melodic phrase).</span></p>
<p><em>looptseg</em> <span>is an elaboration of </span><em>loopseg</em><span> in that is allows us to define the shape of each segment individually whether that be convex, linear of concave. This aspect is defined using the 'type' parameters. A 'type' value of 0 denotes a linear segement, a positive value denotes a convex segment with higher positive values resulting in increasingly convex curves. Negative values denote concave segments with increasing negative values resulting in increasingly concave curves. In this example </span><em>looptseg</em><span> is used to define a filter envelope which, like the amplitude envelope, repeats for every note. The addition of the 'type' parameter allows us to modulate the sharpness of the decay of the filter envelope. This is a crucial element of the TB303 design. Note that </span><em>looptseg</em><span> is only available in Csound 5.12 or later. </span></p>
<p><span>Other crucial features of this instrument such as 'note on/off' and 'hold' for each step are also implemented using </span><em>lpshold</em><span>.</span></p>
<p><span>A number of the input parameters of this example are modulated automatically using the </span><a href="http://www.csounds.com/manual/html/randomi.html">randomi</a><span> opcodes in order to keep it interesting. It is suggested that these modulations could be replaced by linkages to other controls such as QuteCsound widgets, FLTK widgets or MIDI controllers. Suggested ranges for each of these values are given in the .csd.</span></p>
<p><strong>  <em>EXAMPLE 05A10.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac ;activates real time sound output
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 4
nchnls = 1
0dbfs = 1

seed 0; seed random number generators from system clock

  instr 1; Bassline instrument
kTempo    =            90          ; tempo in beats per minute
kCfBase   randomi      1,4, 0.2    ; base filter frequency (oct format)
kCfEnv    randomi      0,4,0.2     ; filter envelope depth
kRes      randomi      0.5,0.9,0.2 ; filter resonance
kVol      =            0.5         ; volume control
kDecay    randomi      -10,10,0.2  ; decay shape of the filter.
kWaveform =            0           ; oscillator waveform. 0=sawtooth 2=square
kDist     randomi      0,1,0.1     ; amount of distortion
kPhFreq   =            kTempo/240  ; freq. to repeat the entire phrase
kBtFreq   =            (kTempo)/15 ; frequency of each 1/16th note
; -- Envelopes with held segments  --
; The first value of each pair defines the relative duration of that segment,
; the second, the value itself.
; Note numbers (kNum) are defined as MIDI note numbers.
; Note On/Off (kOn) and hold (kHold) are defined as on/off switches, 1 or zero
;                    note:1      2     3     4     5     6     7     8
;                         9     10    11    12    13    14    15    16    0
kNum  lpshold kPhFreq, 0, 0,40,  1,42, 1,50, 1,49, 1,60, 1,54, 1,39, 1,40, \
                       1,46, 1,36, 1,40, 1,46, 1,50, 1,56, 1,44, 1,47,1,45
kOn   lpshold kPhFreq, 0, 0,1,   1,1,  1,1,  1,1,  1,1,  1,1,  1,0,  1,1,  \
                       1,1,  1,1,  1,1,  1,1,  1,1,  1,1,  1,0,  1,1,  1,1
kHold lpshold kPhFreq, 0, 0,0,   1,1,  1,1,  1,0,  1,0,  1,0,  1,0,  1,1,  \
                       1,0,  1,0,  1,1,  1,1,  1,1,  1,1,  1,0,  1,0,  1,0
kHold     vdel_k       kHold, 1/kBtFreq, 1 ; offset hold by 1/2 note duration
kNum      portk        kNum, (0.01*kHold)  ; apply portamento to pitch changes
                                           ; if note is not held: no portamento
kCps      =            cpsmidinn(kNum)     ; convert note number to cps
kOct      =            octcps(kCps)        ; convert cps to oct format
; amplitude envelope                  attack    sustain       decay  gap
kAmpEnv   loopseg      kBtFreq, 0, 0, 0,0.1, 1, 55/kTempo, 1, 0.1,0, 5/kTempo,0
kAmpEnv   =            (kHold=0?kAmpEnv:1)  ; if a held note, ignore envelope
kAmpEnv   port         kAmpEnv,0.001

; filter envelope
kCfOct    looptseg      kBtFreq,0,0,kCfBase+kCfEnv+kOct,kDecay,1,kCfBase+kOct
; if hold is off, use filter envelope, otherwise use steady state value:
kCfOct    =             (kHold=0?kCfOct:kCfBase+kOct)
kCfOct    limit        kCfOct, 4, 14 ; limit the cutoff frequency (oct format)
aSig      vco2         0.4, kCps, i(kWaveform)*2, 0.5 ; VCO-style oscillator
aFilt      lpf18        aSig, cpsoct(kCfOct), kRes, (kDist^2)*10 ; filter audio
aSig      balance       aFilt,aSig             ; balance levels
kOn       port         kOn, 0.006              ; smooth on/off switching
; audio sent to output, apply amp. envelope,
; volume control and note On/Off status
          out          aSig * kAmpEnv * kVol * kOn
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3600 ; instr 1 plays for 1 hour
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span id="ch033_b-panning-and-spatialization.xhtml"></span></p>
<h1>PANNING AND SPATIALIZATION</h1>
<h2>Simple Stereo Panning </h2>
<p>Csound provides a large number of opcodes designed to assist in the distribution of sound amongst two or more speakers. These range from opcodes that merely balance a sound between two channel to ones that include algorithms to simulate the doppler shift that occurs when sound moves, algorithms that simulate the filtering and inter-aural delay that occurs as sound reaches both our ears and algorithms that simulate distance in an acoustic space.</p>
<p>First we will look at some 'first principles' methods of panning a sound between two speakers.</p>
<p>The simplest method that is typically encountered is to multiply one channel of audio (aSig) by a panning variable (kPan) and to multiply the other side by 1 minus the same variable like this:</p>
<pre><code>aSigL  =  aSig * kPan
aSigR  =  aSig * (1 – kPan)
          outs aSigL, aSigR</code></pre>
<p>where kPan is within the range zero to 1. If kPan is 1 all the signal will be in the left channel, if it is zero all the signal will be in the right channel and if it is 0.5 there will be signal of equal amplitide in both the left and the right channels. This way the signal can be continuously panned between the left and right channels.</p>
<p>The problem with this method is that the overall power drops as the sound is panned to the middle.</p>
<p>One possible solution to this problem is to take the square root of the panning variable for each channel before multiplying it to the audio signal like this:</p>
<pre><code>aSigL  =     aSig * sqrt(kPan)
aSigR  =     aSig * sqrt((1 – kPan))
       outs  aSigL, aSigR</code></pre>
<p>By doing this, the straight line function of the input panning variable becomes a convex curve so that less power is lost as the sound is panned centrally.</p>
<p>Using 90º sections of a sine wave for the mapping produces a more convex curve and a less immediate drop in power as the sound is panned away from the extremities. This can be implemented using the code shown below.</p>
<pre><code>aSigL  =     aSig * sin(kPan*$M_PI_2)
aSigR  =     aSig * cos(kPan*$M_PI_2)
       outs  aSigL, aSigR</code></pre>
<p>(Note that '$M_PI_2' is one of <a href="http://www.csounds.com/manual/html/define.html">Csound's built in macros</a> and is equivalent to pi/2.)</p>
<p>A fourth method, devised by Michael Gogins, places the point of maximum power for each channel slightly before the panning variable reaches its extremity. The result of this is that when the sound is panned dynamically it appears to move beyond the point of the speaker it is addressing. This method is an elaboration of the previous one and makes use of a different 90 degree section of a sine wave. It is implemented using the following code:</p>
<pre><code>aSigL  =     aSig * sin((kPan + 0.5) * $M_PI_2)
aSigR  =     aSig * cos((kPan + 0.5) * $M_PI_2)
       outs  aSigL, aSigR
</code></pre>
<p>The following example demonstrates all three methods one after the other for comparison. Panning movement is controlled by a slow moving LFO. The input sound is filtered pink noise.</p>
<p><strong>   <em>EXAMPLE 05B01.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 10
nchnls = 2
0dbfs = 1

  instr 1
imethod  =         p4; read panning method variable from score (p4)

;---------------- generate a source sound -------------------
a1       pinkish   0.3; pink noise
a1       reson     a1, 500, 30, 1; bandpass filtered
aPan     lfo       0.5, 1, 1; panning controlled by an lfo
aPan     =         aPan + 0.5; offset shifted +0.5
;------------------------------------------------------------

 if imethod=1 then
;------------------------ method 1 --------------------------
aPanL    =         aPan
aPanR    =         1 - aPan
;------------------------------------------------------------
 endif

 if imethod=2 then
;------------------------ method 2 --------------------------
aPanL    =       sqrt(aPan)
aPanR    =       sqrt(1 - aPan)
;------------------------------------------------------------
 endif

 if imethod=3 then
;------------------------ method 3 --------------------------
aPanL    =       sin(aPan*$M_PI_2)
aPanR    =       cos(aPan*$M_PI_2)
;------------------------------------------------------------
 endif

 if imethod=4 then
;------------------------ method 4 --------------------------
aPanL   =  sin ((aPan + 0.5) * $M_PI_2)
aPanR   =  cos ((aPan + 0.5) * $M_PI_2)
;------------------------------------------------------------
 endif

         outs    a1*aPanL, a1*aPanR ; audio sent to outputs
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; 4 notes one after the other to demonstrate 4 different methods of panning
;p1 p2  p3   p4(method)
i 1 0   4.5  1
i 1 5   4.5  2
i 1 10  4.5  3
i 1 15  4.5  4
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p><em></em></p>
<p>An opcode called <a href="http://www.csounds.com/manual/html/pan2.html">pan2</a><span> exist which makes panning slightly easier for us to implement simple panning employing various methods. The following example demonstrates the three methods that this opcode offers one after the other. The first is the 'equal power' method, the second 'square root' and the third is simple linear. The <a href="http://www.csounds.com/manual/html/index.html">Csound Manual</a> alludes to fourth method but this does not seem to function currently.</span></p>
<p><strong>   <em>EXAMPLE 05B02.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 10
nchnls = 2
0dbfs = 1

  instr 1
imethod        =         p4 ; read panning method variable from score (p4)
;----------------------- generate a source sound ------------------------
aSig           pinkish   0.5              ; pink noise
aSig           reson     aSig, 500, 30, 1 ; bandpass filtered
;------------------------------------------------------------------------

;---------------------------- pan the signal ----------------------------
aPan           lfo       0.5, 1, 1        ; panning controlled by an lfo
aPan           =         aPan + 0.5       ; DC shifted + 0.5
aSigL, aSigR   pan2      aSig, aPan, imethod; create stereo panned output
;------------------------------------------------------------------------

               outs      aSigL, aSigR     ; audio sent to outputs
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; 3 notes one after the other to demonstrate 3 methods used by pan2
;p1 p2  p3   p4
i 1  0  4.5   0 ; equal power (harmonic)
i 1  5  4.5   1 ; square root method
i 1 10  4.5   2 ; linear
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt; </code></pre>
<h2>3-d Binaural Encoding </h2>
<p>3-D binaural simulation is availalable in a number of opcodes that make use of spectral data files that provide information about the filtering and inter-aural delay effects of the human head. The older one of these is <a href="http://www.csounds.com/manual/html/hrtfer.html">hrtfer</a>. The newer ones are <a href="http://www.csounds.com/manual/html/hrtfmove.html">hrtfmove</a>, <a href="http://www.csounds.com/manual/html/hrtfmove2.html">hrtfmove2</a> and <a href="http://www.csounds.com/manual/html/hrtfstat.html">hrftstat</a>. The main parameters for controlfor the opcodes are azimuth (where the sound source in the horizontal plane relative to the direction we are facing) and elevation (the angle by which the sound deviates from this horizontal plane, either above or below). Both these parameters are defined in degrees. 'Binaural' infers that the stereo output of this opcode should be listened to using headphones so that no mixing in the air of the two channels occurs before they reach our ears.</p>
<p>The following example take a monophonic source sound of noise impulses and processes it using the <em>hrtfmove2</em> opcode. First of all the sound is rotated around us in the horizontal plane then it is raised above our head then dropped below us and finally returned to be straight and level in front of us.For this example to work you will need to download the files <a href="http://csound.cvs.sourceforge.net/csound/csound5/samples/">hrtf-44100-left.dat</a> and <a href="http://en.flossmanuals.net/bin/view/Csound/hrtf-44100-right.dat">hrtf-44100-right.dat</a> and place them in your SADIR (see <a href="http://www.csounds.com/manual/html/CommandEnvironment.html">setting environment variables</a>) or in the same directory as the .csd.<br />
</p>
<p><strong>   <em>EXAMPLE 05B03.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 10
nchnls = 2
0dbfs = 1

giSine         ftgen       0, 0, 2^12, 10, 1                ; sine wave
giLFOShape     ftgen       0, 0, 131072, 19, 0.5, 1, 180, 1 ; U-shape parabola

  instr 1
; create an audio signal (noise impulses)
krate          oscil       30,0.2,giLFOShape                ; rate of impulses
; amplitude envelope: a repeating pulse
kEnv           loopseg     krate+3,0, 0,1, 0.1,0, 0.9,0
aSig           pinkish     kEnv                             ; noise pulses

; -- apply binaural 3d processing --
; azimuth (direction in the horizontal plane)
kAz            linseg      0, 8, 360
; elevation (held horizontal for 8 seconds then up, then down, then horizontal
kElev          linseg      0, 8,   0, 4, 90, 8, -40, 4, 0
; apply hrtfmove2 opcode to audio source - create stereo ouput
aLeft, aRight  hrtfmove2   aSig, kAz, kElev, \
                                &quot;hrtf-44100-left.dat&quot;,&quot;hrtf-44100-right.dat&quot;
               outs        aLeft, aRight                    ; audio to outputs
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 60 ; instr 1 plays a note for 60 seconds
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span id="ch034_c-filters.xhtml"></span></p>
<h1>FILTERS</h1>
<p>Audio filters can range from devices that subtly shape the tonal characteristics of a sound to ones that dramatically remove whole portions of a sound spectrum to create new sounds. Csound includes several versions of each of the commonest types of filters and some more esoteric ones also. The full list of Csound's standard filters can be found <a href="http://www.csounds.com/manual/html/SigmodStandard.html">here</a>. A list of the more specialized filters can be found <a href="http://www.csounds.com/manual/html/SigmodSpeciali.html">here</a>.<br />
</p>
<h2>Lowpass Filters</h2>
<p>The first type of filter encountered is normally the lowpass filter. As its name suggests it allows lower frequencies to pass through unimpeded and therefore filters higher frequencies. The crossover  frequency is normally referred to as the 'cutoff' frequency. Filters of this type do not really cut frequencies off at the cutoff point like a brick wall but instead attenuate increasingly according to a cutoff slope. Different filters offer cutoff slopes of different of steepness. Another aspect of a lowpass filter that we may be concerned with is a ripple that might emerge at the cutoff point. If this is exaggerated intentionally it is referred to as resonance or 'Q'.<br />
<br />
In the following example, three lowpass filters filters are demonstrated: <a href="http://www.csounds.com/manual/html/tone.html">tone</a>, <a href="http://www.csounds.com/manual/html/butterlp.html">butlp</a> and <a href="http://www.csounds.com/manual/html/moogladder.html">moogladder</a>. <em>tone</em> offers a quite gentle cutoff slope and therefore is better suited to subtle spectral enhancement tasks. <em>butlp</em> is based on the Butterworth filter design and produces a much sharper cutoff slope at the expense of a slightly greater CPU overhead. <em>moogladder</em> is an interpretation of an analogue filter found in a moog synthesizer – it includes a resonance control.<br />
<br />
In the example a sawtooth waveform is played in turn through each filter. Each time the cutoff frequency is modulated using an envelope, starting high and descending low so that more and more of the spectral content of the sound is removed as the note progresses. A sawtooth waveform has been chosen as it contains strong higher frequencies and therefore demonstrates the filters characteristics well; a sine wave would be a poor choice of source sound on account of its lack of spectral richness.<br />
</p>
<p>   <strong><em>EXAMPLE 05C01.csd</em></strong></p>
<h4></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

  instr 1
        prints       &quot;tone%n&quot;    ; indicate filter type in console
aSig    vco2         0.5, 150    ; input signal is a sawtooth waveform
kcf     expon        10000,p3,20 ; descending cutoff frequency
aSig    tone         aSig, kcf   ; filter audio signal
        out          aSig        ; filtered audio sent to output
  endin

  instr 2
        prints       &quot;butlp%n&quot;   ; indicate filter type in console
aSig    vco2         0.5, 150    ; input signal is a sawtooth waveform
kcf     expon        10000,p3,20 ; descending cutoff frequency
aSig    butlp        aSig, kcf   ; filter audio signal
        out          aSig        ; filtered audio sent to output
  endin

  instr 3
        prints       &quot;moogladder%n&quot; ; indicate filter type in console
aSig    vco2         0.5, 150       ; input signal is a sawtooth waveform
kcf     expon        10000,p3,20    ; descending cutoff frequency
aSig    moogladder   aSig, kcf, 0.9 ; filter audio signal
        out          aSig           ; filtered audio sent to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; 3 notes to demonstrate each filter in turn
i 1 0  3; tone
i 2 4  3; butlp
i 3 8  3; moogladder
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Highpass Filters</h2>
<p>A highpass filter is the converse of a lowpass filter; frequencies higher than the cutoff point are allowed to pass whilst those lower are attenuated. <a href="http://www.csounds.com/manual/html/atone.html">atone</a> and <a href="http://www.csounds.com/manual/html/butterhp.html">buthp</a> are the analogues of <em>tone</em> and <em>butlp</em>. Resonant highpass filters are harder to find but Csound has one in <a href="http://www.csounds.com/manual/html/bqrez.html">bqrez</a>. <em>bqrez</em> is actually a multi-mode filter and could also be used as a resonant lowpass filter amongst other things. We can choose which mode we want by setting one of its input arguments appropriately. Resonant highpass is mode 1. In this example a sawtooth waveform is again played through each of the filters in turn but this time the cutoff frequency moves from low to high. Spectral content is increasingly removed but from the opposite spectral direction.<br />
</p>
<p><strong>   <em>EXAMPLE 05C02.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

  instr 1
        prints       &quot;atone%n&quot;     ; indicate filter type in console
aSig    vco2         0.2, 150      ; input signal is a sawtooth waveform
kcf     expon        20, p3, 20000 ; define envelope for cutoff frequency
aSig    atone        aSig, kcf     ; filter audio signal
        out          aSig          ; filtered audio sent to output
  endin

  instr 2
        prints       &quot;buthp%n&quot;     ; indicate filter type in console
aSig    vco2         0.2, 150      ; input signal is a sawtooth waveform
kcf     expon        20, p3, 20000 ; define envelope for cutoff frequency
aSig    buthp        aSig, kcf     ; filter audio signal
        out          aSig          ; filtered audio sent to output
  endin

  instr 3
        prints       &quot;bqrez(mode:1)%n&quot; ; indicate filter type in console
aSig    vco2         0.03, 150         ; input signal is a sawtooth waveform
kcf     expon        20, p3, 20000     ; define envelope for cutoff frequency
aSig    bqrez        aSig, kcf, 30, 1  ; filter audio signal
        out          aSig              ; filtered audio sent to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; 3 notes to demonstrate each filter in turn
i 1 0  3 ; atone
i 2 5  3 ; buthp
i 3 10 3 ; bqrez(mode 1)
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Bandpass Filters</h2>
<p>A bandpass filter allows just a narrow band of sound to pass through unimpeded and as such is a little bit like a combination of a lowpass and highpass filter connected in series. We normally expect at least one additional parameter of control: control over the width of the band of frequencies allowed to pass through, or 'bandwidth'.<br />
<br />
In the next example cutoff frequency and bandwidth are demonstrated independently for two different bandpass filters offered by Csound. First of all a sawtooth waveform is passed through a <a href="http://www.csounds.com/manual/html/reson.html">reson</a> filter and a <a href="http://www.csounds.com/manual/html/butterbp.html">butbp</a> filter in turn while the cutoff frequency rises (bandwidth remains static). Then pink noise is passed through <em>reson</em> and <em>butbp</em> in turn again but this time the cutoff frequency remains static at 5000Hz while the bandwidth expands from 8 to 5000Hz. In the latter two notes it will be heard how the resultant sound moves from almost a pure sine tone to unpitched noise. <em>butbp</em> is obviously the Butterworth based bandpass filter. <em>reson</em> can produce dramatic variations in amplitude depending on the bandwidth value and therefore some balancing of amplitude in the output signal may be necessary if out of range samples and distortion are to be avoided. Fortunately the opcode itself includes two modes of amplitude balancing built in but by default neither of these methods are active and in this case the use of the balance opcode may be required. Mode 1 seems to work well with spectrally sparse sounds like harmonic tones while mode 2 works well with spectrally dense sounds such as white or pink noise.<br />
</p>
<p> </p>
<p><strong><em>   EXAMPLE 05C03.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

  instr 1
        prints       &quot;reson%n&quot;          ; indicate filter type in console
aSig    vco2         0.5, 150           ; input signal: sawtooth waveform
kcf     expon        20,p3,10000        ; rising cutoff frequency
aSig    reson        aSig,kcf,kcf*0.1,1 ; filter audio signal
        out          aSig               ; send filtered audio to output
  endin

  instr 2
        prints       &quot;butbp%n&quot;          ; indicate filter type in console
aSig    vco2         0.5, 150           ; input signal: sawtooth waveform
kcf     expon        20,p3,10000        ; rising cutoff frequency
aSig    butbp        aSig, kcf, kcf*0.1 ; filter audio signal
        out          aSig               ; send filtered audio to output
  endin

  instr 3
        prints       &quot;reson%n&quot;          ; indicate filter type in console
aSig    pinkish      0.5                ; input signal: pink noise
kbw     expon        10000,p3,8         ; contracting bandwidth
aSig    reson        aSig, 5000, kbw, 2 ; filter audio signal
        out          aSig               ; send filtered audio to output
  endin

  instr 4
        prints       &quot;butbp%n&quot;          ; indicate filter type in console
aSig    pinkish      0.5                ; input signal: pink noise
kbw     expon        10000,p3,8         ; contracting bandwidth
aSig    butbp        aSig, 5000, kbw    ; filter audio signal
        out          aSig               ; send filtered audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0  3 ; reson - cutoff frequency rising
i 2 4  3 ; butbp - cutoff frequency rising
i 3 8  6 ; reson - bandwidth increasing
i 4 15 6 ; butbp - bandwidth increasing
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Comb Filtering</h2>
<p>A comb filter is a special type of filter that creates a harmonically related stack of resonance peaks on an input sound file. A comb filter is really just a very short delay effect with feedback. Typically the delay times involved would be less than 0.05 seconds. Many of the comb filters documented in <a href="http://www.csounds.com/manual/html/">the Csound Manual</a> term this delay time, 'loop time'. The fundamental of the harmonic stack of resonances produced will be 1/loop time. Loop time and the frequencies of the resonance peaks will be inversely proportionsl – as loop time get smaller, the frequencies rise. For a loop time of 0.02 seconds the fundamental resonance peak will be 50Hz, the next peak 100Hz, the next 150Hz and so on. Feedback is normally implemented as reverb time – the time taken for amplitude to drop to 1/1000 of its original level or by 60dB. This use of reverb time as opposed to feedback alludes to the use of comb filters in the design of reverb algorithms. Negative reverb times will result in only the odd numbered partials of the harmonic stack being present.<br />
<br />
The following example demonstrates a comb filter using the <a href="http://www.csounds.com/manual/html/vcomb.html">vcomb</a> opcode. This opcode allows for performance time modulation of the loop time parameter. For the first 5 seconds of the demonstration the reverb time increases from 0.1 seconds to 2 while the loop time remains constant at 0.005 seconds. Then the loop time decreases to 0.0005 seconds over 6 seconds (the resonant peaks rise in frequency), finally over the course of 10 seconds the loop time rises to 0.1 seconds (the resonant peaks fall in frequency). A repeating noise impulse is used as a source sound to best demonstrate the qualities of a comb filter.<br />
</p>
<p> </p>
<p><strong><em>   EXAMPLE 05C04.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ;activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

  instr 1
; -- generate an input audio signal (noise impulses) --
; repeating amplitude envelope:
kEnv         loopseg   1,0, 0,1,0.005,1,0.0001,0,0.9949,0
aSig         pinkish   kEnv*0.6                     ; pink noise pulses

; apply comb filter to input signal
krvt    linseg  0.1, 5, 2                           ; reverb time
alpt    expseg  0.005,5,0.005,6,0.0005,10,0.1,1,0.1 ; loop time
aRes    vcomb   aSig, krvt, alpt, 0.1               ; comb filter
        out     aRes                                ; audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 25
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span id="ch035_d-delay-and-feedback.xhtml"></span></p>
<h1>DELAY AND FEEDBACK</h1>
<p>A delay in DSP is a special kind of buffer sometimes called a circular buffer. The length of this buffer is finite and must be declared upon initialization as it is stored in RAM. One way to think of the circular buffer is that as new items are added at the beginning of the buffer the oldest items at the end of the buffer are being 'shoved' out.</p>
<p>Besides their typical application for creating echo effects, delays can also be used to implement chorus, flanging, pitch shifting and filtering effects.</p>
<p>Csound offers many opcodes for implementing delays. Some of these offer varying degrees of quality - often balanced against varying degrees of efficiency whilst some are for quite specialized purposes.</p>
<p>To begin with this section is going to focus upon a pair of opcodes, <a href="http://www.csounds.com/manual/html/delayr.html">delayr</a> and <a href="http://www.csounds.com/manual/html/delayw.html">delay<span>w</span></a><em>.</em> Whilst not the most efficient to use in terms of the number of lines of code required, the use of <em>delayr</em> and <em>delayw</em> helps to clearly illustrate how a delay buffer works. Besides this, <em>delayr</em> and <em>delayw</em> actually offer a lot more flexibility and versatility than many of the other delay opcodes.</p>
<p>When using <em>delayr</em> and <em>delayw</em> the establishement of a delay buffer is broken down into two steps: reading from the end of the buffer using <em>delayr</em> (and by doing this defining the length or duration of the buffer) and then writing into the beginning of the buffer using <em>delayw</em>.</p>
<p>The code employed might look like this:</p>
<pre><code>aSigOut  delayr  1
         delayw  aSigIn</code></pre>
<p>where 'aSigIn' is the input signal written into the beginning of the buffer and 'aSigOut' is the output signal read from the end of the buffer. The fact that we declare reading from the buffer before writing to it is sometimes initially confusing but, as alluded to before, one reason this is done is to declare the length of the buffer. The buffer length in this case is 1 second and this will be the apparent time delay between the input audio signal and audio read from the end of the buffer.</p>
<p>The following example implements the delay described above in a .csd file. An input sound of sparse sine tone pulses is created. This is written into the delay buffer from which a new audio signal is created by read from the end of this buffer. The input signal (sometimes referred to as the dry signal) and the delay output signal (sometimes referred to as the wet signal) are mixed and set to the output. The delayed signal is attenuated with respect to the input signal.</p>
<p><strong>   <em>EXAMPLE 05D01.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1
giSine   ftgen   0, 0, 2^12, 10, 1 ; a sine wave

  instr 1
; -- create an input signal: short &#39;blip&#39; sounds --
kEnv    loopseg  0.5, 0, 0, 0,0.0005, 1 , 0.1, 0, 1.9, 0
kCps    randomh  400, 600, 0.5
aEnv    interp   kEnv
aSig    poscil   aEnv, kCps, giSine

; -- create a delay buffer --
aBufOut delayr   0.3
        delayw   aSig

; -- send audio to output (input and output to the buffer are mixed)
        out      aSig + (aBufOut*0.4)
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 25
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>If we mix some of the delayed signal into the input signal that is written into the buffer then we will delay some of the delayed signal thus creating more than a single echo from each input sound. Typically the sound that is fed back into the delay input is attenuated so that sound cycle through the buffer indefinitely but instead will eventually die away. We can attenuate the feedback signal by multiplying it by a value in the range zero to 1. The rapidity with which echoes will die away is defined by how close the zero this value is. The following example implements a simple delay with feedback.</p>
<p><strong>   <em>EXAMPLE 05D02.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ;activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen   0, 0, 2^12, 10, 1  ; a sine wave

  instr 1
; -- create an input signal: short &#39;blip&#39; sounds --
kEnv    loopseg  0.5,0,0,0,0.0005,1,0.1,0,1.9,0 ; repeating envelope
kCps    randomh  400, 600, 0.5                  ; &#39;held&#39; random values
aEnv    interp   kEnv                           ; a-rate envelope
aSig    poscil   aEnv, kCps, giSine             ; generate audio

; -- create a delay buffer --
iFdback =        0.7                    ; feedback ratio
aBufOut delayr   0.3                    ; read audio from end of buffer
; write audio into buffer (mix in feedback signal)
        delayw   aSig+(aBufOut*iFdback)

; send audio to output (mix the input signal with the delayed signal)
        out      aSig + (aBufOut*0.4)
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 25
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Constructing a delay effect in this way is rather limited as the delay time is static. If we want to change the delay time we need to reinitialise the code that implements the delay buffer. A more flexible approach is to read audio from within the buffer using one of Csounds opcodes for 'tapping' a delay buffer, <em>deltap</em>, <em>deltapi</em>, <em><span>deltap3 or</span></em> <em>deltapx.</em> The opcodes are listed in order of increasing quality which also reflects an increase in computational expense. In the next example a delay tap is inserted within the delay buffer (between the <em>delayr</em> and the <em>delayw</em>) opcodes. As our delay time is modulating quite quickly we will use <em>deltapi</em> which uses linear interpolation as it rebuilds the audio signal whenever the delay time is moving. Note that this time we are not using the audio output from the <em>delayr</em> opcode as we are using the audio output from <em>deltapi</em> instead. The delay time used by <em>deltapi</em> is created by <em>randomi</em> which creates a random function of straight line segments. A-rate is used for the delay time to improve the accuracy of its values, use of k-rate would result in a noticeably poorer sound quality. You will notice that as well as modulating the time gap between echoes, this example also modulates the pitch of the echoes – if the delay tap is static within the buffer there would be no change in pitch, if is moving towards the beginning of the buffer then pitch will rise and if it is moving towards the end of the buffer then pitch will drop. This side effect has led to digital delay buffers being used in the design of many pitch shifting effects.</p>
<p>The user must take care that the delay time demanded from the delay tap does not exceed the length of the buffer as defined in the <em>delayr</em> line. If it does it will attempt to read data beyond the end of the RAM buffer – the results of this are unpredictable. The user must also take care that the delay time does not go below zero, in fact the minumum delay time that will be permissible will be the duration of one k cycle (ksmps/sr).</p>
<p><strong>   <em>EXAMPLE 05D03.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen   0, 0, 2^12, 10, 1  ; a sine wave

  instr 1
; -- create an input signal: short &#39;blip&#39; sounds --
kEnv          loopseg  0.5,0,0,0,0.0005,1,0.1,0,1.9,0
aEnv          interp   kEnv
aSig          poscil   aEnv, 500, giSine

aDelayTime    randomi  0.05, 0.2, 1      ; modulating delay time
; -- create a delay buffer --
aBufOut       delayr   0.2               ; read audio from end of buffer
aTap          deltapi  aDelayTime        ; &#39;tap&#39; the delay buffer
              delayw   aSig + (aTap*0.9) ; write audio into buffer

; send audio to the output (mix the input signal with the delayed signal)
              out      aSig + (aTap*0.4)
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 30
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>We are not limited to inserting only a single delay tap within the buffer. If we add further taps we create what is known as a multi-tap delay. The following example implements a multi-tap delay with three delay taps. Note that only the final delay (the one closest to the end of the buffer) is fed back into the input in order to create feedback but all three taps are mixed and sent to the output. There is no reason not to experiment with arrangements other than this but this one is most typical.</p>
<p><strong>   <em>EXAMPLE 05D04.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen   0, 0, 2^12, 10, 1 ; a sine wave

  instr 1
; -- create an input signal: short &#39;blip&#39; sounds --
kEnv    loopseg  0.5,0,0,0,0.0005,1,0.1,0,1.9,0 ; repeating envelope
kCps    randomh  400, 1000, 0.5                 ; &#39;held&#39; random values
aEnv    interp   kEnv                           ; a-rate envelope
aSig    poscil   aEnv, kCps, giSine             ; generate audio

; -- create a delay buffer --
aBufOut delayr   0.5                    ; read audio end buffer
aTap1   deltap   0.1373                 ; delay tap 1
aTap2   deltap   0.2197                 ; delay tap 2
aTap3   deltap   0.4139                 ; delay tap 3
        delayw   aSig + (aTap3*0.4)     ; write audio into buffer

; send audio to the output (mix the input signal with the delayed signals)
        out      aSig + ((aTap1+aTap2+aTap3)*0.4)
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 25
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>As mentioned at the top of this section many familiar effects are actually created from using delay buffers in various ways. We will briefly look at one of these effects: the flanger. Flanging derives from a phenomenon which occurs when the delay time becomes so short that we begin to no longer perceive individual echoes but instead a stack of harmonically related resonances are perceived the frequencies of which are in simple ratio with 1/delay_time. This effect is known as a comb filter. When the delay time is slowly modulated and the resonances shifting up and down in sympathy the effect becomes known as a flanger. In this example the delay time of the flanger is modulated using an LFO that employs a U-shaped parabola as its waveform as this seems to provide the smoothest comb filter modulations.</p>
<p><strong>   <em>EXAMPLE 05D05.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen   0, 0, 2^12, 10, 1                 ; a sine wave
giLFOShape  ftgen   0, 0, 2^12, 19, 0.5, 1, 180, 1 ; u-shaped parabola

  instr 1
aSig    pinkish  0.1                               ; pink noise

aMod    poscil   0.005, 0.05, giLFOShape           ; delay time LFO
iOffset =        ksmps/sr                          ; minimum delay time
kFdback linseg   0.8,(p3/2)-0.5,0.95,1,-0.95       ; feedback

; -- create a delay buffer --
aBufOut delayr   0.5                   ; read audio from end buffer
aTap    deltap3  aMod + iOffset        ; tap audio from within buffer
        delayw   aSig + (aTap*kFdback) ; write audio into buffer

; send audio to the output (mix the input signal with the delayed signal)
        out      aSig + aTap
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 25
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p><span id="ch036_e-reverberation.xhtml"></span></p>
<h1>REVERBERATION</h1>
<p>Reverb is the effect a room or space has on a sound where the sound we perceive is a mixture of the direct sound and the dense overlapping echoes of that sound reflecting off walls and objects within the space.</p>
<p>Csound's earliest reverb opcodes are <em>reverb</em><span> and </span><em>nreverb</em><span>. By today's standards these sound rather crude and as a consequence modern Csound users tend to prefer the more recent opcodes </span><em>freeverb</em><span> and </span><em>reverbsc</em><span>.</span></p>
<p>The typical way to use a reverb is to run as a effect throughout the entire Csound performance and to send it audio from other instruments to which it adds reverb. This is more efficient than initiating a new reverb effect for every note that is played. This arrangement is a reflection of how a reverb effect would be used with a mixing desk in a conventional studio. There are several methods of sending audio from sound producing instruments to the reverb instrument, three of which will be introduced in the coming examples</p>
<p>The first method uses Csound's global variables so that an audio variable created in one instrument and be read in another instrument. There are several points to highlight here. First the global audio variable that is use to send audio the reverb instrument is initialized to zero (silence) in the header area of the orchestra.</p>
<p>This is done so that if no sound generating instruments are playing at the beginning of the performance this variable still exists and has a value. An error would result otherwise and Csound would not run. When audio is written into this variable in the sound generating instrument it is added to the current value of the global variable.</p>
<p>This is done in order to permit polyphony and so that the state of this variable created by other sound producing instruments is not overwritten. Finally it is important that the global variable is cleared (assigned a value of zero) when it is finished with at the end of the reverb instrument. If this were not done then the variable would quickly 'explode' (get astronomically high) as all previous instruments are merely adding values to it rather that redeclaring it. Clearing could be done simply by setting to zero<span> but the </span><em>clear</em><span> opcode might prove useful in the future as it provides us with the opportunity to clear many variables simultaneously.</span></p>
<p><span>This example uses the <a href="http://www.csounds.com/manual/html/freeverb.html">freeverb</a></span><span> opcode and is based on a plugin of the same name. Freeverb has a smooth reverberant tail and is perhaps similar in sound to a plate reverb. It provides us with two main parameters of control: 'room size' which is essentially a control of the amount of internal feedback and therefore reverb time, and 'high frequency damping' which controls the amount of attenuation of high frequencies. Both there parameters should be set within the range 0 to 1. For room size a value of zero results in a very short reverb and a value of 1 results in a very long reverb. For high frequency damping a value of zero provides minimum damping of higher frequencies giving the impression of a space with hard walls, a value of 1 provides maximum high frequency damping thereby giving the impression of a space with soft surfaces such as thick carpets and heavy curtains.</span></p>
<p><strong>   <em>EXAMPLE 05E01.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr =  44100
ksmps = 32
nchnls = 2
0dbfs = 1

gaRvbSend    init      0 ; global audio variable initialized to zero

  instr 1 ; sound generating instrument (sparse noise bursts)
kEnv         loopseg   0.5,0,0,1,0.003,1,0.0001,0,0.9969,0 ; amp. env.
aSig         pinkish   kEnv              ; noise pulses
             outs      aSig, aSig        ; audio to outs
iRvbSendAmt  =         0.8               ; reverb send amount (0 - 1)
; add some of the audio from this instrument to the global reverb send variable
gaRvbSend    =         gaRvbSend + (aSig * iRvbSendAmt)
  endin

  instr 5 ; reverb - always on
kroomsize    init      0.85          ; room size (range 0 to 1)
kHFDamp      init      0.5           ; high freq. damping (range 0 to 1)
; create reverberated version of input signal (note stereo input and output)
aRvbL,aRvbR  freeverb  gaRvbSend, gaRvbSend,kroomsize,kHFDamp
             outs      aRvbL, aRvbR ; send audio to outputs
             clear     gaRvbSend    ; clear global audio variable
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 300 ; noise pulses (input sound)
i 5 0 300 ; start reverb
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The next example uses Csound's zak patching system to send audio from one instrument to another. The zak system is a little like a patch bay you might find in a recording studio. Zak channels can be a, k or i-rate. These channels will be addressed using numbers so it will be important to keep track of what each numbered channel is used for. Our example will be very simple in that we will only be using one zak audio channel. Before using any of the zak opcodes for reading and writing data we must initialize zak storage space. This is done in the orchestra header area using the <a href="http://www.csounds.com/manual/html/zakinit.html">zakinit</a> opcode. This opcode initializes both a and k rate channels; we must intialize at least one of each even if we don't require both.</p>
<pre><code>zakinit    1, 1</code></pre>
<p>The audio from the sound generating instrument is mixed into a zak audio channel the <a href="http://www.csounds.com/manual/html/zawm.html">zawm</a> opcode like this:</p>
<pre><code>zawm    aSig * iRvbSendAmt, 1</code></pre>
<p>This channel is read from in the reverb instrument using the <a href="http://www.csounds.com/manual/html/zar.html">zar</a> opcode like this:</p>
<pre><code>aInSig  zar   1</code></pre>
<p>Because audio is begin mixed into our zak channel but it is never redefined (only mixed into) it needs to be cleared after we have finished with it. This is accomplished at the bottom of the reverb instrument using the <a href="http://www.csounds.com/manual/html/zacl.html">zacl</a> opcode like this:</p>
<pre><code>zacl      0, 1</code></pre>
<p>This example uses the <a href="http://www.csounds.com/manual/html/reverbsc.html">reverbsc</a> opcode. It too has a stereo input and output. The arguments that define its character are feedback level and cutoff frequency. Feedback level should be in the range zero to 1 and controls reverb time. Cutoff frequency should be within the range of human hearing (20Hz -20kHz) and less than the Nyqvist frequency (sr/2) - it controls the cutoff frequencies of low pass filters within the algorithm.</p>
<p><strong>   <em>EXAMPLE 05E02.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr =  44100
ksmps = 32
nchnls = 2
0dbfs = 1

; initialize zak space  - one a-rate and one k-rate variable.
; We will only be using the a-rate variable.
             zakinit   1, 1

  instr 1 ; sound generating instrument - sparse noise bursts
kEnv         loopseg   0.5,0, 0,1,0.003,1,0.0001,0,0.9969,0 ; amp. env.
aSig         pinkish   kEnv       ; pink noise pulses
             outs      aSig, aSig ; send audio to outputs
iRvbSendAmt  =         0.8        ; reverb send amount (0 - 1)
; write to zak audio channel 1 with mixing
             zawm      aSig*iRvbSendAmt, 1
  endin

  instr 5 ; reverb - always on
aInSig       zar       1    ; read first zak audio channel
kFblvl       init      0.88 ; feedback level - i.e. reverb time
kFco         init      8000 ; cutoff freq. of a filter within the reverb
; create reverberated version of input signal (note stereo input and output)
aRvbL,aRvbR  reverbsc  aInSig, aInSig, kFblvl, kFco
             outs      aRvbL, aRvbR ; send audio to outputs
             zacl      0, 1         ; clear zak audio channels
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 10 ; noise pulses (input sound)
i 5 0 12 ; start reverb
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p> </p>
<p><em>reverbsc</em><span> contains a mechanism to modulate delay times internally which has the effect of harmonically blurring sounds the longer they are reverberated. This contrasts with </span><em>freeverb</em><span>'s rather static reverberant tail. On the other hand </span><em>screverb</em><span>'s tail is not as smooth as that of </span><em>freeverb,</em> <span>inidividual echoes are sometimes discernible so it may not be as well suited to the reverberation of percussive sounds. Also be aware that as well as reducing the reverb time, the feedback level parameter reduces the overall amplitude of the effect to the point where a setting of 1 will result in silence from the opcode.</span></p>
<p>A more recent option for sending sound from instrument to instrument in Csound is to use the <em>chn...</em> opcodes. These opcodes can also be used to allow Csound to interface with external programs using the software bus and the Csound API.</p>
<p><strong>   <em>EXAMPLE 05E03.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activates real time sound output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr =  44100
ksmps = 32
nchnls = 2
0dbfs = 1

  instr 1 ; sound generating instrument - sparse noise bursts
kEnv         loopseg   0.5,0, 0,1,0.003,1,0.0001,0,0.9969,0 ; amp. envelope
aSig         pinkish   kEnv                                 ; noise pulses
             outs      aSig, aSig                           ; audio to outs
iRvbSendAmt  =         0.4                        ; reverb send amount (0 - 1)
;write audio into the named software channel:
             chnmix    aSig*iRvbSendAmt, &quot;ReverbSend&quot;
  endin

  instr 5 ; reverb (always on)
aInSig       chnget    &quot;ReverbSend&quot;   ; read audio from the named channel
kTime        init      4              ; reverb time
kHDif        init      0.5            ; &#39;high frequency diffusion&#39; (0 - 1)
aRvb         nreverb   aInSig, kTime, kHDif ; create reverb signal
outs         aRvb, aRvb               ; send audio to outputs
             chnclear  &quot;ReverbSend&quot;   ; clear the named channel
endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 10 ; noise pulses (input sound)
i 5 0 12 ; start reverb
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>The Schroeder Reverb Design</h2>
<p>Many reverb algorithms including Csound's freeverb, reverb and reverbn are based on what is known as the Schroeder reverb design. This was a design proposed in the early 1960s by the physicist Manfred Schroeder. In the Schroeder reverb a signal is passed into four parallel comb filters the outputs of which are summed and then passed through two allpass filters as shown in the diagram below. Essentially the comb filters provide the body of the reverb effect and the allpass filters smear their resultant sound to reduce ringing artefacts the comb filters might produce. More modern designs might extent the number of filters used in an attempt to create smoother results. The freeverb opcode employs eight parallel comb filters followed by four series allpass filters on each channel. The two main indicators of poor implementations of the Schoeder reverb are individual echoes being excessively apparent and ringing artefacts. The results produced by the freeverb opcode are very smooth but a criticism might be that it is lacking in character and is more suggestive of a plate reverb than of a real room.</p>
<p><img src="static/Csound-Picts-05_SoundMod-schroeder-en.jpg" alt="schroeder.jpg" /><br />
<br />
The next example implements the basic Schroeder reverb with four parallel comb filters followed by three series allpass filters. This also proves a useful exercise in routing audio signals within Csound. Perhaps the most crucial element of the Schroeder reverb is the choice of loop times for the comb and allpass filters – careful choices here should obviate the undesirable artefacts mentioned in the previous paragraph. If loop times are too long individual echoes will become apparent, if they are too short the characteristic ringing of comb filters will become apparent. If loop times between filters differ too much the outputs from the various filters will not fuse. It is also important that the loop times are prime numbers so that echoes between different filters do not reinforce each other. It may also be necessary to adjust loop times when implementing very short reverbs or very long reverbs. The duration of the reverb is effectively determined by the reverb times for the comb filters. There is ceratinly scope for experimentation with the design of this example and exploration of settings other than the ones suggested here.<br />
<br />
This example consists of five instruments. The fifth instrument implements the reverb algorithm described above. The first four instruments act as a kind of generative drum machine to provide source material for the reverb. Generally sharp percussive sounds provide the sternest test of a reverb effect. Instrument 1 triggers the various synthesized drum sounds (bass drum, snare and closed hi-hat) produced by instruments 2 to 4.<br />
</p>
<h4></h4>
<p><strong><em>  EXAMPLE 05E04.csd</em></strong></p>
<h4></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac -m0
; activate real time sound output and suppress note printing
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr =  44100
ksmps = 1
nchnls = 2
0dbfs = 1

giSine       ftgen       0, 0, 2^12, 10, 1 ; a sine wave
gaRvbSend    init        0                 ; global audio variable initialized
giRvbSendAmt init        0.4               ; reverb send amount (range 0 - 1)

  instr 1 ; trigger drum hits
ktrigger    metro       5                  ; rate of drum strikes
kdrum       random      2, 4.999           ; randomly choose which drum to hit
            schedkwhen  ktrigger, 0, 0, kdrum, 0, 0.1 ; strike a drum
  endin

  instr 2 ; sound 1 - bass drum
iamp        random      0, 0.5               ; amplitude randomly chosen
p3          =           0.2                  ; define duration for this sound
aenv        line        1,p3,0.001           ; amplitude envelope (percussive)
icps        exprand     30                   ; cycles-per-second offset
kcps        expon       icps+120,p3,20       ; pitch glissando
aSig        oscil       aenv*0.5*iamp,kcps,giSine  ; oscillator
            outs        aSig, aSig           ; send audio to outputs
gaRvbSend   =           gaRvbSend + (aSig * giRvbSendAmt) ; add to send
  endin

  instr 3 ; sound 3 - snare
iAmp        random      0, 0.5                   ; amplitude randomly chosen
p3          =           0.3                      ; define duration
aEnv        expon       1, p3, 0.001             ; amp. envelope (percussive)
aNse        noise       1, 0                     ; create noise component
iCps        exprand     20                       ; cps offset
kCps        expon       250 + iCps, p3, 200+iCps ; create tone component gliss.
aJit        randomi     0.2, 1.8, 10000          ; jitter on freq.
aTne        oscil       aEnv, kCps*aJit, giSine  ; create tone component
aSig        sum         aNse*0.1, aTne           ; mix noise and tone components
aRes        comb        aSig, 0.02, 0.0035       ; comb creates a &#39;ring&#39;
aSig        =           aRes * aEnv * iAmp       ; apply env. and amp. factor
            outs        aSig, aSig               ; send audio to outputs
gaRvbSend   =           gaRvbSend + (aSig * giRvbSendAmt); add to send
  endin

  instr 4 ; sound 4 - closed hi-hat
iAmp        random      0, 1.5               ; amplitude randomly chosen
p3          =           0.1                  ; define duration for this sound
aEnv        expon       1,p3,0.001           ; amplitude envelope (percussive)
aSig        noise       aEnv, 0              ; create sound for closed hi-hat
aSig        buthp       aSig*0.5*iAmp, 12000 ; highpass filter sound
aSig        buthp       aSig,          12000 ; -and again to sharpen cutoff
            outs        aSig, aSig           ; send audio to outputs
gaRvbSend   =           gaRvbSend + (aSig * giRvbSendAmt) ; add to send
  endin


  instr 5 ; schroeder reverb - always on
; read in variables from the score
kRvt        =           p4
kMix        =           p5

; print some information about current settings gleaned from the score
            prints      &quot;Type:&quot;
            prints      p6
            prints      &quot;\\nReverb Time:%2.1f\\nDry/Wet Mix:%2.1f\\n\\n&quot;,p4,p5

; four parallel comb filters
a1          comb        gaRvbSend, kRvt, 0.0297; comb filter 1
a2          comb        gaRvbSend, kRvt, 0.0371; comb filter 2
a3          comb        gaRvbSend, kRvt, 0.0411; comb filter 3
a4          comb        gaRvbSend, kRvt, 0.0437; comb filter 4
asum        sum         a1,a2,a3,a4 ; sum (mix) the outputs of all comb filters

; two allpass filters in series
a5          alpass      asum, 0.1, 0.005 ; send mix through first allpass filter
aOut        alpass      a5, 0.1, 0.02291 ; send 1st allpass through 2nd allpass

amix        ntrpol      gaRvbSend, aOut, kMix  ; create a dry/wet mix
            outs        amix, amix             ; send audio to outputs
            clear       gaRvbSend              ; clear global audio variable
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; room reverb
i 1  0 10                     ; start drum machine trigger instr
i 5  0 11 1 0.5 &quot;Room Reverb&quot; ; start reverb

; tight ambience
i 1 11 10                          ; start drum machine trigger instr
i 5 11 11 0.3 0.9 &quot;Tight Ambience&quot; ; start reverb

; long reverb (low in the mix)
i 1 22 10                                      ; start drum machine
i 5 22 15 5 0.1 &quot;Long Reverb (Low In the Mix)&quot; ; start reverb

; very long reverb (high in the mix)
i 1 37 10                                            ; start drum machine
i 5 37 25 8 0.9 &quot;Very Long Reverb (High in the Mix)&quot; ; start reverb
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This chapter has introduced some of the more recent Csound opcodes for delay-line based reverb algorithms which in most situations can be used to provide high quality and efficient reverberation. Convolution offers a whole new approach for the creation of realistic reverbs that imitate actual spaces - this technique is demonstrated in the <a href="http://en.flossmanuals.net/csound/ch038_h-convolution/">Convolution</a> chapter.<br />
</p>
<p><span id="ch037_f-am-rm-waveshaping.xhtml"></span></p>
<h1>AM / RM / WAVESHAPING</h1>
<p>An introduction as well as some background theory of amplitude modulation, ring modulation and waveshaping is given in the fourth chapter entitled &quot;sound-synthesis&quot;. As all of these techniques merely modulate the amplitude of a signal in a variety of ways, they can also be used for the modification of non-synthesized sound. In this chapter we will explore amplitude modulation, ring modulation and waveshaping as applied to non-synthesized sound.<span id="ch037_f-am-rm-waveshaping.xhtml#InsertNoteID_6_marker7" class="InsertNoteMarker"><sup><a href="f-am-rm-waveshaping#InsertNoteID_6">1</a></sup></span> <br />
</p>
<h2>AMPLITUDE MODULATION<br />
</h2>
<p>With &quot;sound-synthesis&quot;, the principle  of AM was shown as a amplitude multiplication of two sine oscillators. Later we've used a more complex modulators, to generate more complex spectrums. The principle also works very well with sound-files (samples) or live-audio-input.<br />
</p>
<p>Karlheinz Stockhausens <em>&quot;Mixtur für Orchester, vier Sinusgeneratoren und vier Ringmodulatoren</em>” (1964) was the first piece which used analog ringmodulation (AM without DC-offset) to alter the acoustic instruments pitch in realtime during a live-performance. The word ringmodulation inherites from the analog <em>four-diode circuit</em> which was arranged in a &quot;ring&quot;.<br />
</p>
<p>In the following example shows how this can be done digitally in Csound. In this case a sound-file works as the <em>carrier</em> which is modulated by a <em>sine-wave-osc</em>. The result sounds like old 'Harald Bode' pitch-shifters from the 1960's.</p>
<p><strong><em>Example: 05F01.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;

sr = 48000
ksmps = 32
nchnls = 1
0dbfs = 1


instr 1   ; Ringmodulation
aSine1 poscil 0.8, p4, 1
aSample diskin2 &quot;fox.wav&quot;, 1, 0, 1, 0, 32
out aSine1*aSample
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1 ; sine

i 1 0 2 400
i 1 2 2 800
i 1 4 2 1600
i 1 6 2 200
i 1 8 2 2400
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; written by Alex Hofmann (Mar. 2011)
</code></pre>
<h2>WAVESHAPING</h2>
<p>In chapter 04E waveshaping has been described as a method of applying a transfer function to an incoming signal. It has been discussed that the table which stores the transfer function must be read with an interpolating table reader to avoid degradation of the signal. On the other hand, degradation can be a nice thing for sound modification. So let us start with this branch here.</p>
<h3>Bit Depth Reduction<br />
</h3>
<p>If the transfer function itself is linear, but the table of the function is small, and no interpolation is applied to the amplitude as index to the table, in effect the bit depth is reduced. For a function table of size 4, a line becomes a staircase:</p>
<p>Bit Depth = high                                                <br />
</p>
<p><img src="static/05Fbild1a.png" width="599" height="599" /><br />
</p>
<p>Bit Depth = 2</p>
<p><img src="static/05Fbild2a.png" width="601" height="601" /></p>
<p>This is the sounding result:</p>
<p><em><strong>EXAMPLE 05G01.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giTrnsFnc ftgen 0, 0, 4, -7, -1, 3, 1

instr 1
aAmp      soundin   &quot;fox.wav&quot;
aIndx     =         (aAmp + 1) / 2
aWavShp   table     aIndx, giTrnsFnc, 1
          outs      aWavShp, aWavShp
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 2.767
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</code></pre>
<h3>Transformation and Distortion<br />
</h3>
<p>In general, the transformation of sound in applying waveshaping depends on the transfer function. The following example applies at first a table which does not change the sound at all, because the function just says <em>y = x</em>. The second one leads aready to a heavy distortion, though &quot;just&quot; the samples between an amplitude of -0.1 and +0.1 are erased. Tables 3 to 7 apply some chebychev functions which are well known from waveshaping synthesis. Finally, tables 8 and 9 approve that even a meaningful sentence and a nice music can regarded as noise ...<br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

giNat   ftgen 1, 0, 2049, -7, -1, 2048, 1
giDist  ftgen 2, 0, 2049, -7, -1, 1024, -.1, 0, .1, 1024, 1
giCheb1 ftgen 3, 0, 513, 3, -1, 1, 0, 1
giCheb2 ftgen 4, 0, 513, 3, -1, 1, -1, 0, 2
giCheb3 ftgen 5, 0, 513, 3, -1, 1, 0, 3, 0, 4
giCheb4 ftgen 6, 0, 513, 3, -1, 1, 1, 0, 8, 0, 4
giCheb5 ftgen 7, 0, 513, 3, -1, 1, 3, 20, -30, -60, 32, 48
giFox   ftgen 8, 0, -121569, 1, &quot;fox.wav&quot;, 0, 0, 1
giGuit  ftgen 9, 0, -235612, 1, &quot;ClassGuit.wav&quot;, 0, 0, 1

instr 1
iTrnsFnc  =         p4
kEnv      linseg    0, .01, 1, p3-.2, 1, .01, 0
aL, aR    soundin   &quot;ClassGuit.wav&quot;
aIndxL    =         (aL + 1) / 2
aWavShpL  tablei    aIndxL, iTrnsFnc, 1
aIndxR    =         (aR + 1) / 2
aWavShpR  tablei    aIndxR, iTrnsFnc, 1
          outs      aWavShpL*kEnv, aWavShpR*kEnv
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7 1 ;natural though waveshaping
i 1 + . 2 ;rather heavy distortion
i 1 + . 3 ;chebychev for 1st partial
i 1 + . 4 ;chebychev for 2nd partial
i 1 + . 5 ;chebychev for 3rd partial
i 1 + . 6 ;chebychev for 4th partial
i 1 + . 7 ;after dodge/jerse p.136
i 1 + . 8 ;fox
i 1 + . 9 ;guitar
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</code></pre>
<p>Instead of using the &quot;self-built&quot; method which has been described here, you can use the Csound opcode <a href="http://www.csounds.com/manual/html/distort.html">distort</a>. It performs the actual waveshaping process and gives a nice control about the amount of distortion in the <em>kdist</em> parameter. Here is a simple example:<span id="ch037_f-am-rm-waveshaping.xhtml#InsertNoteID_18_marker19" class="InsertNoteMarker"><sup><a href="f-am-rm-waveshaping#InsertNoteID_18">2</a></sup></span> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr     = 44100
ksmps  = 32
nchnls = 2
0dbfs  = 1

gi1 ftgen 1,0,257,9,.5,1,270 ;sinoid (also the next)
gi2 ftgen 2,0,257,9,.5,1,270,1.5,.33,90,2.5,.2,270,3.5,.143,90
gi3 ftgen 3,0,129,7,-1,128,1 ;actually natural
gi4 ftgen 4,0,129,10,1 ;sine
gi5 ftgen 5,0,129,10,1,0,1,0,1,0,1,0,1 ;odd partials
gi6 ftgen 6,0,129,21,1 ;white noise
gi7 ftgen 7,0,129,9,.5,1,0 ;half sine
gi8 ftgen 8,0,129,7,1,64,1,0,-1,64,-1 ;square wave

instr 1
ifn       =         p4
ivol      =         p5
kdist     line      0, p3, 1 ;increase the distortion over p3
aL, aR    soundin   &quot;ClassGuit.wav&quot;
aout1     distort   aL, kdist, ifn
aout2     distort   aR, kdist, ifn
          outs      aout1*ivol, aout2*ivol
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 7 1 1
i . + . 2 .3
i . + . 3 1
i . + . 4 .5
i . + . 5 .15
i . + . 6 .04
i . + . 7 .02
i . + . 8 .02
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</code></pre>
<p><br />
</p>
<ol>
<li><span id="ch037_f-am-rm-waveshaping.xhtml#InsertNoteID_6">This is the same for Granular Synthesis which can either be &quot;pure&quot; synthesis or applied so sampled sound.<span id="ch037_f-am-rm-waveshaping.xhtml#InsertNoteID_6_LinkBacks"><sup><a href="f-am-rm-waveshaping#InsertNoteID_6_marker7">^</a></sup></span></span></li>
<li><span id="ch037_f-am-rm-waveshaping.xhtml#InsertNoteID_18">Have a look at Iain McCurdy's Realtime example (which has also been ported to CsoundQt by René Jopi) for 'distort' for a more interactive exploration of the opcode.<span id="ch037_f-am-rm-waveshaping.xhtml#InsertNoteID_18_LinkBacks"><sup><a href="f-am-rm-waveshaping#InsertNoteID_18_marker19">^</a></sup></span></span></li>
</ol>
<p><span id="ch038_g-granular-synthesis.xhtml"></span></p>
<h1>GRANULAR SYNTHESIS</h1>
<p>This chapter will focus upon granular synthesis used as a DSP technique upon recorded sound files and will introduce techniques including time stretching, time compressing and pitch shifting. The emphasis will be upon asynchronous granulation. For an introduction to synchronous granular synthesis using simple waveforms please refer to chapter 04F.</p>
<p>Csound offers a wide range of opcodes for sound granulation. Each has its own strengths and weaknesses and suitability for a particular task. Some are easier to use than others, some, such as <a href="http://www.csounds.com/manual/html/granule.html">granule</a> and <a href="http://www.csounds.com/manual/html/partikkel.html">partikkel</a>, are extremely complex and are, at least in terms of the number of input arguments they demand, amongst Csound's most complex opcodes.</p>
<h2>sndwarp - Time Stretching and Pitch Shifting</h2>
<p>sndwarp may not be Csound's newest or most advanced opcode for sound granulation but it is quite easy to use and is certainly up to the task of time stretching and pitch shifting. sndwarp has two modes by which we can modulate time stretching characteristics, one in which we define a 'stretch factor', a value of 2 defining a stretch to twice the normal length, and the other in which we directly control a pointer into the file. The following example uses sndwarp's first mode to produce a sequence of time stretches and pitch shifts. An overview of each procedure will be printed to the terminal as it occurs. sndwarp does not allow for k-rate modulation of grain size or density so for this level we need to look elsewhere.</p>
<p>You will need to make sure that a sound file is available to sndwarp via a GEN01 function table. You can replace the one used in this example with one of your own by replacing the reference to 'ClassicalGuitar.wav'. This sound file is stereo therefore instrument 1 uses the stereo version of sndwarp. 'sndwarpst'. A mismatch between the number of channels in the sound file and the version of sndwarp used will result in playback at an unexpected pitch. You will also need to give GEN01 an appropriate size that will be able to contain your chosen sound file. You can calculate the table size you will need by multiplying the duration of the sound file (in seconds) by the sample rate - for stereo files this value should be doubled - and then choose the next power of 2 above this value. You can download the sample used in the example at <a href="http://www.iainmccurdy.org/csoundrealtimeexamples/sourcematerials/ClassicalGuitar.wav" class="uri">http://www.iainmccurdy.org/csoundrealtimeexamples/sourcematerials/ClassicalGuitar.wav</a>.<br />
</p>
<p>sndwarp describes grain size as 'window size' and it is defined in samples so therefore a window size of 44100 means that grains will last for 1s each (when sample rate is set at 44100). Window size randomization (irandw) adds a random number within that range to the duration of each grain. As these two parameters are closely related it is sometime useful to set irandw to be a fraction of window size. If irandw is set to zero we will get artefacts associated with synchronous granular synthesis.</p>
<p>sndwarp (along with many of Csound's other granular synthesis opcodes) requires us to supply it with a window function in the form of a function table according to which it will apply an amplitude envelope to each grain. By using different function tables we can alternatively create softer grains with gradual attacks and decays (as in this example), with more of a percussive character (short attack, long decay) or 'gate'-like (short attack, long sustain, short decay).</p>
<p><strong>   <em>EXAMPLE 05G01.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac -m0
; activate real-time audio output and suppress printing
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr = 44100
ksmps = 16
nchnls = 2
0dbfs = 1

; waveform used for granulation
giSound  ftgen 1,0,2097152,1,&quot;ClassicalGuitar.wav&quot;,0,0,0

; window function - used as an amplitude envelope for each grain
; (first half of a sine wave)
giWFn   ftgen 2,0,16384,9,0.5,1,0

  instr 1
kamp        =          0.1
ktimewarp   expon      p4,p3,p5  ; amount of time stretch, 1=none 2=double
kresample   line       p6,p3,p7  ; pitch change 1=none 2=+1oct
ifn1        =          giSound   ; sound file to be granulated
ifn2        =          giWFn     ; window shaped used to envelope every grain
ibeg        =          0
iwsize      =          3000      ; grain size (in sample)
irandw      =          3000      ; randomization of grain size range
ioverlap    =          50        ; density
itimemode   =          0         ; 0=stretch factor 1=pointer
            prints     p8        ; print a description
aSigL,aSigR sndwarpst  kamp,ktimewarp,kresample,ifn1,ibeg, \
                                 iwsize,irandw,ioverlap,ifn2,itimemode
            outs       aSigL,aSigR
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p3 = stretch factor begin / pointer location begin
;p4 = stretch factor end / pointer location end
;p5 = resample begin (transposition)
;p6 = resample end (transposition)
;p7 = procedure description
;p8 = description string
; p1 p2   p3 p4 p5  p6    p7    p8
i 1  0    10 1  1   1     1     &quot;No time stretch. No pitch shift.&quot;
i 1  10.5 10 2  2   1     1     &quot;%nTime stretch x 2.&quot;
i 1  21   20 1  20  1     1     \
                 &quot;%nGradually increasing time stretch factor from x 1 to x 20.&quot;
i 1  41.5 10 1  1   2     2     &quot;%nPitch shift x 2 (up 1 octave).&quot;
i 1  52   10 1  1   0.5   0.5   &quot;%nPitch shift x 0.5 (down 1 octave).&quot;
i 1  62.5 10 1  1   4     0.25  \
 &quot;%nPitch shift glides smoothly from 4 (up 2 octaves) to 0.25 (down 2 octaves).&quot;
i 1  73   15 4  4   1     1     \
&quot;%nA chord containing three transpositions: \
                                   unison, +5th, +10th. (x4 time stretch.)&quot;
i 1  73   15 4  4   [3/2] [3/2] &quot;&quot;
i 1  73   15 4  4   3     3     &quot;&quot;
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The next example uses sndwarp's other timestretch mode with which we explicitly define a pointer position from where in the source file grains shall begin. This method allows us much greater freedom with how a sound will be time warped; we can even freeze movement an go backwards in time - something that is not possible with timestretching mode.</p>
<p>This example is self generative in that instrument 2, the instrument that actually creates the granular synthesis textures, is repeatedly triggered by instrument 1. Instrument 2 is triggered once every 12.5s and these notes then last for 40s each so will overlap. Instrument 1 is played from the score for 1 hour so this entire process will last that length of time. Many of the parameters of granulation are chosen randomly when a note begins so that each note will have unique characteristics. The timestretch is created by a <a href="http://www.csounds.com/manual/html/line.html">line</a> function: the start and end points of which are defined randomly when the note begins. Grain/window size and window size randomization are defined randomly when a note begins - notes with smaller window sizes will have a fuzzy airy quality wheres notes with a larger window size will produce a clearer tone. Each note will be randomly transposed (within a range of +/- 2 octaves) but that transposition will be quantized to a rounded number of semitones - this is done as a response to the equally tempered nature of source sound material used.</p>
<p>Each entire note is enveloped by an amplitude envelope and a resonant lowpass filter in each case encasing each note under a smooth arc. Finally a small amount of reverb is added to smooth the overall texture slightly<br />
</p>
<p><strong>   <em>EXAMPLE 05G02.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example written by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

; the name of the sound file used is defined as a string variable -
; - as it will be used twice in the code.
; This simplifies adapting the orchestra to use a different sound file
gSfile = &quot;ClassicalGuitar.wav&quot;

; waveform used for granulation
giSound  ftgen 1,0,2097152,1,gSfile,0,0,0

; window function - used as an amplitude envelope for each grain
giWFn   ftgen 2,0,16384,9,0.5,1,0

seed 0 ; seed the random generators from the system clock
gaSendL init 0  ; initialize global audio variables
gaSendR init 0

  instr 1 ; triggers instrument 2
ktrigger  metro   0.08         ;metronome of triggers. One every 12.5s
schedkwhen ktrigger,0,0,2,0,40 ;trigger instr. 2 for 40s
  endin

  instr 2 ; generates granular synthesis textures
;define the input variables
ifn1        =          giSound
ilen        =          nsamp(ifn1)/sr
iPtrStart   random     1,ilen-1
iPtrTrav    random     -1,1
ktimewarp   line       iPtrStart,p3,iPtrStart+iPtrTrav
kamp        linseg     0,p3/2,0.2,p3/2,0
iresample   random     -24,24.99
iresample   =          semitone(int(iresample))
ifn2        =          giWFn
ibeg        =          0
iwsize      random     400,10000
irandw      =          iwsize/3
ioverlap    =          50
itimemode   =          1
; create a stereo granular synthesis texture using sndwarp
aSigL,aSigR sndwarpst  kamp,ktimewarp,iresample,ifn1,ibeg,\
                              iwsize,irandw,ioverlap,ifn2,itimemode
; envelope the signal with a lowpass filter
kcf         expseg     50,p3/2,12000,p3/2,50
aSigL       moogvcf2    aSigL, kcf, 0.5
aSigR       moogvcf2    aSigR, kcf, 0.5
; add a little of our audio signals to the global send variables -
; - these will be sent to the reverb instrument (2)
gaSendL     =          gaSendL+(aSigL*0.4)
gaSendR     =          gaSendR+(aSigR*0.4)
            outs       aSigL,aSigR
  endin

  instr 3 ; reverb (always on)
aRvbL,aRvbR reverbsc   gaSendL,gaSendR,0.85,8000
            outs       aRvbL,aRvbR
;clear variables to prevent out of control accumulation
            clear      gaSendL,gaSendR
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; p1 p2 p3
i 1  0  3600 ; triggers instr 2
i 3  0  3600 ; reverb instrument
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>granule - Clouds of Sound</h2>
<p>The <a href="http://www.csounds.com/manual/html/granule.html">granule</a> opcode is one of Csound's most complex opcodes requiring up to 22 input arguments in order to function. Only a few of these arguments are available during performance (k-rate) so it is less well suited for real-time modulation, for real-time a more nimble implementation such as <a href="http://www.csounds.com/manual/html/syncgrain.html">syncgrain</a>, <a href="http://www.csounds.com/manual/html/fog.html">fog</a>, or <a href="http://www.csounds.com/manual/html/grain3.html">grain3</a> would be recommended.<span> </span><span>For more complex </span><span>realtime granular techniques, the <a href="http://csounds.com/manual/html/partikkel.html" title="partikkel">partikkel</a> opcode can be used. The g</span>ranule opcode as used here, proves itself ideally suited at the production of massive clouds of granulated sound in which individual grains are often completed indistinguishable. There are still two important k-rate variables that have a powerful effect on the texture created when they are modulated during a note, they are: grain gap - effectively density - and grain size which will affect the clarity of the texture - textures with smaller grains will sound fuzzier and airier, textures with larger grains will sound clearer. In the following example <a href="http://www.csounds.com/manual/html/transeg.html">transeg</a> envelopes move the grain gap and grain size parameters through a variety of different states across the duration of each note.</p>
<p>With granule we define a number a grain streams for the opcode using its 'ivoice' input argument. This will also have an effect on the density of the texture produced. Like sndwarp's first timestretching mode, granule also has a stretch ratio parameter. Confusingly it works the other way around though, a value of 0.5 will slow movement through the file by 1/2, 2 will double is and so on. Increasing grain gap will also slow progress through the sound file. granule also provides up to four pitch shift voices so that we can create chord-like structures without having to use more than one iteration of the opcode. We define the number of pitch shifting voices we would like to use using the 'ipshift' parameter. If this is given a value of zero, all pitch shifting intervals will be ignored and grain-by-grain transpositions will be chosen randomly within the range +/-1 octave. granule contains built-in randomizing for several of it parameters in order to easier facilitate asynchronous granular synthesis. In the case of grain gap and grain size randomization these are defined as percentages by which to randomize the fixed values.</p>
<p>Unlike Csound's other granular synthesis opcodes, granule does not use a function table to define the amplitude envelope for each grain, instead attack and decay times are defined as percentages of the total grain duration using input arguments. The sum of these two values should total less than 100.<br />
</p>
<p>Five notes are played by this example. While each note explores grain gap and grain size in the same way each time, different permutations for the four pitch transpositions are explored in each note. Information about what these transpositions are, are printed to the terminal as each note begins.<br />
</p>
<p><strong>   <em>EXAMPLE 05G03.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac -m0
; activate real-time audio output and suppress note printing
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;waveforms used for granulation
giSoundL ftgen 1,0,1048576,1,&quot;ClassicalGuitar.wav&quot;,0,0,1
giSoundR ftgen 2,0,1048576,1,&quot;ClassicalGuitar.wav&quot;,0,0,2

seed 0; seed the random generators from the system clock
gaSendL init 0
gaSendR init 0

  instr 1 ; generates granular synthesis textures
            prints     p9
;define the input variables
kamp        linseg     0,1,0.1,p3-1.2,0.1,0.2,0
ivoice      =          64
iratio      =          0.5
imode       =          1
ithd        =          0
ipshift     =          p8
igskip      =          0.1
igskip_os   =          0.5
ilength     =          nsamp(giSoundL)/sr
kgap        transeg    0,20,14,4,       5,8,8,     8,-10,0,    15,0,0.1
igap_os     =          50
kgsize      transeg    0.04,20,0,0.04,  5,-4,0.01, 8,0,0.01,   15,5,0.4
igsize_os   =          50
iatt        =          30
idec        =          30
iseedL      =          0
iseedR      =          0.21768
ipitch1     =          p4
ipitch2     =          p5
ipitch3     =          p6
ipitch4     =          p7
;create the granular synthesis textures; one for each channel
aSigL  granule  kamp,ivoice,iratio,imode,ithd,giSoundL,ipshift,igskip,\
     igskip_os,ilength,kgap,igap_os,kgsize,igsize_os,iatt,idec,iseedL,\
     ipitch1,ipitch2,ipitch3,ipitch4
aSigR  granule  kamp,ivoice,iratio,imode,ithd,giSoundR,ipshift,igskip,\
     igskip_os,ilength,kgap,igap_os,kgsize,igsize_os,iatt,idec,iseedR,\
     ipitch1,ipitch2,ipitch3,ipitch4
;send a little to the reverb effect
gaSendL     =          gaSendL+(aSigL*0.3)
gaSendR     =          gaSendR+(aSigR*0.3)
            outs       aSigL,aSigR
  endin

  instr 2 ; global reverb instrument (always on)
; use reverbsc opcode for creating reverb signal
aRvbL,aRvbR reverbsc   gaSendL,gaSendR,0.85,8000
            outs       aRvbL,aRvbR
;clear variables to prevent out of control accumulation
            clear      gaSendL,gaSendR
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; p4 = pitch 1
; p5 = pitch 2
; p6 = pitch 3
; p7 = pitch 4
; p8 = number of pitch shift voices (0=random pitch)
; p1 p2  p3   p4  p5    p6    p7    p8    p9
i 1  0   48   1   1     1     1     4    &quot;pitches: all unison&quot;
i 1  +   .    1   0.5   0.25  2     4    \
  &quot;%npitches: 1(unison) 0.5(down 1 octave) 0.25(down 2 octaves) 2(up 1 octave)&quot;
i 1  +   .    1   2     4     8     4    &quot;%npitches: 1 2 4 8&quot;
i 1  +   .    1   [3/4] [5/6] [4/3] 4    &quot;%npitches: 1 3/4 5/6 4/3&quot;
i 1  +   .    1   1     1     1     0    &quot;%npitches: all random&quot;

i 2 0 [48*5+2]; reverb instrument
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Grain delay effect</h2>
<p>Granular techniques can be used to implement a flexible delay effect, where we can do transposition, time modification and disintegration of the sound into small particles, all within the delay effect itself. To implement this effect, we record live audio into a buffer (Csound table), and let the granular synthesizer/generator read sound for the grains from this buffer. We need a granular synthesizer that allows manual control over the read start point for each grain, since the relationship between the write position and the read position in the buffer determines the delay time. We've used the fof2 opcode for this purpose here.</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
; activate real-time audio output and suppress note printing
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example by Oeyvind Brandtsegg</code></pre>
<pre><code>sr = 44100
ksmps = 512
nchnls = 2
0dbfs = 1

; empty table, live audio input buffer used for granulation
giTablen  = 131072
giLive    ftgen 0,0,giTablen,2,0  

; sigmoid rise/decay shape for fof2, half cycle from bottom to top
giSigRise ftgen 0,0,8192,19,0.5,1,270,1		

; test sound
giSample  ftgen 0,0,524288,1,&quot;fox.wav&quot;, 0,0,0

instr 1
; test sound, replace with live input
  a1      loscil 1, 1, giSample, 1
  	  outch 1, a1
          chnmix a1, &quot;liveAudio&quot;
endin

instr 2
; write live input to buffer (table)
  a1      chnget &quot;liveAudio&quot;
  gkstart tablewa giLive, a1, 0
  if gkstart &lt; giTablen goto end
  gkstart = 0
  end:
  a0      = 0
          chnset a0, &quot;liveAudio&quot;
endin

instr 3
; delay parameters
  kDelTim = 0.5			; delay time in seconds (max 2.8 seconds)
  kFeed   = 0.8
; delay time random dev
  kTmod	  = 0.2
  kTmod   rnd31 kTmod, 1
  kDelTim = kDelTim+kTmod
; delay pitch random dev
  kFmod   linseg 0, 1, 0, 1, 0.1, 2, 0, 1, 0
  kFmod	  rnd31 kFmod, 1
 ; grain delay processing
  kamp	  = ampdbfs(-8)
  kfund   = 25 ; grain rate
  kform   = (1+kFmod)*(sr/giTablen) ; grain pitch transposition
  koct    = 0
  kband   = 0
  kdur    = 2.5 / kfund ; duration relative to grain rate
  kris    = 0.5*kdur
  kdec    = 0.5*kdur
  kphs    = (gkstart/giTablen)-(kDelTim/(giTablen/sr)) ; calculate grain phase based on delay time
  kgliss  = 0
  a1     fof2 1, kfund, kform, koct, kband, kris, kdur, kdec, 100, \
      giLive, giSigRise, 86400, kphs, kgliss 
          outch     2, a1*kamp
          chnset a1*kFeed, &quot;liveAudio&quot;
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 20
i 2 0 20
i 3 0 20
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt; </code></pre>
</pre>
<h2>Conclusion</h2>
<p>Two contrasting opcodes for granular synthesis have been considered in this chapter but this is in no way meant to suggest that these are the best, in fact it is strongly recommended to explore all of Csound's other opcodes as they each have their own unique character. The <a href="http://www.csounds.com/manual/html/syncgrain.html">syncgrain</a> family of opcodes (including also <a href="http://www.csounds.com/manual/html/syncloop.html">syncloop</a> and <a href="http://www.csounds.com/manual/html/diskgrain.html">diskgrain</a>) are deceptively simple as their k-rate controls encourages further abstractions of grain manipulation, <a href="http://www.csounds.com/manual/html/fog.html">fog</a>is designed for FOF synthesis type synchronous granulation but with sound files and <a href="http://www.csounds.com/manual/html/partikkel.html">partikkel</a> offers a comprehensive control of grain characteristics on a grain-by-grain basis inspired by Curtis Roads' encyclopedic book on granular synthesis 'Microsound'.<br />
</p>
<p><span id="ch039_h-convolution.xhtml"></span></p>
<h1>CONVOLUTION</h1>
<p>Convolution is a mathematical procedure whereby one function is modified by another. Applied to audio, one of these functions might be a sound file or a stream of live audio whilst the other will be, what is referred to as, an impulse response file; this could actually just be another shorter sound file. The longer sound file or live audio stream will be modified by the impulse response so that the sound file will be imbued with certain qualities of the impulse response. It is important to be aware that convolution is a far from trivial process and that realtime performance may be a frequent consideration. Effectively every sample in the sound file to be processed will be multiplied in turn by every sample contained within the impulse response file. Therefore, for a 1 second impulse response at a sampling frequency of 44100 hertz, each and every sample of the input sound file or sound stream will undergo 44100 multiplication operations. Expanding upon this even further, for 1 second's worth of a convolution procedure this will result in 44100 x 44100 (or 1,944,810,000) multiplications. This should provide some insight into the processing demands of a convolution procedure and also draw attention to the efficiency cost of using longer impulse response files.<br />
</p>
<p>The most common application of convolution in audio processing is reverberation but convolution is equally adept at, for example, imitating the filtering and time smearing characteristics of vintage microphones, valve amplifiers and speakers. It is also used sometimes to create more unusual special effects. The strength of convolution based reverbs is that they implement acoustic imitations of actual spaces based upon 'recordings' of those spaces. All the quirks and nuances of the original space will be retained. Reverberation algorithms based upon networks of comb and allpass filters create only idealised reverb responses imitating spaces that don't actually exist. The impulse response is a little like a 'fingerprint' of the space. It is perhaps easier to manipulate characteristics such as reverb time and high frequency diffusion (i.e. lowpass filtering) of the reverb effect when using a Schroeder derived algorithm using comb and allpass filters but most of these modification are still possible, if not immediately apparent, when implementing reverb using convolution. The quality of a convolution reverb is largely dependent upon the quality of the impulse response used. An impulse response recording is typically achieved by recording the reverberant tail that follows a burst of white noise. People often employ techniques such as bursting balloons to achieve something approaching a short burst of noise. Crucially the impulse sound should not excessively favour any particular frequency or exhibit any sort of resonance. More modern techniques employ a sine wave sweep through all the audible frequencies when recording an impulse response. Recorded results using this technique will normally require further processing in order to provide a usable impulse response file and this approach will normally be beyond the means of a beginner. <br />
</p>
<p>Many commercial, often expensive, implementations of convolution exist both in the form of software and hardware but fortunately Csound provides easy access to convolution for free. Csound currently lists six different opcodes for convolution, <a href="http://www.csounds.com/manual/html/convolve.html">convolve (convle)</a>, <a href="http://www.csounds.com/manual/html/cross2.html">cross2</a>, <a href="http://www.csounds.com/manual/html/dconv.html">dconv</a>, <a href="http://www.csounds.com/manual/html/ftconv.html">ftconv</a>, <a href="http://www.csounds.com/manual/html/ftmorf.html">ftmorf</a> and <a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a>. <a href="http://www.csounds.com/manual/html/convolve.html">convolve (convle)</a> and <a href="http://www.csounds.com/manual/html/dconv.html">dconv</a> are earlier implementations and are less suited to realtime operation, <a href="http://www.csounds.com/manual/html/cross2.html">cross2</a> relates to FFT-based cross synthesis and <a href="http://www.csounds.com/manual/html/ftmorf.html">ftmorf</a> is used to morph between similar sized function table and is less related to what has been discussed so far, therefore in this chapter we shall focus upon just two opcodes, <a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a> and <a href="http://www.csounds.com/manual/html/ftconv.html">ftconv.</a></p>
<h2>pconvolve</h2>
<p><a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a> is perhaps the easiest of Csound's convolution opcodes to use and the most useful in a realtime application. It uses the uniformly partitioned (hence the 'p') overlap-save algorithm which permits convolution with very little delay (latency) in the output signal. The impulse response file that it uses is referenced directly, i.e. it does not have to be previously loaded into a function table, and multichannel files are permitted. The impulse response file can be any standard sound file acceptable to Csound and does not need to be pre-analysed as is required by <a href="http://www.csounds.com/manual/html/convolve.html">convolve</a>. Convolution procedures through their very nature introduce a delay in the output signal but <a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a> minimises this using the algorithm mentioned above. It will still introduce some delay but we can control this using the opcode's 'ipartitionsize' input argument. What value we give this will require some consideration and perhaps some experimentation as choosing a high partition size will result in excessively long delays (only an issue in realtime work) whereas very low partition sizes demand more from the CPU and too low a size may result in buffer under-runs and interrupted realtime audio. Bear in mind still that realtime CPU performance will depend heavily on the length of the impulse file. The partition size argument is actually an optional argument and if omitted it will default to whatever the software buffer size is as defined by the -b command line flag. If we specify the partition size explicitly however, we can use this information to delay the input audio (after it has been used by pconvolve) so that it can be realigned in time with the latency affected audio output from pconvolve - this will be essential in creating a 'wet/dry' mix in a reverb effect. Partition size is defined in sample frames therefore if we specify a partition size of 512, the delay resulting from the convolution procedure will be 512/sr (sample rate).</p>
<p>In the following example a monophonic drum loop sample undergoes processing through a convolution reverb implemented using <a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a> which in turn uses two different impulse files. The first file is a more conventional reverb impulse file taken in a stairwell whereas the second is a recording of the resonance created by striking a terracota bowl sharply. If you wish to use the three sound files I have used in creating this example the mono input sound file is <a href="http://www.iainmccurdy.org/CsoundRealtimeExamples/SourceMaterials/loop.wav">here</a> and the two stereo sound files used as impulse responses are <a href="http://www.iainmccurdy.org/CsoundRealtimeExamples/SourceMaterials/stairwell.wav">here</a> and <a href="http://www.iainmccurdy.org/CsoundRealtimeExamples/SourceMaterials/dish.wav">here</a>. You can, of course, replace them with ones of your own but remain mindful of mono/stereo/multichannel integrity.</p>
<h4><em>EXAMPLE 05H01.csd</em><br />
</h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;

sr     =  44100
ksmps  =  512
nchnls =  2
0dbfs  =  1

gasig init 0

 instr 1 ; sound file player
gasig           diskin2   p4,1,0,1
 endin

 instr 2 ; convolution reverb
; Define partion size.
; Larger values require less CPU but result in more latency.
; Smaller values produce lower latency but may cause -
; - realtime performance issues
ipartitionsize	=	  256
ar1,ar2	        pconvolve gasig, p4,ipartitionsize
; create a delayed version of the input signal that will sync -
; - with convolution output
adel            delay     gasig,ipartitionsize/sr
; create a dry/wet mix
aMixL           ntrpol    adel,ar1*0.1,p5
aMixR           ntrpol    adel,ar2*0.1,p5
                outs      aMixL,aMixR
gasig	        =         0
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; instr 1. sound file player
;    p4=input soundfile
; instr 2. convolution reverb
;    p4=impulse response file
;    p5=dry/wet mix (0 - 1)

i 1 0 8.6 &quot;loop.wav&quot;
i 2 0 10 &quot;Stairwell.wav&quot; 0.3

i 1 10 8.6 &quot;loop.wav&quot;
i 2 10 10 &quot;Dish.wav&quot; 0.8
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>ftconv</h2>
<p><a href="http://www.csounds.com/manual/html/ftconv.html">ftconv</a> (abbreviated from 'function table convolution) is perhaps slightly more complicated to use than <a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a> but offers additional options. The fact that <a href="http://www.csounds.com/manual/html/ftconv.html">ftconv</a> utilises an impulse response that we must first store in a function table rather than directly referencing a sound file stored on disk means that we have the option of performing transformations upon the audio stored in the function table before it is employed by <a href="http://www.csounds.com/manual/html/ftconv.html">ftconv</a> for convolution. This example begins just as the previous example: a mono drum loop sample is convolved first with a typical reverb impulse response and then with an impulse response derived from a terracotta bowl. After twenty seconds the contents of the function tables containing the two impulse responses are reversed by calling a UDO (instrument 3) and the convolution procedure is repeated, this time with a 'backwards reverb' effect. When the reversed version is performed the dry signal is delayed further before being sent to the speakers so that it appears that the reverb impulse sound occurs at the culmination of the reverb build-up. This additional delay is switched on or off via p6 from the score. As with pconvolve, ftconv performs the convolution process in overlapping partitions to minimise latency. Again we can minimise the size of these partitions and therefore the latency but at the cost of CPU efficiency. ftconv's documentation refers to this partition size as 'iplen' (partition length). ftconv offers further facilities to work with multichannel files beyond stereo. When doing this it is suggested that you use <a href="http://www.csounds.com/manual/html/GEN52.html">GEN52</a> which is designed for this purpose. <a href="http://www.csounds.com/manual/html/GEN01.html">GEN01</a> seems to work fine, at least up to stereo, provided that you do not defer the table size definition (size=0). With ftconv we can specify the actual length of the impulse response - it will probably be shorter than the power-of-2 sized function table used to store it - and this action will improve realtime efficiency. This optional argument is defined in sample frames and defaults to the size of the impulse response function table.<em></em></p>
<h4><em>EXAMPLE 05H02.csd</em></h4>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;

sr     =  44100
ksmps  =  512
nchnls =  2
0dbfs  =  1

; impulse responses stored as stereo GEN01 function tables
giStairwell	ftgen	1,0,131072,1,&quot;Stairwell.wav&quot;,0,0,0
giDish		ftgen	2,0,131072,1,&quot;Dish.wav&quot;,0,0,0

gasig init 0

; reverse function table UDO
 opcode	tab_reverse,0,i
ifn             xin
iTabLen         =               ftlen(ifn)
iTableBuffer    ftgentmp        0,0,-iTabLen,-2, 0
icount          =               0
loop:
ival            table           iTabLen-icount-1, ifn
                tableiw         ival,icount,iTableBuffer
                loop_lt         icount,1,iTabLen,loop
icount          =               0
loop2:
ival            table           icount,iTableBuffer
                tableiw		ival,icount,ifn
                loop_lt         icount,1,iTabLen,loop2
 endop

 instr 3 ; reverse the contents of a function table
          tab_reverse p4
 endin

 instr 1 ; sound file player
gasig           diskin2   p4,1,0,1
 endin

 instr 2 ; convolution reverb
; buffer length
iplen	=	1024
; derive the length of the impulse response
iirlen	=	nsamp(p4)
ar1,ar2	ftconv	gasig, p4, iplen,0, iirlen
; delay compensation. Add extra delay if reverse reverb is used.
adel            delay     gasig,(iplen/sr) + ((iirlen/sr)*p6)
; create a dry/wet mix
aMixL   ntrpol    adel,ar1*0.1,p5
aMixR   ntrpol    adel,ar2*0.1,p5
        outs      aMixL,aMixR
gasig	        =         0
 endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; instr 1. sound file player
;    p4=input soundfile
; instr 2. convolution reverb
;    p4=impulse response file
;    p5=dry/wet mix (0 - 1)
;    p6=reverse reverb switch (0=off,1=on)
; instr 3. reverse table contents
;    p4=function table number

; &#39;stairwell&#39; impulse response
i 1 0 8.5 &quot;loop.wav&quot;
i 2 0 10 1 0.3 0

; &#39;dish&#39; impulse response
i 1 10 8.5 &quot;loop.wav&quot;
i 2 10 10 2 0.8 0

; reverse the impulse responses
i 3 20 0 1
i 3 20 0 2

; &#39;stairwell&#39; impulse response (reversed)
i 1 21 8.5 &quot;loop.wav&quot;
i 2 21 10 1 0.5 1

; &#39;dish&#39; impulse response (reversed)
i 1 31 8.5 &quot;loop.wav&quot;
i 2 31 10 2 0.5 1

e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer</code></pre>
<p>Suggested avenues for further exploration with ftconv could be applying envelopes to, filtering and time stretching and compressing the function table stored impulse files before use in convolution.</p>
<p>The impulse responses I have used here are admittedly of rather low quality and whilst it is always recommended to maintain as high standards of sound quality as possible the user should not feel restricted from exploring the sound transformation possibilities possible form whatever source material they may have lying around. Many commercial convolution algorithms demand a proprietary impulse response format inevitably limiting the user to using the impulse responses provided by the software manufacturers but with Csound we have the freedom to use any sound we like.<br />
</p>
<p><span></span></p>
<p><span id="ch040_i-fourier-analysis-spectral-processing.xhtml"></span></p>
<h1>FOURIER TRANSFORMATION / SPECTRAL PROCESSING</h1>
<p>A fourier transformation (FT) is used to transfer an audio-signal from time-domain to the frequency-domain. This can, for instance, be used to analyze and visualize the spectrum of the signal appearing in a certain time span. Fourier transform and subsequent manipulations in the frequency domain open a wide area of interesting sound transformations, like time stretching, pitch shifting and much more.<br />
</p>
<h2><strong>How does it work?</strong></h2>
<p>The mathematician J.B. Fourier (1768-1830) developed a method to approximate unknown functions by using trigonometric functions. The advantage of this was, that the properties of the trigonometric functions (sin &amp; cos) were well-known and helped to describe the properties of the unknown function.</p>
<p>In music, a fourier transformed signal is decomposed into its sum of sinoids. In easy words: Fourier transform is the opposite of additive synthesis. Ideally, a sound can be splitted by Fourier transformation into its partial components, and resynthesized again by adding these components.<br />
</p>
<p>Because of sound beeing represented as discrete samples in the computer, the computer implementation calculates a discrete Fourier transform (DFT). As each transformation needs a certain number of samples, one main decision in performing DFT is about the number of samples used. The analysis of the frequency components is better the more samples are used for it. But as samples are progression in time, a caveat must be found for each FT in music between either better time resolution (fewer samples) or better frequency resolution (more samples). A typical value for FT in music is to have about 20-100 &quot;snapshots&quot; per second (which can be compared to the single frames in a film or video).</p>
<p>At a sample rate of 48000 samples per second, these are about 500-2500 samples for one frame or window. The standard method for DFT in computer music works with window sizes which are power-of-two samples long, for instance 512, 1024 or 2048 samples. The reason for this restriction is that DFT for these power-of-two sized frames can be calculated much faster. So it is called Fast Fourier Transform (FFT), and this is the standard implementation of the Fourier transform in audio applications.<br />
</p>
<h2><strong>How to do it in Csound?</strong></h2>
<p>As usual, there is not just one way to work with FFT and spectral processing in Csound. There are several families of opcodes. Each family can be very useful for a specific approach of working in the frequency domain. Have a look at the <a href="http://www.csounds.com/manual/html/SpectralTop.html">Spectral Processing</a> overview in the Csound Manual. This introduction will focus on the so-called &quot;Phase Vocoder Streaming&quot; opcodes (all these opcodes begin with the charcters &quot;pvs&quot;) which came into Csound by the work of Richard Dobson, Victor Lazzarini and others. They are designed to work in realtime in the frequency domain in Csound; and indeed they are not just very fast but also easier to use than FFT implementations in some other applications.</p>
<h2>Changing from Time-domain to Frequency-domain<br />
</h2>
<p>For dealing with signals in the frequency domain, the pvs opcodes implement a new signal type, the <strong>f-signals</strong>. Csound shows the type of a variable in the first letter of its name. Each audio signal starts with an <strong>a</strong>, each control signal with a <strong>k</strong>, and so each signal in the frequency domain used by the pvs-opcodes starts with an <strong>f</strong>.</p>
<p>There are several ways to create an f-signal. The most common way is to convert an audio signal to a frequency signal. The first example covers two typical situations:</p>
<ul>
<li>the audio signal derives from playing back a soundfile from the hard disc (instr 1)</li>
<li>the audio signal is the live input (instr 2)</li>
</ul>
<p>(Be careful - the example can produce a feedback three seconds after the start. Best results are with headphones.)</p>
<p><em><strong>EXAMPLE 05I01.csd</strong></em> <span id="ch040_i-fourier-analysis-spectral-processing.xhtml#InsertNoteID_8_marker9" class="InsertNoteMarker"><sup><a href="i-fourier-analysis-spectral-processing#InsertNoteID_8">1</a></sup></span> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc -o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
;uses the file &quot;fox.wav&quot; (distributed with the Csound Manual)
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

;general values for fourier transform
gifftsiz  =         1024
gioverlap =         256
giwintyp  =         1 ;von hann window

instr 1 ;soundfile to fsig
asig      soundin   &quot;fox.wav&quot;
fsig      pvsanal   asig, gifftsiz, gioverlap, gifftsiz*2, giwintyp
aback     pvsynth   fsig
          outs      aback, aback
endin

instr 2 ;live input to fsig
          prints    &quot;LIVE INPUT NOW!%n&quot;
ain       inch      1 ;live input from channel 1
fsig      pvsanal   ain, gifftsiz, gioverlap, gifftsiz, giwintyp
alisten   pvsynth   fsig
          outs      alisten, alisten
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3
i 2 3 10
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt; </code></pre>
<p>You should hear first the &quot;fox.wav&quot; sample, and then, the slightly delayed live input signal. The delay depends first on the general settings for realtime input (ksmps, -b and -B: see chapter 2D). But second, there is also a delay added by the FFT. The window size here is 1024 samples, so the additional delay is 1024/44100 = 0.023 seconds. If you change the window size <em>gifftsiz</em> to 2048 or to 512 samples, you should get a larger or shorter delay. - So for realtime applications, the decision about the FFT size is not only a question &quot;better time resolution versus better frequency resolution&quot;, but it is also a question of tolerable latency.</p>
<p>What happens in the example above? At first, the audio signal (<em>asig, ain</em>) is being analyzed and transformed in an f-signal. This is done via the opcode <a href="http://www.csounds.com/manual/html/pvsanal.html">pvsanal</a>. Then nothing happens but transforming the frequency domain signal back into an audio signal. This is called inverse Fourier transformation (IFT or IFFT) and is done by the opcode <a href="http://www.csounds.com/manual/html/pvsynth.html">pvsynth</a>.<span id="ch040_i-fourier-analysis-spectral-processing.xhtml#InsertNoteID_18_marker19" class="InsertNoteMarker"><sup><a href="i-fourier-analysis-spectral-processing#InsertNoteID_18">2</a></sup></span>  In this case, it is just a test: to see if everything works, to hear the results of different window sizes, to check the latency. But potentially you can insert any other pvs opcode(s) in between this entrance and exit:</p>
<p> </p>
<p><img src="static/04ISchema_1.png" width="600" height="104" /></p>
<p><br />
</p>
<h2>Pitch shifting</h2>
<p>Simple pitch shifting can be done by the opcode <a href="http://www.csounds.com/manual/html/pvscale.html">pvscale</a>. All the frequency data in the f-signal are scaled by a certain value. Multiplying by 2 results in transposing an octave upwards; multiplying by 0.5 in transposing an octave downwards. For accepting cent values instead of ratios as input, the <a href="http://www.csounds.com/manual/html/cent.html">cent</a> opcode can be used.</p>
<p><em><strong>EXAMPLE 05I02.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by joachim heintz
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

gifftsize =         1024
gioverlap =         gifftsize / 4
giwinsize =         gifftsize
giwinshape =        1; von-Hann window

instr 1 ;scaling by a factor
ain       soundin  &quot;fox.wav&quot;
fftin     pvsanal  ain, gifftsize, gioverlap, giwinsize, giwinshape
fftscal   pvscale  fftin, p4
aout      pvsynth  fftscal
          out      aout
endin

instr 2 ;scaling by a cent value
ain       soundin  &quot;fox.wav&quot;
fftin     pvsanal  ain, gifftsize, gioverlap, giwinsize, giwinshape
fftscal   pvscale  fftin, cent(p4)
aout      pvsynth  fftscal
          out      aout/3
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 3 1; original pitch
i 1 3 3 .5; octave lower
i 1 6 3 2 ;octave higher
i 2 9 3 0
i 2 9 3 400 ;major third
i 2 9 3 700 ;fifth
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Pitch shifting via FFT resynthesis is very simple in general, but more or less complicated in detail. With speech for instance, there is a problem because of the formants. If you simply scale the frequencies, the formants are shifted, too, and the sound gets the typical &quot;Mickey-Mousing&quot; effect. There are some parameters in the <em>pvscale</em> opcode, and some other pvs-opcodes which can help to avoid this, but the result always depends on the individual sounds and on your ideas.</p>
<h2>Time stretch/compress<br />
</h2>
<p>As the Fourier transformation seperates the spectral information from the progression in time, both elements can be varied independently. Pitch shifting via the <em>pvscale</em> opcode, as in the previous example, is independent from the speed of reading the audio data. The complement is changing the time without changing the pitch: time stretching or time compression.</p>
<p>The simplest way to alter the speed of a sampled sound is using <a href="http://www.csounds.com/manual/html/pvstanal.html">pvstanal</a> (which is new in Csound 5.13). This opcode transforms a sound which is stored in a function table, in an f-signal, and time manipulations are simply done by altering the <em>ktimescal</em> parameter.</p>
<p><em><strong>Example 05I03.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by joachim heintz
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

;store the sample &quot;fox.wav&quot; in a function table (buffer)
gifil     ftgen     0, 0, 0, 1, &quot;fox.wav&quot;, 0, 0, 1

;general values for the pvstanal opcode
giamp     =         1 ;amplitude scaling
gipitch   =         1 ;pitch scaling
gidet     =         0 ;onset detection
giwrap    =         0 ;no loop reading
giskip    =         0 ;start at the beginning
gifftsiz  =         1024 ;fft size
giovlp    =         gifftsiz/8 ;overlap size
githresh  =         0 ;threshold

instr 1 ;simple time stretching / compressing
fsig      pvstanal  p4, giamp, gipitch, gifil, gidet, giwrap, giskip,
                    gifftsiz, giovlp, githresh
aout      pvsynth   fsig
          out       aout
endin

instr 2 ;automatic scratching
kspeed    randi     2, 2, 2 ;speed randomly between -2 and 2
kpitch    randi     p4, 2, 2 ;pitch between 2 octaves lower or higher
fsig      pvstanal  kspeed, 1, octave(kpitch), gifil
aout      pvsynth   fsig
aenv      linen     aout, .003, p3, .1
          out       aout
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
;         speed
i 1 0 3   1
i . + 10   .33
i . + 2   3
s
i 2 0 10 0;random scratching without ...
i . 11 10 2 ;... and with pitch changes
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Cross Synthesis </h2>
<p>Working in the frequency domain makes it possible to combine or &quot;cross&quot; the spectra of two sounds. As the Fourier transform of an analysis frame results in a frequency and an amplitude value for each frequency &quot;bin&quot;, there are many different ways of performing cross synthesis. The most common methods are:</p>
<ul>
<li>Combine the amplitudes of sound A with the frequencies of sound B. This is the classical phase vocoder approach. If the frequencies are not completely from sound B, but can be scaled between A and B, the crossing is more flexible and adjustable to the sounds being used. This is what <a href="http://www.csounds.com/manual/html/pvsvoc.html">pvsvoc</a> does. </li>
<li>Combine the frequencies of sound A with the amplitudes of sound B. Give more flexibility by scaling the amplitudes between A and B: <a href="http://www.csounds.com/manual/html/pvscross.html">pvscross</a>.</li>
<li>Get the frequencies from sound A. Multiply the amplitudes of A and B. This can be described as spectral filtering. <a href="http://www.csounds.com/manual/html/pvsfilter.html">pvsfilter</a> gives a flexible portion of this filtering effect.<br />
</li>
</ul>
<p>This is an example for phase vocoding. It is nice to have speech as sound A, and a rich sound, like classical music, as sound B. Here the &quot;fox&quot; sample is being played at half speed and &quot;sings&quot; through the music of sound B: <br />
</p>
<p><em><strong>EXAMPLE 05I04.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by joachim heintz
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

;store the samples in function tables (buffers)
gifilA    ftgen     0, 0, 0, 1, &quot;fox.wav&quot;, 0, 0, 1
gifilB    ftgen     0, 0, 0, 1, &quot;ClassGuit.wav&quot;, 0, 0, 1


;general values for the pvstanal opcode
giamp     =         1 ;amplitude scaling
gipitch   =         1 ;pitch scaling
gidet     =         0 ;onset detection
giwrap    =         1 ;loop reading
giskip    =         0 ;start at the beginning
gifftsiz  =         1024 ;fft size
giovlp    =         gifftsiz/8 ;overlap size
githresh  =         0 ;threshold

instr 1
;read &quot;fox.wav&quot; in half speed and cross with classical guitar sample
fsigA     pvstanal  .5, giamp, gipitch, gifilA, gidet, giwrap, giskip,
                     gifftsiz, giovlp, githresh
fsigB     pvstanal  1, giamp, gipitch, gifilB, gidet, giwrap, giskip,
                     gifftsiz, giovlp, githresh
fvoc      pvsvoc    fsigA, fsigB, 1, 1	
aout      pvsynth   fvoc
aenv      linen     aout, .1, p3, .5
          out       aout
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 11
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The next example introduces <em>pvscross</em>:</p>
<p><em><strong>EXAMPLE 05I05.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by joachim heintz
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

;store the samples in function tables (buffers)
gifilA    ftgen     0, 0, 0, 1, &quot;BratscheMono.wav&quot;, 0, 0, 1
gifilB    ftgen     0, 0, 0, 1, &quot;fox.wav&quot;, 0, 0, 1

;general values for the pvstanal opcode
giamp     =         1 ;amplitude scaling
gipitch   =         1 ;pitch scaling
gidet     =         0 ;onset detection
giwrap    =         1 ;loop reading
giskip    =         0 ;start at the beginning
gifftsiz  =         1024 ;fft size
giovlp    =         gifftsiz/8 ;overlap size
githresh  =         0 ;threshold

instr 1
;cross viola with &quot;fox.wav&quot; in half speed
fsigA     pvstanal  1, giamp, gipitch, gifilA, gidet, giwrap, giskip,
                    gifftsiz, giovlp, githresh
fsigB     pvstanal  .5, giamp, gipitch, gifilB, gidet, giwrap, giskip,
                     gifftsiz, giovlp, githresh
fcross    pvscross  fsigA, fsigB, 0, 1	
aout      pvsynth   fcross
aenv      linen     aout, .1, p3, .5
          out       aout
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 11
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The last example shows spectral filtering via <em>pvsfilter</em>. The well-known &quot;fox&quot; (sound A) is now filtered by the viola (sound B). Its resulting intensity depends on the amplitudes of sound B, and if the amplitudes are strong enough, you hear a resonating effect:<br />
</p>
<p><em><strong>EXAMPLE 05I06.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example by joachim heintz
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

;store the samples in function tables (buffers)
gifilA    ftgen     0, 0, 0, 1, &quot;fox.wav&quot;, 0, 0, 1
gifilB    ftgen     0, 0, 0, 1, &quot;BratscheMono.wav&quot;, 0, 0, 1

;general values for the pvstanal opcode
giamp     =         1 ;amplitude scaling
gipitch   =         1 ;pitch scaling
gidet     =         0 ;onset detection
giwrap    =         1 ;loop reading
giskip    =         0 ;start at the beginning
gifftsiz  =         1024 ;fft size
giovlp    =         gifftsiz/4 ;overlap size
githresh  =         0 ;threshold

instr 1
;filters &quot;fox.wav&quot; (half speed) by the spectrum of the viola (double speed)
fsigA     pvstanal  .5, giamp, gipitch, gifilA, gidet, giwrap, giskip,
                     gifftsiz, giovlp, githresh
fsigB     pvstanal  2, 5, gipitch, gifilB, gidet, giwrap, giskip,
                     gifftsiz, giovlp, githresh
ffilt     pvsfilter fsigA, fsigB, 1	
aout      pvsynth   ffilt
aenv      linen     aout, .1, p3, .5
          out       aout
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 11
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt; </code></pre>
<p>There are much more ways of working with the pvs opcodes. Have a look at the <em>Signal Processing II</em> section of the <em>Opcodes Overview</em> to find some hints.<br />
</p>
<p><br />
</p>
<ol>
<li><span id="ch040_i-fourier-analysis-spectral-processing.xhtml#InsertNoteID_8">All soundfiles used in this manual are free and can be downloaded at www.csound-tutorial.net<span id="ch040_i-fourier-analysis-spectral-processing.xhtml#InsertNoteID_8_LinkBacks"><sup><a href="i-fourier-analysis-spectral-processing#InsertNoteID_8_marker9">^</a></sup></span></span></li>
<li><span id="ch040_i-fourier-analysis-spectral-processing.xhtml#InsertNoteID_18">For some cases it is good to have pvsadsyn as an alternative, which is using a bank of oscillators for resynthesis.<span id="ch040_i-fourier-analysis-spectral-processing.xhtml#InsertNoteID_18_LinkBacks"><sup><a href="i-fourier-analysis-spectral-processing#InsertNoteID_18_marker19">^</a></sup></span></span></li>
</ol>
<p><span id="ch042_a-record-and-play-soundfiles.xhtml"></span></p>
<h1>RECORD AND PLAY SOUNDFILES</h1>
<h2>Playing Soundfiles From Disk - diskin2</h2>
<p>The simplest way of playing a sound file from Csound is to use the <a href="http://www.csounds.com/manual/html/diskin2.html"><span>diskin2</span></a><span> </span><em></em><span>opcode. This opcode reads audio directly from the hard drive location where it is stored, i.e. it does not pre-load the sound file at initialisation time. This method of sound file playback is therefore good for playing back very long, or parts of very long, sound files. It is perhaps less well suited to playing back sound files where dense polyphony, multiple iterations and rapid random access to the file is required. In these situations reading from a function table or buffer is preferable.</span></p>
<p><span></span><a href="http://www.csounds.com/manual/html/diskin2.html"><span>diskin2</span></a><span> has additional parameters for speed of playback, and interpolation</span><em></em><span>.</span></p>
<p>   <em><strong>EXAMPLE 06A01.csd</strong></em>  <br />
</p>
<pre class="western"><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activate real-time audio output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1	

  instr	1 ; play audio from disk
kSpeed  init     1           ; playback speed
iSkip   init     0           ; inskip into file (in seconds)
iLoop   init     0           ; looping switch (0=off 1=on)
; read audio from disk using diskin2 opcode
a1      diskin2  &quot;loop.wav&quot;, kSpeed, iSkip, iLoop
        out      a1          ; send audio to outputs
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 6
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Writing Audio to Disk</h2>
<p>The traditional method of rendering Csound's audio to disk is to specify a sound file as the audio destination in the Csound command or under &lt;CsOptions&gt;, in fact before real-time performance became a possibility this was the only way in which Csound was used. With this method, all audio that is piped to the output using <em>out, outs</em><span> etc. will be written to this file. The number of channels that the file will conatain will be determined by the number of channels specified in the orchestra header using 'nchnls'. The disadvantage of this method is that we cannot simultaneously listen to the audio in real-time.</span></p>
<p>   <em><strong>EXAMPLE 06A02.csd</strong></em>   <br />
</p>
<pre class="western"><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; audio output destination is given as a sound file (wav format specified)
; this method is for deferred time performance,
; simultaneous real-time audio will not be possible
-oWriteToDisk1.wav -W
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr     =  44100
ksmps  =  32
nchnls =  1	
0dbfs  =  1

giSine  ftgen  0, 0, 4096, 10, 1             ; a sine wave

  instr	1 ; a simple tone generator
aEnv    expon    0.2, p3, 0.001              ; a percussive envelope
aSig    poscil   aEnv, cpsmidinn(p4), giSine ; audio oscillator
        out      aSig                        ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; two chords
i 1   0 5 60
i 1 0.1 5 65
i 1 0.2 5 67
i 1 0.3 5 71

i 1   3 5 65
i 1 3.1 5 67
i 1 3.2 5 73
i 1 3.3 5 78
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Writing Audio to Disk with Simultaneous Real-time Audio Output - fout and monitor<br />
</h2>
<p>Recording audio output to disk whilst simultaneously monitoring in real-time is best achieved through combining the opcodes <a href="http://www.csounds.com/manual/html/monitor.html">monitor</a> and <a href="http://www.csounds.com/manual/html/fout.html">fout</a><span>. 'monitor' can be used to create an audio signal that consists of a mix of all audio output from all instruments. This audio signal can then be rendered to a sound file on disk using 'fout'. 'monitor' can read multi-channel outputs but its number of outputs should correspond to the number of channels defined in the header using 'nchnls'. In this example it is reading just in mono. 'fout' can write audio in a number of formats and bit depths and it can also write multi-channel sound files. </span></p>
<p>   <em><strong>EXAMPLE 06A03.csd</strong></em>   <br />
</p>
<pre class="western"><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activate real-time audio output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example written by Iain McCurdy

sr      =       44100
ksmps   =       32
nchnls  =       1	
0dbfs   =       1

giSine  ftgen  0, 0, 4096, 10, 1 ; a sine wave
gaSig   init   0; set initial value for global audio variable (silence)

  instr	1 ; a simple tone generator
aEnv    expon    0.2, p3, 0.001              ; percussive amplitude envelope
aSig    poscil   aEnv, cpsmidinn(p4), giSine ; audio oscillator
        out      aSig
  endin

  instr 2 ; write to a file (always on in order to record everything)
aSig    monitor                              ; read audio from output bus
        fout     &quot;WriteToDisk2.wav&quot;,4,aSig   ; write audio to file (16bit mono)
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; activate recording instrument to encapsulate the entire performance
i 2 0 8.3

; two chords
i 1   0 5 60
i 1 0.1 5 65
i 1 0.2 5 67
i 1 0.3 5 71

i 1   3 5 65
i 1 3.1 5 67
i 1 3.2 5 73
i 1 3.3 5 78
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer</code></pre>
<p><span id="ch043_b-record-and-play-buffers.xhtml"></span></p>
<h1>RECORD AND PLAY BUFFERS</h1>
<h2>Playing Audio From RAM - flooper2</h2>
<p><span>Csound offers many opcodes for playing back sound files that have first been loaded into a function table (and therefore are loaded into RAM). Some of these offer higher quality at the expense of computation speed some are simpler and less fully featured.</span></p>
<p><span>One of the newer and easier to use opcodes for this task is </span><a href="http://www.csounds.com/manual/html/flooper2.html"><span>flooper2</span></a><em></em><span>. As its name might suggest it is intended for the playback of files with looping. </span><span>'flooper2'</span> <em></em> <span>can also apply a cross-fade between the end and the beginning of the loop in order to smooth the transition where looping takes place.</span></p>
<p><span>In the following example a sound file that has been loaded into a GEN01 function table is played back using </span><span>'flooper2</span><span>'. </span><span>'flooper2'</span><span> also includes a parameter for modulating playback speed/pitch</span><em>.</em><span> There is also the option of modulating the loop points at k-rate. In this example the entire file is simply played and looped. You can replace the sound file with one of your own or you can download the one used in the example from <a href="b-record-and-play-buffers/www.iainmccurdy.org/csoundrealtimeexamples/sourcematerials/loop.wav">here</a>:</span><br />
</p>
<h3>Some notes about GEN01 and function table sizes:</h3>
<p>When storing sound files in GEN01 function tables we must ensure that we define a table of sufficient size to store our sound file. Normally function table sizes should be powers of 2 (2, 4, 8, 16, 32 etc.). If we know the duration of our sound file we can derive the required table size by multiplying this duration by the sample rate and then choosing the next power of 2 larger than this. For example when the sampling rate is 44100, we will require 44100 table locations to store 1 second of audio; but 44100 is not a power of 2 so we must choose the next power of 2 larger than this which is 65536. (Hint: you can discover a sound file's duration by using Csound's 'sndinfo' utility.)<br />
</p>
<p>There are some 'lazy' options however: if we underestimate the table size, when we then run Csound it will warn us that this table size is too small and conveniently inform us via the terminal what the minimum size required to store the entire file would be - we can then substitute this value in our GEN01 table. We can also overestimate the table size in which case Csound won't complain at all, but this is a rather inefficient approach.</p>
<p>If we give table size a value of zero we have what is referred to as 'deferred table size'. This means that Csound will calculate the exact table size needed to store our sound file and use this as the table size but this will probably not be a power of 2. Many of Csound's opcodes will work quite happily with non-power of 2 function table sizes, but not all! It is a good idea to know how to deal with power of 2 table sizes. We can also explicitly define non-power of 2 table sizes by prefacing the table size with a minus sign '-'.<br />
</p>
<p>All of the above discussion about required table sizes assumed that the sound file was mono, to store a stereo sound file will naturally require twice the storage space, for example, 1 second of stereo audio will require 88200 storage locations. GEN01 will indeed store stereo sound files and many of Csound's opcodes will read from stereo GEN01 function tables, but again not all! We must be prepared to split stereo sound files, either to two sound files on disk or into two function tables using GEN01's 'channel' parameter (p8), depending on the opcodes we are using.</p>
<p>Storing audio in GEN01 tables as mono channels with non-deferred and power of 2 table sizes will ensure maximum compatibility.<br />
</p>
<p>   <em><strong>EXAMPLE 06B01.csd</strong></em>  </p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac ; activate real-time audio
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1	
0dbfs   =       1

; STORE AUDIO IN RAM USING GEN01 FUNCTION TABLE
giSoundFile   ftgen   0, 0, 262144, 1, &quot;loop.wav&quot;, 0, 0, 0

  instr	1 ; play audio from function table using flooper2 opcode
kAmp         =         1   ; amplitude
kPitch       =         p4  ; pitch/speed
kLoopStart   =         0   ; point where looping begins (in seconds)
kLoopEnd     =         nsamp(giSoundFile)/sr; loop end (end of file)
kCrossFade   =         0   ; cross-fade time
; read audio from the function table using the flooper2 opcode
aSig         flooper2  kAmp,kPitch,kLoopStart,kLoopEnd,kCrossFade,giSoundFile
             out       aSig ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
; p4 = pitch
; (sound file duration is 4.224)
i 1 0 [4.224*2] 1
i 1 + [4.224*2] 0.5
i 1 + [4.224*1] 2
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Csound's Built-in Record-Play Buffer - sndloop</h2>
<p>Csound has an opcode called <a href="http://www.csounds.com/manual/html/sndloop.html">sndloop</a> which provides a simple method of recording some audio into a buffer and then playing it back immediately. The duration of audio storage required is defined when the opcode is initialized. In the following example two seconds is provided. Once activated, as soon as two seconds of live audio has been recorded by 'sndloop', it<em></em> immediately begins playing it back in a loop. 'sndloop' <em></em> <span>allows us to modulate the speed/pitch of the played back audio as well as providing the option of defining a crossfade time between the end and the beginning of the loop. </span>In the example pressing 'r' on the computer keyboard activates record followed by looped playback, pressing 's' stops record or playback, pressing '+' increases the speed and therefore the pitch of playback and pressing '-' decreases the speed/pitch of playback. If playback speed is reduced below zero it enters the negative domain in which case playback will be reversed.</p>
<p>You will need to have a microphone connected to your computer in order to use this example.<br />
</p>
<p>   <em><strong>EXAMPLE 06B02.csd</strong></em>  </p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; real-time audio in and out are both activated
-iadc -odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1	

  instr	1
; PRINT INSTRUCTIONS
           prints  &quot;Press &#39;r&#39; to record, &#39;s&#39; to stop playback, &quot;
           prints  &quot;&#39;+&#39; to increase pitch, &#39;-&#39; to decrease pitch.\\n&quot;
; SENSE KEYBOARD ACTIVITY
kKey sensekey; sense activity on the computer keyboard
aIn        inch    1             ; read audio from first input channel
kPitch     init    1             ; initialize pitch parameter
iDur       init    2             ; inititialize duration of loop parameter
iFade      init    0.05          ; initialize crossfade time parameter
 if kKey = 114 then              ; if &#39;r&#39; has been pressed...
kTrig      =       1             ; set trigger to begin record-playback
 elseif kKey = 115 then          ; if &#39;s&#39; has been pressed...
kTrig      =       0             ; set trigger to turn off record-playback
 elseif kKey = 43 then           ; if &#39;+&#39; has been pressed...
kPitch     =       kPitch + 0.02 ; increment pitch parameter
 elseif kKey = 95 then           ; if &#39;-&#39; has been pressed
kPitch     =       kPitch - 0.02 ; decrement pitch parameter
 endif                           ; end of conditional branches
; CREATE SNDLOOP INSTANCE
aOut, kRec sndloop aIn, kPitch, kTrig, iDur, iFade ; (kRec output is not used)
           out     aOut          ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 3600 ; instr 1 plays for 1 hour
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Recording to and Playback from a Function Table</h2>
<p>Writing to and reading from buffers can also be achieved through the use of Csound's opcodes for table reading and writing operations. Although the procedure is a little more complicated than that required for 'sndloop'<span> it is ultimately more flexible. In the next example separate instruments are used for recording to the table and for playing back from the table. Another instrument which runs constantly scans for activity on the computer keyboard and activates the record or playback instruments accordingly. For writing to the table we will use the </span><a href="http://www.csounds.com/manual/html/tablew.html">tablew</a><span> opcode and for reading from the table we will use the <a href="http://www.csounds.com/manual/html/table.html">table</a></span><span> opcode (if we were to modulate the playback speed it would be better to use one of Csound's interpolating variations of '</span>table<span>' such as </span><a href="http://www.csounds.com/manual/html/tablei.html">tablei</a><span> or </span><a href="http://www.csounds.com/manual/html/table3.html">table3</a><span>. Csound writes individual values to table locations, the exact table locations being defined by an 'index'</span><em></em><span>. For writing continuous audio to a table this index will need to be continuously moving 1 location for every sample. This moving index (or 'pointer') can be created with an a-rate <a href="http://www.csounds.com/manual/html/line.html">line</a> or a <a href="http://www.csounds.com/manual/html/phasor.html">phasor</a>. The next example uses 'line'</span><span>. When using Csound's table operation opcodes we first need to create that table, either in the orchestra header or in the score. The duration of the audio buffer can be calculated from the size of the table. In this example the table is 2^17 points long, that is 131072 points. The duration in seconds is this number divided by the sample rate which in our example is 44100Hz. Therefore maximum storage duration for this example is 131072/44100 which is around 2.9 seconds.</span></p>
<p>   <em><strong>EXAMPLE 06B03.csd</strong></em>    </p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; real-time audio in and out are both activated
-iadc -odac -d -m0
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; example written by Iain McCurdy

sr 	= 	44100
ksmps 	= 	32
nchnls 	= 	1

giBuffer ftgen  0, 0, 2^17, 7, 0; table for audio data storage
maxalloc 2,1 ; allow only one instance of the recording instrument at a time!

  instr	1 ; Sense keyboard activity. Trigger record or playback accordingly.
           prints  &quot;Press &#39;r&#39; to record, &#39;p&#39; for playback.\\n&quot;
iTableLen  =       ftlen(giBuffer)  ; derive buffer function table length
idur       =       iTableLen / sr   ; derive storage time in seconds
kKey sensekey                       ; sense activity on the computer keyboard
  if kKey=114 then                  ; if ASCCI value of 114 (&#39;r&#39;) is output
event	&quot;i&quot;, 2, 0, idur, iTableLen  ; activate recording instrument (2)
  endif
 if kKey=112 then                   ; if ASCCI value of 112 (&#39;p) is output
event	&quot;i&quot;, 3, 0, idur, iTableLen  ; activate playback instrument
 endif
  endin

  instr 2 ; record to buffer
iTableLen  =        p4              ; table/recording length in samples
; -- print progress information to terminal --
           prints   &quot;recording&quot;
           printks  &quot;.&quot;, 0.25       ; print &#39;.&#39; every quarter of a second
krelease   release                  ; sense when note is in final k-rate pass...
 if krelease=1 then                 ; then ..
           printks  &quot;\\ndone\\n&quot;, 0 ; ... print a message
 endif
; -- write audio to table --
ain        inch     1               ; read audio from live input channel 1
andx       line     0,p3,iTableLen  ; create an index for writing to table
           tablew   ain,andx,giBuffer ; write audio to function table
endin

  instr 3 ; playback from buffer
iTableLen  =        p4              ; table/recording length in samples
; -- print progress information to terminal --
           prints   &quot;playback&quot;
           printks  &quot;.&quot;, 0.25       ; print &#39;.&#39; every quarter of a second
krelease   release                  ; sense when note is in final k-rate pass
 if krelease=1 then                 ; then ...
           printks  &quot;\\ndone\\n&quot;, 0 ; ... print a message
 endif; end of conditional branch
; -- read audio from table --
aNdx       line     0, p3, iTableLen; create an index for reading from table
a1         table    aNdx, giBuffer  ; read audio to audio storage table
           out      a1              ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 3600 ; Sense keyboard activity. Start recording - playback.
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>Encapsulating Record and Play Buffer Functionality to a UDO</h2>
<p>Recording and playing of buffers can also be encapsulated into a User Defined Opcode. For being flexible in the size of the buffer, the <em>tabw</em> opcode will be used for writing audio data to a buffer. <em>tabw</em> writes to a table of any size and does not need a power-of-two table size like <em>tablew</em>.<br />
An empty table (buffer) of any size can be created with a negative number as size. A table for recording 10 seconds of audio data can be created in this way:<br />
</p>
<pre><code>giBuf1    ftgen    0, 0, -(10*sr), 2, 0</code></pre>
<p>The used can decide whether he wants to assign a certain number to the table, or whether he lets Csound do this job, calling the table via its variable, in this case giBuf1. This is a UDO for creating a mono buffer, and another UDO for creating a stereo buffer:<br />
</p>
<pre><code> opcode BufCrt1, i, io
ilen, inum xin
ift       ftgen     inum, 0, -(ilen*sr), 2, 0
          xout      ift
 endop

 opcode BufCrt2, ii, io
ilen, inum xin
iftL      ftgen     inum, 0, -(ilen*sr), 2, 0
iftR      ftgen     inum, 0, -(ilen*sr), 2, 0
          xout      iftL, iftR
 endop </code></pre>
<p>This simplifies the procedure of creating a record/play buffer, because the user is just asked for the length of the buffer. A number can be given, but by default Csound will assign this number. This statement will create an empty stereo table for 5 seconds of recording:<br />
</p>
<pre><code>iBufL,iBufR BufCrt2   5</code></pre>
<p>A first, simple version of a UDO for recording will just write the incoming audio to sequential locations of the table. This can be done by setting the <em>ksmps</em> value to 1 inside this UDO (setksmps 1), so that each audio sample has its own discrete k-value. In this way the write index for the table can be assigned via the statement andx=kndx, and increased by one for the next k-cycle. An additional k-input turns recording on and of:<br />
</p>
<pre><code> opcode BufRec1, 0, aik
ain, ift, krec  xin
          setksmps  1
if krec == 1 then ;record as long as krec=1
kndx      init      0
andx      =         kndx
          tabw      ain, andx, ift
kndx      =         kndx+1
endif
 endop</code></pre>
<p>The reading procedure is simple, too. Actually the same code can be used; it is sufficient just to replace the opcode for writing (<em>tabw</em>) with the opcode for reading (<em>tab</em>):<br />
</p>
<pre><code> opcode BufPlay1, a, ik
ift, kplay  xin
          setksmps  1
if kplay == 1 then ;play as long as kplay=1
kndx      init      0
andx      =         kndx
aout      tab       andx, ift
kndx      =         kndx+1
endif
 endop</code></pre>
<p>So - let's use these first simple UDOs in a Csound instrument. Press the &quot;r&quot; key as long as you want to record, and the &quot;p&quot; key for playing back. Note that you must disable the key repeats on your computer keyboard for this example (in QuteCsound, disable &quot;Allow key repeats&quot; in Configuration -&gt; General).<br />
</p>
<p>   <em><strong>EXAMPLE 06B04.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc -o dac -d -m0
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example written by Joachim Heintz
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

  opcode BufCrt1, i, io
ilen, inum xin
ift       ftgen     inum, 0, -(ilen*sr), 2, 0
          xout      ift
  endop

  opcode BufRec1, 0, aik
ain, ift, krec  xin
          setksmps  1
imaxindx  =         ftlen(ift)-1 ;max index to write
knew      changed   krec
if krec == 1 then ;record as long as krec=1
 if knew == 1 then ;reset index if restarted
kndx      =         0
 endif
kndx      =         (kndx &gt; imaxindx ? imaxindx : kndx)
andx      =         kndx
          tabw      ain, andx, ift
kndx      =         kndx+1
endif
  endop

  opcode BufPlay1, a, ik
ift, kplay  xin
          setksmps  1
imaxindx  =         ftlen(ift)-1 ;max index to read
knew      changed   kplay
if kplay == 1 then ;play as long as kplay=1
 if knew == 1 then ;reset index if restarted
kndx      =         0
 endif
kndx      =         (kndx &gt; imaxindx ? imaxindx : kndx)
andx      =         kndx
aout      tab       andx, ift
kndx      =         kndx+1
endif
          xout      aout
  endop

  opcode KeyStay, k, kkk
;returns 1 as long as a certain key is pressed
key, k0, kascii    xin ;ascii code of the key (e.g. 32 for space)
kprev     init      0 ;previous key value
kout      =         (key == kascii || (key == -1 &amp;&amp; kprev == kascii) ? 1 : 0)
kprev     =         (key &gt; 0 ? key : kprev)
kprev     =         (kprev == key &amp;&amp; k0 == 0 ? 0 : kprev)
          xout      kout
  endop

  opcode KeyStay2, kk, kk
;combines two KeyStay UDO&#39;s (this way is necessary
;because just one sensekey opcode is possible in an orchestra)
kasci1, kasci2 xin ;two ascii codes as input
key,k0    sensekey
kout1     KeyStay   key, k0, kasci1
kout2     KeyStay   key, k0, kasci2
          xout      kout1, kout2
  endop


instr 1
ain        inch      1 ;audio input on channel 1
iBuf       BufCrt1   3 ;buffer for 3 seconds of recording
kRec,kPlay KeyStay2  114, 112 ;define keys for record and play
           BufRec1   ain, iBuf, kRec ;record if kRec=1
aout       BufPlay1  iBuf, kPlay ;play if kPlay=1
           out       aout ;send out
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Let's realize now a more extended and easy to operate version of these two UDO's for recording and playing a buffer. The wishes of a user might be the following:</p>
<p><strong>Recording:</strong><br />
</p>
<ul>
<li>allow recording not just from the beginning of the buffer, but also from any arbitrary starting point <em>kstart</em><br />
</li>
<li>allow circular recording (wrap around) if the end of the buffer has been reached: <em>kwrap=1</em><br />
</li>
</ul>
<p><strong>Playing:</strong></p>
<ul>
<li>play back with different speed <em>kspeed</em> (negaitve speed means playing backwards)<br />
</li>
<li>start playback at any point of the buffer <em>kstart</em><br />
</li>
<li>end playback at any point of the buffer <em>kend</em><br />
</li>
<li>allow certain modes of wraparound <em>kwrap</em> while playing:</li>
</ul>
<blockquote>

</blockquote>
<ul>
<ul>
<li>kwrap=0 stops at the defined end point of the buffer</li>
<li>kwrap=1 repeats playback between defined end and start points</li>
<li>kwrap=2 starts at a the defined starting point but wraps between end point and beginning of the buffer</li>
<li>kwrap=3 wraps between <em>kstart</em> and the end of the table</li>
</ul>
</ul>
<p>The following example provides versions of <em>BufRec</em> and <em>BufPlay</em> which do this job. We will use the table3 opcode instead of the simple tab or table opcodes in this case, because we want to translate any number of samples in the table to any number of output samples by different speed values:</p>
<p><img src="/csound/_v/1.0/http:/en.flossmanuals.net/floss/pub/Csound" width="0" height="0" /></p>
<p><img src="static/Csound-Picts-06_Samples-101124table3-en.png" title="101124table3" alt="101124table3" width="605" height="643" /> </p>
<p>For higher or lower speed values than the original record speed, interpolation must be used in between certain sample values if the original shape of the wave is to be reproduced as accurately as possible. This job is performed with high quality by <a href="http://www.csounds.com/manual/html/table3.html">table3</a> which employs cubic interpolation.</p>
<p>In a typical application of recording and playing buffer buffers, the ability to interact with the process will be paramount. We can benefit from having interactive access to the following:</p>
<ul>
<li>starting and stopping record</li>
</ul>
<ul>
<li>adjusting the start and end points of recording</li>
<li>use or prevent wraparound while recording</li>
<li>starting and stopping playback</li>
<li>adjusting the start and end points of playback</li>
<li>adjusting wraparound in playback at one of the specified modes (1 - 4) </li>
<li>applying volume at playback</li>
</ul>
<p>These interactions could be carried out via widgets, MIDI, OSC or something else. As we want to provide examples which can be used with any Csound frontend here, we are restricted to triggering the record and play events by hitting the space bar of the computer keyboard. (See the QuteCsound version of this example for a more interactive version.)</p>
<p>   <em><strong>EXAMPLE 06B05.csd</strong></em>  <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-i adc -o dac -d
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;example written by joachim heintz
sr = 44100
ksmps = 32
nchnls = 2
0dbfs = 1

  opcode BufCrt2, ii, io ;creates a stereo buffer
ilen, inum xin ;ilen = length of the buffer (table) in seconds
iftL      ftgen     inum, 0, -(ilen*sr), 2, 0
iftR      ftgen     inum, 0, -(ilen*sr), 2, 0
          xout      iftL, iftR
  endop

  opcode BufRec1, k, aikkkk ;records to a buffer
ain, ift, krec, kstart, kend, kwrap xin
		setksmps	1
kendsmps	=		kend*sr ;end point in samples
kendsmps	=		(kendsmps == 0 || kendsmps &gt; ftlen(ift) ? ftlen(ift) : kendsmps)
kfinished	=		0
knew		changed	krec ;1 if record just started
 if krec == 1 then
  if knew == 1 then
kndx		=		kstart * sr - 1 ;first index to write
  endif
  if kndx &gt;= kendsmps-1 &amp;&amp; kwrap == 1 then
kndx		=		-1
  endif
  if kndx &lt; kendsmps-1 then
kndx		=		kndx + 1
andx		=		kndx
		tabw		ain, andx, ift
  else
kfinished	=		1
  endif
 endif
 		xout		kfinished
  endop

  opcode BufRec2, k, aaiikkkk ;records to a stereo buffer
ainL, ainR, iftL, iftR, krec, kstart, kend, kwrap xin
kfin      BufRec1     ainL, iftL, krec, kstart, kend, kwrap
kfin      BufRec1     ainR, iftR, krec, kstart, kend, kwrap
          xout        kfin
  endop

  opcode BufPlay1, ak, ikkkkkk
ift, kplay, kspeed, kvol, kstart, kend, kwrap xin
;kstart = begin of playing the buffer in seconds
;kend = end of playing in seconds. 0 means the end of the table
;kwrap = 0: no wrapping. stops at kend (positive speed) or kstart
;  (negative speed).this makes just sense if the direction does not
;  change and you just want to play the table once
;kwrap = 1: wraps between kstart and kend
;kwrap = 2: wraps between 0 and kend
;kwrap = 3: wraps between kstart and end of table
;CALCULATE BASIC VALUES
kfin		init		0
iftlen		=		ftlen(ift)/sr ;ftlength in seconds
kend		=		(kend == 0 ? iftlen : kend) ;kend=0 means end of table
kstart01	=		kstart/iftlen ;start in 0-1 range
kend01		=		kend/iftlen ;end in 0-1 range
kfqbas		=		(1/iftlen) * kspeed ;basic phasor frequency
;DIFFERENT BEHAVIOUR DEPENDING ON WRAP:
if kplay == 1 &amp;&amp; kfin == 0 then
 ;1. STOP AT START- OR ENDPOINT IF NO WRAPPING REQUIRED (kwrap=0)
 if kwrap == 0 then
; -- phasor freq so that 0-1 values match distance start-end
kfqrel		=		kfqbas / (kend01-kstart01)
andxrel	phasor 	kfqrel ;index 0-1 for distance start-end
; -- final index for reading the table (0-1)
andx		=		andxrel * (kend01-kstart01) + (kstart01)
kfirst		init		1 ;don&#39;t check condition below at the first k-cycle (always true)
kndx		downsamp	andx
kprevndx	init		0
 ;end of table check:
  ;for positive speed, check if this index is lower than the previous one
  if kfirst == 0 &amp;&amp; kspeed &gt; 0 &amp;&amp; kndx &lt; kprevndx then
kfin		=		1
 ;for negative speed, check if this index is higher than the previous one
  else
kprevndx	=		(kprevndx == kstart01 ? kend01 : kprevndx)
   if kfirst == 0 &amp;&amp; kspeed &lt; 0 &amp;&amp; kndx &gt; kprevndx then
kfin		=		1
   endif
kfirst		=		0 ;end of first cycle in wrap = 0
  endif
 ;sound out if end of table has not yet reached
asig		table3		andx, ift, 1	
kprevndx	=		kndx ;next previous is this index
 ;2. WRAP BETWEEN START AND END (kwrap=1)
 elseif kwrap == 1 then
kfqrel		=		kfqbas / (kend01-kstart01) ;same as for kwarp=0
andxrel	phasor 	kfqrel
andx		=		andxrel * (kend01-kstart01) + (kstart01)
asig		table3		andx, ift, 1	;sound out
 ;3. START AT kstart BUT WRAP BETWEEN 0 AND END (kwrap=2)
 elseif kwrap == 2 then
kw2first	init		1
  if kw2first == 1 then ;at first k-cycle:
		reinit		wrap3phs ;reinitialize for getting the correct start phase
kw2first	=		0
  endif
kfqrel		=		kfqbas / kend01 ;phasor freq so that 0-1 values match distance start-end
wrap3phs:
andxrel	phasor 	kfqrel, i(kstart01) ;index 0-1 for distance start-end
		rireturn	;end of reinitialization
andx		=		andxrel * kend01 ;final index for reading the table
asig		table3		andx, ift, 1	;sound out
 ;4. WRAP BETWEEN kstart AND END OF TABLE(kwrap=3)
 elseif kwrap == 3 then
kfqrel		=		kfqbas / (1-kstart01) ;phasor freq so that 0-1 values match distance start-end
andxrel	phasor 	kfqrel ;index 0-1 for distance start-end
andx		=		andxrel * (1-kstart01) + kstart01 ;final index for reading the table
asig		table3		andx, ift, 1	
 endif
else ;if either not started or finished at wrap=0
asig		=		0 ;don&#39;t produce any sound
endif
  		xout		asig*kvol, kfin
  endop

  opcode BufPlay2, aak, iikkkkkk ;plays a stereo buffer
iftL, iftR, kplay, kspeed, kvol, kstart, kend, kwrap xin
aL,kfin   BufPlay1     iftL, kplay, kspeed, kvol, kstart, kend, kwrap
aR,kfin   BufPlay1     iftR, kplay, kspeed, kvol, kstart, kend, kwrap
          xout         aL, aR, kfin
  endop

  opcode In2, aa, kk ;stereo audio input
kchn1, kchn2 xin
ain1      inch      kchn1
ain2      inch      kchn2
          xout      ain1, ain2
  endop

  opcode Key, kk, k
;returns &#39;1&#39; just in the k-cycle a certain key has been pressed (kdown)
;  or released (kup)
kascii    xin ;ascii code of the key (e.g. 32 for space)
key,k0    sensekey
knew      changed   key
kdown     =         (key == kascii &amp;&amp; knew == 1 &amp;&amp; k0 == 1 ? 1 : 0)
kup       =         (key == kascii &amp;&amp; knew == 1 &amp;&amp; k0 == 0 ? 1 : 0)
          xout      kdown, kup
  endop

instr 1
giftL,giftR BufCrt2   3 ;creates a stereo buffer for 3 seconds
gainL,gainR In2     1,2 ;read input channels 1 and 2 and write as global audio
          prints    &quot;PLEASE PRESS THE SPACE BAR ONCE AND GIVE AUDIO INPUT
                     ON CHANNELS 1 AND 2.\n&quot;
          prints    &quot;AUDIO WILL BE RECORDED AND THEN AUTOMATICALLY PLAYED
                     BACK IN SEVERAL MANNERS.\n&quot;
krec,k0   Key       32
 if krec == 1 then
          event     &quot;i&quot;, 2, 0, 10
 endif
endin

instr 2
; -- records the whole buffer and returns 1 at the end
kfin      BufRec2   gainL, gainR, giftL, giftR, 1, 0, 0, 0
  if kfin == 0 then
          printks   &quot;Recording!\n&quot;, 1
  endif
 if kfin == 1 then
ispeed    random    -2, 2
istart    random    0, 1
iend      random    2, 3
iwrap     random    0, 1.999
iwrap     =         int(iwrap)
printks &quot;Playing back with speed = %.3f, start = %.3f, end = %.3f,
                    wrap = %d\n&quot;, p3, ispeed, istart, iend, iwrap
aL,aR,kf  BufPlay2  giftL, giftR, 1, ispeed, 1, istart, iend, iwrap
  if kf == 0 then
          printks   &quot;Playing!\n&quot;, 1
  endif
 endif
krel      release
 if kfin == 1 &amp;&amp; kf == 1 || krel == 1 then
          printks   &quot;PRESS SPACE BAR AGAIN!\n&quot;, p3
          turnoff
 endif
          outs      aL, aR
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 1000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p><br />
</p>
<p><span id="ch045_a-receiving-events-by-midiin.xhtml"></span></p>
<h1>RECEIVING EVENTS BY MIDIIN</h1>
<p>Csound provides a variety of opcodes, such as <a href="http://www.csounds.com/manual/html/cpsmidi.html" title="cpsmidi">cpsmidi</a>, <a href="http://www.csounds.com/manual/html/ampmidi.html" title="ampmidi">ampmidi</a> and <a href="http://www.csounds.com/manual/html/ctrl7.html" title="ctrl7">ctrl7</a> which allow for transparent interpretation of incoming midi data. These opcodes allow us to read in midi information without us having to worry about parsing status bytes and so on. Occasionally when we are involved in more complex midi interaction, it might be advantageous for us to scan all raw midi information that is coming into Csound. The <a href="file:///C:/Program%20Files/Csound/doc/manual/midiin.html" title="midiin">midiin</a> opcode allows us to do this.</p>
<p>In the next example a simple midi monitor is constructed. Incoming midi events are printed to the terminal with some formatting to make them readable. We can disable Csound's default instrument triggering mechanism (which in this example we don't want) by giving the line:</p>
<pre><code>massign 0,0 </code></pre>
<p>just after the header statement (sometimes referred to as instrument 0).</p>
<p>For this example to work you will need to ensure that you have activated live midi input within Csound, either by using the <a href="http://www.csounds.com/manual/html/CommandFlagsCategory.html#FlagsCatMinusUpperM">-M flag</a> or from within the QuteCsound configuration menu, and that you have a midi keyboard or controller connected. You may also want to include the <a href="http://www.csounds.com/manual/html/CommandFlags.html#FlagsMinusLowerM">-m0 flag</a> which will disable some of Csound's additional messaging output and therefore allow our midi printout to be presented more clearly.<br />
</p>
<p>The status byte tells us what sort of midi information has been received. For example, a value of 144 tells us that a midi note event has been received, a value of 176 tells us that a midi controller event has been received, a value of 224 tells us that pitch bend has been received and so on.</p>
<p>The meaning of the two data bytes depends on what sort of status byte has been received. For example if a midi note event has been received then data byte 1 gives us the note velocity and data byte 2 gives us the note number, if a midi controller event has been received then data byte 1 gives us the controller number and data byte 2 gives us the controller value. <br />
</p>
<p><strong>   <em>EXAMPLE 07A01.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-Ma -m0
; activates all midi devices, suppress note printings
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

; no audio so &#39;sr&#39; or &#39;nchnls&#39; aren&#39;t relevant
ksmps = 32

; using massign with these arguments disables default instrument triggering
massign	0,0

  instr 1
kstatus, kchan, kdata1, kdata2  midiin            ;read in midi
ktrigger  changed  kstatus, kchan, kdata1, kdata2 ;trigger if midi data changes
 if	 ktrigger=1&amp;&amp;kstatus!=0	then              ;if status byte is non-zero...
; -- print midi data to the terminal with formatting --
 printks &quot;status:%d%tchannel:%d%tdata1:%d%tdata2:%d%n&quot;\
                                    ,0,kstatus,kchan,kdata1,kdata2
 endif
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 3600 ; instr 1 plays for 1 hour
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The principle advantage of the <em>midiin</em> opcode is that, unlike opcodes such as <em>cpsmidi</em>, <em>ampmidi</em> and <em>ctrl7</em> which only receive specific midi data types on a specific channel, <em>midiin</em> 'listens' to all incoming data including system exclusive. In situations where elaborate Csound instrument triggering mappings that are beyond the default triggering mechanism's capabilities, are required then the use for <em>midiin</em> might be beneficial.<br />
</p>
<p><span id="ch046_b-triggering-instrument-instances.xhtml"></span></p>
<h1>TRIGGERING INSTRUMENT INSTANCES</h1>
<h2>Csound's Default System of Instrument Triggering Via Midi<br />
</h2>
<p>Csound has a default system for instrument triggering via midi. Provided a midi keyboard has been connected and the appropriate commmand line flags for midi input have been set (see <a href="http://en.flossmanuals.net/bin/view/Csound/CONFIGURINGMIDI">configuring midi</a> for further information) or the appropriate  settings have been made in QuteCsound's configuration menu, then midi notes received on midi channel 1 will trigger instrument 1, notes on channel 2 will trigger instrument 2 and so on. Instruments will turn on and off in sympathy with notes being pressed and released on the midi keyboard and Csound will correctly unravel polyphonic layering and turn on and off only the correct layer of the same instrument begin played. Midi activated notes can be thought of as 'held' notes, similar to notes activated in the score with a negative duration (p3). Midi activated notes will sustain indefinitely as long as the performance time will allow until a corresponding note off has been received - this is unless this infinite p3 duration is overwritten within the instrument itself by p3 begin explicitly defined.</p>
<p>The following example confirms this default mapping of midi channels to instruments. You will need a midi keyboard that allows you to change the midi channel on which it is transmmitting. Besides a written confirmation to the console of which instrument is begin triggered, there is an audible confirmation in that instrument 1 plays single pulses, instrument 2 plays sets of two pulses and instrument 3 plays sets of three pulses. The example does not go beyond three instruments. If notes are received on midi channel 4 and above, because corresonding instruments do not exist, notes on any of these channels will be directed to instrument 1.<br />
</p>
<p><strong> <em>  EXAMPLE 07B01.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-Ma -odac -m0
;activates all midi devices, real time sound output, and suppress note printings
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

gisine ftgen 0,0,2^12,10,1

  instr 1 ; 1 impulse (midi channel 1)
prints &quot;instrument/midi channel: %d%n&quot;,p1 ; print instrument number to terminal
reset:                                    ; label &#39;reset&#39;
     timout 0, 1, impulse                 ; jump to &#39;impulse&#39; for 1 second
     reinit reset                         ; reninitialize pass from &#39;reset&#39;
impulse:                                  ; label &#39;impulse&#39;
aenv expon     1, 0.3, 0.0001             ; a short percussive envelope
aSig poscil    aenv, 500, gisine          ; audio oscillator
     out       aSig                       ; audio to output
  endin

  instr 2 ; 2 impulses (midi channel 2)
prints &quot;instrument/midi channel: %d%n&quot;,p1
reset:
     timout 0, 1, impulse
     reinit reset
impulse:
aenv expon     1, 0.3, 0.0001
aSig poscil    aenv, 500, gisine
a2   delay     aSig, 0.15                 ; short delay adds another impulse
     out       aSig+a2                    ; mix two impulses at output
  endin

  instr 3 ; 3 impulses (midi channel 3)
prints &quot;instrument/midi channel: %d%n&quot;,p1
reset:
     timout 0, 1, impulse
     reinit reset
impulse:
aenv expon     1, 0.3, 0.0001
aSig poscil    aenv, 500, gisine
a2   delay     aSig, 0.15                 ; delay adds a 2nd impulse
a3   delay     a2, 0.15                   ; delay adds a 3rd impulse
     out       aSig+a2+a3                 ; mix the three impulses at output
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 300
e
&lt;/CsScore&gt;
&lt;CsoundSynthesizer&gt;</code></pre>
<h2>Using massign to Map MIDI Channels to Instruments</h2>
<p>We can use the <a href="http://www.csounds.com/manual/html/massign.html">massign</a> opcode, which is used just after the header statement, to explicitly map midi channels to specific instruments and thereby overrule Csound's default mappings. <em>massign</em> takes two input arguments, the first defines the midi channel to be redirected and the second stipulates which instrument it should be directed to. The following example is identical to the previous one except that the <em>massign</em> statements near the top of the orchestra jumble up the default mappings. Midi notes on channel 1 will be mapped to instrument 3, notes on channel 2 to instrument 1 and notes on channel 3 to instrument 2. Undefined channel mappings will be mapped according to the default arrangement and once again midi notes on channels for which an instrument does not exist will be mapped to instrument 1.<br />
</p>
<p><strong> <em>  EXAMPLE 07B02.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-Ma -odac -m0
; activate all midi devices, real time sound output, and suppress note printing
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

gisine ftgen 0,0,2^12,10,1

massign 1,3  ; channel 1 notes directed to instr 3
massign 2,1  ; channel 2 notes directed to instr 1
massign 3,2  ; channel 3 notes directed to instr 2

  instr 1 ; 1 impulse (midi channel 1)
iChn midichn                                  ; discern what midi channel
prints &quot;channel:%d%tinstrument: %d%n&quot;,iChn,p1 ; print instr num and midi channel
reset:                                        ; label &#39;reset&#39;
     timout 0, 1, impulse                     ; jump to &#39;impulse&#39; for 1 second
     reinit reset                             ; reninitialize pass from &#39;reset&#39;
impulse:                                      ; label &#39;impulse&#39;
aenv expon     1, 0.3, 0.0001                 ; a short percussive envelope
aSig poscil    aenv, 500, gisine              ; audio oscillator
     out       aSig                           ; send audio to output
  endin

  instr 2 ; 2 impulses (midi channel 2)
iChn midichn
prints &quot;channel:%d%tinstrument: %d%n&quot;,iChn,p1
reset:
     timout 0, 1, impulse
     reinit reset
impulse:
aenv expon     1, 0.3, 0.0001
aSig poscil    aenv, 500, gisine
a2   delay     aSig, 0.15                      ; delay generates a 2nd impulse
     out       aSig+a2                         ; mix two impulses at the output
  endin

  instr 3 ; 3 impulses (midi channel 3)
iChn midichn
prints &quot;channel:%d%tinstrument: %d%n&quot;,iChn,p1
reset:
     timout 0, 1, impulse
     reinit reset
impulse:
aenv expon     1, 0.3, 0.0001
aSig poscil    aenv, 500, gisine
a2   delay     aSig, 0.15                      ; delay generates a 2nd impulse
a3   delay     a2, 0.15                        ; delay generates a 3rd impulse
     out       aSig+a2+a3                      ; mix three impulses at output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
f 0 300
e
&lt;/CsScore&gt;

&lt;CsoundSynthesizer&gt;</code></pre>
<p><em>massign</em> also <em></em> has a couple of additional functions that may come in useful. A channel number of zero is interpreted as meaning 'any'. The following instruction will map notes on any and all channels to instrument 1.</p>
<pre><code>massign 0,1</code></pre>
<p>An instrument number of zero is interpreted as meaning 'none' so the following instruction will instruct Csound to ignore triggering for notes received on any and all channels.</p>
<pre><code>massign 0,0</code></pre>
<p>The above feature is useful when we want to scan midi data from an already active instrument using the <a href="http://www.csounds.com/manual/html/midiin.html">midiin</a> opcode, as we did in EXAMPLE 0701.csd.</p>
<h2>Using Multiple Triggering<br />
</h2>
<p>Csound's <a href="http://www.csounds.com/manual/html/event.html">event</a>/<a href="http://www.csounds.com/manual/html/event_i.html">event_i</a> opcode (see the <a href="http://en.flossmanuals.net/bin/view/Csound/TriggeringInstrumentEvents">Triggering Instrument Events chapter</a>) makes it possible to trigger any other instrument from a midi-triggered one. As you can assign a fractional number to an instrument, you can distinguish the single instances from each other. This is an example for using fractional instrument numbers.</p>
<p><strong> <em>  EXAMPLE 07B03.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-Ma
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz, using code of Victor Lazzarini
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

          massign   0, 1 ;assign all incoming midi to instr 1

  instr 1 ;global midi instrument, calling instr 2.cc.nnn (c=channel, n=note number)
inote     notnum    ;get midi note number
ichn      midichn   ;get midi channel
instrnum  =         2 + ichn/100 + inote/100000 ;make fractional instr number
     ; -- call with indefinite duration
           event_i   &quot;i&quot;, instrnum, 0, -1, ichn, inote
kend      release   ;get a &quot;1&quot; if instrument is turned off
 if kend == 1 then
          event     &quot;i&quot;, -instrnum, 0, 1 ;then turn this instance off
 endif
  endin

  instr 2
ichn      =         int(frac(p1)*100)
inote     =         round(frac(frac(p1)*100)*1000)
          prints    &quot;instr %f: ichn = %f, inote = %f%n&quot;, p1, ichn, inote
          printks   &quot;instr %f playing!%n&quot;, 1, p1
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>This example merely demonstrates a technique for passing information about MIDI channel and note number from the directly triggered instrument to a sub-instrument. A practical application for this would be in creating keygroups - triggering different instruments by playing in different regions of the keyboard. In this case you could change just the line:</p>
<pre><code>instrnum  =         2 + ichn/100 + inote/100000</code></pre>
<p>to this:</p>
<pre><code> if inote &lt; 48 then
instrnum  =         2
 elseif inote &lt; 72 then
instrnum  =         3
 else
instrnum  =         4
 endif
instrnum  =         instrnum + ichn/100 + inote/100000</code></pre>
<p>In this case you will call for any key below C3 instrument 2, for any key between C3 and B4 instrument 3, and for any higher key instrument 4.</p>
<p>By this multiple triggering you are also able to trigger more than one instrument at the same time (which is not possible by the <em>massign</em> opcode). This is an example using a User Defined Opcode (see the <a href="http://en.flossmanuals.net/bin/view/Csound/Userdefinedopcodes">UDO chapter</a> of this manual):</p>
<p><strong> <em>  EXAMPLE 07B04.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-Ma
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz, using code of Victor Lazzarini
sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

          massign   0, 1 ;assign all incoming midi to instr 1
giInstrs  ftgen     0, 0, -5, -2, 2, 3, 4, 10, 100 ;instruments to be triggered

 opcode MidiTrig, 0, io
;triggers the first inum instruments in the function table ifn by a midi event,
; with fractional numbers containing channel and note number information

; -- if inum=0 or not given, all instrument numbers in ifn are triggeredifn, inum  xin
inum      =         (inum == 0 ? ftlen(ifn) : inum)
inote     notnum
ichn      midichn
iturnon   =         0
turnon:
iinstrnum tab_i     iturnon, ifn
if iinstrnum &gt; 0 then
ifracnum  =         iinstrnum + ichn/100 + inote/100000
         event_i   &quot;i&quot;, ifracnum, 0, -1
endif
         loop_lt   iturnon, 1, inum, turnon
kend      release
if kend == 1 then
kturnoff  =         0
turnoff:
kinstrnum tab       kturnoff, ifn
 if kinstrnum &gt; 0 then
kfracnum  =         kinstrnum + ichn/100 + inote/100000
         event     &quot;i&quot;, -kfracnum, 0, 1
         loop_lt   kturnoff, 1, inum, turnoff
 endif
endif
 endop

 instr 1 ;global midi instrument
; -- trigger the first two instruments in the giInstrs table
         MidiTrig  giInstrs, 2
 endin

 instr 2
ichn      =         int(frac(p1)*100)
inote     =         round(frac(frac(p1)*100)*1000)
         prints    &quot;instr %f: ichn = %f, inote = %f%n&quot;, p1, ichn, inote
         printks   &quot;instr %f playing!%n&quot;, 1, p1
 endin

 instr 3
ichn      =         int(frac(p1)*100)
inote     =         round(frac(frac(p1)*100)*1000)
         prints    &quot;instr %f: ichn = %f, inote = %f%n&quot;, p1, ichn, inote
         printks   &quot;instr %f playing!%n&quot;, 1, p1
 endin


&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p><br />
</p>
<p><span id="ch047_c-working-with-controllers.xhtml"></span></p>
<h1>WORKING WITH CONTROLLERS</h1>
<h2>Scanning MIDI Continuous Controllers</h2>
<p>The most useful opcode for reading in midi continuous controllers is <a href="http://www.csounds.com/manual/html/ctrl7.html">ctrl7</a>. <span></span>'ctrl7's input arguments allow us to specify midi channel and controller number of the controller to be scanned in addition to giving us the option to rescale the received midi values between a new minimum and maximum value as defined by the 3rd and 4th input arguments. Further possibilities for modifying the data output are provided by the 5th (optional) argument which is used to point to a function table that reshapes the controllers output response to something other than linear. This can be useful when working with parameters which are normally expressed on a  logarithmic scale such as frequency.<br />
</p>
<p>The following example scans midi controller 1 on channel 1 and prints values received to the console. The minimum and maximum values are given as 0 and 127 therefore they are not rescaled at all. (Controller 1 is also the modulation wheel on a midi keyboard.)</p>
<p><strong>  <em>EXAMPLE 07C01.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-Ma -odac
; activate all MIDI devices
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

; &#39;sr&#39; and &#39;nchnls&#39; are irrelevant so are omitted
ksmps = 32

  instr 1
kCtrl    ctrl7    1,1,0,127    ; read in controller 1 on channel 1
kTrigger changed  kCtrl        ; if &#39;kCtrl&#39; changes generate a trigger (&#39;bang&#39;)
 if kTrigger=1 then
; Print kCtrl to console with formatting, but only when its value changes.
printks &quot;Controller Value: %d%n&quot;, 0, kCtrl
 endif
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 3600
e
&lt;/CsScore&gt;

&lt;CsoundSynthesizer&gt;</code></pre>
<p>There are also 14 bit and 21 bit versions of <em>ctrl7</em> (<a href="http://www.csounds.com/manual/html/ctrl14.html">ctrl14</a> and <a href="http://www.csounds.com/manual/html/ctrl21.html">ctrl21</a>) which improve upon the 7 bit resolution of 'ctrl7' but hardware that outputs 14 or 21 bit controller information is rare so these opcodes are seldom used.</p>
<h2>Scanning Pitch Bend and Aftertouch</h2>
<p>We can scan pitch bend and aftertouch in a similar way using the opcodes <a href="http://www.csounds.com/manual/html/pchbend.html">pchbend</a> and <a href="http://www.csounds.com/manual/html/aftouch.html">aftouch</a>. Once again we can specify minimum and maximum values with which to re-range the output. In the case of 'pchbend' we specify the value it outputs when the pitch bend wheel is at rest followed by a value which defines the entire range from when it is pulled to its minimum to when it is pushed to its maximum. In this example playing a key on the keyboard will play a note, the pitch of which can be bent up or down two semitones using the pitch bend wheel. Aftertouch can be used to modify the amplitude of the note while it is playing. Pitch bend and aftertouch data is also printed at the terminal whenever it changes. One thing to bear in mind is that for 'pchbend' to function the Csound instrument that contains it needs to have been activated by a MIDI event: you will need to play a midi note on your keyboard and then move the pitch bend wheel.</p>
<p><strong><em>  EXAMPLE 07C02.csd</em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-odac -Ma
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine  ftgen  0,0,2^10,10,1  ; a sine wave

  instr 1
; -- pitch bend --
kPchBnd  pchbend  0,4                ; read in pitch bend (range -2 to 2)
kTrig1   changed  kPchBnd            ; if &#39;kPchBnd&#39; changes generate a trigger
 if kTrig1=1 then
printks &quot;Pitch Bend:%f%n&quot;,0,kPchBnd  ; print kPchBnd to console when it changes
 endif

; -- aftertouch --
kAfttch  aftouch 0,0.9               ; read in aftertouch (range 0 to 0.9)
kTrig2   changed kAfttch             ; if &#39;kAfttch&#39; changes generate a trigger
 if kTrig2=1 then
printks &quot;Aftertouch:%d%n&quot;,0,kAfttch  ; print kAfttch to console when it changes
 endif

; -- create a sound --
iNum     notnum                      ; read in MIDI note number
; MIDI note number + pitch bend are converted to cycles per seconds
aSig     poscil   0.1,cpsmidinn(iNum+kPchBnd),giSine
         out      aSig               ; audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
f 0 300
e
&lt;/CsScore&gt;

&lt;CsoundSynthesizer&gt;</code></pre>
<h2>Initializing MIDI Controllers</h2>
<p>It may be useful to be able to define the beginning value of a midi controller that will be used in an orchestra - that is, the value it will adopt until its corresponding hardware control has been moved. Until a controller has been moved its value in Csound defaults to its minimum setting unless additional initialization has been carried out. It is important to be aware that midi controllers only send out information when they are moved, when lying idle they send out no information. As an example, if we imagine we have an Csound instrument in which the output volume is controlled by a midi controller it might prove to be slightly frustrating that each time the orchestra is launched, this instrument will remain silent until the volume control is moved. This frustration might become greater when many midi controllers are begin utilized. It would be more useful to be able to define the starting value for each of these controllers. The <a href="http://www.csounds.com/manual/html/initc7.html">initc7</a> opcode allows us to define the starting value of a midi controller until its hardware control has been moved. If 'initc7' is placed within the instrument itself it will be re-initialized each time the instrument is called, if it is placed in instrument 0 (just after the header statements) then it will only be initialized when the orchestra is first launched. The latter case is probably most useful.</p>
<p>In the following example a simple synthesizer is implemented. Midi controller 1 controls the output volume of this instrument but the 'initc7' <span></span>statement near the top of the orchestra ensures that this control does not default to its minimum setting. The arguments that 'initc7' takes are for midi channel, controller number and initial value. Initial value is defined within the range 0-1, therefore a value of 1 set this controller to its maximum value (midi value 127), and a value of 0.5 sets it to its halfway value (midi value 64) and so on.</p>
<p>Additionally this example uses the <a href="http://www.csounds.com/manual/html/cpsmidi.html">cpsmidi</a> opcode to scan in midi pitch and the <a href="http://www.csounds.com/manual/html/ampmidi.html">ampmidi</a> opcode to scan in note velocity.</p>
<p><strong><em><em>  EXAMPLE 07C03.csd</em></em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-Ma -odac
; activate all midi inputs and real-time audio output
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine ftgen 0,0,2^12,10,1 ; a sine wave
initc7 1,1,1               ; initialize CC 1 on chan. 1 to its max level

  instr 1
iCps cpsmidi               ; read in midi pitch in cycles-per-second
iAmp ampmidi 1             ; read in note velocity - re-range to be from 0 to 1
kVol ctrl7   1,1,0,1       ; read in CC 1, chan. 1. Re-range to be from 0 to 1
aSig poscil  iAmp*kVol, iCps, giSine ; an audio oscillator
     out     aSig          ; send audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
f 0 3600
e
&lt;/CsScore&gt;

&lt;CsoundSynthesizer&gt;</code></pre>
<p>You will maybe hear that this instrument produces 'clicks' as notes begin and end. To find out how to prevent this please see the section on envelopes with release sensing in the chapter <a href="http://en.flossmanuals.net/csound/ch031_a-envelopes/">Sound Modification: Envelopes</a>.<br />
</p>
<h2>Smoothing 7-bit Quantization in MIDI Controllers</h2>
<p>A problem we encounter with 7 bit midi controllers is the poor resolution that they offer us. 7 bit means that we have 2 to the power of 7 possible values; therefore 128 possible values, which is rather inadequate for defining the frequency of an oscillator over a number of octaves, the cutoff frequency of a filter or a volume control. We quickly become aware of the parameter that is being controlled moving up in steps - not so much of a 'continuous' control. We may also experience clicking artefacts, sometimes called 'zipper noise', as the value changes. There are some things we can do to address this problem. We can filter the controller signal within Csound so that the sudden changes that occur between steps along the controller's travel are smoothed using additional interpolating values - we must be careful not to smooth excessively otherwise the response of the controller will become sluggish. Any k-rate compatible lowpass filter can be used for this task but the <a href="http://www.csounds.com/manual/html/portk.html">portk</a> opcode is particularly useful as it allows us to define the amount of smoothing as a time taken to glide to half the required value rather than having to specify a cutoff frequency. Additionally this 'half time' value can be varied as a k-rate value which provides an advantage availed of in the following example.</p>
<p>This example takes the simple synthesizer of the previous example as its starting point. The volume control which is controlled by midi controller 1 on channel 1 is passed through a 'portk' filter. The 'half time' for 'portk'<em></em> ramps quickly up to its required value of 0.01 through the use of a <a href="http://www.csounds.com/manual/html/linseg.html">linseg</a> statement in the previous line. This is done so that when a new note begins the volume control jumps immediately to its required value rather than gliding up from zero on account of the effect of the 'portk'<em></em> filter. Try this example with the 'portk'<em></em> half time defined as a constant to hear the difference. To further smooth the volume control, it is converted to an a-rate variable through the use of the <a href="http://www.csounds.com/manual/html/interp.html">interp</a> opcode which, as well as performing this conversion, interpolates values in the gaps between k-cycles.</p>
<p><strong><em><em>  EXAMPLE 07C04.csd</em></em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-Ma -odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giSine   ftgen    0,0,2^12,10,1
         initc7   1,1,1          ; initialize CC 1 to its max. level

  instr 1
iCps      cpsmidi                ; read in midi pitch in cycles-per-second
iAmp      ampmidi 1              ; read in note velocity - re-range 0 to 1
kVol      ctrl7   1,1,0,1        ; read in CC 1, chan. 1. Re-range from 0 to 1
kPortTime linseg  0,0.001,0.01   ; create a value that quickly ramps up to 0.01
kVol      portk   kVol,kPortTime ; create a filtered version of kVol
aVol      interp  kVol           ; create an a-rate version of kVol
aSig      poscil  iAmp*aVol,iCps,giSine
          out     aSig
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 300
e
&lt;/CsScore&gt;
&lt;CsoundSynthesizer&gt;</code></pre>
<p>All of the techniques introduced in this section are combined in the final example which includes a 2-semitone pitch bend and tone control which is controlled by aftertouch. For tone generation this example uses the <a href="http://www.csounds.com/manual/html/gbuzz.html">gbuzz</a> opcode.</p>
<p><strong><em><em>  EXAMPLE 07C05.csd</em></em></strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
-Ma -odac
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

giCos   ftgen    0,0,2^12,11,1 ; a cosine wave
         initc7   1,1,1        ; initialize controller to its maximum level

  instr 1
iNum      notnum                   ; read in midi note number
iAmp      ampmidi 0.1              ; read in note velocity - range 0 to 0.2
kVol      ctrl7   1,1,0,1          ; read in CC 1, chan. 1. Re-range from 0 to 1
kPortTime linseg  0,0.001,0.01     ; create a value that quickly ramps up to 0.01
kVol      portk   kVol, kPortTime  ; create filtered version of kVol
aVol      interp  kVol             ; create an a-rate version of kVol.
iRange    =       2                ; pitch bend range in semitones
iMin      =       0                ; equilibrium position
kPchBnd	  pchbend iMin, 2*iRange   ; pitch bend in semitones (range -2 to 2)
kPchBnd   portk   kPchBnd,kPortTime; create a filtered version of kPchBnd
aEnv      linsegr 0,0.005,1,0.1,0  ; amplitude envelope with release stage
kMul      aftouch 0.4,0.85         ; read in aftertouch
kMul      portk   kMul,kPortTime   ; create a filtered version of kMul
; create an audio signal using the &#39;gbuzz&#39; additive synthesis opcode
aSig      gbuzz   iAmp*aVol*aEnv,cpsmidinn(iNum+kPchBnd),70,0,kMul,giCos
          out     aSig             ; audio to output
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
f 0 300
e
&lt;/CsScore&gt;

&lt;CsoundSynthesizer&gt;</code></pre>
<p><span id="ch048_d-reading-midi-files.xhtml"></span></p>
<h1>READING MIDI FILES</h1>
<p>Instead of using either the standard Csound score or live midi events as input for a orchestra Csound can read a midi file and use the data contained within it as if it were a live midi input.</p>
<p>The command line flag to instigate reading from a midi file is '<a href="http://www.csounds.com/manual/html/CommandFlags.html#FlagsMinusUpperF">-F</a>' followed by the name of the file or the complete path to the file if it is not in the same directory as the .csd file. Midi channels will be mapped to instrument according to the rules and options discussed in <a href="http://en.flossmanuals.net/bin/view/Csound/Triggering%20Instrument%20Instances">Triggering Instrument Instances</a> and all controllers can be interpretted as desired using the techniques discussed in <a href="http://en.flossmanuals.net/bin/view/Csound/WORKINGWITHCONTROLLERS">Working with Controllers</a>. One thing we need to be concerned with is that without any events in our standard Csound score our performance will terminate immedately. To circumvent this problem we need some sort of dummy event in our score to fool Csound into keeping going until our midi file has completed. Something like the following, placed in the score, is often used.</p>
<pre><code>f 0 3600</code></pre>
<p>This dummy 'f' event will force Csound to wait for 3600 second (1 hour) before terminating performance. It doesn't really matter what number of seconds we put in here, as long as it is more than the number of seconds duration of the midi file. Alternatively a conventional 'i' score event can also keep performance going; sometimes we will have, for example, a reverb effect running throughout the performance which can also prevent Csound from terminating. Performance can be interrupted at any time by typing ctrl+c in the terminal window. </p>
<p>The following example plays back a midi file using Csound's 'fluidsynth' family of opcodes to facilitate playing soundfonts (sample libraries). For more information on these opcodes please consult the <a href="http://www.csounds.com/manual/html/index.html">Csound Reference Manual</a>. In order to run the example you will need to download a midi file and two (ideally contrasting) soundfonts. Adjust the references to these files in the example accordingly. Free midi files and soundfonts are readily available on the internet. I am suggesting that you use contrasting soundfonts, such as a marimba and a trumpet, so that you can easily hear the parsing of midi channels in the midi file to different Csound instruments. In the example channels 1,3,5,7,9,11,13 and 15 play back using soundfont 1 and channels 2,4,6,8,10,12,14 and 16 play back using soundfont 2. When using fluidsynth in Csound we normally use an 'always on' instrument to gather all the audio from the various soundfonts (in this example instrument 99) which also conveniently keeps performance going while our midi file plays back.</p>
<p><strong>  <em>EXAMPLE 07D01.csd</em> </strong></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
;&#39;-F&#39; flag reads in a midi file
-F AnyMIDIfile.mid
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

sr = 44100
ksmps = 32
nchnls = 1
0dbfs = 1

sr = 44100
ksmps = 32
nchnls = 2

giEngine     fluidEngine; start fluidsynth engine
; load a soundfont
iSfNum1      fluidLoad          &quot;ASoundfont.sf2&quot;, giEngine, 1
; load a different soundfont
iSfNum2      fluidLoad          &quot;ADifferentSoundfont.sf2&quot;, giEngine, 1
; direct each midi channels to a particular soundfonts
             fluidProgramSelect giEngine, 1, iSfNum1, 0, 0
             fluidProgramSelect giEngine, 3, iSfNum1, 0, 0
             fluidProgramSelect giEngine, 5, iSfNum1, 0, 0
             fluidProgramSelect giEngine, 7, iSfNum1, 0, 0
             fluidProgramSelect giEngine, 9, iSfNum1, 0, 0
             fluidProgramSelect giEngine, 11, iSfNum1, 0, 0
             fluidProgramSelect giEngine, 13, iSfNum1, 0, 0
             fluidProgramSelect giEngine, 15, iSfNum1, 0, 0
             fluidProgramSelect giEngine, 2, iSfNum2, 0, 0
             fluidProgramSelect giEngine, 4, iSfNum2, 0, 0
             fluidProgramSelect giEngine, 6, iSfNum2, 0, 0
             fluidProgramSelect giEngine, 8, iSfNum2, 0, 0
             fluidProgramSelect giEngine, 10, iSfNum2, 0, 0
             fluidProgramSelect giEngine, 12, iSfNum2, 0, 0
             fluidProgramSelect giEngine, 14, iSfNum2, 0, 0
             fluidProgramSelect giEngine, 16, iSfNum2, 0, 0

  instr 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 ; fluid synths for channels 1-16
iKey         notnum                 ; read in midi note number
iVel         ampmidi            127 ; read in key velocity
; create a note played by the soundfont for this instrument
             fluidNote          giEngine, p1, iKey, iVel
  endin

  instr 99 ; gathering of fluidsynth audio and audio output
aSigL, aSigR fluidOut           giEngine      ; read all audio from soundfont
             outs               aSigL, aSigR  ; send audio to outputs
  endin
&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 99 0 3600 ; audio output instrument also keeps performance going
e
&lt;/CsScore&gt;

&lt;CsoundSynthesizer&gt;</code></pre>
<p>Midi file input can be combined with other Csound inputs from the score or from live midi and also bear in mind that a midi file doesn't need to contain midi note events, it could instead contain, for example, a sequence of controller data used to automate parameters of effects during a live performance.</p>
<p>Rather than to directly play back a midi file using Csound instruments it might be useful to import midi note events as a standard Csound score. This way events could be edited within the Csound editor or several scores could be combined. The following example takes a midi file as input and outputs standard Csound .sco files of the events contained therein. For convenience each midi channel is output to a separate .sco file, therefore up to 16 .sco files will be created. Multiple .sco files can be later recombined by using <a href="http://www.csounds.com/manual/html/include.html">#include</a>... statements or simply by using copy and paste.</p>
<p>The only tricky aspect of this example is that note-ons followed by note-offs need to be sensed and calculated as p3 duration values. This is implemented by sensing the note-off by using the <a href="http://www.csounds.com/manual/html/release.html">release</a> opcode and at that moment triggering a note in another instrument with the required score data. It is this second instrument that is responsible for writing this data to a score file. Midi channels are rendered as p1 values, midi note numbers as p4 and velocity values as p5.<br />
</p>
<p><strong><em>  EXAMPLE 07D02.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; enter name of input midi file
-F InputMidiFile.mid
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

;ksmps needs to be 10 to ensure accurate rendering of timings
ksmps = 10

massign 0,1

  instr 1
iChan       midichn
iCps        cpsmidi            ; read pitch in frequency from midi notes
iVel        veloc	0, 127 ; read in velocity from midi notes
kDur        timeinsts          ; running total of duration of this note
kRelease    release            ; sense when note is ending
 if kRelease=1 then            ; if note is about to end
;           p1  p2  p3    p4     p5    p6
event &quot;i&quot;,  2,  0, kDur, iChan, iCps, iVel ; send full note data to instr 2
 endif
  endin

  instr 2
iDur        =        p3
iChan       =        p4
iCps        =        p5
iVel        =        p6
iStartTime  times        ; read current time since the start of performance
; form file name for this channel (1-16) as a string variable
SFileName   sprintf  &quot;Channel%d.sco&quot;,iChan
; write a line to the score for this channel&#39;s .sco file
            fprints  SFileName, &quot;i%d\\t%f\\t%f\\t%f\\t%d\\n&quot;,\
	                         iChan,iStartTime-iDur,iDur,iCps,iVel
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
f 0 480 ; ensure this duration is as long or longer that duration of midi file
e
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The example above ignores continuous controller data, pitch bend and aftertouch. The second example on the page in the <a href="http://www.csounds.com/manual/html/index.html">Csound Manual</a> for the opcode <a href="http://www.csounds.com/manual/html/fprintks.html">fprintks</a> renders all midi data to a score file.<br />
</p>
<p><span id="ch049_e-midi-output.xhtml"></span></p>
<h1>MIDI OUTPUT</h1>
<p>Csound's ability to output midi data in real-time can open up many possibilities. We can relay the Csound score to a hardware synthesizer so that it plays the notes in our score instead of a Csound instrument. We can algorithmically generate streams of notes within the orchestra and have these played by the external device. We could even route midi data internally to another piece of software. Csound could be used as a device to transform incoming midi data, transforming, transposing or arpeggiating incoming notes before they are output again. Midi output could also be used to preset faders on a motorized fader box (such as the Behringer BCF 2000) to their correct initial locations.</p>
<h2>Initiating Realtime MIDI Output</h2>
<p>The command line flag for realtime midi output is -Q. Just as when setting up an audio input or output device or a midi input device we must define the desired device number after the flag. When in doubt what midi output devices we have on our system we can always specify an 'out of range' device number (e.g. -Q999) in which case Csound will not run but will instead give an error and provide us with a list of available devices and their corresponding numbers. We can then insert an appropriate device number.</p>
<h2>midiout - Outputting Raw MIDI Data<br />
</h2>
<p>The analog of the opcode for the input of raw midi data, <a href="http://www.csounds.com/manual/html/midiin.html">midiin</a>, is <a href="http://www.csounds.com/manual/html/midiout.html">midiout</a>. midiout will output a midi message with its given input arguments once every k period - this could very quickly lead to clogging of incoming midi data in the device to which midi is begin sent unless measures are taken to prevent the <em>midiout</em> code from begin executed on every k pass. In the following example this is dealt with by turning off the instrument as soon as the <em>midiout</em> line has been executed just once by using the <a href="http://www.csounds.com/manual/html/turnoff.html">turnoff</a> opcode. Alternative approaches would be to set the status byte to zero after the first k pass or to embed the <em>midiout</em> within a conditional (<em>if</em>... <em>then</em>...) so that its rate of execution can be controlled in some way.<br />
</p>
<p>Another thing we need to be aware of is that midi notes do not contain any information about note duration; instead the device playing the note waits until it receives a corresponding note-off instruction on the same midi channel and with the same note number before stopping the note. When working with <em>midiout</em> we must also be aware of this. The status byte for a midi note-off is 128 but it is more common for note-offs to be expressed as a note-on (status byte 144) with zero velocity. In the following example two notes (and corresponding note offs) are send to the midi output - the first note-off makes use of the zero velocity convention whereas the second makes use of the note-off status byte. Hardware and software synths should respond similarly to both. One advantage of the note-off message using status byte 128 is that we can also send a note-off velocity, i.e. how forcefully we release the key. Only more expensive midi keyboards actually sense and send note-off velocity and it is even rarer for hardware to respond to received note-off velocities in a meaningful way. Using Csound as a sound engine we could respond to this data in a creative way however.<br />
</p>
<p>In order for the following example to work you must connect a midi sound module or keyboard receiving on channel 1 to the midi output of your computer. You will also need to set the appropriate device number after the '-Q' flag.</p>
<p>No use is made of audio so sample rate (sr), and number of channels (nchnls) are left undefined - nonetheless they will assume default values.<br />
</p>
<p>  <em><strong>EXAMPLE 07E01.csd</strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; amend device number accordingly
-Q999
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

ksmps = 32 ;no audio so sr and nchnls irrelevant

  instr 1
; arguments for midiout are read from p-fields
istatus   init      p4
ichan     init      p5
idata1    init      p6
idata2    init      p7
          midiout   istatus, ichan, idata1, idata2; send raw midi data
          turnoff   ; turn instrument off to prevent reiterations of midiout
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p1 p2 p3   p4 p5 p6 p7
i 1 0 0.01 144 1  60 100 ; note on
i 1 2 0.01 144 1  60   0 ; note off (using velocity zero)

i 1 3 0.01 144 1  60 100 ; note on
i 1 5 0.01 128 1  60 100 ; note off (using &#39;note off&#39; status byte)
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The use of separate score events for note-ons and note-offs is rather cumbersome. It would be more sensible to use the Csound note duration (p3) to define when the midi note-off is sent. The next example does this by utilizing a release flag generated by the <a href="http://www.csounds.com/manual/html/release.html">release</a> opcode whenever a note ends and sending the note-off then.<br />
</p>
<p>  <em><strong>EXAMPLE 07E02.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; amend device number accordingly
-Q999
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
;Example by Iain McCurdy

ksmps = 32 ;no audio so sr and nchnls omitted

  instr 1
;arguments for midiout are read from p-fields
istatus   init      p4
ichan     init      p5
idata1    init      p6
idata2    init      p7
kskip     init      0
 if kskip=0 then
          midiout   istatus, ichan, idata1, idata2; send raw midi data (note on)
kskip     =         1; ensure that the note on will only be executed once
 endif
krelease  release; normally output is zero, on final k pass output is 1
 if krelease=1 then; i.e. if we are on the final k pass...
       midiout   istatus, ichan, idata1, 0; send raw midi data (note off)
 endif
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p1 p2 p3   p4 p5 p6 p7
i 1 0    4 144 1  60 100
i 1 1    3 144 1  64 100
i 1 2    2 144 1  67 100
f 0 5; extending performance time prevents note-offs from being lost
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Obviously <em>midiout</em> is not limited to only sending only midi note information but instead this information could include continuous controller information, pitch bend, system exclusive data and so on. The next example, as well as playing a note, sends controller 1 (modulation) data which rises from zero to maximum (127) across the duration of the note. To ensure that unnessessary midi data is not sent out, the output of the <em>line</em> function is first converted into integers, and <em>midiout</em> for the continuous controller data is only executed whenever this integer value changes. The function that creates this stream of data goes slightly above this maximum value (it finishes at a value of 127.1) to ensure that a rounded value of 127 is actually achieved.</p>
<p>In practice it may be necessary to start sending the continuous controller data slightly before the note-on to allow the hardware time to respond.<br />
</p>
<p>  <em><strong>EXAMPLE 07E03.csd</strong></em> <br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; amend device number accordingly
-Q999
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

ksmps = 32 ; no audio so sr and nchnls irrelevant

  instr 1
; play a midi note
; read in values from p-fields
ichan     init      p4
inote     init      p5
iveloc    init      p6
kskip     init      0 ; &#39;skip&#39; flag ensures that note-on is executed just once
 if kskip=0 then
          midiout   144, ichan, inote, iveloc; send raw midi data (note on)
kskip     =         1   ; flip flag to prevent repeating the above line
 endif
krelease  release       ; normally zero, on final k pass this will output 1
 if krelease=1 then     ; if we are on the final k pass...
          midiout   144, ichan, inote, 0  ; send a note off
 endif

; send continuous controller data
iCCnum    =         p7
kCCval    line      0, p3, 127.1  ; continuous controller data function
kCCval    =         int(kCCval)   ; convert data function to integers
ktrig     changed   kCCval        ; generate a trigger each time kCCval changes
 if ktrig=1 then                  ; if kCCval has changed...
          midiout   176, ichan, iCCnum, kCCval  ; ...send a controller message
 endif
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p1 p2 p3   p4 p5 p6  p7
i 1 0  5    1  60 100 1
f 0 7 ; extending performance time prevents note-offs from being lost
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>midion - Outputting MIDI Notes Made Easier</h2>
<p><em>midiout</em> is the most powerful opcode for midi output but if we are only interested in sending out midi notes from an instrument then the <a href="http://www.csounds.com/manual/html/midion.html">midion</a> opcode simplifies the procedure as the following example demonstrates by playing a simple major arpeggio.</p>
<p>  <em><strong>EXAMPLE 07E04.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; amend device number accordingly
-Q999
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

ksmps = 32 ;no audio so sr and nchnls irrelevant

  instr 1
; read values in from p-fields
kchn    =       p4
knum    =       p5
kvel    =       p6
        midion  kchn, knum, kvel ; send a midi note
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p1 p2  p3  p4 p5 p6
i 1 0   2.5 1 60  100
i 1 0.5 2   1 64  100
i 1 1   1.5 1 67  100
i 1 1.5 1   1 72  100
f 0 30 ; extending performance time prevents note-offs from being missed
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Changing any of 'midion's k-rate input arguments in realtime will force it to stop the current midi note and send out a new one with the new parameters.</p>
<p><a href="http://www.csounds.com/manual/html/midion2.html">midion2</a> allows us to control when new notes are sent (and the current note is stopped) through the use of a trigger input. The next example uses 'midion2' to algorithmically generate a melodic line. New note generation is controlled by a <a href="http://www.csounds.com/manual/html/metro.html">metro</a>, the rate of which undulates slowly through the use of a <a href="http://www.csounds.com/manual/html/randomi.html">randomi</a> function.</p>
<p>  <em><strong>EXAMPLE 07E05.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; amend device number accordingly
-Q999
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

ksmps = 32 ; no audio so sr and nchnls irrelevant

  instr 1
; read values in from p-fields
kchn    =        p4
knum    random   48,72.99  ; note numbers chosen randomly across a 2 octaves
kvel    random   40, 115   ; velocities are chosen randomly
krate   randomi  1,2,1     ; rate at which new notes will be output
ktrig   metro    krate^2   ; &#39;new note&#39; trigger
        midion2  kchn, int(knum), int(kvel), ktrig ; send midi note if ktrig=1
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
i 1 0 20 1
f 0 21 ; extending performance time prevents the final note-off being lost
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<p>'midion' and 'midion2' generate monophonic melody lines with no gaps between notes.</p>
<p><a href="http://www.csounds.com/manual/html/moscil.html">moscil</a> works in a slightly different way and allows us to explicitly define note durations as well as the pauses between notes thereby permitting the generation of more staccato melodic lines. Like<span> '</span>midion' and<em></em> 'midion2', <em></em>'moscil' will not generate overlapping notes (unless two or more instances of it are concurrent). The next example algorithmically generates a melodic line using 'moscil'.</p>
<p>  <em><strong>EXAMPLE 07E06.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;

&lt;CsOptions&gt;
; amend device number accordingly
-Q999
&lt;/CsOptions&gt;

&lt;CsInstruments&gt;
; Example by Iain McCurdy

ksmps = 32 ;no audio so sr and nchnls omitted

seed 0; random number generators seeded by system clock

  instr 1
; read value in from p-field
kchn    =         p4
knum    random    48,72.99  ; note numbers chosen randomly across a 2 octaves
kvel    random    40, 115   ; velocities are chosen randomly
kdur    random    0.2, 1    ; note durations chosen randomly from 0.2 to 1
kpause  random    0, 0.4    ; pauses betw. notes chosen randomly from 0 to 0.4
        moscil    kchn, knum, kvel, kdur, kpause ; send a stream of midi notes
  endin

&lt;/CsInstruments&gt;

&lt;CsScore&gt;
;p1 p2 p3 p4
i 1 0  20 1
f 0 21 ; extending performance time prevents final note-off from being lost
&lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>MIDI File Output</h2>
<p>As well as (or instead of) outputting midi in realtime, Csound can render data from all of its midi output opcodes to a midi file. To do this we use the '--midioutfile=' flag followed by the desired name for our file. For example:</p>
<pre><code>&lt;CsOptions&gt;
-Q2 --midioutfile=midiout.mid
&lt;/CsOptions&gt;</code></pre>
<p>will simultaneously stream realtime midi to midi output device number 2 and render to a file named 'midiout.mid' which will be saved in our home directory.<br />
</p>
<p><span id="ch051_osc-and-wii.xhtml"></span></p>
<h1>OPEN SOUND CONTROL - NETWORK COMMUNICATION</h1>
<p>Open Sound Control (OSC) is a network protocol format for musical control data communication. A few of its advantages compared to MIDI are, that it's more accurate, quicker and much more flexible. With OSC you can easily send messages to other software independent if it's running on the same machine or over network. There is OSC support in software like PD, Max/Msp, Chuck or SuperCollider. A nice <a href="http://www.youtube.com/watch?v=JX1C3TqP_9Y">screencast</a> of Andrés Cabrera shows communication between PD and Csound via OSC.<br />
</p>
<p>OSC messages contain an IP adress with port information and the data-package which will be send over network. In Csound, there are two opcodes, which provide access to network communication called OSCsend, OSClisten.</p>
<p><strong><em>Example 08A01.csd</em></strong><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-o dac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 48000
ksmps = 32
nchnls = 2
0dbfs = 1

; localhost means communication on the same machine, otherwise you need
; an IP adress
#define IPADDRESS	# &quot;localhost&quot; #
#define S_PORT 		# 47120 #
#define R_PORT 		# 47120 #

turnon 1000  ; starts instrument 1000 immediately
turnon 1001  ; starts instrument 1001 immediately
	

instr 1000  ; this instrument sends OSC-values
	kValue1 randomh 0, 0.8, 4
	kNum randomh 0, 8, 8
	kMidiKey tab (int(kNum)), 2
	kOctave randomh 0, 7, 4
	kValue2 = cpsmidinn (kMidiKey*kOctave+33)
	kValue3 randomh 0.4, 1, 4
	Stext sprintf &quot;%i&quot;, $S_PORT
	OSCsend   kValue1+kValue2, $IPADDRESS, $S_PORT, &quot;/QuteCsound&quot;,
                  &quot;fff&quot;, kValue1, kValue2, kValue3
endin


instr 1001  ; this instrument receives OSC-values	
	kValue1Received init 0.0
	kValue2Received init 0.0
	kValue3Received init 0.0
	Stext sprintf &quot;%i&quot;, $R_PORT
	ihandle OSCinit $R_PORT
	kAction  OSClisten	ihandle, &quot;/QuteCsound&quot;, &quot;fff&quot;,
                 kValue1Received, kValue2Received, kValue3Received
		if (kAction == 1) then	
			printk2 kValue2Received
			printk2 kValue1Received
			
		endif
	aSine poscil3 kValue1Received, kValue2Received, 1
	; a bit reverbration
	aInVerb = aSine*kValue3Received
	aWetL, aWetR freeverb aInVerb, aInVerb, 0.4, 0.8
outs aWetL+aSine, aWetR+aSine
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 1 0 1024 10 1
f 2 0 8 -2      0 2 4 7 9 11 0 2
e 3600
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
; example by Alex Hofmann (Mar. 2011)</code></pre>
<p><span id="ch053_csound-in-pd.xhtml"></span></p>
<h1>CSOUND IN PD</h1>
<h2>INSTALLING<br />
</h2>
<p>You can embed Csound in PD via the external <strong>csoundapi~</strong>, which has been written by Victor Lazzarini. This external is part of the Csound distribution.</p>
<p>On <strong>Ubuntu Linux</strong>, you can install the csoundapi~ via the Synaptic package manager. Just look for &quot;csoundapi~&quot; or &quot;pd-csound&quot;, check &quot;install&quot;, and your system will install the library at the appropriate location. If you build Csound from sources, you should also be able to get the csoundapi~ via the scons option buildPDClass=1. It will be put as csoundapi~.pd_linux in /usr/lib/pd/extra, so that PD should be able to find it. If not, add it to PD's search path (File-&gt;Path...).<br />
</p>
<p>On <strong>Mac OSX</strong>, you find the csoundapi~ in the following path:<br />
</p>
<p>/Library/Frameworks/CsoundLib.framework/Versions/5.2/Resources/PD/csoundapi~.pd_darwin<br />
</p>
<p>Put this file in a folder which is in PD's search path. For PD-extended, it's by default ~/Library/Pd. But you can put it anywhere. Just make sure that the location is specified in PD's Preferences &gt; Path... menu.</p>
<p>On <strong>Windows</strong>, while installing Csound, open up the &quot;Front ends&quot; component in the Installer box and make sure the item &quot;csoundapi~&quot; is checked:</p>
<p> <img src="static/pd-cs_installer_win.png" /><br />
<br />
After having finished the installation, you will find csoundapi~.dll in the csound/bin folder. Copy this file into the pd/extra folder, or in any other location in PD's search path.</p>
<p>When you have installed the &quot;csoundapi~&quot; extension on any platform, and included the file in PD's search path if necessary, you should be able to call the csoundapi~ object in PD. Just open a PD window, put a new object, and type in &quot;csoundapi~&quot;:<br />
</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-pd2-en.png" title="pd2" alt="pd2" width="671" height="342" /> <br />
<br />
</p>
<h2>CONTROL DATA</h2>
<p>You can send control data from PD to your Csound instrument via the keyword &quot;control&quot; in a message box. In your Csound code, you must receive the data via <strong>invalue</strong> or <strong>chnget</strong>. This is a simple example:</p>
<p><em><strong>EXAMPLE 09A01.csd</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

sr = 44100
nchnls = 2
0dbfs = 1
ksmps = 8

giSine    ftgen     0, 0, 2^10, 10, 1

instr 1
kFreq     invalue   &quot;freq&quot;
kAmp      invalue   &quot;amp&quot;
aSin      oscili    kAmp, kFreq, giSine
          outs      aSin, aSin
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>Save this file under the name &quot;control.csd&quot;. Save a PD window in the same folder and create the following patch:</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-pd3-en.png" alt="pd3.png" width="600" height="349" /> </p>
<p>Note that for invalue channels, you first must register these channels by a &quot;set&quot; message.</p>
<p>As you see, the first two outlets of the csoundapi~ object are the signal outlets for the audio channels 1 and 2. The third outlet is an outlet for control data (not used here, see below). The rightmost outlet sends a bang when the score has been finished.</p>
<h2>LIVE INPUT</h2>
<p>Audio streams from PD can be received in Csound via the <strong>inch</strong> opcode. As many input channels there are, as many audio inlets are created in the csoundapi~ object. The following CSD uses two audio inputs:</p>
<p><em><strong>EXAMPLE 09A02.csd </strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
0dbfs = 1
ksmps = 8
nchnls = 2

instr 1
aL        inch      1
aR        inch      2
kcfL      randomi   100, 1000; center frequency
kcfR      randomi   100, 1000; for band pass filter
aFiltL    butterbp  aL, kcfL, kcfL/10
aoutL     balance   aFiltL, aL
aFiltR    butterbp  aR, kcfR, kcfR/10
aoutR     balance   aFiltR, aR
          outch     1, aoutL
          outch     2, aoutR
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 10000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The corresponding PD patch is extremely simple:</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-pd4-en.png" alt="pd4.png" width="600" height="341" /> </p>
<h2>MIDI</h2>
<p>The csoundapi~ object receives MIDI data via the keyword &quot;midi&quot;. Csound is able to trigger instrument instances in receiving a &quot;note on&quot; message, and turning them off in receiving a &quot;note off&quot; message (or a note-on message with velocity=0). So this is a very simple way to build a synthesizer with arbitrary polyphonic output:</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-pd5-en.png" alt="pd5.png" width="468" height="341" /><br />
</p>
<p>This is the corresponding midi.csd. It must contain the options -+rtmidi=null -M0 in the &lt;CsOptions&gt; tag. It's an FM synth which changes the modulation index according to the verlocity: the more you press a key, the higher the index, and the more partials you get. The ratio is calculated randomly between two limits which can be adjusted.</p>
<p><em><strong>EXAMPLE 09A03.csd </strong></em><br />
</p>
<pre><code>&lt;CsOptions&gt;
-+rtmidi=null -M0
&lt;/CsOptions&gt;
&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr      =  44100
ksmps   =  8
nchnls  =  2
0dbfs = 1

giSine    ftgen     0, 0, 2^10, 10, 1

instr 1
iFreq     cpsmidi   ;gets frequency of a pressed key
iAmp      ampmidi   8;gets amplitude and scales 0-8
iRatio    random    .9, 1.1; ratio randomly between 0.9 and 1.1
aTone     foscili   .1, iFreq, 1, iRatio/5, iAmp+1, giSine; fm
aEnv      linenr    aTone, 0, .01, .01; avoiding clicks at the end of a note
          outs      aEnv, aEnv
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000; play for 10 hours
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>SCORE EVENTS</h2>
<p>Score events can be sent from PD to Csound by a message with the keyword <strong>event</strong>. You can send any kind of score events, like instrument calls or function table statements. The following example triggers Csound's instrument 1 whenever you press the message box on the top. Different sounds can be selected by sending f events (building/replacing a function table) to Csound.</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-pd6-en.png" alt="pd6.png" width="479" height="403" /></p>
<p><em><strong>EXAMPLE 09A04.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz
sr = 44100
ksmps = 8
nchnls = 2
0dbfs = 1

          seed      0; each time different seed
giSine    ftgen     1, 0, 2^10, 10, 1; function table 1

instr 1
iDur      random    0.5, 3
p3        =         iDur
iFreq1    random    400, 1200
iFreq2    random    400, 1200
idB       random    -18, -6
kFreq     linseg    iFreq1, iDur, iFreq2
kEnv      transeg   ampdb(idB), p3, -10, 0
aTone     oscili    kEnv, kFreq, 1
          outs      aTone, aTone
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 36000; play for 10 hours
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<h2>CONTROL OUTPUT</h2>
<p>If you want Csound to give any sort of control data to PD, you can use the opcodes <strong>outvalue</strong> or <strong>chnset</strong>. You will receive this data at the second outlet from the right of the csoundapi~ object. The data are sent as a list with two elements. The name of the control channel is the first element, and the value is the second element. You can get the values by a <em>route</em> object or by a <em>send/receive</em> chain. This is a simple example:<br />
</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-pd7-en.png" alt="pd7.png" width="396" height="340" /> </p>
<p><em><strong>EXAMPLE 09A05.csd </strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
;Example by Joachim Heintz

sr = 44100
nchnls = 2
0dbfs = 1
ksmps = 8

instr 1
ktim      times
kphas     phasor    1
          outvalue  &quot;time&quot;, ktim
          outvalue  &quot;phas&quot;, kphas*127
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
i 1 0 30
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt; </code></pre>
<h2>SEND/RECEIVE BUFFERS FROM PD TO CSOUND AND BACK<br />
</h2>
<p>Recently (January 2012) Victor Lazzarini has introduced a new feature which makes it possible to send a PD array to Csound, and a Csound function table to PD. The message <em>tabset</em> [tabset array-name ftable-number] copies a PD array into a Csound function table. The message <em>tabget</em> [tabget array-name ftable-number] copies a Csound function table into a PD array. The example below should explain everything. Just choose another soundfile instead of &quot;stimme.wav&quot;.<br />
</p>
<p><img src="static/09A06a.png" /> <em><br />
</em></p>
<p><em><strong>EXAMPLE 06A06.csd</strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-odac
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 8
nchnls = 1
0dbfs = 1

giCopy ftgen 1, 0, -88200, 2, 0 ;&quot;empty&quot; table
giFox  ftgen 2, 0, 0, 1, &quot;fox.wav&quot;, 0, 0, 1

  opcode BufPlay1, a, ipop
ifn, ispeed, iskip, ivol xin
icps      =         ispeed / (ftlen(ifn) / sr)
iphs      =         iskip / (ftlen(ifn) / sr)
asig      poscil3   ivol, icps, ifn, iphs
          xout      asig
  endop

  instr 1
itable    =         p4
aout      BufPlay1  itable
          out       aout
  endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 99999
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
;example by joachim heintz</code></pre>
<h2>SETTINGS</h2>
<p>Make sure that the Csound vector size given by the <a href="http://www.csounds.com/manual/html/ksmps.html">ksmps</a> value, is not larger than the internal PD vector size. It should be a power of 2. I'd recommend to start with ksmps=8. If there are performance problems, try to increase this value to 16, 32, or 64.</p>
<p>The csoundapi~ object runs by default if you turn on audio in PD. You can stop it by sending a &quot;run 0&quot; message, and start it again with a &quot;run 1&quot; message.</p>
<p>You can recompile the .csd file of a csoundapi~ object by sending a &quot;reset&quot; message.</p>
<p>By default, you see all the messages of Csound in the PD window. If you don't want to see them, send a &quot;message 0&quot; message. &quot;message 1&quot; prints the output again.</p>
<p>If you want to open a new .csd file in the csoundapi~ object, send the message &quot;open&quot;, followed by the path of the .csd file you want to load.</p>
<p>A &quot;rewind&quot; message rewinds the score without recompilation. The message &quot;offset&quot;, followed by a number, offsets the score playback by an amount of seconds.<br />
</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-pd8-en.png" /><br />
</p>
<p><span id="ch054_csound-in-maxmsp.xhtml"></span></p>
<h1>CSOUND IN MAXMSP</h1>
<p><em>The information contained within this document pertains to csound~ v1.0.7. </em><br />
</p>
<h2>INTRODUCTION</h2>
<p>Csound can be embedded in a Max patch using the csound~ object. This allows you to synthesize and process audio, MIDI, or control data with Csound.<br />
</p>
<h2>INSTALLING</h2>
<p>Before installing csound~, <a href="http://en.flossmanuals.net/bin/view/Csound/MakeCsoundRun">install Csound5</a>. csound~ needs a normal Csound5 installation in order to work. You can download Csound5 from <a href="http://sourceforge.net/projects/csound/files/csound5/">here.</a></p>
<p>Once Csound5 is installed, download the csound~ zip file from <a href="http://www.davixology.com/csound~.html">here.</a></p>
<h3>INSTALLING ON MAC OS X</h3>
<ol>
<li>Expand the zip file and navigate to binaries/MacOSX/.</li>
<li>Choose an mxo file based on what kind of CPU you have (intel or ppc) and which type of floating point numbers are used in your Csound5 version (double or float). The name of the Csound5 installer may give a hint with the letters &quot;f&quot; or &quot;d&quot; or explicitly with the words &quot;double&quot; or &quot;float&quot;. However, if you do not see a hint, then that means the installer contains both, in which case you only have to match your CPU type.</li>
<li>Copy the mxo file to:
<ul>
<li><em>Max 4.5</em>: /Library/Application Support/Cycling '74/externals/</li>
<li><em>Max 4.6</em>: /Applications/MaxMSP 4.6/Cycling'74/externals/</li>
<li><em>Max 5</em>: /Applications/Max5/Cycling '74/msp-externals/</li>
</ul></li>
<li>Rename the mxo file to &quot;csound~.mxo&quot;.</li>
<li>If you would like to install the help patches, navigate to the help_files folder and copy all files to:
<ul>
<li><em>Max 4.5</em>: /Applications/MaxMSP 4.5/max-help/</li>
<li><em>Max 4.6</em>: /Applications/MaxMSP 4.6/max-help/</li>
<li><em>Max 5</em>: /Applications/Max5/Cycling '74/msp-help/</li>
</ul></li>
</ol>
<h3>INSTALLING ON WINDOWS</h3>
<ol>
<li>Expand the zip file and navigate to binaries\Windows\.</li>
<li>Choose an mxe file based on the type of floating point numbers used in your Csound5 version (double or float). The name of the Csound5 installer may give a hint with the letters &quot;f&quot; or &quot;d&quot; or explicitly with the words &quot;double&quot; or &quot;float&quot;.</li>
<li>Copy the mxe file to:
<ul>
<li><em>Max 4.5</em>: C:\Program Files\Common Files\Cycling '74\externals\</li>
<li><em>Max 4.6</em>: C:\Program Files\Cycling '74\MaxMSP 4.6\Cycling '74\externals\</li>
<li><em>Max 5</em>: C:\Program Files\Cycling '74\Max 5.0\Cycling '74\msp-externals\</li>
</ul></li>
<li>Rename the mxe file to &quot;csound~.mxe&quot;.</li>
<li>If you would like to install the help patches, navigate to the help_files folder and copy all files to:
<ul>
<li><em>Max 4.5</em>: C:\Program Files\Cycling '74\MaxMSP 4.5\max-help\</li>
<li><em>Max 4.6</em>: C:\Program Files\Cycling '74\MaxMSP 4.6\max-help\</li>
<li><em>Max 5</em>: C:\Program Files\Cycling '74\Max 5.0\Cycling '74\msp-help\</li>
</ul></li>
</ol>
<h3>KNOWN ISSUES</h3>
<p>On Windows (only), various versions of Csound5 have a known incompatibility with csound~ that has to do with the fluid opcodes. How can you tell if you're affected? Here's how: if you stop a Csound performance (or it stops by itself) and you click on a non-MaxMSP or non-Live window and it crashes, then you are affected. Until this is fixed, an easy solution is to remove/delete fluidOpcodes.dll from your plugins or plugins64 folder. Here are some common locations for that folder:</p>
<ul>
<li>C:\Program Files\Csound\plugins</li>
<li>C:\Program Files\Csound\plugins64<br />
</li>
</ul>
<h2>CREATING A CSOUND~ PATCH</h2>
<ol>
<li>Create the following patch:<br />
 <img src="static/Csound-Picts-09_CsInOtherApps-create_a_csound__patch-en.png" alt="create_a_csound__patch.png" width="240" height="242" /></li>
<li>Save as &quot;helloworld.maxpat&quot; and close it.</li>
<li>Create a text file called &quot;helloworld.csd&quot; within the same folder as your patch.</li>
<li><p>Add the following to the text file: <em><strong></strong></em><br />
</p>
<p><em><strong>EXAMPLE 09B01.csd </strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Davis Pyon
sr     = 44100
ksmps  = 32
nchnls = 2
0dbfs  = 1

instr 1
aNoise noise .1, 0
       outch 1, aNoise, 2, aNoise
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f0 86400
i1 0 86400
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
    </code></pre></li>
<li>Open the patch, press the bang button, then press the speaker icon.</li>
</ol>
<p>At this point, you should hear some noise. Congratulations! You created your first csound~ patch.</p>
<p>You may be wondering why we had to save, close, and reopen the patch. This is needed in order for csound~ to find the csd file. In effect, saving and opening the patch allows csound~ to &quot;know&quot; where the patch is. Using this information, csound~ can then find csd files specified using a relative pathname (e.g. &quot;helloworld.csd&quot;). Keep in mind that this is only necessary for newly created patches that have not been saved yet. By the way, had we specified an absolute pathname (e.g. &quot;C:/Mystuff/helloworld.csd&quot;), the process of saving and reopening would have been unnecessary.</p>
<p>The &quot;@scale 0&quot; argument tells csound~ not to scale audio data between Max and Csound. By default, csound~ will scale audio to match 0dB levels. Max uses a 0dB level equal to one, while Csound uses a 0dB level equal to 32768. Using &quot;@scale 0&quot; and adding the statement &quot;<strong><a href="http://www.csounds.com/manual/html/Zerodbfs.html">0dbfs</a></strong> = 1&quot; within the csd file allows you to work with a 0dB level equal to one everywhere. This is highly recommended.</p>
<h2>AUDIO I/O</h2>
<p>All csound~ inlets accept an audio signal and some outlets send an audio signal. The number of audio outlets is determined by the arguments to the csound~ object. Here are four ways to specify the number of inlets and outlets:</p>
<ul>
<li>[csound~ @io 3]</li>
<li>[csound~ @i 4 @o 7]</li>
<li>[csound~ 3]</li>
<li>[csound~ 4 7]</li>
</ul>
<p>&quot;@io 3&quot; creates 3 audio inlets and 3 audio outlets. &quot;@i 4 @o 7&quot; creates 4 audio inlets and 7 audio outlets. The third and fourth lines accomplish the same thing as the first two. If you don't specify the number of audio inlets or outlets, then csound~ will have two audio inlets and two audio oulets. By the way, audio outlets always appear to the left of non-audio outlets. Let's create a patch called audio_io.maxpat that demonstrates audio i/o:</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-audio_io_patch-en.png" alt="audio_io_patch.png" width="397" height="233" /><br />
</p>
<p>Here is the corresponding text file (let's call it audio_io.csd):</p>
<p><em><strong>EXAMPLE 09B02.csd </strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Davis Pyon
sr     = 44100
ksmps  = 32
nchnls = 3
0dbfs  = 1

instr 1
aTri1 inch 1
aTri2 inch 2
aTri3 inch 3
aMix  = (aTri1 + aTri2 + aTri3) * .2
      outch 1, aMix, 2, aMix
endin

&lt;/CsInstruments&gt;
&lt;⁞CsScore&gt;
f0 86400
i1 0 86400
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>In audio_io.maxpat, we are mixing three triangle waves into a stereo pair of outlets. In audio_io.csd, we use <strong><a href="http://www.csounds.com/manual/html/inch.html">inch</a></strong> and <strong><a href="http://www.csounds.com/manual/html/outch.html">outch</a></strong> to receive and send audio from and to csound~. <strong><a href="http://www.csounds.com/manual/html/inch.html">inch</a></strong> and <strong><a href="http://www.csounds.com/manual/html/outch.html">outch</a></strong> both use a numbering system that starts with one (the left-most inlet or outlet).</p>
<p>Notice the statement &quot;<strong><a href="http://www.csounds.com/manual/html/nchnls.html">nchnls</a></strong> = 3&quot; in the orchestra header. This tells the Csound compiler to create three audio input channels and three audio output channels. Naturally, this means that our csound~ object should have no more than three audio inlets or outlets.</p>
<h2>CONTROL MESSAGES</h2>
<p>Control messages allow you to send numbers to Csound. It is the primary way to control Csound parameters at i-rate or k-rate. To control a-rate (audio) parameters, you must use and audio inlet. Here are two examples:</p>
<ul>
<li>control frequency 2000</li>
<li>c resonance .8</li>
</ul>
<p>Notice that you can use either &quot;control&quot; or &quot;c&quot; to indicate a control message. The second argument specifies the name of the channel you want to control and the third argument specifies the value.</p>
<p>The following patch and text file demonstrates control messages:</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-control_messages_patch-en.png" alt="control_messages_patch.png" width="360" height="261" /></p>
<p><em><strong>EXAMPLE 09B03.csd </strong></em> </p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Davis Pyon
sr     = 44100
ksmps  = 32
nchnls = 2
0dbfs  = 1

giSine ftgen 1, 0, 16384, 10, 1 ; Generate a sine wave table.

instr 1
kPitch chnget &quot;pitch&quot;
kMod   invalue &quot;mod&quot;
aFM    foscil .2, cpsmidinn(kPitch), 2, kMod, 1.5, giSine
       outch 1, aFM, 2, aFM
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f0 86400
i1 0 86400
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>In the patch, notice that we use two different methods to construct control messages. The &quot;pak&quot; method is a little faster than the message box method, but do whatever looks best to you. You may be wondering how we can send messages to an audio inlet (remember, all inlets are audio inlets). Don't worry about it. In fact, we can send a message to any inlet and it will work.</p>
<p>In the text file, notice that we use two different opcodes to receive the values sent in the control messages: <strong><a href="http://www.csounds.com/manual/html/chnget.html">chnget</a></strong> and <strong><a href="http://www.csounds.com/manual/html/invalue.html">invalue</a></strong>. <strong><a href="http://www.csounds.com/manual/html/chnget.html">chnget</a></strong> is more versatile (it works at i-rate and k-rate, and it accepts strings) and is a tiny bit faster than <strong><a href="http://www.csounds.com/manual/html/invalue.html">invalue</a></strong>. On the other hand, the limited nature of <strong><a href="http://www.csounds.com/manual/html/invalue.html">invalue</a></strong> (only works at k-rate, never requires any declarations in the header section of the orchestra) may be easier for newcomers to Csound.</p>
<h2>MIDI</h2>
<p>csound~ accepts raw MIDI numbers in it's first inlet. This allows you to create Csound instrument instances with MIDI notes and also control parameters using MIDI Control Change. csound~ accepts all types of MIDI messages, except for: sysex, time code, and sync. Let's look at a patch and text file that uses MIDI:</p>
<p><img src="static/Csound-Picts-09_CsInOtherApps-midi_patch-en.png" alt="midi_patch.png" width="422" height="353" /><br />
</p>
<p><br />
</p>
<p><em><strong>EXAMPLE 09B04.csd </strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Davis Pyon
sr     = 44100
ksmps  = 32
nchnls = 2
0dbfs  = 1

massign 0, 0 ; Disable default MIDI assignments.
massign 1, 1 ; Assign MIDI channel 1 to instr 1.

giSine ftgen 1, 0, 16384, 10, 1 ; Generate a sine wave table.

instr 1
iPitch cpsmidi
kMod   midic7 1, 0, 10
aFM    foscil .2, iPitch, 2, kMod, 1.5, giSine
       outch 1, aFM, 2, aFM
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f0 86400
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>In the patch, notice how we're using midiformat to format note and control change lists into raw MIDI bytes. The &quot;1&quot; argument for midiformat specifies that all MIDI messages will be on channel one.</p>
<p>In the text file, notice the <strong><a href="http://www.csounds.com/manual/html/massign.html">massign</a></strong> statements in the header of the orchestra. &quot;<strong><a href="http://www.csounds.com/manual/html/massign.html">massign</a></strong> 0,0&quot; tells Csound to clear all mappings between MIDI channels and Csound instrument numbers. This is highly recommended because forgetting to add this statement may cause confusion somewhere down the road. The next statement &quot;<strong><a href="http://www.csounds.com/manual/html/massign.html">massign</a></strong> 1,1&quot; tells Csound to map MIDI channel one to instrument one.</p>
<p>To get the MIDI pitch, we use the opcode <strong><a href="http://www.csounds.com/manual/html/cpsmidi.html">cpsmidi</a></strong>. To get the FM modulation factor, we use <strong><a href="http://www.csounds.com/manual/html/midic7.html">midic7</a></strong> in order to read the last known value of MIDI CC number one (mapped to the range [0,10]).</p>
<p>Notice that in the score section of the text file, we no longer have the statement &quot;i1 0 86400&quot; as we had in earlier examples. This is a good thing as you should never instantiate an instrument via both MIDI and score events (at least that has been this writer's experience).</p>
<h2>Events</h2>
<p>To send Csound events (i.e. score statements), use the &quot;event&quot; or &quot;e&quot; message. You can send any type of event that Csound understands. The following patch and text file demonstrates how to send events:<br />
</p>
<p>  <img src="static/Csound-Picts-09_CsInOtherApps-events-en.png" /></p>
<p><em><strong>EXAMPLE 09B05.csd </strong></em></p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;Example by Davis Pyon
sr     = 44100
ksmps  = 32
nchnls = 2
0dbfs  = 1

instr 1
  iDur = p3
  iCps = cpsmidinn(p4)
 iMeth = 1
       print iDur, iCps, iMeth
aPluck pluck .2, iCps, iCps, 0, iMeth	
       outch 1, aPluck, 2, aPluck
endin
&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f0 86400
e
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>In the patch, notice how the arguments to the pack object are declared. The &quot;i1&quot; statement tells Csound that we want to create an instance of instrument one. There is no space between &quot;i&quot; and &quot;1&quot; because pack considers &quot;i&quot; as a special symbol signifying an integer. The next number specifies the start time. Here, we use &quot;0&quot; because we want the event to start right now. The duration &quot;3.&quot; is specified as a floating point number so that we can have non-integer durations. Finally, the number &quot;64&quot; determines the MIDI pitch. You might be wondering why the pack object output is being sent to a message box. This is good practice as it will reveal any mistakes you made in constructing an event message.<br />
</p>
<p>In the text file, we access the event parameters using p-statements. We never access <strong>p1</strong> (instrument number) or <strong>p2</strong> (start time) because they are not important within the context of our instrument. Although <strong>p3</strong> (duration) is not used for anything here, it is often used to create audio envelopes. Finally, <strong>p4</strong> (MIDI pitch) is converted to cycles-per-second. The <strong><a href="http://www.csounds.com/manual/html/print.html">print</a></strong> statement is there so that we can verify the parameter values.</p>
<p><br />
</p>
<p><span id="ch055_csound-in-ableton-live.xhtml"></span></p>
<h1>CSOUND IN ABLETON LIVE</h1>
<p>Csound can be used in Ableton Live through Max4Live. Max4Live is a toolkit which allows users to build devices for Live using Max/MSP.  Please see the previous section on using Csound in Max/MSP for more details on how to use Csound in Live.</p>
<p>Cabbage can also be used to run Csound in Live, or any other audio plugin host. Please refer to the section titled 'Cabbage' in chapter 10.  </p>
<p><span id="ch056_d-csound-as-a-vst-plugin.xhtml"></span></p>
<h1>D. CSOUND AS A VST PLUGIN</h1>
<p>Csound can be built into a VST or AU plugin through the use of the Csound host API. Refer to the section on using the Csound API for more details. </p>
<p>If you are not well versed in low level computer programming you can just use Cabbage to create Csound based plugins.  See the section titled 'Cabbage' in Chapter 10. </p>
<p><span id="ch058_qutecsound.xhtml"></span></p>
<h1>CsoundQt</h1>
<p><span></span>CsoundQt is a free, cross-platform graphical frontend to Csound. It features syntax highlighting, code completion and a graphical widget editor for realtime control of Csound. It comes with many useful code examples, from basic tutorials to complex synthesizers and pieces written in Csound. It also features an integrated Csound language help display.</p>
<p>CsoundQt (named QuteCsound until automn 2011) can be used as a code editor tailored for Csound, as it facilitates running and rendering Csound files without the need of typing on the command line using the Run and Render buttons.</p>
<p><img src="static/snapshot1.png" /><br />
</p>
<p>In the widget editor panel, you can create a variety of widgets to control Csound. To link the value from a widget, you first need to set its channel, and then use the Csound opcode invalue. To send values to widgets, e.g. for data display, you need to use the outvalue opcode.</p>
<p><img src="static/snapshot2.png" /><br />
<br />
  CsoundQt also offers convenient facilities for score editing in a spreadsheet like environment which can be transformed using Python scripting.</p>
<p><img src="static/snapshot3.png" /></p>
<p>You will find more detailed information and video tutorials in the CsoundQt home page at <a href="http://qutecsound.sourceforge.net" class="uri" title="http://qutecsound.sourceforge.net">http://qutecsound.sourceforge.net</a>.<br />
</p>
<p><span id="ch059_winxound.xhtml"></span></p>
<h1>WinXound</h1>
<div class="wikidoc">
<strong>WinXound Description:</strong><br />
WinXound is a free and open-source Front-End GUI Editor for CSound 5, CSoundAV,<br />
CSoundAC, with Python and Lua support, developed by Stefano Bonetti.<br />
It runs on Microsoft Windows, Apple Mac OsX and Linux.<br />
WinXound is optimized to work with the new CSound 5 compiler.<br />
<br />
<br />
<strong>WinXound Features:</strong>
</div>
<div class="wikidoc">
<ul>
<li>Edit CSound, Python and Lua files (csd, orc, sco, py, lua) with Syntax Highlight and Rectangular Selection;</li>
<li>Run CSound, CSoundAV, CSoundAC, Python and Lua compilers;</li>
<li>Run external language tools (QuteCsound, Idle, or other GUI Editors);</li>
<li>CSound analysis user friendly GUI;</li>
<li>Integrated CSound manual help;</li>
<li>Possibilities to set personal colors for the syntax highlighter;</li>
<li>Convert orc/sco to csd or csd to orc/sco;</li>
<li>Split code into two windows horizontally or vertically;</li>
<li>CSound csd explorer (File structure for Tags and Instruments);</li>
<li>CSound Opcodes autocompletion menu;</li>
<li>Line numbers;</li>
<li>Bookmarks;</li>
<li>...and much more ... (Download it!)<br />
</li>
</ul>
</div>
<p><strong>Web Site and Contacts:</strong><br />
- Web: <a href="http://winxound.codeplex.com" title="winxound.codeplex.com">winxound.codeplex.com</a><br />
- Email: <a href="mailto:stefano_bonetti@tin.it">stefano_bonetti@tin.it</a> (or <a href="mailto:stefano_bonetti@alice.it">stefano_bonetti@alice.it</a>)</p>
<hr />
<p><strong> <br />
REQUIREMENTS<br />
</strong><br />
<strong>System requirements for Microsoft Windows:</strong></p>
<ul>
<li>Supported: Xp, Vista, Seven (32/64 bit versions);</li>
<li>(Note: For Windows Xp you also need the Microsoft Framework .Net version 2.0 or major. You can download it from www.microsoft.com site);</li>
<li>CSound 5: <a href="http://sourceforge.net/projects/csound" class="externalLink">http://sourceforge.net/projects/csound<span class="externalLinkIcon"></span></a> - (needed for CSound and LuaJit compilers);</li>
<li>Not requested but suggested: CSoundAV by Gabriel Maldonado (<a href="http://www.csounds.com/maldonado/" class="externalLink">http://www.csounds.com/maldonado/<span class="externalLinkIcon"></span></a>);</li>
<li>Requested to work with Python: Python compiler (<a href="http://www.python.org/download/" class="externalLink">http://www.python.org/download/<span class="externalLinkIcon"></span></a>)<br />
</li>
</ul>
<p><strong>System requirements for Apple Mac OsX:</strong></p>
<ul>
<li>Osx 10.5 or major;</li>
<li>CSound 5: <a href="http://sourceforge.net/projects/csound" class="externalLink">http://sourceforge.net/projects/csound<span class="externalLinkIcon"></span></a> - (needed for CSound compiler);</li>
</ul>
<p><strong>System requirements for Linux:</strong></p>
<ul>
<li>Gnome environment or libraries;</li>
<li>Please, read carefully the &quot;ReadMe&quot; file in the source code.<br />
</li>
</ul>
<hr />
<p><br />
<br />
<strong>INSTALLATION AND USAGE<br />
<br />
Microsoft Windows Installation and Usage:</strong></p>
<ul>
<li>Download and install the Microsoft Framework .Net version 2.0 or major (only for Windows Xp);</li>
<li>Download and install the latest version of CSound 5 (<a href="http://sourceforge.net/projects/csound" class="externalLink">http://sourceforge.net/projects/csound<span class="externalLinkIcon"></span></a>);</li>
<li>Download the WinXound zipped file, decompress it where you want (see the (*)note below), and double-click on &quot;WinXound_Net&quot; executable;</li>
<li>(*)note: THE WINXOUND FOLDER MUST BE LOCATED IN A PATH WHERE YOU HAVE FULL READ AND WRITE PERMISSION (for example in your User Personal folder).<br />
</li>
</ul>
<p><strong>Apple Mac OsX Installation and Usage:</strong></p>
<ul>
<li>Download and install the latest version of CSound 5 (<a href="http://sourceforge.net/projects/csound" class="externalLink">http://sourceforge.net/projects/csound<span class="externalLinkIcon"></span></a>);</li>
<li>Download the WinXound zipped file, decompress it and drag WinXound.app to your Applications folder (or where you want). Launch it from there.</li>
</ul>
<p><strong>Linux Installation and Usage:</strong></p>
<ul>
<li>Download and install the latest version of CSound 5 for your distribution;</li>
<li>Ubuntu (32/64 bit): Download the WinXound zipped file, decompress it in a location where you have the full read and write permissions;</li>
<li>To compile the source code:<br />
1) Before to compile WinXound you need to install:<br />
- gtkmm-2.4 (libgtkmm-2.4-dev) &gt;= 2.12<br />
- vte (libvte-dev)<br />
- webkit-1.0 (libwebkit-dev)<br />
<br />
2) To compile WinXound open the terminal window, go into the uncompressed &quot;winxound_gtkmm&quot; directory and type:<br />
./configure<br />
make<br />
<br />
3) To use WinXound without installing it:<br />
make standalone<br />
./bin/winxound<br />
[Note: WinXound folder must be located in a path where you have full read and write permission.]<br />
<br />
4) To install WinXound:<br />
make install</li>
</ul>
<hr />
<p><br />
<strong>Source Code:</strong></p>
<ul>
<li>Windows: The source code is written in C# using Microsoft Visual Studio C# Express Edition 2008.</li>
<li>OsX: The source code is written in Cocoa and Objective-C using XCode 3.2 version.</li>
<li>Linux: The source code is written in C++ (Gtkmm) using Anjuta.</li>
</ul>
<p><br />
Note: <em>The TextEditor is entirely based on the wonderful SCINTILLA text control by Neil Hodgson (<a href="http://www.scintilla.org" class="externalLink">http://www.scintilla.org<span class="externalLinkIcon"></span></a>).</em><br />
<br />
</p>
<hr />
<p><br />
<br />
<strong>Screenshots:</strong><br />
<br />
Look at: <span class="Apple-style-span"><a href="http://winxound.codeplex.com/" title="winxound.codeplex.com">winxound.codeplex.com</a> </span></p>
<hr />
<p><br />
</p>
<p><strong>Credits:</strong><br />
Many thanks for suggestions and debugging help to Roberto Doati, Gabriel Maldonado, Mark Jamerson, Andreas Bergsland, Oeyvind Brandtsegg, Francesco Biasiol, Giorgio Klauer, Paolo Girol, Francesco Porta, Eric Dexter, Menno Knevel, Joseph Alford, Panos Katergiathis, James Mobberley, Fabio Macelloni, Giuseppe Silvi, Maurizio Goina, Andrés Cabrera, Peiman Khosravi, Rory Walsh and Luis Jure.<br />
<br />
</p>
<p><span id="ch060_blue.xhtml"></span></p>
<h1>BLUE</h1>
<p>blue is a Java-based music composition environment for use with Csound.  It provides higher level abstractions such as a timeline, GUI-based instruments, score generating soundObjects like pianoRolls, scripting, and more.  It is available at:</p>
<p><a href="http://blue.kunstmusik.com" class="uri">http://blue.kunstmusik.com</a> </p>
<p><span id="ch061_cecilia.xhtml"></span></p>
<div id="ch061_cecilia.xhtml#header">
<h2><span class="image"><img src="static/logo_cabbage_sw_white_bck_1.png" /></span></h2>
</div>
<div id="ch061_cecilia.xhtml#content">
<div class="sect1">
<div class="sectionbody">
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><span>Cabbage is a software for prototyping and developing audio plugins with the Csound audio synthesis language. It provides Csound programmers with a simple albeit powerful toolkit for the development of cross-platform audio software. Pre-built binaries for Microsoft Windows and Apple OSX(Built on OSX 10.6) are available from the <a href="http://code.google.com/p/cabbage">Cabbage google code homepage.</a> You will also find a zipped archive of sample instruments.   </span></p>
<div class="paragraph">
<p><span>This document will take you through the basics of using Cabbage. It starts with a look at features provided by the host and then moves on to some simple examples. The text concludes with a reference section for the various GUI controls available in Cabbage. It’s assumed that the reader has some prior knowledge of Csound.</span></p>
</div>
<div class="paragraph">
<p><span>In order to use Cabbage you MUST have Csound installed. Cabbage is only available for the doubles version of Csound. This is the version that comes with the various installers so there shouldn't be any problems. If however you build your own version of Csound and don't build with the 'useDouble=1' options Cabbage will not work properly.</span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch061_cecilia.xhtml#_the_cabbage_standalone_player"><span>The Cabbage standalone player</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="static/CabbageStandaloneHost_1.PNG" /></span></p>
</div>
<div class="paragraph">
<p><span>Most prototyping will be done in the Cabbage standalone host. This host lets you load and run Cabbage instruments, as seen in the screenshot above. Clicking on the options button will give you access to the following commands:</span></p>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_open_cabbage_instrument"><span>Open Cabbage Instrument</span></h3>
<div class="paragraph">
<p><span>Use this command to open a cabbage instrument(Unified Csound file with a dedicated &lt;Cabbage&gt;&lt;/Cabbage&gt; section). You may open any .csd file you wish and add a Cabbage section yourself once it’s open. If opening existing Csound instrument you will need to use the<em>-n</em> command line options to tell Csound not to open any audio devices, as these are handled directly by Cabbage.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="static/smallLogo.png" /></span></td>
<td><span>On OSX users can open .csd files contained within plugins. Just select a .vst file instaed of a .csd file when opening. See the sections on exporting plugins for more information.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_new_cabbage_8230"><span>New Cabbage…</span></h3>
<div class="paragraph">
<p><span>This command will help you create a new Cabbage instrument/effect. Cabbage instruments are synthesisers capable of creating sounds from scratch while effects process incoming audio. Effects can access the incoming audio by using the <em>inch</em> or <em>ins</em> opcodes. All effects have stereo inputs and stereo outputs. Instruments can access the incoming MIDI data in a host of different ways but the easiest is to pipe the MIDI data directly to instrument p-fields using the MIDI inter-op command line flags. Examples can be found in the examples folder.</span></p>
</div>
<div class="paragraph">
<p><span>The <em>ctrl7</em> opcode doesn’t currently work so you should avoid using it in your instruments. <em>ctrl7</em> will be available in future versions</span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_view_source_editor"><span>View Source Editor</span></h3>
<div class="paragraph">
<p><span>This command will launch the integrated text editor. The text editor will always contain the text which corresponds to the instrument that is currently open. Each time a file is saved in the editor(Ctrl+S), Cabbage will automatically recompile the underlying Csound instrument and update any changes that have been made to the instruments GUI. The editor also features a Csound message console that can prove useful when debugging instruments.</span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_audio_settings"><span>Audio Settings</span></h3>
<div class="paragraph">
<p><span>Clicking on the audio settings command will open the audio settings window. Here you can choose your audio/MIDI input/output devices. You can also select the sampling rate and audio buffer sizes. Small buffer sizes will reduce latency but might cause some clicks in the audio. Keep testing buffer sizes until you find a setting that works best for your PC.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><img src="/csound/_edit/static/smallLogo.png" /></td>
<td><span>Cabbage hosts Csound instruments. It uses its own audio IO callbacks which will override any IO settings specified in the &lt;CsOptions&gt; sections of your Csound file.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_export_8230"><span>Export…</span></h3>
<div class="paragraph">
<p><span>This command will export your Cabbage instrument as a plugin. Clicking <em>synth</em> or <em>plugin</em> will cause Cabbage to create a plugin file(with a .dll file extension) into teh same directory as teh csd file you are using. When <em>exporting as</em> Cabbage will prompt you to save your plugin in a set location, under a specific name. Once Cabbage has created the plugin it will make a copy of the current .csd file and locate it in the same folder as the plugin. This new .csd file will have the same name as the plugin and should ALWAYS be in the same directory as the plugin.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><img src="/csound/_edit/static/smallLogo.png" /></td>
<td><span>You do not need to keep exporting instruments as plugins every time you modify them. You need only modify the associated source code. To simplify this task, Cabbage will automatically load the associated .csd file whenever you export as a plugin. On OSX Cabbage can open a plugin’s .csd file directly by selecting the plugin when prompted to select a file to open.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_always_on_top"><span>Always on Top</span></h3>
<div class="paragraph">
<p><span>This command lets you toggle <em>Always on top</em> mode. By default it is turned on. This means your Cabbage instrument will always appear on top of any other applications that are currently open.</span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_update_instrument"><span>Update Instrument</span></h3>
<div class="paragraph">
<p><span>This command updates Cabbage. This is useful if you decide to use another editor rather the one provided. Just remember to save any changes made to your Cabbage instrument before hitting update.</span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_batch_convert"><span>Batch Convert</span></h3>
<div class="paragraph">
<p><span>This command will let you convert a selection of Cabbage .csd files into plugins so you don’t have to manually open and export each one.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><img src="/csound/_edit/static/smallLogo.png" /></td>
<td><span>This feature is currently only available on Windows.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch061_cecilia.xhtml#X1"><span>Your first Cabbage instruments</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p><span>The following section illustrates the steps involved in building a simple Cabbage instrument. It’s assumed that the user has some prior knowledge of Csound. When creating a Cabbage patch users must provide special xml-style tags at the top of a unified Csound file. The Cabbage specific code should be placed between an opening &lt;Cabbage&gt; and a closing &lt;/Cabbage&gt; tag. You can create a new instrument by using the <em>New Cabbage Instrument</em> menu command. Select either a synth or an effect and Cabbage will automatically generate a basic template for you to work with.</span></p>
</div>
<div class="paragraph">
<p><span>Each line of Cabbage specific code relates to one graphical user interface(GUI) control only. Lines must start with the type of GUI control you wish to use, i.e, vslider, button, xypad, etc. Users then add identifiers to indicate how the control will look and behave. All parameters passed to identifiers are either strings denoted with double quotes or numerical values. Information on different identifiers and their parameters is given below in the reference section. Long lines can be broken up with a <em>\</em> placed at the end of a line.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><img src="/csound/_edit/static/smallLogo.png" /></td>
<td><span>This section does not go into details about each Cabbage control, nor does it show all available identifiers. Details about the various Cabbage controls can be found in reference section below.</span></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_a_basic_cabbage_synthesiser"><span>A basic Cabbage synthesiser</span></h3>
<div class="paragraph">
<p><span>Code to create the most basic of Cabbage synthesisers is presented below. This instrument uses the MIDI interop command line flags to pipe MIDI data directly to p-fields in instrument 1. In this case all MIDI pitch data is sent directly to p4, and all MIDI amplitude data is sent to p5. MIDI data been sent on channel 1 will cause instrument 1 to play. Data being sent on channel 2 will cause instrument 2 to play. It has been reported that the <em>massign</em> opcode does not work as expected with Cabbage. This is currently under investigation.</span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Cabbage&gt;
form size(400, 120), caption(&quot;Simple Synth&quot;), pluginID(&quot;plu1&quot;)
keyboard bounds(0, 0, 380, 100)
&lt;/Cabbage&gt;
&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-n -d -+rtmidi=NULL -M0 --midi-key-cps=4 --midi-velocity-amp=5
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

instr 1
kenv linenr p5, 0.1, .25, 0.01
a1 oscil kenv*k1, p4, 1
outs a1, a1
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f1 0 1024 10 1
f0 3600
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
</div>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="/csound/_edit/static/smallLogo.png" /></span></td>
<td><span>You’ll notice that a <em>-n</em> and <em>-d</em> are passed to Csound in the CsOptions section. -n stops Csound from writing audio to disk. This must be used as Cabbage manages its own audio IO callbacks. The <em>-d</em> prevents any FLTK widgets from displaying. You will also notice that our instrument is stereo. ALL Cabbage instruments operate in stereo.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_controlling_your_cabbage_patch"><span>Controlling your Cabbage patch</span></h3>
<div class="paragraph">
<p><span>The most obvious limitation to the above instrument is that users cannot interact directly with Csound. In order to do this one can use a Csound channel opcode and a Cabbage control such as a slider. Any control that is to interact with Csound must have a channel identifier.</span></p>
</div>
<div class="paragraph">
<p><span>When one supplies a channel name to the channel() identifier Csound will listen for data being sent on that channel through the use of the named channel opcodes. There are a few ways of retrieving data from the named channel bus in Csound, the most straightforward one being the chnget opcode. It’s defined in the Csound reference manual as:</span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>kval chnget Sname</code></pre>
</div>
</div>
<div class="paragraph">
<p><span><em>Sname</em> is the name of the channel. This same name must be passed to the <em>channel()</em> identifier in the corresponding &lt;Cabbage&gt; section. </span></p>
<div class="sect2">
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><img src="/csound/_edit/static/smallLogo.png" /></td>
<td>At present Cabbage only works with the chnget/chnset method of sending and receiving channel data. invalue and outvalue won't work. </td>
</tr>
</tbody>
</table>
</div>
</div>
<p><span>Our previous example can be modified so that a slider now controls the volume of our oscillator.</span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Cabbage&gt;
form size(400, 170), caption(&quot;Simple Synth&quot;), pluginID(&quot;plu1&quot;)
hslider bounds(0, 110, 380, 50), channel(&quot;gain&quot;), range(0, 1, .5), textBox(1)
keyboard bounds(0, 0, 380, 100)
&lt;/Cabbage&gt;
&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-n -d -+rtmidi=NULL -M0 --midi-key-cps=4 --midi-velocity-amp=5
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
ksmps = 64
nchnls = 2
0dbfs=1

instr 1
k1 chnget &quot;gain&quot;
kenv linenr p5, 0.1, 1, 0.1
a1 oscil kenv*k1, p4, 1
outs a1, a1
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f1 0 1024 10 1
f0 3600
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>In the example above we use a <em>hslider</em> control which is a horizontal slider. The bounds() identifier sets up the position and size of the widget. The most important identifier is <strong><em>channel(&quot;gain&quot;)</em></strong>. It is passed a string called <em>gain.</em> <span>This is the same string we pass to</span><em> chnget</em> in our Csound code. When a user moves the slider, the current position of the slider is sent to Csound on a channel named &quot;gain&quot;. Without the channel() identifier no communication would take place between the Cabbage control and Csound. The above example also uses a MIDI keyboard that can be used en lieu of a real MIDI keyboard when testing plugins.</span></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/simpleSynth_1.PNG" /></span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_a_basic_cabbage_effect"><span>A basic Cabbage effect</span></h3>
<div class="paragraph">
<p><span>Cabbage effects are used to process incoming audio. To do so one must make sure they can access the incoming audio stream. Any of Csound's signal input opcodes can be used for this. The examples that come with Cabbage use both the <em>ins</em> and <em>inch</em><span> opcodes to retreive the incoming audio signal. </span>The following code is for a simple reverb unit. It accepts a stereo input and outputs a stereo signal.</span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Cabbage&gt;
form caption(&quot;Reverb&quot;) size(230, 130)
groupbox text(&quot;Stereo Reverb&quot;), bounds(0, 0, 200, 100)
rslider channel(&quot;size&quot;), bounds(10, 25, 70, 70), text(&quot;Size&quot;), range(0, 2, 0.2)
rslider channel(&quot;fco&quot;), bounds(70, 25, 70, 70), text(&quot;Cut-off&quot;), range(0, 22000, 10000)
rslider channel(&quot;gain&quot;), bounds(130, 25, 70, 70), text(&quot;Gain&quot;), range(0, 1, 0.5)
&lt;/Cabbage&gt;
&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-d -n
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
; Initialize the global variables.
sr = 44100
ksmps = 32
nchnls = 2

instr 1
kfdback chnget &quot;size&quot;
kfco chnget &quot;fco&quot;
kgain chnget &quot;gain&quot;
ainL inch 1
ainR inch 2
aoutL, aoutR reverbsc ainL, ainR, kfdback, kfco
outs aoutL*kgain, aoutR*kgain
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f1 0 4096 10 1
i1 0 1000
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>The above instrument uses 3 sliders to control </span></p>
<ul>
<li>the reverb size</li>
<li>the cut-off frequency for the internal low-pass filters set up on the different delay lines</li>
<li>overall gain. <br />
<br />
</li>
</ul>
The range() identifier is used with each slider to specify the min, max and starting value of the sliders.
</div>
<div class="paragraph">
<p><span class="image"><img src="static/simpleReverb.PNG" /></span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="/csound/_edit/static/smallLogo.png" /></span></td>
<td><span>If you compare the two score sections in the above instruments you’ll notice that the synth instrument doesn't use any i-statement. Instead it uses an <em>f0 3600</em>. This tells Csound to wait for 3600 seconds before exiting. Because the instrument is to be controlled via MIDI we don’t need to use an i-statement in the score. In the other example we use an i-statement with a long duration so that the effect runs without stopping for a long time.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_exporting_your_instruments_as_plugins"><span>Exporting your instruments as plugins</span></h3>
<div class="paragraph">
<p><span>Once you have created your instruments you will need to export them as plugins if you want them to be seen by other host applications. When you export in Cabbage it will create a plugin file that will have the same name as the csd file you are currently working on. In your plugin host you will need to add the directory that contains your Cabbage plugins and csd files.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="/csound/_edit/static/smallLogo.png" /></span></td>
<td><span>In order to make future changes to the instrument you only need to edit the associated .csd file. For instance, if you have a plugin called &quot;SavageCabbage.dll&quot; and you wish to make some changes, you only have to edit the corresponding &quot;SavageCabbage.csd&quot; file. In order to see the changes in your plugin host you will need to delete and re-instantiate the plugin from the track. Your changes will be seen once you re-instantiate the plugin. </span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch061_cecilia.xhtml#_cabbage_reference"><span>Cabbage Reference</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p><span>Each and every Cabbage control has a numbers of possible identifiers that can be used to tell Cabbage how it will look and behave. Identifiers with parameters enclosed in quote marks must be passed a quoted string. Identifiers containing parameters without quotes must be passed numerical values. All parameters except <em>pos()</em> have default values and are therefore optional. In the reference tables below any identifiers enclosed in square brackets are optional.</span></p>
</div>
<div class="paragraph">
<p><span>As pos() and size() are used so often they can be set in one go using the bounds() identifier:</span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: bounds takes integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="paragraph">
<p><span>Below is a list of the different GUI controls currently available in Cabbage. Controls can be split into two groups, interactive controls and non-interactive controls. The non-interactive controls such as group boxes and images don’t interact in any way with either Csound or plugin hosts. The interactive controls such as sliders and buttons do interact with Csound. Each interactive control that one inserts into a Cabbage instrument will be accessible in a plugin host if the instrument has been exported as a plugin. The name that appears beside each native slider in the plugin host will be the assigned channel name for that control.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="/csound/_edit/static/smallLogo.png" /></span></td>
<td><span>In order to save space in the following reference section <em>bounds()</em> will be used instead of <em>pos()</em> and <em>size()</em> wherever applicable.</span></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_form"><span>Form</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>form caption(&quot;title&quot;), size(Width, Height), pluginID(&quot;plug&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>Form creates the main application window. pluginID() is the only required identifier. The default values for size are 600x300.</span></p>
</div>
<div class="paragraph">
<p><span><code>caption</code>: The string passed to caption will be the string that appears on the main application window.</span></p>
</div>
<div class="paragraph">
<p><span><code>size(Width, Height)</code>: integer values denoted the width and height of the form.</span></p>
</div>
<div class="paragraph">
<p><span><code>pluginID(&quot;plug&quot;)</code>: this unique string must be four characters long. It is the ID given to your plugin when loaded by plugin hosts.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="/csound/_edit/static/smallLogo.png" /></span></td>
<td><span>Every plugin must have a unique pluginID. If two plugins share the same ID there will be conflicts when trying to load them into a plugin host.</span></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>form  caption(&quot;Simple Synth&quot;), pluginID(&quot;plu1&quot;)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_groupbox"><span>GroupBox</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>groupbox bounds(x, y, width, height), text(&quot;Caption&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>Groupbox creates a container for other GUI controls. They do not communicate with Csound but can be useful for organising widgets into panels.</span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="paragraph">
<p><span><em>text(&quot;caption&quot;)</em>: &quot;caption&quot; will be the string to appear on the group box</span></p>
</div>
<p> </p>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>groupbox bounds(0, 0, 200, 100), text(&quot;Group box&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/groupbox.PNG" /></span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_keyboard"><span>Keyboard</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>keyboard bounds(x, y, width, height)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>Keyboard create a piano keyboard that will send MIDI information to your Csound instrument. This component can be used together with a hardware controller. Pressing keys on the actual MIDI keyboard will cause the on-screen keys to light up.</span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="/csound/_edit/static/smallLogo.png" /></span></td>
<td><span>you can only use one MIDI keyboard component with each Cabbage instrument. Also note that the keyboard can be played at different velocities depending on where you click on the key with your mouse. Clicking at the top of the key will cause a smaller velocity while clicking on the bottom will cause the note to sound with full velocity. The keyboard control is only provided as a quick and easy means of testing plugins in Cabbage. Treating it as anything more than that could result in severe disappointment!</span></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>keyboard bounds(0, 0, 200, 100)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/keyboard.PNG" /></span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_csoundoutput"><span>CsoundOutput</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>csoundoutput bounds(x, y, width, height), text(&quot;name&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>csoundoutput will let you view the Csound output console within your instrument’s GUI, useful when 'de-slugging'(debugging in Cabbage is known as de-slugging!) Cabbage instruments.</span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="paragraph">
<p><span><em>text(&quot;name&quot;)</em>: &quot;name&quot; will be the text that appears on the top of the check box.<br />
<br />
</span></p>
</div>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>csoundoutput bounds(210, 00, 340, 145), text(&quot;Csound Output&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/csoundoutput.PNG" /></span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_image"><span>Image</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>image bounds(x, y, width, height), file(&quot;file name&quot;), shape(&quot;type&quot;), colour(&quot;colour&quot;)\
        outline(&quot;colour&quot;), line(thickness)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>Image creates a static shape or graphic. It can be used to show pictures or it can be used to draw simple shapes. If you wish to display a picture you must pass the file name to the file() identifier. The file MUST be in the same directory as your Cabbage instrument. If you simply wish to draw a shape you can choose a background colour with colour() and an outline colour with outline(). line() will let you determine the thickness of the outline.</span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="paragraph">
<p><span><em>file(&quot;filename&quot;)</em>: &quot;filename&quot; is the name of the image to be displayed on the control</span></p>
</div>
<div class="paragraph">
<p><span><em>shape(&quot;type&quot;);</em>: &quot;shape&quot; must be either &quot;round&quot;(with rounded corners, default), &quot;sharp&quot;(with sharp corners), or &quot;ellipse&quot;(an elliptical shape)</span></p>
</div>
<div class="paragraph">
<p><span><em>colour(&quot;colour&quot;)</em>: This sets the colour of the image if no file name is given with the file identifier. Any CSS or HTML colour string can be passed to this identifier.</span></p>
</div>
<div class="paragraph">
<p><span><em>outline(&quot;colour&quot;)</em>: This sets the outline colour of the image/shape. Any CSS or HTML colour string can be passed to this identifier.</span></p>
</div>
<div class="paragraph">
<p><span><em>line(thickness)</em>: This sets the line thickness in pixels.<br />
<br />
</span></p>
</div>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>image bounds(0, 10, 260, 190), colour(&quot;white&quot;)
image bounds(5, 15, 250, 180), colour(&quot;brown&quot;)
image bounds(30, 30, 200, 150), file(&quot;logo_cabbage_sw_no_text.png&quot;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/images.PNG" /></span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_sliders"><span>Sliders</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>hslider bounds(x, y, width, height), channel(&quot;chanName&quot;)[, caption(&quot;caption&quot;) \
        text(&quot;name&quot;), textBox(on/off), range(min, max, value, skew, incr) \
        midCtrl(Channel, Ctrlnum), colour(&quot;colour&quot;)]</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>Slider can be used to create an on-screen slider. Data can be sent to Csound on the channel specified through the chanName string. Presented above is the syntax for a horizontal slider, i.e., <em>hslider</em>. In order to change it to another slider type simple substitute hslider with the appropriate identifier as outlined below.</span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="paragraph">
<p><span><em>channel(&quot;chanName&quot;)</em>: &quot;chanName&quot; is the name of the channel upon which to communicate with Csound(see examples above).</span></p>
</div>
<div class="paragraph">
<p><span><em>caption(&quot;caption&quot;)</em>: This identifier lets you place your control within a groupbox. &quot;caption&quot; is the text that will appear on groupbox. This identifier is useful for naming and containing controls.</span></p>
</div>
<div class="paragraph">
<p><span><em>range(min, max, value, skew, incr)</em>: the first 2 parameters are required. The rest are optional. The first two parameters let you set the minimum value and the maximum value. The next parameter determines the initial value of the slider. The next allows you to adjust the skew factor. Tweaking the skew factor can cause the slider to output values in a non linear fashion. A skew of 0.5 will cause the slider to output values in an exponential fashion. A skew of 1 is the default value, which causes the slider to behave is a typical linear form.</span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="/csound/_edit/static/smallLogo.png" /></span></td>
<td><span>For the moment <em>min</em> must be less than <em>max</em>. In other words you can’t invert the slider. Also note that skew defaults to 1 when the slider is being controlled by MIDI.</span></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p><span><em>text(&quot;name&quot;)</em>: The string passed in for &quot;name&quot; will appear on a label beside the slider. This is useful for naming sliders.</span></p>
</div>
<div class="paragraph">
<p><span><em>textBox(on/off)</em>: textbox takes a 0 or a 1. 1 will cause a text box to appear with the sliders values. Leaving this out will result in the numbers appearing automatically when you hover over the sliders with your mouse.</span></p>
</div>
<div class="paragraph">
<p><span><em>midCtrl(channel, Ctrlnum)</em> : channel must be a valid midi channel, while controller num should be the number of the controller you wish to use. This identifier only works when running your instruments within the Cabbage standalone player. </span></p>
</div>
<div class="paragraph">
<p><span><em>colour(&quot;colour&quot;)</em>: This sets the colour of the image if a file name is not passed to file. Any CSS or HTML colour string can be passed to this identifier.</span></p>
</div>
<div class="paragraph">
<p><span>Slider types:</span></p>
</div>
<div class="paragraph">
<p><span><em>hslider:</em> horizontal slider</span></p>
</div>
<div class="paragraph">
<p><span><em>vslider:</em> vertical slider</span></p>
</div>
<div class="paragraph">
<p><span><em>rslider:</em> rotary slider<br />
<br />
</span></p>
</div>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>rslider bounds(0, 110, 90, 90), caption(&quot;Freq1&quot;), channel(&quot;freq2&quot;), colour(&quot;cornflowerblue&quot;)\
        range(0, 1, .5), midictrl(0, 1)
rslider bounds(100, 120, 70, 70), text(&quot;Freq2&quot;), channel(&quot;freq2&quot;), colour(&quot;red&quot;)\
         range(0, 1, .5), midictrl(0, 1)
rslider bounds(190, 120, 70, 70), text(&quot;Freq3&quot;), channel(&quot;freq2&quot;), colour(&quot;green&quot;)\
        text(&quot;Freq3&quot;), textbox(1)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/sliders.PNG" /></span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_button"><span>Button</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>button bounds(x, y, width, height), channel(&quot;chanName&quot;)[, text(&quot;offCaption&quot;,&quot;onCaption&quot;)\
        caption(&quot;caption&quot;), value(val)]</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>Button creates a button that can be used for a whole range of different tasks. The &quot;channel&quot; string identifies the channel on which the host will communicate with Csound. &quot;OnCaption&quot; and &quot;OffCaption&quot; determine the strings that will appear on the button as users toggle between two states, i.e., 0 or 1. By default these captions are set to &quot;On&quot; and &quot;Off&quot; but the user can specify any strings they wish. Button will constantly toggle between 0 and 1. </span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="paragraph">
<p><span><em>channel(&quot;chanName&quot;)</em>: &quot;chanName&quot; is the name of the channel upon which to communicate with Csound(see examples above).</span></p>
</div>
<div class="paragraph">
<p><span><em>caption(&quot;caption&quot;)</em>: This identifier lets you place your control within a groupbox. &quot;caption&quot; is the text that will appear on group box. This identifier is useful for naming and containing controls.</span></p>
</div>
<div class="paragraph">
<p><span><em>text(&quot;offCaption&quot;, &quot;onCaption&quot;)</em>: The text identifier must be passed at least one string argument. This string will be the one that will appear on the button. If you pass two strings to text() the button will toggle between the two string each time it is pushed.</span></p>
</div>
<div class="paragraph">
<p><span><em>value(val)</em>: val sets the initial state of the control<br />
<br />
</span></p>
</div>
<div class="paragraph">
<p><code>Example:</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>button bounds(0, 110, 120, 70), caption(&quot;Freq1&quot;), text(&quot;On&quot;, &quot;Off&quot;), channel(&quot;freq2&quot;), value(1)
button bounds(150, 110, 120, 70), text(&quot;On&quot;, &quot;Off&quot;), channel(&quot;freq2&quot;), value(0)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/buttons.PNG" /></span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_checkbox"><span>CheckBox</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>checkbox bounds(x, y, width, height), channel(&quot;chanName&quot;)[, text(&quot;name&quot;), value(val), caption(&quot;Caption&quot;)]</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>Checkbox creates a checkbox which functions like a button only the associated caption will not change when the user checks it. As with all controls capable of sending data to an instance of Csound the channel string is the channel on which the control will communicate with Csound.</span></p>
</div>
<div class="paragraph">
<p><span><em>channel(&quot;chanName&quot;)</em>: &quot;chanName&quot; is the name of the channel upon which to communicate with Csound(see examples above).</span></p>
</div>
<div class="paragraph">
<p><span><em>caption(&quot;caption&quot;)</em>: This identifier lets you place your control within a groupbox. &quot;caption&quot; is the text that will appear on groupbox. This identifier is useful for naming and containing controls.</span></p>
</div>
<div class="paragraph">
<p><span><em>text(&quot;name&quot;)</em>: &quot;name&quot; will be the text that appears beside the checkbox.</span></p>
</div>
<div class="paragraph">
<p><span><em>value(val)</em>: val sets the initial state of the control</span></p>
<p> </p>
</div>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>checkbox bounds(0, 110, 120, 70), caption(&quot;Freq1&quot;), text(&quot;On&quot;), channel(&quot;freq2&quot;)
checkbox bounds(130, 110, 120, 70), text(&quot;Mute&quot;), channel(&quot;freq2&quot;), value(1)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/checkboxes.PNG" /></span></p>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_combobox"><span>ComboBox</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>combobox bounds(x, y, width, height), channel(&quot;chanName&quot;)[, value(val), items(&quot;item1&quot;, &quot;item2&quot;, ...)\
        caption(&quot;caption&quot;)]</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>Combobox creates a drop-down list of items which users can choose from. Once the user selects an item, the index of their selection will be sent to Csound on a channel named by the channel string. The default value is 0.</span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="paragraph">
<p><span><em>channel(&quot;chanName&quot;)</em>: &quot;chanName&quot; is the name of the channel upon which to communicate with Csound(see examples above).</span></p>
</div>
<div class="paragraph">
<p><span><strong><em><code>items(&quot;item1&quot;,  &quot;item2&quot;, etc)</code>:</em></strong> list of items that will populate the combobox. Each item has a corresponding index value. The first item when selected will send a 1, the second item a 2, the third a 3 etc.</span></p>
</div>
<div class="paragraph">
<p><span><em>value(val)</em>: val sets the initial state of the control</span></p>
</div>
<div class="paragraph">
<p><span><em>caption(&quot;caption&quot;)</em>: This identifier lets you place your control within a groupbox. &quot;caption&quot; is the text that will appear on groupbox. This identifier is useful for naming and containing controls.<br />
<br />
</span></p>
</div>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>combobox bounds(0, 110, 120, 70), channel&quot;freq&quot;), caption(&quot;Freq&quot;), items(&quot;200Hz&quot;, &quot;400Hz&quot;, &quot;800Hz&quot;), value(2)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/combobox.PNG" /></span></p>
</div>
<div class="admonitionblock">
<table>
<tbody>
<tr class="odd">
<td><span><img src="/csound/_edit/static/smallLogo.png" /></span></td>
<td><span>Combo boxes are proving a little troublesome when used in plugin hosts. We hope to resolve this issue shortly. In the mean time one can use a slider and split it into different regions. Note that all GUI controls appear as sliders when shown as native controls in a plugin host. </span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch061_cecilia.xhtml#_xypad"><span>XYPad</span></h3>
<div class="listingblock">
<div class="content">
<pre><code>xypad bounds(x, y, width, height), channel(&quot;chanName&quot;)[, rangex(min, max, val)\
        rangey(min, max, val), text(&quot;name&quot;)]</code></pre>
</div>
</div>
<div class="paragraph">
<p><span>xypad is an x/y controller that sends data to Csound on two named channels. The first channel transmits the current position of the ball on the X axis, while the second transmits the position of the ball on the Y axis. If you turn on automation via the checkbox located on the bottom left of the xypad you can throw the ball from edge to edge. Once the ball is in full flight you can control the speed of the ball using the XYpad slider.</span></p>
</div>
<div class="paragraph">
<p><span><em>bounds(x, y, width, height)</em>: integer values that set position and size on screen(in pixels)</span></p>
</div>
<div class="paragraph">
<p><span><em>channel(&quot;chanName&quot;)</em>: &quot;chanName&quot; is the name of the channel in which to communicate with Csound(see examples above).</span></p>
</div>
<div class="paragraph">
<p><span><em>text(&quot;name&quot;)</em>: &quot;name&quot; will be the text that appears on the top right hand side of the XYpad surface.</span></p>
</div>
<div class="paragraph">
<p><span><em>rangex(min, max, value)</em>: sets the range of the X axis. The first 2 parameters are required. The third is optional. The first two parameters let you set the minimum value and the maximum value. The next parameter determines the initial value.</span></p>
</div>
<div class="paragraph">
<p><span><em>rangey(min, max, value)</em>: sets the range of the Y axis. The first 2 parameters are required. The third is optional. The first two parameters let you set the minimum value and the maximum value. The next parameter determines the initial value.<br />
<br />
</span></p>
</div>
<div class="paragraph">
<p><span><strong>Example:</strong></span></p>
</div>
<div class="listingblock">
<div class="content">
<pre><code>xypad bounds(0, 0, 300, 300), text(&quot;X/Y PAD&quot;), rangex(0, 500, 250), rangey(0, 100, 25)</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="static/xypad.PNG" /></span></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch061_cecilia.xhtml#_quick_reference"><span>Q</span><span>uick Reference</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p><span>This quick reference table table gives a list of the valid identifiers for each Cabbage control.</span></p>
</div>
<div class="tableblock">
<table style="width:100%;">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">form</th>
<th style="text-align: left;">slider</th>
<th style="text-align: left;">button</th>
<th style="text-align: left;">checkbox</th>
<th style="text-align: left;">groupbox</th>
<th style="text-align: left;">combobox</th>
<th style="text-align: left;">xypad</th>
<th style="text-align: left;">image</th>
<th style="text-align: left;">csoundoutput</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>bounds</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>caption</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>channel</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>colour</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>file</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>items</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>line</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>max</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>midictrl</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>min</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>outline</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>pos</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>rangex</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>rangey</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>shape</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>size</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>text</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>value</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"><p>x</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch061_cecilia.xhtml#_troubleshooting_faqs_tips_and_tricks"><span>Troubleshooting, FAQs, tips and tricks</span></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li><p><span><em>Why doesn’t my VST host see my Cabbage plugins?</em> The most likely reason is that you have not added the directory containing your plugins to your host’s preferences. Most hosts will allow you to choose the folders that contain plugins. If you don’t set the Cabbage plugin directory then the host has no idea where your Cabbage plugins are located.</span></p></li>
<li><p><span><em>Why doesn’t my Cabbage plugin load?</em> The most likely reason a plugin will not load is because there are errors in the Csound code. Cabbage plugins will load regardless of errors in the Cabbage code, but errors in the Csound code will stop Csound from compiling successfully and prevent the plugin from loading. Always make sure that the Csound code is error free before exporting.</span></p></li>
<li><p><span><em>One mega plugin or several smaller ones?</em> It’s a good idea to split multi-effects instruments into separate plugins. This allows greater modularity within you plugin host and can often lead to less demand on your PC’s CPU.</span></p></li>
<li><p><span><em>Mixing effects and instruments?</em> Adding an effect processor to a plugin instrument might seem like a good idea. For instance you might add some reverb to the output of your FM synth to create some nice presence. In general however it is best to keep them separate. Plugin instruments demand a whole lot more CPU than their effects siblings. Performance will be a lot smoother if you split the two processes up and simply send the output of your synthesiser into an instance of a Cabbage reverb effect plugin.</span></p></li>
<li><p><span><em>What’s up? My plugin makes a load of noise?</em> If you have nchnls set to 1 thre will be noise sent to the second, or right channel. Make sure that nchnls is ALWAYS set to 2! Also be careful when dealing with stereo input. If you try to access the incoming signal on the right channel but you don't have any audio going to the right channel you may experience some noise. </span></p></li>
<li><p><span><em>I can’t tell whether my sliders are controlling anything?!</em> There will be times when moving sliders or other interactive controls just doesn’t do what you might expect. The best way to de-slug Cabbage instruments is to use the <em>printk2</em> opcode in Csound. For instance if a slider is not behaving as expected make sure that Csound is receiving data from the slider on the correct channel. Using the code below should print the values of the slider to the Csound output console each time you move it. If not, then you most likely have the wrong channel name set.</span></p></li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre><code>(...)
k1 chnget &quot;slider1&quot;
printk2 k1
(...)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li><p><span><em>What gives? I’ve checked my channels and they are consistent, yet moving my sliders does nothing?</em> Believe it or not we have come across some cases of this happening! In all cases it was due to the fact that the chosen channel name contained a /. Please try to use plain old letters for your channel names. Avoid using any kind of mathematical operators or fancy symbols and everything should be Ok.</span></p></li>
<li><p><span><em>Can I use nchnls to determine the number of output channels in my plugin?</em> Currently all Cabbage plugins are stereo by default. We are looking into ways of making plugins multichannel but limitations in the VST SDK are proving to be a stumbling block. It is something we are committed to finding a fix for.</span></p></li>
<li><p><span><em>Can I use Csound MACROs in the &lt;Cabbage&gt; section of my csd file?</em> I’m afraid not. The Cabbage section of your csd file is parsed by Cabbage’s own parser therefore it will not understand any Csound syntax whatsoever.</span></p></li>
<li><p><span><em>I’ve built some amazing instruments, how do I share them with the world?!</em> Easy. Send me(rory walsh at ear dot ie), your instruments and I will add them to the Cabbage examples so that other Cabbage users can have a go.</span></p></li>
</ul>
</div>
</div>
</div>
</div>
<div id="ch061_cecilia.xhtml#footer">
<div id="ch061_cecilia.xhtml#footer-text">
Last updated 2012-03-30 17:19:47 GMT Daylight Time
</div>
</div>
<p><span id="ch062_csound-via-terminal.xhtml"></span></p>
<h1>CSOUND VIA TERMINAL</h1>
<p>Whilst many of us now interact with Csound through one of its many front-ends which provide us with an experience more akin the that of mainstream software, new-comers to Csound should bear in mind that there was a time when the only way running Csound was from the command line using the <a href="http://www.csounds.com/manual/html/CommandTop.html">Csound command</a>. In fact we must still run Csound in this way but front-ends do this for us usually via some toolbar button or widget. Many people still prefer to interact with Csound from a terminal window and feel this provides a more 'naked' and honest interfacing with the program. Very often these people come from the group of users who have been using Csound for many years, form the time before front-ends. It is still important for all users to be aware of how to run Csound from the terminal as it provides a useful backup if problems develop with a preferred front-end.</p>
<h2>The Csound Command<br />
</h2>
<p>The Csound command follows the format:</p>
<pre><code>csound [performance_flags] [input_orc/sco/csd]</code></pre>
<p>Executing 'csound' with no additional arguments will run the program but after a variety of configuration information is printed to the terminal we will be informed that we provided &quot;insufficient arguments&quot; for Csound to do anything useful. This action can still be valid for first testing if Csound is installed and configured for terminal use, for checking what version is installed and for finding out what performance flags are available without having to refer to the manual.</p>
<p>Performance flags are controls that can be used to define how Csound will run. All of these flags have defaults but we can make explicitly use flags and change these defaults to do useful things like controlling the amount of information that Csound displays for us while running, activating a MIDI device for input, or altering buffer sizes for fine tuning realtime audio performance. Even if you are using a front-end, command line flags can be manipulated in a familiar format usually in 'settings' or 'preferences' menu. Adding flags here will have the same effect as adding them as part of the Csound command. To learn more about Csound's command line flags it is best to start on the page in the reference manual where they are listed and described <a href="http://www.csounds.com/manual/html/CommandFlagsCategory.html">by category</a>.</p>
<p>Command line flags can also be defined within the &lt;CsOptions&gt; &lt;/CsOptions&gt; part of a .csd file and also in a file called .csoundrc which can be located in the Csound home program directory and/or in the current working directory. Having all these different options for where esentially the same information is stored might seem excessive but it is really just to allow flexibiliy in how users can make changes to how Csound runs, depending on the situation and in the most efficient way possible. This does however bring up one one issue in that if a particular command line flag has been set in two different places, how does Csound know which one to choose? There is an order of precedence that allows us to find out.</p>
<p>Beginning from its own defaults the first place Csound looks for additional flag options is in the .csoundrc file in Csound's home directory, the next is in a .csoundrc file in the current working directory (if it exists), the next is in the &lt;CsOptions&gt; of the .csd and finally the Csound command itself. Flags that are read later in this list will overwrite earlier ones. Where flags have been set within a front-end's options, these will normally overwrite any previous instructions for that flag as they form part of the Csound command. Often a front-end will incorporate a check-box for disabling its own inclusion of flag (without actually having to delete them from the dialogue window).</p>
<p>After the command line flags (if any) have been declared in the Csound command, we provide the name(s) of out input file(s) - originally this would have been the orchestra (.orc) and score (.sco) file but this arrangement has now all but been replaced by the more recently introduced .csd (unified orchestra and score) file. The facility to use a separate orchestra and score file remains however.</p>
<p>For example:</p>
<pre><code>Csound -d -W -osoundoutput.wav inputfile.csd</code></pre>
<p>will run Csound and render the input .csd 'inputfile.csd' as a wav file ('-W' flag) to the file 'soundoutput.wav' ('-o' flag). Additionally displays will be suppressed as dictated by the '-d' flag. The input .csd file will need to be in the current working directory as no full path has been provided. the output file will be written to the current working directory of <a href="http://www.csounds.com/manual/html/CommandEnvironment.html">SFDIR</a> if specified.<br />
</p>
<p><br />
</p>
<p><span id="ch064_csound-utilities.xhtml"></span></p>
<h1>CSOUND UTILITIES</h1>
<p>Csound comes bundled with a variety of additional utility applications. These are small programs that perform a single function, very often with a sound file, that might be useful just before or just after working with the main Csound program. Originally these were programs that were run from the command line but many of Csound front-ends now offer direct access to many of these utilities through their own utilities menus. It is useful to still have access to these programs via the command line though, if all else fails.</p>
<p>The standard syntax for using these programs from the command line is to type the name of the utility followed optionally by one or more command line flags which control various performance options of the program - all of these will have useable defaults anyway - and finally the name of the sound file upon which the utility will operate.</p>
<pre><code>utility_name [flag(s)] [file_name(s)]</code></pre>
<p>If we require some help or information about a utility and don't want to be bothered hunting through the Csound Manual we can just type the the utility's name with no additional arguments, hit enter and the commmand line response will give us some information about that utility and what command line flags it offers. We can also run the utility through Csound - perhaps useful if there are problems running the utility directly - by calling Csound with the -U flag. The -U flag will instruct Csound to run the utility and to interpret subsequent flags as those of the utility and not its own.<br />
</p>
<pre><code>Csound -U utility_name [flag(s)] [file_name(s)]</code></pre>
<h2>sndinfo<br />
</h2>
<p>As an example of invoking one of these utilities form the command line we shall look at the utility 'sndinfo' (sound information) which provides the user with some information about one or more sound files. 'sndinfo' is invoked and provided with a file name thus:</p>
<pre><code>sndinfo /Users/iainmccurdy/sounds/mysound.wav</code></pre>
<p>If you are unsure of the file address of your sound file you can always just drag and drop it into the terminal window. The output should be something like:<br />
</p>
<pre><code>util sndinfo:
/Users/iainmccurdy/sounds/mysound.wav:
	srate 44100, stereo, 24 bit WAV, 3.335 seconds
	(147078 sample frames)</code></pre>
<p>'sndinfo' will accept a list of file names and provide information on all of them in one go so it may prove more efficient gleaning the same information from a GUI based sample editor. We also have the advantage of begin able to copy and paste from the terminal window into a .csd file.<br />
</p>
<h2>Analysis Utilities<br />
</h2>
<p>Although many of Csound's opcodes already operate upon commonly encountered sound file formats such as 'wav' and 'aiff', a number of them require sound information in more specialised and pre-analysed formats and for this Csound provides the sound analysis utilities <a href="http://www.csounds.com/manual/html/UtilityAtsa.html">atsa</a>, <a href="http://www.csounds.com/manual/html/cvanal.html">cvanal,</a> <a href="http://www.csounds.com/manual/html/hetro.html">hetro</a>, <a href="http://www.csounds.com/manual/html/lpanal.html">lpanal</a> and <a href="http://www.csounds.com/manual/html/pvanal.html">pvanal.</a> By far the most commonly used of these is <a href="http://www.csounds.com/manual/html/pvanal.html">pvanal</a> which, although originally written to provide analysis files for <a href="http://www.csounds.com/manual/html/pvoc.html">pvoc</a> and its generation of opcodes, has now been extended to be able to generate files in the pvoc-ex (.pvx) format for use with the newer 'pvs' streaming pvoc opcodes.</p>
<p>This time as well as requiring an input sound file for analysis we will need to provide a name (and optionally the full address) for the output file. Using pvanal's command flags we can have full control over typical FFT conversion parameters such as FFT size, overlap, window type etc. as well as additional options that may prove useful such as the ability to select a fragment of a larger sound file for the analysis. In the following illustration we shall make use of just one flag, -s, for selecting which channel of the input sound file to analyse, all other flag values shall assume their default values which should work fine in most situations.</p>
<pre><code> pvanal -s1 mysound.wav myanalysis.pvx</code></pre>
<p><a href="http://www.csounds.com/manual/html/pvanal.html">pvanal</a> will analyse the first (left if stereo) channel of the input sound file 'mysound.wav' (and in this case as no full address has been provided it will need to be in either the current working directory or <a href="http://www.csounds.com/manual/html/CommandEnvironment.html">SSDIR</a>), and a name has been provided for the output file 'myanalysis.pvx', which, as no full address has been given, will be placed in the current working directory. While <a href="http://www.csounds.com/manual/html/pvanal.html">pvanal</a> is running it will print a running momentary and finally inform us once the process is complete.</p>
<p>If you use CsoundQT you can have direct access to <a href="http://www.csounds.com/manual/html/pvanal.html">pvanal</a> with all its options through the 'utilities' button in the toolbar. Once opened it will reveal a dialogue window looking something like this:</p>
<p><img src="static/CsoundQTpvanal_1.jpg" /><br />
</p>
<p>Especially helpful is the fact that we are also automatically provided with <a href="http://www.csounds.com/manual/html/pvanal.html">pvanal</a>'s manual page.</p>
<h2>File Conversion Utilities</h2>
<p>The next group of utilities, <a href="http://www.csounds.com/manual/html/het_import.html">het_import</a>, <a href="http://www.csounds.com/manual/html/het_export.html">het_export</a>, <a href="http://www.csounds.com/manual/html/pvlook.html">pvlook</a>, <a href="http://www.csounds.com/manual/html/pv_export.html">pv_export</a>, <a href="http://www.csounds.com/manual/html/pv_import.html">pv_import</a>, <a href="http://www.csounds.com/manual/html/sdif2ad.html">sdif2ad</a> and <a href="http://www.csounds.com/manual/html/srconv.html">srconv</a> facilitate file conversions between various types. Perhaps the most interesting of these are <a href="http://www.csounds.com/manual/html/pvlook.html">pvlook</a>, which prints to the terminal a formatted text version of a <a href="http://www.csounds.com/manual/html/pvanal.html">pvanal</a> file - useful to finding out exactly what is going on inside individual analysis bins, something that may be of use when working with the more advanced resynthesis opcodes such as <a href="http://www.csounds.com/manual/html/pvadd.html">pvadd</a> or <a href="http://www.csounds.com/manual/html/pvsbin.html">pvsbin</a>. <a href="http://www.csounds.com/manual/html/srconv.html">srconv</a> can be used to convert the sample rate of a sound file.</p>
<h2>Miscellaneous Utilities</h2>
<p>A final grouping gathers together various unsorted utilities: <a href="http://www.csounds.com/manual/html/cs.html">cs</a>, <a href="http://www.csounds.com/manual/html/csb64enc.html">csb64enc</a>, <a href="http://www.csounds.com/manual/html/envext.html">envext</a>, <a href="http://www.csounds.com/manual/html/extractor.html">extractor</a>, <a href="http://www.csounds.com/manual/html/makecsd.html">makecsd</a>, <a href="http://www.csounds.com/manual/html/mixer.html">mixer</a>, <a href="http://www.csounds.com/manual/html/scaleutility.html">scale</a> and <a href="http://www.csounds.com/manual/html/mkdb.html">mkdb</a>. Most interesting of these are perhaps <a href="http://www.csounds.com/manual/html/extractor.html">extractor</a> which will extract a user defined fragment of a sound file which it will then write to a new file, <a href="http://www.csounds.com/manual/html/mixer.html">mixer</a> which mixes together any number of sound files and with gain control over each file and <a href="http://www.csounds.com/manual/html/scaleutility.html">scale</a> which will scale the amplitude of an individual sound file.</p>
<p>It has been seen that the Csound utilities offer a wealth of useful, but often overlooked, tools to augment our work with Csound. Whilst some of these utilities may seem redundant now that most of us have access to fully featured 3rd-party sound editing software, it should be borne in mind that many of these utilities were written in the 1980s and early 90s when such tools were less readily available.<br />
</p>
<p> </p>
<h2><br />
</h2>
<p><br />
</p>
<p><span id="ch066_the-csound-api.xhtml"></span></p>
<h1>THE CSOUND API</h1>
<p>An application programming interface (API) is an interface provided by a computer system, library or application that allows users to access functions and routines for a particular task. It gives developers a way to harness the functionality of existing software within a host application. The Csound API can be used to control an instance of Csound through a series of different functions thus making it possible to harness all the power of Csound in one’s own applications. In other words, almost anything that can be done within Csound can be done with the API. The API is written in C, but there are interfaces to other languages as well, such as Python, C++ and Java.   </p>
<p>To use the Csound C API, you have to include csound.h in your source file and to link your code with libcsound. Here is an example of the csound command line application written using the Csound C API:</p>
<pre><code>#include &lt;csound/csound.h&gt;

int main(int argc, char **argv)
{
  CSOUND *csound = csoundCreate(NULL);
  int result = csoundCompile(csound, argc, argv);
  if (result == 0) {
    result = csoundPerform(csound);
  }
  csoundDestroy(csound);
  return (result &gt;= 0 ? 0 : result);
}</code></pre>
<p>First we create an instance of Csound. To do this we call csoundCreate() which returns an opaque pointer that will be passed to most Csound API functions. Then we compile the orc/sco files or the csd file given as input arguments through the argv parameter of the main function. If the compilation is successful (result == 0), we call the csoundPerform() function. csoundPerform() will cause Csound to perform until the end of the score is reached. When this happens csoundPerform() returns a non-zero value and we destroy our instance before ending the program.</p>
<p>On a linux system, with libcsound named libcsound64 (double version of the csound library), supposing that all include and library paths are set correctly, we would build the above example with the following command:</p>
<pre><code>gcc -DUSE_DOUBLE -o csoundCommand csoundCommand.c -lcsound64</code></pre>
<p>The C API has been wrapped in a C++ class for convenience. This gives the Csound basic C++ API. With this API, the above example would become:</p>
<pre><code>#include &lt;csound/csound.hpp&gt;

int main(int argc, char **argv)
{
  Csound *cs = new Csound();
  int result = cs-&gt;Compile(argc, argv);
  if (result == 0) {
    result = cs-&gt;Perform();
  }
  return (result &gt;= 0 ? 0 : result);
}</code></pre>
<p>Here, we get a pointer to a Csound object instead of the csound opaque pointer. We call methods of this object instead of C functions, and we don't need to call csoundDestroy in the end of the program, because the C++ object destruction mechanism takes care of this. On our linux system, the example would be built with the following command:</p>
<pre><code>g++ -DUSE_DOUBLE -o csoundCommandCpp csoundCommand.cpp -lcsound64</code></pre>
<p>The Csound API has also been wrapped to other languages. The Csound Python API wraps the Csound API to the Python language. To use this API, you have to import the csnd module. The csnd module is normally installed in the site-packages or dist-packages directory of your python distribution as a csnd.py file. Our csound command example becomes:</p>
<pre><code>import sys
import csnd

def csoundCommand(args):
    csound = csnd.Csound()
    arguments = csnd.CsoundArgVList()
    for s in args:
        arguments.Append(s)
    result = csound.Compile(arguments.argc(), arguments.argv())
    if result == 0:
        result = csound.Perform()
    return result

def main():
    csoundCommand(sys.argv)

if __name__ ==&#39;__main__&#39;:
    main()</code></pre>
<p>We use a Csound object (remember Python has OOp features). Note the use of the CsoundArgVList helper class to wrap the program input arguments into a C++ manageable object. In fact, the Csound class has syntactic sugar (thanks to method  overloading) for the Compile method. If you have less than six string arguments to pass to this method, you can pass them directly. But here, as we don't know the number of arguments to our csound command, we use the more general mechanism of the CsoundArgVList helper class.</p>
<p>The Csound Java API wraps the Csound API to the Java language. To use this API, you have to import the csnd package. The csnd package is located in the csnd.jar archive which has to be known from your Java path. Our csound command example becomes:</p>
<pre><code>import csnd.*;

public class CsoundCommand
{
  private Csound csound = null;
  private CsoundArgVList arguments = null;

  public CsoundCommand(String[] args) {
    csound = new Csound();
    arguments = new CsoundArgVList();
    arguments.Append(&quot;dummy&quot;);
    for (int i = 0; i &lt; args.length; i++) {
      arguments.Append(args[i]);
    }
    int result = csound.Compile(arguments.argc(), arguments.argv());
    if (result == 0) {
      result = csound.Perform();
    }
    System.out.println(result);
  }


  public static void main(String[] args) {
    CsoundCommand csCmd = new CsoundCommand(args);
  }
}</code></pre>
<p>Note the &quot;dummy&quot; string as first argument in the arguments list. C, C++ and Python expect that the first argument in a program argv input array is implicitly the name of the calling program. This is not the case in Java: the first location in the program argv input array contains the first command line argument if any.  So we have to had this &quot;dummy&quot; string value in the first location of the arguments array so that the C API function called by our csound.Compile method is happy.</p>
<p>This illustrates a fundamental point about the Csound API. Whichever API wrapper is used (C++, Python, Java, etc), it is the C API which is working under the hood. So a thorough knowledge of the Csound C API is highly recommended if you plan to use the Csound API in any of its different flavours. The main source of information about the Csound C API is the csound.h header file which is fully commented.</p>
<p>On our linux system, with csnd.jar located in /usr/local/lib/csound/java, our Java Program would be compiled and run with the following commands:</p>
<pre><code>javac -cp /usr/local/lib/csound/java/csnd.jar CsoundCommand.java
java -cp /usr/local/lib/csound/java/csnd.jar:. CsoundCommand</code></pre>
<p>There also exists an extended Csound C++ API, which adds to the Csound C++ API a CsoundFile class, the CsoundAC C++ API, which provides a class hierarchy for doing algorithmic composition using Michael Gogins' concept of music graphs, and API wrappers for the LISP, LUA and HASKELL languages.</p>
<p>For now, this chapter chapter we will focus on the basic C/C++ API, and the Python and Java API.</p>
<h2>Threading</h2>
<p>Before we begin to look at how to control Csound in real time we need to look at threads. Threads are used so that a program can split itself into two or more simultaneously running tasks. Multiple threads can be executed in parallel on many computer systems. The advantage of running threads is that you do not have to wait for one part of your software to finish executing before you start another.</p>
<p>In order to control aspects of your instruments in real time your will need to employ the use of threads. If you run the first example found on this page you will see that the host will run for as long as csoundPerform() returns 0. As soon as it returns non-zero it will exit the loop and cause the application to quit. Once called, csoundPerform() will cause the program to hang until it is finished. In order to interact with Csound while it is performing you will need to call csoundPerform() in a separate unique thread. </p>
<p>When implementing threads using the Csound API, we must define a special performance function thread. We then pass the name of this performance function to csoundCreateThread(), thus registering our performance-thread function with Csound. When defining a Csound performance-thread routine you must declare it to have a return type uintptr_t, hence it will need to return a value when called. The thread function will take only one parameter, a pointer to void. This pointer to void is quite important as it allows us to pass important data from the main thread to the performance thread. As several variables are needed in our thread function the best approach is to create a user defined data structure that will hold all the information your performance thread will need. For example:</p>
<pre><code>typedef struct{ 
/*result of csoundCompile()*/ 
int result;  
/*instance of csound*/ 
CSOUND* csound;  
/*performance status*/ 
bool PERF_STATUS;  
}userData; </code></pre>
<p>Below is a basic performance-thread routine. *data is cast as a userData data type so that we can access its members. </p>
<pre><code>uintptr_t csThread(void *data)
{
userData* udata = (userData*)data;
if(!udata-&gt;result)
  {
  while((csoundPerformKsmps(udata-&gt;csound) == 0)&amp;&amp;
					(udata-&gt;PERF_STATUS==1));
  csoundDestroy(udata-&gt;csound);
  }
udata-&gt;PERF_STATUS = 0;
return 1;
}          </code></pre>
<p>In order to start this thread we must call the csoundCreateThread() API function which is declared in csound.h as:  </p>
<pre><code>void *csoundCreateThread(uintptr_t (*threadRoutine) (void *),void *userdata);  </code></pre>
<p>If you are building a command line program you will need to use some kind of mechanism to prevent int main() from returning until after the performance has taken place. A simple while loop will suffice. </p>
<p>The first example presented above can now be rewritten to include a unique performance thread:</p>
<pre><code>#include &lt;stdio.h&gt; 
#include &quot;csound.h&quot; 

uintptr_t csThread(void *clientData); 

typedef struct { 
int result; 
CSOUND* csound; 
int PERF_STATUS; 
}userData; 

int main(int argc, char *argv[]) 
{ 
void* ThreadID; 
userData* ud; 
ud = (userData *)malloc(sizeof(userData));  
MYFLT* pvalue; 
csoundInitialize(&amp;argc, &amp;argv, 0);  
ud-&gt;csound=csoundCreate(NULL);  
ud-&gt;result=csoundCompile(ud-&gt;csound,argc,argv); 

if(!ud-&gt;result)  {  
ud-&gt;PERF_STATUS=1; 
ThreadID = csoundCreateThread(csThread, (void*)ud); 
} 
else{ 
return 0; 
}  

//keep performing until user presses enter
scanf(&quot;%d&quot;, &amp;finish);
ud-&gt;PERF_STATUS=0; 
csoundDestroy(ud-&gt;csound); 
free(ud);  
return 1; 
} 

//performance thread function
uintptr_t csThread(void *data) 
{ 
  userData* udata = (userData*)data; 
      if(!udata-&gt;result) 
        { 
        while((csoundPerformKsmps(udata-&gt;csound) == 0) &amp;&amp;(udata-&gt;PERF_STATUS==1)); 
    	csoundDestroy(udata-&gt;csound); 
        }        
  udata-&gt;PERF_STATUS = 0;    
  return 1; 
}  </code></pre>
<p>The application above might not appear all that interesting. In fact it's almost the exact same as the first example presented except that users can now stop Csound by hitting 'enter'.  The real worth of threads can only be appreciated when you start to control your instrument in real time.</p>
<p><span class="Apple-style-span">Channel I/O</span></p>
<p>The big advantage to using the API is that it allows a host to control your Csound instruments in real time. There are several mechanisms provided by the API that allow us to do this. The simplest mechanism makes use of a 'software bus'.</p>
<p>The term bus is usually used to describe a means of communication between hardware components. Buses are used in mixing consoles to route signals out of the mixing desk into external devices. Signals get sent through the sends and are taken back into the console through the returns. The same thing happens in a software bus, only instead of sending analog signals to different hardware devices we send data to and from different software. </p>
<p>Using one of the software bus opcodes in Csound we can provide an interface for communication with a host application. An example of one such opcode is <a href="http://www.csounds.com/manual/html/chnget.html">chnget</a>. The <em>chnget</em> opcode reads data that is being sent from a host Csound API application on a particular named channel, and assigns it to an output variable. In the following example instrument 1 retrieves any data the host may be sending on a channel named &quot;pitch&quot;:</p>
<pre><code>instr 1 
kval chnget &quot;pitch&quot; 
a1 oscil 10000, kval, 1 
out a1 
endin </code></pre>
<p>One way in which data can be sent from a host application to an instance of Csound is through the use of the csoundGetChannelPtr() API function which is defined in csound.h as:   </p>
<p>int csoundGetChannelPtr(CSOUND *, MYFLT **p, const char *name,  int type);</p>
<p>CsoundGetChannelPtr() stores a pointer to the specified channel of the bus in p. The channel pointer p is of type MYFLT. The argument name is the name of the channel and the argument type is a bitwise OR of exactly one of the following values:  </p>
<p>CSOUND_CONTROL_CHANNEL - control data (one MYFLT value) <br />
CSOUND_AUDIO_CHANNEL - audio data (ksmps MYFLT values) <br />
CSOUND_STRING_CHANNEL - string data (MYFLT values with enough space to store csoundGetStrVarMaxLen(CSOUND*) characters, including the NULL character at the end of the string)   </p>
<p>and at least one of these:  </p>
<p>CSOUND_INPUT_CHANNEL - when you need Csound to accept incoming values from a host<br />
CSOUND_OUTPUT_CHANNEL - when you need Csound to send outgoing values to a host </p>
<p>If the call to csoundGetChannelPtr() is successful the function will return zero. If not, it will return a negative error code. We can now modify our previous code in order to send data from our application on a named software bus to an instance of Csound using csoundGetChannelPtr().  </p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;csound.h&quot;

//performance thread function prototype
uintptr_t csThread(void* clientData);

//userData structure declaration
typedef struct {
int result;
CSOUND* csound;
int PERF_STATUS;
}userData;


//------------------------------------------------------------
// main function
//-----------------------------------------------------------int main(int argc, char *argv[])
{
int userInput=200;
void* ThreadID;
userData* ud;
ud = (userData*)malloc(sizeof(userData));
MYFLT* pvalue;
csoundInitialize(&amp;argc, &amp;argv, 0);
ud-&gt;csound=csoundCreate(NULL);
ud-&gt;result=csoundCompile(ud-&gt;csound,argc,argv);
if(!ud-&gt;result)
{
ud-&gt;PERF_STATUS=1;
ThreadID = csoundCreateThread(csThread, (void*)ud);
}
else{
printf(&quot;csoundCompiled returned an error&quot;);
return 0;
}
printf(&quot;\nEnter a pitch in
Hz(0 to Exit) and type return\n&quot;); 
while(userInput!=0)
{
if(csoundGetChannelPtr(ud-&gt;csound,
&amp;pvalue, &quot;pitch&quot;,
CSOUND_INPUT_CHANNEL
| CSOUND_CONTROL_CHANNEL)==0);
*pvalue =
(MYFLT)userInput;
scanf(&quot;%d&quot;,
&amp;userInput);
}
ud-&gt;PERF_STATUS=0;
csoundDestroy(ud-&gt;csound);
free(ud);
return 1;
}
//-------------------------------------------------------------
//definition of our performance thread function
//-------------------------------------------------------------
uintptr_t csThread(void *data)
{
userData* udata =(userData*)data;
if(!udata-&gt;result)
{
while((csoundPerformKsmps(udata-&gt;csound)== 0)
	&amp;&amp;(udata-&gt;PERF_STATUS==1));
	csoundDestroy(udata-&gt;csound);
}
udata-&gt;PERF_STATUS = 0;
return 1;
} </code></pre>
<h2>Score Events </h2>
<p>Adding score events to the csound instance is easy to do. It requires that csound has its threading done, see the paragraph above on threading. To enter a score event into csound, one calls the following function:</p>
<pre><code>void myInputMessageFunction( void* data, const char* message)
{
	userData* udata = (userData*) data;
	csoundInputMessage( udata-&gt;csound , message );
}</code></pre>
</pre>
<p>Now we can call that function to insert Score events into a running csound instance. The formatting of the message should be the same as one would normally have in the Score part of the .csd file. The example shows the format for the message. Note that if you're allowing csound to print its error messages, if you send a malformed message, it will warn you. Good for debugging. There's an example with the csound source code that allows you to type in a message, and then it will send it.<br />
</p>
<pre><code>                       instrNum    start    duration   p4   p5  p6   ...   pN
const char* message = &quot;i1          0        1         0.5  0.3 0.1&quot;   ;
myInputMessageFunction( (void*) udata , message);</code></pre>
</pre>
<p><span class="Apple-style-span"><br />
Callbacks</span></p>
<h2>Conclusion</h2>
<h2>References &amp; Links<br />
</h2>
<p>Michael Gogins 2006, &quot;Csound and CsoundVST API Reference Manual&quot;, http://csound.sourceforge.net/refman.pdf</p>
<p>Rory Walsh 2006, &quot;Developing standalone applications using the Csound Host API and wxWidgets&quot;, Csound Journal Volume 1 Issue 4 - Summer 2006, http://www.csounds.com/journal/2006summer/wxCsound.html</p>
<p>Rory Walsh 2010, &quot;Developing Audio Software with the Csound Host API&quot;,  The Audio Programming Book, DVD Chapter 35, The MIT Press<br />
</p>
<p>François Pinot 2011, &quot;Real-time Coding Using the Python API: Score Events&quot;, Csound Journal Issue 14 - Winter 2011, http://www.csounds.com/journal/issue14/realtimeCsoundPython.html<br />
</p>
<p><span id="ch067_using-python-inside-csound.xhtml"></span></p>
<h1>USING PYTHON INSIDE CSOUND</h1>
<p>coming in the next release ...</p>
<p>For now, have a look at Andrés Cabrera, Using Python inside Csound, An introduction to the Python opcodes, Csound Journal Issue 6, Spring 2007: http://www.csounds.com/journal/issue6/pythonOpcodes.html<br />
</p>
<p><span id="ch068_c-python-in-csoundqt.xhtml"></span></p>
<h1>C. PYTHON IN CSOUNDQT</h1>
<p>coming in the next release ...</p>
<p>For now, you may want to have a look at Andrés Cabrera's paper <a href="http://www.incontri.hmtm-hannover.de/fileadmin/www.incontri/Csound_Conference/Cabrera.pdf">Python Scripting in QuteCsound</a> at the Csound Conference in Hannover.<br />
</p>
<p><span id="ch069_d-lua-in-csound.xhtml"></span></p>
<h1>D. LUA IN CSOUND</h1>
<p>coming in the next release ...</p>
<p>For now, have a look at Michael Gogins' paper <a href="http://www.incontri.hmtm-hannover.de/fileadmin/www.incontri/Csound_Conference/Gogins.pdf">Writing Csound Opcodes in Lua</a> at the Csound Conference in Hannover (there is also a video from the workshop at <a href="d-lua-in-csound/www.youtube.com/user/csconf2011">www.youtube.com/user/csconf2011</a>).<br />
</p>
<p><span id="ch071_extending-csound.xhtml"></span></p>
<h1>EXTENDING CSOUND</h1>
<p>coming in the next release ...<br />
</p>
<p><span id="ch073_overview.xhtml"></span></p>
<h1>OPCODE GUIDE: OVERVIEW</h1>
<p>If you run Csound from the command line with the option -z, you get a list of all opcodes. Currently (Csound 5.13), the total number of all opcodes is about 1500. There are already overviews of all of Csound's opcodes in the <a href="http://www.csounds.com/manual/html/PartOpcodesOverview.html">Opcodes Overview</a> and the <a href="http://www.csounds.com/manual/html/MiscQuickref.html">Opcode Quick Reference</a> of the <a href="http://www.csounds.com/manual/html/index.html">Canonical Csound Manual</a>.</p>
<p>This chapter is another attempt to provide some orientation within Csound's wealth of opcodes. Unlike to the references mentioned above not all opcodes are listed, but the ones listed are commented briefly. Some opcodes appear more than once, which is done intentionally, for example, there are different contexts within which you might use the <em>ftgen</em> opcode and the layout here reflects this multipurpose nature of a number of opcodes. This guide may also provide insights into the opcodes listed that the other sources do not.</p>
<h2>BASIC SIGNAL PROCESSING</h2>
<ul>
<li><h3>OSCILLATORS AND PHASORS</h3>
<ul>
<li><h4>Standard Oscillators</h4>
<p><a href="http://www.csounds.com/manual/html/oscils.html">(oscils)</a>  <a href="http://www.csounds.com/manual/html/poscil.html">poscil</a>  <a href="http://www.csounds.com/manual/html/poscil3.html">poscil3</a>  <a href="http://www.csounds.com/manual/html/oscili.html">oscili</a>  <a href="http://www.csounds.com/manual/html/oscil3.html">oscil3</a>  <a href="http://www.csounds.com/manual/html/SiggenBasic.html">more</a> </p></li>
<li><h4>Dynamic Sprectrum Oscillators</h4>
<p><a href="http://www.csounds.com/manual/html/buzz.html">buzz</a>  <a href="http://www.csounds.com/manual/html/gbuzz.html">gbuzz</a>  <a href="http://www.csounds.com/manual/html/mpulse.html">mpulse</a>  <a href="http://www.csounds.com/manual/html/vco.html">vco</a>  <a href="http://www.csounds.com/manual/html/vco2.html">vco2</a> <br />
</p></li>
<li><h4>Phasors</h4>
<p><a href="http://www.csounds.com/manual/html/phasor.html">phasor</a>  <a href="http://www.csounds.com/manual/html/syncphasor.html">syncphasor</a> <br />
</p></li>
</ul></li>
</ul>
<ul>
<li><h3>RANDOM AND NOISE GENERATORS</h3>
<p><a href="http://www.csounds.com/manual/html/seed.html">(seed)</a>  <a href="http://www.csounds.com/manual/html/rand.html">rand</a>  <a href="http://www.csounds.com/manual/html/randi.html">randi</a>  <a href="http://www.csounds.com/manual/html/randh.html">randh</a>  <a href="http://www.csounds.com/manual/html/rnd31.html">rnd31</a>  <a href="http://www.csounds.com/manual/html/random.html">random</a>  (<a href="http://www.csounds.com/manual/html/randomi.html">randomi</a> /<a href="http://www.csounds.com/manual/html/randomh.html">randomh</a>)  <a href="http://www.csounds.com/manual/html/pinkish.html">pinkish</a>  <a href="http://www.csounds.com/manual/html/SiggenNoise.html">more</a>  <br />
</p></li>
</ul>
<ul>
<li><h3>ENVELOPES</h3>
<ul>
<li><h4>Simple Standard Envelopes</h4>
<p><a href="http://www.csounds.com/manual/html/linen.html">linen</a>  <a href="http://www.csounds.com/manual/html/linenr.html">linenr</a>  <a href="http://www.csounds.com/manual/html/adsr.html">adsr</a>  <a href="http://www.csounds.com/manual/html/madsr.html">madsr</a>  <a href="http://www.csounds.com/manual/html/SiggenEnvelope.html">more</a> <br />
</p></li>
<li><h4>Envelopes By Linear And Exponential Generators </h4>
<p><a href="http://www.csounds.com/manual/html/linseg.html">linseg</a>  <a href="http://www.csounds.com/manual/html/expseg.html">expseg</a>  <a href="http://www.csounds.com/manual/html/transeg.html">transeg</a>  (<a href="http://www.csounds.com/manual/html/linsegr.html">linsegr</a>  <a href="http://www.csounds.com/manual/html/expsegr.html">expsegr</a>  <a href="http://en.flossmanuals.net/bin/view/Csound/transegr">transegr</a>)  <a href="http://www.csounds.com/manual/html/SiggenLineexp.html">more</a>  </p></li>
<li><h4>Envelopes By Function Tables</h4></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h3>DELAYS</h3>
<ul>
<li><h4>Audio Delays</h4>
<p><a href="http://www.csounds.com/manual/html/vdelay.html">vdelay</a>  <a href="http://www.csounds.com/manual/html/vdelayx.html">vdelayx</a>  <a href="http://www.csounds.com/manual/html/vdelayw.html">vdelayw</a>  </p>
<p><a href="http://www.csounds.com/manual/html/delayr.html">delayr</a>  <a href="http://www.csounds.com/manual/html/delayw.html">delayw</a>  <a href="http://www.csounds.com/manual/html/deltap.html">deltap</a>  <a href="http://www.csounds.com/manual/html/deltapi.html">deltapi</a>  <a href="http://www.csounds.com/manual/html/deltap3.html">deltap3</a>  <a href="http://www.csounds.com/manual/html/deltapx.html">deltapx</a>  <a href="http://www.csounds.com/manual/html/deltapxw.html">deltapxw</a>  <a href="http://www.csounds.com/manual/html/deltapn.html">deltapn</a>  <br />
</p></li>
<li><h4>Control Delays</h4>
<p><a href="http://www.csounds.com/manual/html/delayk.html">delk</a>  <a href="http://www.csounds.com/manual/html/delayk.html">vdel_k</a> <br />
</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h3>FILTERS</h3>
<p>Compare <a href="http://www.csounds.com/manual/html/SigmodStandard.html">Standard Filters</a> and <a href="http://www.csounds.com/manual/html/SigmodSpeciali.html">Specialized Filters</a> overviews.<br />
</p>
<ul>
<li><h4>Low Pass Filters</h4>
<p><a href="http://www.csounds.com/manual/html/tone.html">tone</a>  <a href="http://www.csounds.com/manual/html/tonex.html">tonex</a>  <a href="http://www.csounds.com/manual/html/butterlp.html">butlp</a>  <a href="http://www.csounds.com/manual/html/clfilt.html">clfilt</a>  <br />
</p></li>
</ul>
<ul>
<li><h4>High Pass Filters</h4>
<p><a href="http://www.csounds.com/manual/html/atone.html">atone</a>  <a href="http://www.csounds.com/manual/html/atonex.html">atonex</a>  <a href="http://www.csounds.com/manual/html/butterhp.html">buthp</a>  <a href="http://www.csounds.com/manual/html/clfilt.html">clfilt</a>  <br />
</p></li>
</ul>
<ul>
<li><h4>Band Pass And Resonant Filters</h4>
<p><a href="http://www.csounds.com/manual/html/reson.html">reson</a>  <a href="http://www.csounds.com/manual/html/resonx.html">resonx</a>  <a href="http://www.csounds.com/manual/html/resony.html">resony</a>  <a href="http://www.csounds.com/manual/html/resonr.html">resonr</a>  <a href="http://www.csounds.com/manual/html/resonz.html">resonz</a>  <a href="http://www.csounds.com/manual/html/butterbp.html">butbp</a>  <br />
</p></li>
</ul>
<ul>
<li><h4>Band Reject Filters</h4>
<p><a href="http://www.csounds.com/manual/html/areson.html">areson</a>  <a href="http://www.csounds.com/manual/html/butterbp.html">butbr</a>  <br />
</p></li>
<li><h4>Filters For Smoothing Control Signals</h4>
<p><a href="http://www.csounds.com/manual/html/port.html">port</a>  <a href="http://www.csounds.com/manual/html/portk.html">portk</a> <br />
</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h3>REVERB</h3>
<p>(<a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a>)  <a href="http://www.csounds.com/manual/html/freeverb.html">freeverb</a>  <a href="http://www.csounds.com/manual/html/reverbsc.html">reverbsc</a>  <a href="http://www.csounds.com/manual/html/reverb.html">reverb</a>  <a href="http://www.csounds.com/manual/html/nreverb.html">nreverb</a>  <a href="http://www.csounds.com/manual/html/babo.html">babo</a>  <br />
</p></li>
</ul>
<ul>
<li><h3>SIGNAL MEASUREMENT, DYNAMIC PROCESSING, SAMPLE LEVEL OPERATIONS</h3>
<ul>
<li><h4>Amplitude Measurement And Following</h4>
<p><a href="http://www.csounds.com/manual/html/rms.html">rms</a>  <a href="http://www.csounds.com/manual/html/balance.html">balance</a>  <a href="http://www.csounds.com/manual/html/follow.html">follow</a>  <a href="http://www.csounds.com/manual/html/follow2.html">follow2</a>  <a href="http://www.csounds.com/manual/html/peak.html">peak</a>  <a href="http://www.csounds.com/manual/html/max_k.html">max_k</a>  <br />
</p></li>
</ul>
<ul>
<li><h4>Pitch Estimation</h4>
<p><a href="http://www.csounds.com/manual/html/ptrack.html">ptrack</a>  <a href="http://www.csounds.com/manual/html/pitch.html">pitch</a>  <a href="http://www.csounds.com/manual/html/pitchamdf.html">pitchamdf</a>  <a href="http://www.csounds.com/manual/html/pvscent.html">pvscent</a>  <br />
</p></li>
</ul>
<ul>
<li><h4>Tempo Estimation</h4>
<p><a href="http://www.csounds.com/manual/html/tempest.html">tempest</a>  <br />
</p></li>
<li><h4>Dynamic Processing</h4>
<p><a href="http://www.csounds.com/manual/html/compress.html">compress</a>  <a href="http://www.csounds.com/manual/html/dam.html">dam</a>  <a href="http://www.csounds.com/manual/html/clip.html">clip</a> <br />
</p></li>
<li><h4>Sample Level Operations</h4>
<p><a href="http://www.csounds.com/manual/html/limit.html">limit</a>  <a href="http://www.csounds.com/manual/html/samphold.html">samphold</a>  <a href="http://www.csounds.com/manual/html/vaget.html">vaget</a>  <a href="http://www.csounds.com/manual/html/vaset.html">vaset</a>  <br />
</p></li>
</ul></li>
</ul>
<ul>
<li><h3> SPATIALIZATION</h3>
<ul>
<li><h4>Panning</h4>
<p><a href="http://www.csounds.com/manual/html/pan2.html">pan2</a>  <a href="http://www.csounds.com/manual/html/pan.html">pan</a>  <br />
</p></li>
</ul>
<ul>
<li><h4>VBAP</h4>
<p><a href="http://www.csounds.com/manual/html/vpaplsinit.html">vbaplsinit</a>  <a href="http://www.csounds.com/manual/html/vpap4.html">vbap4</a>  <a href="http://www.csounds.com/manual/html/vbap8.html">vbap8</a>  <a href="http://www.csounds.com/manual/html/vbap16.html">vbap16</a> <br />
</p></li>
<li><h4>Ambisonics</h4>
<p><a href="http://www.csounds.com/manual/html/bformenc1.html">bformenc1</a>  <a href="http://www.csounds.com/manual/html/bformdec1.html">bformdec1</a>  <br />
</p></li>
<li><h4>Binaural / HRTF</h4>
<p><a href="http://www.csounds.com/manual/html/hrtfstat.html">hrtfstat</a>  <a href="http://www.csounds.com/manual/html/hrtfmove.html">hrtfmove</a>  <a href="http://www.csounds.com/manual/html/hrtfmove2.html">hrtfmove2</a>  <a href="http://www.csounds.com/manual/html/hrtfer.html">hrtfer</a> <br />
</p></li>
</ul></li>
</ul>
<h2>ADVANCED SIGNAL PROCESSING</h2>
<ul>
<li><h3>MODULATION AND DISTORTION</h3>
<ul>
<li><h4>Frequency Modulation</h4>
<p><a href="http://www.csounds.com/manual/html/foscil.html">foscil</a>  <a href="http://www.csounds.com/manual/html/foscili.html">foscili</a> <br />
</p>
<p><a href="http://www.csounds.com/manual/html/crossfm.html">crossfm</a>  <a href="http://www.csounds.com/manual/html/crossfm.html">crossfmi</a>  <a href="http://www.csounds.com/manual/html/crossfm.html">crosspm</a>  <a href="http://www.csounds.com/manual/html/crossfm.html">crosspmi</a>  <a href="http://www.csounds.com/manual/html/crossfm.html">crossfmpm</a>  <a href="http://www.csounds.com/manual/html/crossfm.html">crossfmpmi</a> <br />
</p></li>
<li><h4>Distortion And Wave Shaping</h4>
<p><a href="http://www.csounds.com/manual/html/distort.html">distort</a>  <a href="http://www.csounds.com/manual/html/distort1.html">distort1</a>  <a href="http://www.csounds.com/manual/html/powershape.html">powershape</a>  <a href="http://www.csounds.com/manual/html/polynomial.html">polynomial</a>  <a href="http://www.csounds.com/manual/html/chebyshevpoly.html">chebyshevpoly</a>  <br />
</p></li>
<li><h4>Flanging, Phasing, Phase Shaping</h4>
<p><a href="http://www.csounds.com/manual/html/flanger.html">flanger</a>  <a href="http://www.csounds.com/manual/html/harmon.html">harmon</a>  <a href="http://www.csounds.com/manual/html/phaser1.html">phaser1</a>  <a href="http://www.csounds.com/manual/html/phaser2.html">phaser2</a>  <a href="http://www.csounds.com/manual/html/pdclip.html">pdclip</a>  <a href="http://www.csounds.com/manual/html/pdhalf.html">pdhalf</a>  <a href="http://www.csounds.com/manual/html/pdhalfy.html">pdhalfy</a> <br />
</p></li>
<li><h4>Doppler Shift</h4>
<p><a href="http://www.csounds.com/manual/html/doppler.html">doppler</a> <br />
</p></li>
</ul></li>
</ul>
<ul>
<li><h3>GRANULAR SYNTHESIS</h3>
<p><a href="http://www.csounds.com/manual/html/partikkel.html">partikkel</a>  <a href="http://www.csounds.com/manual/html/SiggenGranular.html">others</a>  <a href="http://www.csounds.com/manual/html/sndwarp.html">sndwarp</a> <br />
</p></li>
</ul>
<ul>
<li><h3>CONVOLUTION</h3>
<p><a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a>  <a href="http://www.csounds.com/manual/html/ftconv.html">ftconv</a>  <a href="http://www.csounds.com/manual/html/dconv.html">dconv</a>  <br />
</p></li>
</ul>
<ul>
<li><h3>FFT AND SPECTRAL PROCESSING</h3>
<ul>
<li><h4>Realtime Analysis And Resynthesis </h4>
<p><a href="http://www.csounds.com/manual/html/pvsanal.html">pvsanal</a>  <a href="http://www.csounds.com/manual/html/pvstanal.html">pvstanal</a>  <a href="http://www.csounds.com/manual/html/pvsynth.html">pvsynth</a>  <a href="http://www.csounds.com/manual/html/pvsadsynth.html">pvsadsyn</a>  <br />
</p></li>
<li><h4>Writing FFT Data To A File And Reading From It</h4>
<p><a href="http://www.csounds.com/manual/html/pvsfwrite.html">pvsfwrite</a>  <a href="http://www.csounds.com/manual/html/pvanal.html">pvanal</a>  <a href="http://www.csounds.com/manual/html/pvsfread.html">pvsfread</a>  <a href="http://www.csounds.com/manual/html/pvsdiskin.html">pvsdiskin</a> <br />
</p></li>
<li><h4>Writing FFT Data To A Buffer And Reading From It </h4>
<p><a href="http://www.csounds.com/manual/html/pvsbuffer.html">pvsbuffer</a>  <a href="http://www.csounds.com/manual/html/pvsbufread.html">pvsbufread</a>  <a href="http://www.csounds.com/manual/html/pvsftw.html">pvsftw</a>  <a href="http://www.csounds.com/manual/html/pvsftr.html">pvsftr</a>  <br />
</p></li>
<li><h4>FFT Info </h4>
<p><a href="http://www.csounds.com/manual/html/pvsinfo.html">pvsinfo</a>  <a href="http://www.csounds.com/manual/html/pvsbin.html">pvsbin</a>  <a href="http://www.csounds.com/manual/html/pvscent.html">pvscent</a>  <br />
</p></li>
<li><h4>Manipulating FFT Signals </h4>
<p><a href="http://www.csounds.com/manual/html/pvscale.html">pvscale</a>  <a href="http://www.csounds.com/manual/html/pvshift.html">pvshift</a>  <a href="http://www.csounds.com/manual/html/pvsbandp.html">pvsbandp</a>  <a href="http://www.csounds.com/manual/html/pvsbandr.html">pvsbandr</a>  <a href="http://www.csounds.com/manual/html/pvsmix.html">pvsmix</a>  <a href="http://www.csounds.com/manual/html/pvscross.html">pvscross</a>  <a href="http://www.csounds.com/manual/html/pvsfilter.html">pvsfilter</a>  <a href="http://www.csounds.com/manual/html/pvsvoc.html">pvsvoc</a>  <a href="http://en.flossmanuals.net/bin/view/Csound/pvsmorph">pvsmorph</a><span> </span><a href="http://www.csounds.com/manual/html/pvsfreeze.html">pvsfreeze</a>  <a href="http://www.csounds.com/manual/html/pvsmaska.html">pvsmaska</a>  <a href="http://www.csounds.com/manual/html/pvsblur.html">pvsblur</a>  <a href="http://www.csounds.com/manual/html/pvstencil.html">pvstencil</a>  <a href="http://www.csounds.com/manual/html/pvsarp.html">pvsarp</a>  <a href="http://www.csounds.com/manual/html/pvsmooth.html">pvsmooth</a> <br />
</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h3>PHYSICAL MODELS AND FM INSTRUMENTS</h3>
<ul>
<li><h4>Waveguide Physical Modelling</h4>
<p>see <a href="http://www.csounds.com/manual/html/SiggenWavguide.html">here</a>  and <a href="http://www.csounds.com/manual/html/SigmodWavguide.html">here</a> <br />
</p></li>
<li><h4>FM Instrument Models</h4>
<p>see <a href="http://www.csounds.com/manual/html/SiggenFmsynth.html">here</a>   <br />
</p></li>
</ul></li>
</ul>
<h2>DATA</h2>
<ul>
<li><h3>BUFFER / FUNCTION TABLES</h3>
<ul>
<li><h4>Creating Function Tables (Buffers)</h4>
<p><a href="http://www.csounds.com/manual/html/ftgen.html">ftgen</a>  <a href="http://www.csounds.com/manual/html/ScoreGenRef.html">GEN Routines</a> <br />
</p>
<h4></h4></li>
<li><h4>Writing To Tables</h4>
<p><a href="http://www.csounds.com/manual/html/tableiw.html">tableiw</a>  / <a href="http://www.csounds.com/manual/html/tablew.html">tablew</a>     <a href="http://www.csounds.com/manual/html/tab.html">tabw_i</a>  / <a href="http://www.csounds.com/manual/html/tab.html">tabw</a> </p>
<h4></h4></li>
<li><h4>Reading From Tables </h4>
<p><a href="http://www.csounds.com/manual/html/table.html">table</a>  / <a href="http://www.csounds.com/manual/html/tablei.html">tablei</a>  / <a href="http://www.csounds.com/manual/html/table3.html">table3</a>     <a href="http://www.csounds.com/manual/html/tab.html">tab_i</a>  / <a href="http://www.csounds.com/manual/html/tab.html">tab</a> </p></li>
<li><h4>Saving Tables To Files </h4>
<p><a href="http://www.csounds.com/manual/html/ftsave.html">ftsave</a>  / <a href="http://www.csounds.com/manual/html/ftsavek.html">ftsavek</a>    <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=122">TableToSF</a>   <br />
</p></li>
<li><h4>Reading Tables From Files</h4>
<p><a href="http://www.csounds.com/manual/html/ftload.html">ftload</a>  / <a href="http://www.csounds.com/manual/html/ftloadk.html">ftloadk</a>     <a href="http://www.csounds.com/manual/html/GEN23.html">GEN23</a>  <br />
</p></li>
</ul></li>
</ul>
<ul>
<li><h3>SIGNAL INPUT/OUTPUT, SAMPLE AND LOOP PLAYBACK, SOUNDFONTS</h3>
<ul>
<li><h4>Signal Input And Output</h4>
<p><a href="http://www.csounds.com/manual/html/inch.html">inch</a>  ;  <a href="http://www.csounds.com/manual/html/outch.html">outch</a>  <a href="http://www.csounds.com/manual/html/out.html">out</a>  <a href="http://www.csounds.com/manual/html/outs.html">outs</a>  ;  <a href="http://www.csounds.com/manual/html/monitor.html">monitor</a> <br />
</p></li>
<li><h4>Sample Playback With Optional Looping</h4>
<p><a href="http://www.csounds.com/manual/html/flooper2.html">flooper2</a>  <a href="http://www.csounds.com/manual/html/sndloop.html">sndloop</a>  <br />
</p></li>
<li><h4>Soundfonts And Fluid Opcodes</h4>
<p><a href="http://www.csounds.com/manual/html/fluidEngine.html">fluidEngine</a>  <a href="http://www.csounds.com/manual/html/fluidSetInterpMethod.html">fluidSetInterpMethod</a>  <a href="http://www.csounds.com/manual/html/fluidLoad.html">fluidLoad</a>  <a href="http://www.csounds.com/manual/html/fluidProgramSelect.html">fluidProgramSelect</a>  <a href="http://www.csounds.com/manual/html/fluidNote.html">fluidNote</a>  <a href="http://www.csounds.com/manual/html/fluidCCi.html">fluidCCi</a>  <a href="http://www.csounds.com/manual/html/fluidCCk.html">fluidCCk</a>  <a href="http://www.csounds.com/manual/html/fluidControl.html">fluidControl</a>  <a href="http://www.csounds.com/manual/html/fluidOut.html">fluidOut</a>  <a href="http://www.csounds.com/manual/html/fluidAllOut.html">fluidAllOut</a> <br />
</p></li>
</ul>
<h4></h4></li>
</ul>
<h4></h4>
<ul>
<li><h3>FILE INPUT AND OUTPUT</h3>
<ul>
<li><h4>Sound File Input </h4>
<p><a href="http://www.csounds.com/manual/html/soundin.html">soundin</a>  <a href="http://www.csounds.com/manual/html/diskin2.html">diskin</a>  <a href="http://www.csounds.com/manual/html/diskin2.html">diskin2</a>  <a href="http://www.csounds.com/manual/html/mp3in.html">mp3in</a>  <a href="http://www.csounds.com/manual/html/GEN01.html">(GEN01)</a> <br />
</p></li>
<li><h4>Sound File Queries </h4>
<p><a href="http://www.csounds.com/manual/html/filelen.html">filelen</a>  <a href="http://www.csounds.com/manual/html/filesr.html">filesr</a>  <a href="http://www.csounds.com/manual/html/filenchnls.html">filenchnls</a>  <a href="http://www.csounds.com/manual/html/filepeak.html">filepeak</a>  <a href="http://www.csounds.com/manual/html/filebit.html">filebit</a>  <br />
</p></li>
<li><h4>Sound File Output </h4>
<p><a href="http://www.csounds.com/manual/html/fout.html">fout</a> <br />
</p></li>
<li><h4>Non-Soundfile Input And Output </h4>
<p><a href="http://www.csounds.com/manual/html/readk.html">readk</a>   <a href="http://www.csounds.com/manual/html/GEN23.html">GEN23</a>   <a href="http://www.csounds.com/manual/html/dumpk.html">dumpk</a>   <a href="http://www.csounds.com/manual/html/fprints.html">fprints</a> /<a href="http://www.csounds.com/manual/html/fprintks.html">fprintks</a>   <a href="http://www.csounds.com/manual/html/ftsave.html">ftsave</a>  / <a href="http://www.csounds.com/manual/html/ftsavek.html">ftsavek</a>    <a href="http://www.csounds.com/manual/html/ftload.html">ftload</a>  / <a href="http://www.csounds.com/manual/html/ftloadk.html">ftloadk</a> </p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h3>CONVERTERS OF DATA TYPES<br />
</h3>
<ul>
<li><h4>i &lt;- k </h4>
<p><a href="http://www.csounds.com/manual/html/opi.html">i(k)</a> <br />
</p></li>
<li><h4>k &lt;- a </h4>
<p><a href="http://www.csounds.com/manual/html/downsamp.html">downsamp</a>   <a href="http://www.csounds.com/manual/html/max_k.html">max_k</a>  <br />
</p></li>
<li><h4>a &lt;- k</h4>
<p><a href="http://www.csounds.com/manual/html/upsamp.html">upsamp</a>  <a href="http://www.csounds.com/manual/html/interp.html">interp</a>  <br />
</p></li>
</ul></li>
</ul>
<ul>
<li><h3>PRINTING AND STRINGS<br />
</h3>
<ul>
<li><h4>Simple Printing </h4>
<p><a href="http://www.csounds.com/manual/html/print.html">print</a>  <a href="http://www.csounds.com/manual/html/printk.html">printk</a>  <a href="http://www.csounds.com/manual/html/printk2.html">printk2</a>  <a href="http://www.csounds.com/manual/html/puts.html">puts</a> <br />
</p></li>
<li><h4>Formatted Printing </h4>
<p><a href="http://www.csounds.com/manual/html/prints.html">prints</a>  <a href="http://www.csounds.com/manual/html/printf.html">printf_i</a>  <a href="http://www.csounds.com/manual/html/printks.html">printks</a>  <a href="http://www.csounds.com/manual/html/printf.html">printf</a>  <br />
</p></li>
<li><h4>String Variables </h4>
<p><a href="http://www.csounds.com/manual/html/sprintf.html">sprintf</a>  <a href="http://www.csounds.com/manual/html/sprintfk.html">sprintfk</a>  <a href="http://www.csounds.com/manual/html/strset.html">strset</a>  <a href="http://www.csounds.com/manual/html/strget.html">strget</a>  <br />
</p></li>
<li><h4>String Manipulation And Conversion</h4>
<p>see <a href="http://www.csounds.com/manual/html/StringsTop.html#stringmanipulate">here</a>  and <a href="http://www.csounds.com/manual/html/stringconvert.html">here</a>   <br />
</p></li>
</ul></li>
</ul>
<h2>REALTIME INTERACTION</h2>
<ul>
<li><h3>MIDI</h3>
<ul>
<li><h4>Opcodes For Use In MIDI-Triggered Instruments </h4>
<p><a href="http://www.csounds.com/manual/html/massign.html">massign</a>  <a href="http://www.csounds.com/manual/html/pgmassign.html">pgmassign</a>  <a href="http://www.csounds.com/manual/html/notnum.html">notnum</a>  <a href="http://www.csounds.com/manual/html/cpsmidi.html">cpsmidi</a>  <a href="http://www.csounds.com/manual/html/veloc.html">veloc</a>  <a href="http://www.csounds.com/manual/html/ampmidi.html">ampmidi</a>  <a href="http://www.csounds.com/manual/html/midichn.html">midichn</a>  <a href="http://www.csounds.com/manual/html/pchbend.html">pchbend</a>  <a href="http://www.csounds.com/manual/html/aftouch.html">aftouch</a>  <a href="http://www.csounds.com/manual/html/polyaft.html">polyaft</a> <br />
</p></li>
<li><h4>Opcodes For Use In All Instruments</h4>
<p><a href="http://www.csounds.com/manual/html/ctrl7.html">ctrl7</a>  (<a href="http://www.csounds.com/manual/html/ctrl14.html">ctrl14</a>/<a href="http://www.csounds.com/manual/html/ctrl21.html">ctrl21</a>) <a href="http://www.csounds.com/manual/html/initc7.html">initc7</a>  <a href="http://www.csounds.com/manual/html/ctrlinit.html">ctrlinit</a>  (<a href="http://www.csounds.com/manual/html/initc14.html">initc14</a>/<a href="http://www.csounds.com/manual/html/initc21.html">initc21</a>)  <a href="http://www.csounds.com/manual/html/midiin.html">midiin</a>  <a href="http://www.csounds.com/manual/html/midiout.html">midiout</a>  <br />
</p></li>
</ul></li>
</ul>
<ul>
<li><h3>OPEN SOUND CONTROL AND NETWORK</h3>
<ul>
<li><h4>Open Sound Control</h4>
<p><a href="http://www.csounds.com/manual/html/OSCinit.html">OSCinit</a>  <a href="http://www.csounds.com/manual/html/OSClisten.html">OSClisten</a>  <a href="http://www.csounds.com/manual/html/OSCsend.html">OSCsend</a>  <br />
</p></li>
<li><h4>Remote Instruments</h4>
<p><a href="http://www.csounds.com/manual/html/remoteport.html">remoteport</a>  <a href="http://www.csounds.com/manual/html/insremot.html">insremot</a>  <a href="http://www.csounds.com/manual/html/insglobal.html">insglobal</a>  <a href="http://www.csounds.com/manual/html/midiremot.html">midiremot</a>  <a href="http://www.csounds.com/manual/html/midiglobal.html">midiglobal</a>  <br />
</p></li>
<li><h4>Network Audio</h4>
<p><a href="http://www.csounds.com/manual/html/socksend.html">socksend</a>  <a href="http://www.csounds.com/manual/html/sockrecv.html">sockrecv</a>   <br />
</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h3>HUMAN INTERFACES</h3>
<ul>
<li><h4>Widgets</h4>
<p>FLTK overview <a href="http://www.csounds.com/manual/html/ControlFltkIntro.html">here</a>  <br />
</p></li>
<li><h4>Keys</h4>
<p><a href="http://www.csounds.com/manual/html/sensekey.html">sensekey</a> <br />
</p></li>
<li><h4>Mouse</h4>
<p><a href="http://www.csounds.com/manual/html/xyin.html">xyin</a> <br />
</p></li>
<li><h4>WII</h4>
<p><a href="http://www.csounds.com/manual/html/wiiconnect.html">wiiconnect</a>  <a href="http://www.csounds.com/manual/html/wiidata.html">wiidata</a>  <a href="http://www.csounds.com/manual/html/wiirange.html">wiirange</a>  <a href="http://www.csounds.com/manual/html/wiisend.html">wiisend</a> <br />
</p></li>
<li><h4>P5 Glove</h4>
<p><a href="http://www.csounds.com/manual/html/p5gconnect.html">p5gconnect</a>  <a href="http://www.csounds.com/manual/html/p5gdata.html">p5gdata</a> </p></li>
</ul></li>
</ul>
<h2>INSTRUMENT CONTROL</h2>
<ul>
<li><h3>SCORE PARAMETER ACCESS</h3>
<p><a href="http://www.csounds.com/manual/html/p.html">p(x)</a>  <a href="http://www.csounds.com/manual/html/pindex.html">pindex</a>  <a href="http://www.csounds.com/manual/html/pset.html">pset</a>  <a href="http://www.csounds.com/manual/html/passign.html">passign</a>  <a href="http://www.csounds.com/manual/html/pcount.html">pcount</a>  <br />
</p></li>
<li><h3>TIME AND TEMPO</h3>
<ul>
<li><h4>Time Reading</h4>
<p><a href="http://www.csounds.com/manual/html/times.html">times</a>/<a href="http://www.csounds.com/manual/html/timek.html">timek</a>    <a href="http://www.csounds.com/manual/html/timeinsts.html">timeinsts</a>/<a href="http://www.csounds.com/manual/html/timeinstk.html">timeinstk</a>   <a href="http://www.csounds.com/manual/html/date.html">date</a>/<a href="http://www.csounds.com/manual/html/dates.html">dates</a>    <a href="http://www.csounds.com/manual/html/setscorepos.html">setscorepos</a> <br />
</p></li>
<li><h4>Tempo Reading</h4>
<p><a href="http://www.csounds.com/manual/html/tempo.html">tempo</a>  <a href="http://www.csounds.com/manual/html/miditempo.html">miditempo</a>  <a href="http://www.csounds.com/manual/html/tempoval.html">tempoval</a>  <br />
</p></li>
<li><h4>Duration Modifications</h4>
<p><a href="http://www.csounds.com/manual/html/ihold.html">ihold</a>  <a href="http://www.csounds.com/manual/html/xtratim.html">xtratim</a>  </p></li>
<li><h4>Time Signal Generators</h4>
<p><a href="http://www.csounds.com/manual/html/metro.html">metro</a>  <a href="http://www.csounds.com/manual/html/mpulse.html">mpulse</a> <br />
</p></li>
</ul></li>
</ul>
<ul>
<li><h3>CONDITIONS AND LOOPS</h3>
<p><a href="http://www.csounds.com/manual/html/changed.html">changed</a>  <a href="http://www.csounds.com/manual/html/trigger.html">trigger</a>  <a href="http://www.csounds.com/manual/html/if.html">if</a>  <a href="http://www.csounds.com/manual/html/loop_lt.html">loop_lt</a>/<a href="http://www.csounds.com/manual/html/loop_le.html">loop_le</a>/<a href="http://www.csounds.com/manual/html/loop_gt.html">loop_gt</a>/<a href="http://www.csounds.com/manual/html/loop_ge.html">loop_ge</a> <br />
</p></li>
</ul>
<ul>
<li><h3>PROGRAM FLOW</h3>
<p><a href="http://www.csounds.com/manual/html/init.html">init</a>  <a href="http://www.csounds.com/manual/html/igoto.html">igoto</a>  <a href="http://www.csounds.com/manual/html/kgoto.html">kgoto</a>  <a href="http://www.csounds.com/manual/html/timout.html">timout</a>   <a href="http://www.csounds.com/manual/html/reinit.html">reinit</a>/<a href="http://www.csounds.com/manual/html/rigoto.html">rigoto</a>/<a href="http://www.csounds.com/manual/html/rireturn.html">rireturn</a> <br />
</p></li>
</ul>
<h4></h4>
<ul>
<li><h3>EVENT TRIGGERING</h3>
<p><a href="http://www.csounds.com/manual/html/event_i.html">event_i</a>  / <a href="http://www.csounds.com/manual/html/event.html">event</a>    <a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a>  / <a href="http://www.csounds.com/manual/html/scoreline.html">scoreline</a>    <a href="http://www.csounds.com/manual/html/schedkwhen.html">schedkwhen</a>   <a href="http://www.csounds.com/manual/html/seqtime.html">seqtime</a> /<a href="http://www.csounds.com/manual/html/seqtime2.html">seqtime2</a>   <a href="http://www.csounds.com/manual/html/timedseq.html">timedseq</a>  <br />
</p></li>
</ul>
<ul>
<li><h3>INSTRUMENT SUPERVISION</h3>
<ul>
<li><h4>Instances And Allocation</h4>
<p><a href="http://www.csounds.com/manual/html/active.html">active</a>  <a href="http://www.csounds.com/manual/html/maxalloc.html">maxalloc</a>  <a href="http://www.csounds.com/manual/html/prealloc.html">prealloc</a>  <br />
</p></li>
</ul>
<ul>
<li><h4>Turning On And Off</h4>
<p><a href="http://www.csounds.com/manual/html/turnon.html">turnon</a>   <a href="http://www.csounds.com/manual/html/turnoff.html">turnoff</a>/<a href="http://www.csounds.com/manual/html/turnoff2.html">turnoff2</a>   <a href="http://www.csounds.com/manual/html/mute.html">mute</a>   <a href="http://www.csounds.com/manual/html/remove.html">remove</a>   <a href="http://www.csounds.com/manual/html/exitnow.html">exitnow</a>  <br />
</p></li>
<li><h4>Named Instruments</h4>
<p><a href="http://www.csounds.com/manual/html/nstrnum.html">nstrnum</a><br />
</p></li>
</ul></li>
</ul>
<ul>
<li><h3>SIGNAL EXCHANGE AND MIXING</h3>
<ul>
<li><h4>chn opcodes</h4>
<h4></h4>
<p><a href="http://www.csounds.com/manual/html/chn.html">chn_k</a> /<a href="http://www.csounds.com/manual/html/chn.html">chn_a</a> /<a href="http://www.csounds.com/manual/html/chn.html">chn_S</a>   <a href="http://www.csounds.com/manual/html/chnset.html">chnset</a>   <a href="http://www.csounds.com/manual/html/chnget.html">chnget</a>   <a href="http://www.csounds.com/manual/html/chnmix.html">chnmix</a>   <a href="http://www.csounds.com/manual/html/chnclear.html">chnclear</a> <br />
</p></li>
<li><h4>zak? <br />
</h4></li>
</ul></li>
</ul>
<h2>MATHS</h2>
<ul>
<li><h3>MATHEMATICAL CALCULATIONS</h3>
<ul>
<li><h4>Arithmetic Operations</h4>
<p><a href="http://www.csounds.com/manual/html/adds.html">+</a>    <a href="http://www.csounds.com/manual/html/subtracts.html">-</a>    <a href="http://www.csounds.com/manual/html/multiplies.html">*</a>    <a href="http://www.csounds.com/manual/html/divides.html">/</a>    <a href="http://www.csounds.com/manual/html/raises.html">^</a>   <a href="http://www.csounds.com/manual/html/modulus.html">%</a> <br />
</p>
<p><a href="http://www.csounds.com/manual/html/exp.html">exp(x)</a>    <a href="http://www.csounds.com/manual/html/log.html">log(x)</a>   <a href="http://www.csounds.com/manual/html/log10.html">log10(x)</a>   <a href="http://www.csounds.com/manual/html/sqrt.html">sqrt(x)</a> <br />
</p>
<p><a href="http://www.csounds.com/manual/html/abs.html">abs(x)</a>  <a href="http://www.csounds.com/manual/html/int.html">int(x)</a>  <a href="http://www.csounds.com/manual/html/frac.html">frac(x)</a> <br />
</p>
<p><a href="http://www.csounds.com/manual/html/round.html">round(x)</a>  <a href="http://www.csounds.com/manual/html/ceil.html">ceil(x)</a>  <a href="http://www.csounds.com/manual/html/floor.html">floor(x)</a> <br />
</p></li>
<li><h4>Trigonometric Functions</h4>
<p><a href="http://www.csounds.com/manual/html/sin.html">sin(x)</a>   <a href="http://www.csounds.com/manual/html/cos.html">cos(x)</a>   <a href="http://www.csounds.com/manual/html/tan.html">tan(x)</a> <br />
</p>
<p><a href="http://www.csounds.com/manual/html/sinh.html">sinh(x)</a>   <a href="http://www.csounds.com/manual/html/cosh.html">cosh(x)</a>   <a href="http://www.csounds.com/manual/html/tanh.html">tanh(x)</a> <br />
</p>
<p><a href="http://www.csounds.com/manual/html/sininv.html">sininv(x)</a>   <a href="http://www.csounds.com/manual/html/cosinv.html">cosinv(x)</a>   <a href="http://www.csounds.com/manual/html/taninv.html">taninv(x)</a>   <a href="http://www.csounds.com/manual/html/taninv2.html">taninv2(x)</a> <br />
</p></li>
<li><h4>Logic Operators</h4>
<p><a href="http://www.csounds.com/manual/html/opand.html">&amp;&amp;</a>    <a href="http://www.csounds.com/manual/html/opor.html">||</a>  <br />
</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h3>CONVERTERS</h3>
<ul>
<li><h4>MIDI To Frequency </h4>
<p><a href="http://www.csounds.com/manual/html/cpsmidi.html">cpsmidi</a>  <a href="http://www.csounds.com/manual/html/cpsmidinn.html">cpsmidinn</a>   <a href="http://www.csounds.com/manual/html/PitchTop.html#PitchFuncs">more</a> </p></li>
</ul>
<ul>
<li><h4>Frequency To MIDI</h4>
<p><a href="http://en.flossmanuals.net/bin/view/Csound/%20http://www.csounds.com/udo/displayOpcode.php?opcode_id=123">F2M</a>   <a href="http://en.flossmanuals.net/bin/view/Csound/%20http://www.csounds.com/udo/displayOpcode.php?opcode_id=124">F2MC</a>  (UDO's)<br />
</p>
<h4></h4>
<h4></h4></li>
<li><h4>Cent Values To Frequency </h4>
<p><a href="http://www.csounds.com/manual/html/cent.html">cent</a>  <br />
</p>
<h4></h4></li>
<li><h4>Amplitude Converters</h4>
<p><a href="http://www.csounds.com/manual/html/ampdb.html">ampdb</a>  <a href="http://www.csounds.com/manual/html/ampdbfs.html">ampdbfs</a>  <a href="http://www.csounds.com/manual/html/dbamp.html">dbamp</a>  <a href="http://www.csounds.com/manual/html/dbfsamp.html">dbfsamp</a> <br />
</p>
<h4></h4></li>
<li><h4>Scaling </h4>
<p><a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=125">Scali</a>   <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=126">Scalk</a>   <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=127">Scala</a>  (UDO's)<br />
</p></li>
</ul></li>
</ul>
<h2>PYTHON AND SYSTEM</h2>
<ul>
<li><h4>PYTHON OPCODES</h4>
<h4></h4>
<p><a href="http://www.csounds.com/manual/html/pyinit.html">pyinit</a>  <a href="http://www.csounds.com/manual/html/pyrun.html">pyrun</a>  <a href="http://www.csounds.com/manual/html/pyexec.html">pyexec</a>  <a href="http://www.csounds.com/manual/html/pycall.html">pycall</a>  <a href="http://www.csounds.com/manual/html/pyeval.html">pyeval</a>  <a href="http://www.csounds.com/manual/html/pyassign.html">pyassign</a> <br />
</p></li>
</ul>
<h4></h4>
<ul>
<li><h4>SYSTEM OPCODES</h4>
<p><a href="http://www.csounds.com/manual/html/getcfg.html">getcfg</a>   <a href="http://www.csounds.com/manual/html/system.html">system</a>/<a href="http://www.csounds.com/manual/html/system.html">system_i</a> <br />
</p></li>
</ul>
<h2>PLUGINS<br />
</h2>
<ul>
<li><h4>PLUGIN HOSTING</h4>
<ul>
<li><h4>LADSPA</h4>
<p><a href="http://www.csounds.com/manual/html/dssiinit.html">dssiinit</a>  <a href="http://www.csounds.com/manual/html/dssiactivate.html">dssiactivate</a>  <a href="http://www.csounds.com/manual/html/dssilist.html">dssilist</a>  <a href="http://www.csounds.com/manual/html/dssiaudio.html">dssiaudio</a>  <a href="http://www.csounds.com/manual/html/dssictls.html">dssictls</a>  <br />
</p></li>
<li><h4>VST</h4>
<p><a href="http://www.csounds.com/manual/html/vstinit.html">vstinit</a>   <a href="http://www.csounds.com/manual/html/vstaudio.html">vstaudio</a>/<a href="http://www.csounds.com/manual/html/vstaudio.html">vstaudiog</a>   <a href="http://www.csounds.com/manual/html/vstmidiout.html">vstmidiout</a>   <a href="http://www.csounds.com/manual/html/vstparamset.html">vstparamset</a>/<a href="http://www.csounds.com/manual/html/vstparamget.html">vstparamget</a>   <a href="http://www.csounds.com/manual/html/vstnote.html">vstnote</a>   <a href="http://www.csounds.com/manual/html/vstinfo.html">vstinfo</a>  <a href="http://www.csounds.com/manual/html/vstbankload.html">vstbankload</a>   <a href="http://www.csounds.com/manual/html/vstprogset.html">vstprogset</a>   <a href="http://www.csounds.com/manual/html/vstedit.html">vstedit</a> <br />
</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h4>EXPORTING CSOUND FILES TO PLUGINS<br />
</h4></li>
</ul>
<p> </p>
<p><span id="ch074_signal-processing-i.xhtml"></span></p>
<h1>OPCODE GUIDE: BASIC SIGNAL PROCESSING</h1>
<p> </p>
<ul>
<li><h2>OSCILLATORS AND PHASORS</h2>
<ul>
<li><h3>Standard Oscillators</h3>
<p><a href="http://www.csounds.com/manual/html/oscils.html"><strong>oscils</strong></a> is a very <strong>simple sine oscillator</strong> which can be used for quick tests. It needs no function table, but provides just i-rate arguments.</p>
<p><a href="http://www.csounds.com/manual/html/ftgen.html"><strong>ftgen</strong></a> generates a function table, which is needed by any oscillator except <a href="http://www.csounds.com/manual/html/oscils.html">oscils</a>. The <a href="http://www.csounds.com/manual/html/ScoreGenRef.html">GEN Routines</a> fill the function table with any desired waveform, either a sine wave or any other curve. Compare the <a href="http://en.flossmanuals.net/bin/view/Csound/FUNCTIONTABLES">function table chapter</a> of this manual for more information.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/poscil.html"><strong>poscil</strong></a> can be recommended as <strong>standard oscillator</strong> because it is very precise also for long tables and low frequencies. It provides linear interpolation, any rate for the input arguments, and works also for non-power-of-two tables. <a href="http://www.csounds.com/manual/html/poscil3.html">poscil3</a> provides cubic interpolation, but has just k-rate input. <strong>Other common oscillators</strong> are <a href="http://www.csounds.com/manual/html/oscili.html">oscili</a> and <a href="http://www.csounds.com/manual/html/oscil3.html">oscil3</a>. They are less precise than poscil/poscili, but you can skip the initialization which can be useful in certain situations. The <a href="http://www.csounds.com/manual/html/oscil.html">oscil</a> opcode does not provide any interpolation, so it should usually be avoided. <strong>More</strong> Csound oscillators can be found <a href="http://www.csounds.com/manual/html/SiggenBasic.html">here</a>.</p></li>
<li><h3>Dynamic Spectrum Oscillators</h3>
<p><a href="http://www.csounds.com/manual/html/buzz.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/buzz.html"><strong>buzz</strong></a> and <a href="http://www.csounds.com/manual/html/gbuzz.html"><strong>gbuzz</strong></a> generate a set of harmonically related sine resp. cosine partials.</p>
<p><a href="http://www.csounds.com/manual/html/mpulse.html"><strong>mpulse</strong></a> generates a set of impulses.</p>
<p><a href="http://www.csounds.com/manual/html/vco.html"><strong>vco</strong></a> and <a href="http://www.csounds.com/manual/html/vco2.html"><strong>vco2</strong></a> implement band-limited, analog modeled oscillators with different standard waveforms.</p></li>
<li><h4>Phasors</h4>
<p><a href="http://www.csounds.com/manual/html/phasor.html"></a><a href="http://www.csounds.com/manual/html/phasor.html"><strong>phasor</strong></a> produces the typical moving phase values between 0 and 1. The more complex <a href="http://www.csounds.com/manual/html/syncphasor.html">syncphasor</a> lets you synchronize more than one phasor precisely.</p></li>
</ul></li>
</ul>
<ul>
<li><h2>RANDOM AND NOISE GENERATORS</h2>
<p><a href="http://www.csounds.com/manual/html/seed.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/seed.html"><strong>seed</strong></a> sets the seed value for the majority of the Csound random generators (seed 0 generates each time another random output, while any other seed value generates the same random chain on each new run).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/rand.html"><strong>rand</strong></a> is the usual opcodes for bipolar random values. If you give 1 as input argument (called &quot;amp&quot;), you will get values between -1 and +1. <strong><a href="http://www.csounds.com/manual/html/randi.html">randi</a></strong> interpolates between values which are generated in a (variable) frequency. <strong><a href="http://www.csounds.com/manual/html/randh.html">randh</a></strong> holds the value until the next one is generated. You can control the seed value by an input argument (a value greater than 1 seeds from current time), you can decide whether to use a 16bit or a 31bit random number, and you can add an offset.<br />
</p>
<p><strong><a href="http://www.csounds.com/manual/html/rnd31.html">rnd31</a></strong> can be used for alle rates of variables (i-rate variables are not supported by rand). It gives the user also control over the random distribution, but has no offset parameter.</p>
<p><a href="http://www.csounds.com/manual/html/random.html"><strong>random</strong></a> is often very convenient to use, because you have a minimum and a maximum value as input argument, instead of a range like <em>rand</em> and <em>rnd31</em>. It can also be used for all rates, but you have no direct seed input, and the <a href="http://www.csounds.com/manual/html/randomi.html">randomi</a>/<a href="http://www.csounds.com/manual/html/randomh.html">randomh</a> variants always start from the lower border, instead anywhere between the borders.</p>
<p><strong><a href="http://www.csounds.com/manual/html/pinkish.html">pinkish</a></strong> produces pink noise at audio-rate (white noise is produced by <em>rand</em>).</p>
<p>There are much more random opcodes. <a href="http://www.csounds.com/manual/html/SiggenNoise.html">Here</a> is an overview. It is also possible to use some GEN Routines for generating random distributions. They can be found in the <a href="http://www.csounds.com/manual/html/ScoreGenRef.html">GEN Routines overview</a>.</p></li>
</ul>
<ul>
<li><h2>ENVELOPES</h2>
<ul>
<li><h3>Simple Standard Envelopes</h3>
<p><a href="http://www.csounds.com/manual/html/linen.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/linen.html"><strong>linen</strong></a> applies a linear rise (fade in) and decay (fade out) to a signal. It is very easy to use, as you put the raw audio signal in and get the enveloped signal out.</p>
<p><a href="http://www.csounds.com/manual/html/linenr.html"><strong>linenr</strong></a> does the same for any note which's duration is not fixed at the beginning, like MIDI notes or any real time events. linenr begins to fade out exactly when the instrument is turned off, adding an extra time after this turnoff.</p>
<p><strong><a href="http://www.csounds.com/manual/html/adsr.html">adsr</a></strong> calculates the classical attack-decay-sustain-release envelope. The result is to be multiplied with the audio signal to get the enveloped signal.</p>
<p><a href="http://www.csounds.com/manual/html/madsr.html"><strong>madsr</strong></a> does the same for a realtime note (like explained above for linenr).</p>
<p>Other standard envelope generators can be found in the <a href="http://www.csounds.com/manual/html/SiggenEnvelope.html">Envelope Generators overview</a> of the Canonical Csound Manual.</p></li>
<li><h3>Envelopes By Linear And Exponential Generators </h3>
<p><strong><a href="http://www.csounds.com/manual/html/linseg.html">linseg</a></strong> creates one or more segments of lines between specified points.</p>
<p><strong><a href="http://www.csounds.com/manual/html/expseg.html">expseg</a></strong> does the same with exponential segments. Note that zero values are illegal.</p>
<p><strong><a href="http://www.csounds.com/manual/html/transeg.html">transeg</a></strong> is very flexible to use, because you can specify the shape of the curve for each segment (continuous transitions from convex to linear to concave).</p>
<p>All these opcodes have a -r variant (<a href="http://www.csounds.com/manual/html/linsegr.html">linsegr</a>, <a href="http://www.csounds.com/manual/html/expsegr.html">expsegr</a>, <a href="http://en.flossmanuals.net/bin/view/Csound/transegr">transegr</a>) for MIDI or other live events.</p>
<p>More opcodes can be found in <a href="http://www.csounds.com/manual/html/SiggenLineexp.html">this</a> overview.</p></li>
<li><h3>Envelopes By Function Tables</h3>
<p>Any curve, or parts of it, of any function table, can be used as envelope. Just create a function table by <a href="http://www.csounds.com/manual/html/ftgen.html">ftgen</a> resp. by a <a href="http://www.csounds.com/manual/html/ScoreGenRef.html">GEN Routine</a>. Then read the function table, or a part of it, by an oscillator, and multiply the result with the audio signal you want to envelope. <br />
</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h2>DELAYS</h2>
<ul>
<li><h3>Audio Delays</h3>
<p>The <strong>vdelay familiy</strong> of opcodes is easy to use and implement all necessary features to work with delays:</p>
<p><a href="http://www.csounds.com/manual/html/vdelay.html"><strong>vdelay</strong></a> implements a variable delay at audio rate with linear interpolation.</p>
<p><a href="http://www.csounds.com/manual/html/vdelay.html"><strong>vdelay3</strong></a> offers cubic interpolation.</p>
<p><a href="http://www.csounds.com/manual/html/vdelayx.html"><strong>vdelayx</strong></a> has an even higher quality interpolation (and is by this reason slower). <a href="http://www.csounds.com/manual/html/vdelayxs.html">vdelayxs</a> lets you input and output two channels, and <a href="http://www.csounds.com/manual/html/vdelayxq.html">vdelayxq</a> four.</p>
<p><a href="http://www.csounds.com/manual/html/vdelayw.html"><strong>vdelayw</strong></a> changes the position of the write tap in the delay line instead of the read tap. <a href="http://www.csounds.com/manual/html/vdelayws.html">vdelayws</a> is for stereo, and <a href="http://www.csounds.com/manual/html/vdelaywq.html">vdelaywq</a> for quadro.</p>
<p>The <strong>delayr/delayw</strong> opcodes establishes a delay line in a more complicated way. The advantage is that you can have as many taps in one delay line as you need.</p>
<p><a href="http://www.csounds.com/manual/html/delayr.html"><strong>delayr</strong></a> establishes a delay line and reads from it.</p>
<p><a href="http://www.csounds.com/manual/html/delayw.html"><strong>delayw</strong></a> writes an audio signal to the delay line.</p>
<p><a href="http://www.csounds.com/manual/html/deltap.html"><strong>deltap</strong></a>, <a href="http://www.csounds.com/manual/html/deltapi.html"><strong>deltapi</strong></a>, <a href="http://www.csounds.com/manual/html/deltap3.html"><strong>deltap3</strong></a>, <a href="http://www.csounds.com/manual/html/deltapx.html"><strong>deltapx</strong></a> and <a href="http://www.csounds.com/manual/html/deltapxw.html"><strong>deltapxw</strong></a> are working similar to the relevant opcodes of the vdelay family (see above).</p>
<p><a href="http://www.csounds.com/manual/html/deltapn.html"><strong>deltapn</strong></a> offers a tap delay measured in samples, not seconds.</p></li>
<li><h3>Control Delays</h3>
<p><a href="http://www.csounds.com/manual/html/delayk.html"></a><a href="http://www.csounds.com/manual/html/delayk.html"><strong>delk</strong></a> and <a href="http://www.csounds.com/manual/html/delayk.html"><strong>vdel_k</strong></a> let you delay any k-signal by some time interval (usable for instance as a kind of <em>wait</em> mode).</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h2>FILTERS</h2>
<p>Csound has an extremely rich collection of filters and they are good available on the Csound Manual pages for <a href="http://www.csounds.com/manual/html/SigmodStandard.html">Standard Filters</a> and <a href="http://www.csounds.com/manual/html/SigmodSpeciali.html">Specialized Filters</a>. So here some most frequently used filters are mentioned, and some tips are given. Note that filters usually change the signal level, so you will need the <a href="http://www.csounds.com/manual/html/balance.html">balance</a> opcode.</p>
<ul>
<li><h3>Low Pass Filters</h3>
<p><a href="http://www.csounds.com/manual/html/tone.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/tone.html"><strong>tone</strong></a> is a first order recursive low pass filter. <a href="http://www.csounds.com/manual/html/tonex.html">tonex</a> implements a series of tone filters.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/butterlp.html"><strong>butlp</strong></a> is a seond order low pass Butterworth filter.</p>
<p><a href="http://www.csounds.com/manual/html/clfilt.html"><strong>clfilt</strong></a> lets you choose between different types and poles numbers.</p></li>
</ul>
<ul>
<li><h3>High Pass Filters</h3>
<p><a href="http://www.csounds.com/manual/html/atone.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/atone.html"><strong>atone</strong></a> is a first order recursive high pass filter. <a href="http://www.csounds.com/manual/html/atonex.html">atonex</a> implements a series of atone filters.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/butterhp.html"><strong>buthp</strong></a> is a second order high pass Butterworth filter.</p>
<p><a href="http://www.csounds.com/manual/html/clfilt.html"><strong>clfilt</strong></a> lets you choose between different types and poles numbers. </p></li>
</ul>
<ul>
<li><h3>Band Pass And Resonant Filters</h3>
<p><a href="http://www.csounds.com/manual/html/reson.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/reson.html"><strong>reson</strong></a> is a second order resonant filter. <a href="http://www.csounds.com/manual/html/resonx.html">resonx</a> implements a series of reson filters, while <a href="http://www.csounds.com/manual/html/resony.html">resony</a> emulates a bank of second order bandpass filters in parallel. <a href="http://www.csounds.com/manual/html/resonr.html">resonr</a> and <a href="http://www.csounds.com/manual/html/resonz.html">resonz</a> are variants of reson with variable frequency response.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/butterbp.html"><strong>butbp</strong></a> is a second order band-pass Butterworth filter.</p></li>
</ul>
<ul>
<li><h3>Band Reject Filters</h3>
<p><a href="http://www.csounds.com/manual/html/areson.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/areson.html"><strong>areson</strong></a> is the complement of the reson filter.  </p>
<p><a href="http://www.csounds.com/manual/html/butterbp.html"><strong>butbr</strong></a> is a band-reject butterworth filter.</p></li>
<li><h3>Filters For Smoothing Control Signals</h3>
<p><a href="http://www.csounds.com/manual/html/port.html"></a><a href="http://www.csounds.com/manual/html/port.html"><strong>port</strong></a> and <a href="http://www.csounds.com/manual/html/portk.html"><strong>portk</strong></a> are very frequently used to smooth control signals which are received by MIDI or widgets.</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h2>REVERB</h2>
<p>Note that you can work easily in Csound with convolution reverbs based on impulse response files, for instance with <a href="http://www.csounds.com/manual/html/pconvolve.html">pconvolve</a>. </p>
<p><a href="http://www.csounds.com/manual/html/freeverb.html"><strong>freeverb</strong></a> is the implementation of Jezar's well-known free (stereo) reverb.</p>
<p><a href="http://www.csounds.com/manual/html/reverbsc.html"><strong>reverbsc</strong></a> is a stereo FDN reverb, based on work of Sean Costello.</p>
<p><a href="http://www.csounds.com/manual/html/reverb.html"><strong>reverb</strong></a> and <a href="http://www.csounds.com/manual/html/nreverb.html"><strong>nreverb</strong></a> are the traditional Csound reverb units.</p>
<p><a href="http://www.csounds.com/manual/html/babo.html"><strong>babo</strong></a> is a physical model reverberator (&quot;ball within the box&quot;).</p></li>
</ul>
<ul>
<li><h2>SIGNAL MEASUREMENT, DYNAMIC PROCESSING, SAMPLE LEVEL OPERATIONS</h2>
<ul>
<li><h3>Amplitude Measurement And Following</h3>
<p><a href="http://www.csounds.com/manual/html/rms.html"><strong>rms</strong></a> determines the root-mean-square amplitude of an audio signal.</p>
<p><strong><a href="http://www.csounds.com/manual/html/balance.html">balance</a></strong> adjusts the amplitudes of an audio signal according to the rms amplitudes of another audio signal.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/follow.html"><strong>follow</strong></a> / <a href="http://www.csounds.com/manual/html/follow2.html"><strong>follow2</strong></a> are envelope followers which report the average amplitude in a certain time span (follow) or according to an attack/decay rate (follow2).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/peak.html"><strong>peak</strong></a> reports the highest absolute amplitude value received.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/max_k.html"><strong>max_k</strong></a> outputs the local maximum or minimum value of an incoming audio signal, checked in a certain time interval.</p></li>
</ul>
<ul>
<li><h3>Pitch Estimation</h3>
<p><a href="http://www.csounds.com/manual/html/ptrack.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/ptrack.html"><strong>ptrack</strong></a>, <a href="http://www.csounds.com/manual/html/pitch.html"><strong>pitch</strong></a> and <a href="http://www.csounds.com/manual/html/pitchamdf.html"><strong>pitchamdf</strong></a> track the pitch of an incoming audio signal, using different methods.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/pvscent.html"><strong>pvscent</strong></a> calculates the spectral centroid for FFT streaming signals (see below under &quot;FFT And Spectral Processing&quot;)</p></li>
</ul>
<ul>
<li><h3>Tempo Estimation</h3>
<p><a href="http://www.csounds.com/manual/html/tempest.html"></a><a href="http://www.csounds.com/manual/html/tempest.html"><strong>tempest</strong></a> estimates the tempo of beat patterns in a control signal.  </p></li>
<li><h3>Dynamic Processing</h3>
<p><a href="http://www.csounds.com/manual/html/compress.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/compress.html"><strong>compress</strong></a> compresses, limits, expands, ducks or gates an audio signal.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/dam.html"><strong>dam</strong></a> is a dynamic compressor/expander.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/clip.html"><strong>clip</strong></a> clips an a-rate signal to a predefined limit, in a “soft” manner.</p></li>
<li><h3>Sample Level Operations</h3>
<p><a href="http://www.csounds.com/manual/html/limit.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/limit.html"><strong>limit</strong></a> sets the lower and upper limits of an incoming value (all rates).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/samphold.html"><strong>samphold</strong></a> performs a sample-and-hold operation on its a- or k-input.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/vaget.html"><strong>vaget</strong></a> / <a href="http://www.csounds.com/manual/html/vaset.html"><strong>vaset</strong></a> allow getting and setting certain samples of an audio vector at k-rate.</p></li>
</ul></li>
</ul>
<ul>
<li><h2> SPATIALIZATION</h2>
<ul>
<li><h3>Panning</h3>
<p><a href="http://www.csounds.com/manual/html/pan2.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/pan2.html"><strong>pan2</strong></a> distributes a mono audio signal across two channels, with different envelope options.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/pan.html"><strong>pan</strong></a> distributes a mono audio signal amongst four channels.</p></li>
</ul>
<ul>
<li><h3>VBAP</h3>
<p><a href="http://www.csounds.com/manual/html/vpaplsinit.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/vpaplsinit.html"><strong>vbaplsinit</strong></a> configures VBAP output according to loudspeaker parameters for a 2- or 3-dimensional space.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/vpap4.html"><strong>vbap4</strong></a> / <a href="http://www.csounds.com/manual/html/vbap8.html"><strong>vbap8</strong></a> / <a href="http://www.csounds.com/manual/html/vbap16.html"><strong>vbap16</strong></a> distributes an audio signal among up to 16 channels, with k-rate control over azimut, elevation and spread.</p></li>
<li><h3>Ambisonics</h3>
<p><a href="http://www.csounds.com/manual/html/bformenc1.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/bformenc1.html"><strong>bformenc1</strong></a><strong></strong> encodes an audio signal to the Ambisonics B format.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/bformdec1.html"><strong>bformdec1</strong></a> decodes Ambisonics B format signals to loudspeaker signals in different possible configurations.</p></li>
<li><h3>Binaural / HRTF</h3>
<p><a href="http://www.csounds.com/manual/html/hrtfstat.html"></a><a href="http://www.csounds.com/manual/html/hrtfstat.html"><strong>hrtfstat</strong></a>, <a href="http://www.csounds.com/manual/html/hrtfmove.html"><strong>hrtfmove</strong></a> and <a href="http://www.csounds.com/manual/html/hrtfmove2.html"><strong>hrtfmove2</strong></a> are opcodes for creating 3d binaural audio for headphones. <a href="http://www.csounds.com/manual/html/hrtfer.html">hrtfer</a> is an older implementation, using an external file. </p></li>
</ul></li>
</ul>
<h2><br />
</h2>
<h3><br />
</h3>
<p><span id="ch075_signal-processing-ii.xhtml"></span></p>
<h1>OPCODE GUIDE: ADVANCED SIGNAL PROCESSING</h1>
<p> </p>
<ul>
<li><h2>MODULATION AND DISTORTION</h2>
<ul>
<li><h3>Frequency Modulation</h3>
<p><a href="http://www.csounds.com/manual/html/foscil.html"><strong>foscil</strong></a> and <a href="http://www.csounds.com/manual/html/foscili.html"><strong>foscili</strong></a> implement composite units for FM in the Chowning setup.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/crossfm.html"><strong>crossfm</strong></a>, <a href="http://www.csounds.com/manual/html/crossfm.html"><strong>crossfmi</strong></a>, <a href="http://www.csounds.com/manual/html/crossfm.html"><strong>crosspm</strong></a>, <a href="http://www.csounds.com/manual/html/crossfm.html"><strong>crosspmi</strong></a>, <a href="http://www.csounds.com/manual/html/crossfm.html"><strong>crossfmpm</strong></a> and <a href="http://www.csounds.com/manual/html/crossfm.html"><strong>crossfmpmi</strong></a> are different units for frequency and/or phase modulation.</p></li>
<li><h3>Distortion And Wave Shaping</h3>
<p><a href="http://www.csounds.com/manual/html/distort.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/distort.html"><strong>distort</strong></a> and <a href="http://www.csounds.com/manual/html/distort1.html"><strong>distort1</strong></a> perform waveshaping by a function table (distort) or by modified hyperbolic tangent distortion (distort1).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/powershape.html"><strong>powershape</strong></a> waveshapes a signal by raising it to a variable exponent.</p>
<p><a href="http://www.csounds.com/manual/html/polynomial.html"><strong>polynomial</strong></a> efficiently evaluates a polynomial of arbitrary order.</p>
<p><a href="http://www.csounds.com/manual/html/chebyshevpoly.html"><strong>chebyshevpoly</strong></a> efficiently evaluates the sum of Chebyshev polynomials of arbitrary order.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/GEN03.html">GEN03</a>, <a href="http://www.csounds.com/manual/html/GEN13.html">GEN13</a>, <a href="http://www.csounds.com/manual/html/GEN14.html">GEN14</a> and <a href="http://www.csounds.com/manual/html/GEN15.html">GEN15</a> are also used for Waveshaping.</p></li>
<li><h3>Flanging, Phasing, Phase Shaping</h3>
<p><a href="http://www.csounds.com/manual/html/flanger.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/flanger.html"><strong>flanger</strong></a> implements a user controllable flanger.</p>
<p><a href="http://www.csounds.com/manual/html/harmon.html"><strong>harmon</strong></a> analyzes an audio input and generates harmonizing voices in synchrony.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/phaser1.html"><strong>phaser1</strong></a> and <a href="http://www.csounds.com/manual/html/phaser2.html"><strong>phaser2</strong></a> implement first- or second-order allpass filters arranged in a series.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/pdclip.html"><strong>pdclip</strong></a>, <a href="http://www.csounds.com/manual/html/pdhalf.html"><strong>pdhalf</strong></a> and <a href="http://www.csounds.com/manual/html/pdhalfy.html"><strong>pdhalfy</strong></a> are useful for phase distortion synthesis.</p></li>
<li><h3>Doppler Shift</h3>
<p><a href="http://www.csounds.com/manual/html/doppler.html"></a><a href="http://www.csounds.com/manual/html/doppler.html"><strong>doppler</strong></a> lets you calculate the doppler shift depending on the position of the sound source and the microphone.</p></li>
</ul></li>
</ul>
<ul>
<li><h2>GRANULAR SYNTHESIS</h2>
<p><a href="http://www.csounds.com/manual/html/partikkel.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/partikkel.html"><strong>partikkel</strong></a> is the most flexible opcode for granular synthesis. You should be able to do everything you like in this field. The only drawback is the large number of input arguments, so you may want to use other opcodes for certain purposes.</p>
<p>You can find a list of other relevant opcodes <a href="http://www.csounds.com/manual/html/SiggenGranular.html">here</a>. </p>
<p><a href="http://www.csounds.com/manual/html/sndwarp.html"><strong>sndwarp</strong></a> focusses granular synthesis on time stretching and/or pitch modifications. Compare <a href="http://www.csounds.com/manual/html/waveset.html">waveset</a> and the pvs-opcodes <a href="http://www.csounds.com/manual/html/pvsfread.html">pvsfread</a>, <a href="http://www.csounds.com/manual/html/pvsdiskin.html">pvsdiskin</a>, <a href="http://www.csounds.com/manual/html/pvscale.html">pvscale</a>, <a href="http://www.csounds.com/manual/html/pvshift.html">pvshift</a> for other implementations of time and/or pitch modifications.</p></li>
</ul>
<ul>
<li><h2>CONVOLUTION</h2>
<p><a href="http://www.csounds.com/manual/html/pconvolve.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/pconvolve.html"><strong>pconvolve</strong></a> performs convolution based on a uniformly partitioned overlap-save algorithm.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/ftconv.html"><strong>ftconv</strong></a> is similar to pconvolve, but you can also use parts of the impulse response file, instead of reading the whole file.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/dconv.html"><strong>dconv</strong></a> performs direct convolution. </p></li>
</ul>
<ul>
<li><h2>FFT AND SPECTRAL PROCESSING</h2>
<ul>
<li><h3>Realtime Analysis And Resynthesis</h3>
<p><a href="http://www.csounds.com/manual/html/pvsanal.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/pvsanal.html"><strong>pvsanal</strong></a> performs a Fast Fourier Transformation of an audio stream (a-signal) and stores the result in an f-variable.</p>
<p><a href="http://www.csounds.com/manual/html/pvstanal.html"><strong>pvstanal</strong></a> creates an f-signal directly from a sound file which is stored in a function table (usually via GEN01). <br />
</p>
<p><a href="http://www.csounds.com/manual/html/pvsynth.html"><strong>pvsynth</strong></a> performs an Inverse FFT (takes a f-signal and returns an audio-signal).</p>
<p><a href="http://www.csounds.com/manual/html/pvsadsynth.html"><strong>pvsadsyn</strong></a> is similar to pvsynth, but resynthesizes with a bank of oscillators, instead of direct IFFT.</p></li>
<li><h3>Writing FFT Data To A File And Reading From It</h3>
<p><a href="http://www.csounds.com/manual/html/pvsfwrite.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/pvsfwrite.html"><strong>pvsfwrite</strong></a> writes an f-signal (= the FFT data) from inside Csound to a file. This file has the PVOCEX format and its name ends on .pvx.</p>
<p><a href="http://www.csounds.com/manual/html/pvanal.html">pvanal</a> does actually the same as Csound <a href="http://www.csounds.com/manual/html/UtilityTop.html">Utility</a> (a seperate program which can be called in QuteCsound or via the Terminal). In this case, the input is an audio file.</p>
<p><a href="http://www.csounds.com/manual/html/pvsfread.html"><strong>pvsfread</strong></a> reads the FFT data from an extisting .pvx file. This file can be generated by the Csound Utility pvanal. Reading the file is done by a time pointer.</p>
<p><a href="http://www.csounds.com/manual/html/pvsdiskin.html"><strong>pvsdiskin</strong></a> is similar to pvsfread, but reading is done by a speed argument.</p></li>
<li><h3>Writing FFT Data To A Buffer And Reading From It </h3>
<p><a href="http://www.csounds.com/manual/html/pvsbuffer.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/pvsbuffer.html"><strong>pvsbuffer</strong></a> writes a f-signal to a circular buffer (and creates it).</p>
<p><a href="http://www.csounds.com/manual/html/pvsbufread.html"><strong>pvsbufread</strong></a> reads a f-signal from a buffer which was created by pvsbuffer.</p>
<p><a href="http://www.csounds.com/manual/html/pvsftw.html"><strong>pvsftw</strong></a> writes amplitude and/or frequency data from a f-signal to a function table.</p>
<p><a href="http://www.csounds.com/manual/html/pvsftr.html"><strong>pvsftr</strong></a> transforms amplitude and/or frequency data from a function table to a f-signal.</p></li>
<li><h3>FFT Info </h3>
<p><a href="http://www.csounds.com/manual/html/pvsinfo.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/pvsinfo.html"><strong>pvsinfo</strong></a> gets info either from a realtime f-signal or from a .pvx file.</p>
<p><a href="http://www.csounds.com/manual/html/pvsbin.html"><strong>pvsbin</strong></a> gets the amplitude and frequency values from a single bin of a f-signal.</p>
<p><a href="http://www.csounds.com/manual/html/pvscent.html"><strong>pvscent</strong></a> calculates the spectral centroid of a signal.<br />
</p></li>
<li><h3>Manipulating FFT Signals </h3>
<p><a href="http://www.csounds.com/manual/html/pvscale.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/pvscale.html"><strong>pvscale</strong></a> transposes the frequency components of a f-stream by simple multiplication.</p>
<p><a href="http://www.csounds.com/manual/html/pvshift.html"><strong>pvshift</strong></a> changes the frequency components of a f-stream by adding a shift value, starting at a certain bin.</p>
<p><a href="http://www.csounds.com/manual/html/pvsbandp.html"><strong>pvsbandp</strong></a> and <a href="http://www.csounds.com/manual/html/pvsbandr.html"><strong>pvsbandr</strong></a> applies a band pass and band reject filter to the frequency components of a f-signal.</p>
<p><a href="http://www.csounds.com/manual/html/pvsmix.html"><strong>pvsmix</strong></a>, <a href="http://www.csounds.com/manual/html/pvscross.html"><strong>pvscross</strong></a>, <a href="http://www.csounds.com/manual/html/pvsfilter.html"><strong>pvsfilter</strong></a>, <a href="http://www.csounds.com/manual/html/pvsvoc.html"><strong>pvsvoc</strong></a> and <a href="http://en.flossmanuals.net/bin/view/Csound/pvsmorph"><strong>pvsmorph</strong></a> perform different methods of cross synthesis between two f-signals.</p>
<p><a href="http://www.csounds.com/manual/html/pvsfreeze.html"><strong>pvsfreeze</strong></a> freezes the amplitude and/or frequency of a f-signal according to a k-rate trigger.</p>
<p><a href="http://www.csounds.com/manual/html/pvsmaska.html"><strong>pvsmaska</strong></a>, <a href="http://www.csounds.com/manual/html/pvsblur.html"><strong>pvsblur</strong></a>, <a href="http://www.csounds.com/manual/html/pvstencil.html"><strong>pvstencil</strong></a>, <a href="http://www.csounds.com/manual/html/pvsarp.html"><strong>pvsarp</strong></a>, <a href="http://www.csounds.com/manual/html/pvsmooth.html"><strong>pvsmooth</strong></a> perform other manipulations on a stream of FFT data.</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h2>PHYSICAL MODELS AND FM INSTRUMENTS</h2>
<ul>
<li><h3>Waveguide Physical Modelling</h3>
<p>see <a href="http://www.csounds.com/manual/html/SiggenWavguide.html">here</a>  and <a href="http://www.csounds.com/manual/html/SigmodWavguide.html">here</a> <br />
</p></li>
<li><h3>FM Instrument Models</h3>
<p>see <a href="http://www.csounds.com/manual/html/SiggenFmsynth.html">here</a>   <br />
</p></li>
</ul></li>
</ul>
<h2></h2>
<h3></h3>
<p> </p>
<p><span id="ch076_data.xhtml"></span></p>
<h1>OPCODE GUIDE: DATA</h1>
<ul>
<li><h2>BUFFER / FUNCTION TABLES</h2>
<p>See the chapter about <a href="http://en.flossmanuals.net/bin/view/Csound/FUNCTIONTABLES">function tables</a> for more detailled information. <br />
</p>
<ul>
<li><h3>Creating Function Tables (Buffers)</h3>
<p><a href="http://www.csounds.com/manual/html/ftgen.html"><strong>ftgen</strong></a> generates any function table. The <a href="http://www.csounds.com/manual/html/ScoreGenRef.html">GEN Routines</a> are used to fill a function table with different kind of data, like soundfiles, envelopes, window functions and much more.</p>
<h4></h4></li>
<li><h3>Writing To Tables</h3>
<p><strong><a href="http://www.csounds.com/manual/html/tableiw.html">tableiw</a></strong> / <strong><a href="http://www.csounds.com/manual/html/tablew.html">tablew</a></strong>: Write values to a function table at i-rate (tableiw), k-rate and a-rate (tablew). These opcodes provide many options and are safe because of boundary check, but you may have problems with non-power-of-two tables.</p>
<p><strong><a href="http://www.csounds.com/manual/html/tab.html">tabw_i</a></strong> / <strong><a href="http://www.csounds.com/manual/html/tab.html">tabw</a></strong>: Write values to a function table at i-rate (tabw_i), k-rate or a-rate (tabw). Offer less options than the tableiw/tablew opcodes, but work also for non-power-of-two tables. They do not provide a boundary check, which makes them fast but also give the user the resposability not writing any value off the table boundaries.</p>
<h4></h4></li>
<li><h3>Reading From Tables </h3>
<p><strong><a href="http://www.csounds.com/manual/html/table.html">table</a></strong> / <strong><a href="http://www.csounds.com/manual/html/tablei.html">tablei</a></strong> / <strong><a href="http://www.csounds.com/manual/html/table3.html">table3</a></strong>: Read values from a function table at any rate, either by direct indexing (table), or by linear (tablei) or cubic (table3) interpolation. These opcodes provide many options and are safe because of boundary check, but you may have problems with non-power-of-two tables.</p>
<p><strong><a href="http://www.csounds.com/manual/html/tab.html">tab_i</a></strong> / <strong><a href="http://www.csounds.com/manual/html/tab.html">tab</a></strong>: Read values from a function table at i-rate (tab_i), k-rate or a-rate (tab). Offer no interpolation and less options than the table opcodes, but they work also for non-power-of-two tables. They do not provide a boundary check, which makes them fast but also give the user the resposability not reading any value off the table boundaries.</p></li>
<li><h3>Saving Tables To Files </h3>
<p><strong><a href="http://www.csounds.com/manual/html/ftsave.html">ftsave</a></strong> / <strong><a href="http://www.csounds.com/manual/html/ftsavek.html">ftsavek</a></strong>: Save a function table as a file, at i-time (ftsave) or k-time (ftsavek). This can be a text file or a binary file, but not a soundfile. If you want to save a soundfile, use the User Defined Opcode <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=122">TableToSF</a>. </p></li>
<li><h3>Reading Tables From Files</h3>
<p><strong><a href="http://www.csounds.com/manual/html/ftload.html">ftload</a></strong> / <strong><a href="http://www.csounds.com/manual/html/ftloadk.html">ftloadk</a></strong>: Load a function table which has been written by ftsave/ftsavek.</p>
<p><a href="http://www.csounds.com/manual/html/GEN23.html"><strong>GEN23</strong></a> transfers a text file into a function table. </p></li>
</ul></li>
</ul>
<ul>
<li><h2>SIGNAL INPUT/OUTPUT, SAMPLE AND LOOP PLAYBACK, SOUNDFONTS</h2>
<ul>
<li><h3>Signal Input And Output</h3>
<p><a href="http://www.csounds.com/manual/html/inch.html"><strong>inch</strong></a> read the audio input from any channel of your audio device. Make sure you have the <a href="http://www.csounds.com/manual/html/nchnls.html">nchnls</a> value in the orchestra header set properly.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/outch.html"><strong>outch</strong></a> writes any audio signal(s) to any output channel(s). If Csound is in realtime mode (by the flag '-o dac' or by the 'Render in Realtime' mode of a frontend like QuteCsound), the output channels are the channels of your output device. If Csound is in 'Render to file' mode (by the flag '-o mysoundfile.wav' or the the frontend's choice), the output channels are the channels of the soundfile which is being written. Make sure you have the <a href="http://www.csounds.com/manual/html/nchnls.html">nchnls</a> value in the orchestra header set properly to get the number of channels you wish to have.</p>
<p><a href="http://www.csounds.com/manual/html/out.html"><strong>out</strong></a> and <a href="http://www.csounds.com/manual/html/outs.html"><strong>outs</strong></a> are frequently used for mono and stereo output. They always write to channel 1 (out) resp. 1 and 2 (outs).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/monitor.html"><strong>monitor</strong></a> can be used (in an instrument with the highest number) to get the sum of all audio on the different output channels.</p></li>
<li><h3>Sample Playback With Optional Looping</h3>
<p><a href="http://www.csounds.com/manual/html/flooper2.html"><strong>flooper2</strong></a> is a function-table-based crossfading looper.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/sndloop.html"><strong>sndloop</strong></a> records input audio and plays it back in a loop with user-defined duration and crossfade time.<br />
</p>
<p>Note that there are also User Defined Opcodes for sample playback of buffers / function tables.</p></li>
<li><h3>Soundfonts And Fluid Opcodes</h3>
<p><a href="http://www.csounds.com/manual/html/fluidEngine.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/fluidEngine.html"><strong>fluidEngine</strong></a> instantiates a FluidSynth engine.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidSetInterpMethod.html"><strong>fluidSetInterpMethod</strong></a> sets an interpolation method for a channel in a FluidSynth engine.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidLoad.html"><strong>fluidLoad</strong></a> loads SoundFonts.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidProgramSelect.html"><strong>fluidProgramSelect</strong></a> assigns presets from a SoundFont to a FluidSynth engine's MIDI channel.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidNote.html"><strong>fluidNote</strong></a> plays a note on a FluidSynth engine's MIDI channel.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidCCi.html"><strong>fluidCCi</strong></a> sends a controller message at i-time to a FluidSynth engine's MIDI channel.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidCCk.html"><strong>fluidCCk</strong></a> sends a controller message at k-rate to a FluidSynth engine's MIDI channel.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidControl.html"><strong>fluidControl</strong></a> plays and controls loaded Soundfonts (using 'raw' MIDI messages).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidOut.html"><strong>fluidOut</strong></a> receives audio from a single FluidSynth engine.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fluidAllOut.html"><strong>fluidAllOut</strong></a> receives audio from all FluidSynth engines.</p></li>
</ul>
<h4></h4></li>
</ul>
<h4></h4>
<ul>
<li><h2>FILE INPUT AND OUTPUT</h2>
<ul>
<li><h3>Sound File Input </h3>
<p><a href="http://www.csounds.com/manual/html/soundin.html"><strong>soundin</strong></a> reads from a soundfile (up to 24 channels). Make sure that the <a href="http://www.csounds.com/manual/html/sr.html">sr</a> value in the orchestra header matches the sample rate of your soundfile, or you will get higher or lower pitched sound.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/diskin2.html"><strong>diskin</strong></a> is like soundin, but can also alter the speed of reading (resulting in higher or lower pitches) and you have an option to loop the file.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/diskin2.html"><strong>diskin2</strong></a> is like diskin, but automatically converts the sample rate of the soundfile if it does not match the sample rate of the orchestra, and it offers different interpolation methods for reading the soundfile at altered speed.</p>
<p><a href="http://www.csounds.com/manual/html/GEN01.html"><strong>GEN01</strong></a> reads soundfile into a function table (buffer).</p>
<p><a href="http://www.csounds.com/manual/html/mp3in.html"><strong>mp3in</strong></a> lets you play mp3 sound files.<br />
</p></li>
<li><h3>Sound File Queries </h3>
<p><a href="http://www.csounds.com/manual/html/filelen.html"><strong>filelen</strong></a> returns the length of a soundfile in seconds.</p>
<p><a href="http://www.csounds.com/manual/html/filesr.html"><strong>filesr</strong></a> returns the sample rate of a soundfile.</p>
<p><a href="http://www.csounds.com/manual/html/filenchnls.html"><strong>filenchnls</strong></a> returns the number of channels of a soundfile.</p>
<p><a href="http://www.csounds.com/manual/html/filepeak.html"><strong>filepeak</strong></a> returns the peak absolute value of a soundfile, either of one specified channel, or from all channels. Make sure you have set <a href="http://www.csounds.com/manual/html/0dbfs.html">0dbfs</a> to 1; otherwise you will get values relative to Csound's default 0dbfs value of 32768.</p>
<p><a href="http://www.csounds.com/manual/html/filebit.html"><strong>filebit</strong></a> returns the bit depth of a soundfile.</p></li>
<li><h3>Sound File Output </h3>
<p><a href="http://www.csounds.com/manual/html/fout.html"></a></p>
<p>Keep in mind that Csound always writes output to a file if you have set the '-o' flag to the name of a soundfile (or if you choose 'render to file' in a frontend like QuteCound).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/fout.html"><strong>fout</strong></a> writes any audio signal(s) to a file, regardless Csound is in realtime or render-to-file mode. So you can record your live performance with this opcode.</p></li>
<li><h3>Non-Soundfile Input And Output </h3>
<p><a href="http://www.csounds.com/manual/html/readk.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/readk.html"><strong>readk</strong></a> can read data from external files (for instance a text file) and transform them to k-rate values.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/GEN23.html"><strong>GEN23</strong></a> transfers a text file into a function table.</p>
<p><a href="http://www.csounds.com/manual/html/dumpk.html"><strong>dumpk</strong></a> writes k-rate signals to a text file.</p>
<p><a href="http://www.csounds.com/manual/html/fprints.html"><strong>fprints</strong></a> / <a href="http://www.csounds.com/manual/html/fprintks.html"><strong>fprintks</strong></a> write any formatted string to a file. If you call this opcode several times during one performance, the strings are appended. If you write to an already existing file, the file will be overwritten.<br />
</p>
<p><strong><a href="http://www.csounds.com/manual/html/ftsave.html">ftsave</a></strong> / <strong><a href="http://www.csounds.com/manual/html/ftsavek.html">ftsavek</a></strong>: Save a function table as a binary or text file, in a specific format.</p>
<p><strong><a href="http://www.csounds.com/manual/html/ftload.html">ftload</a></strong> / <strong><a href="http://www.csounds.com/manual/html/ftloadk.html">ftloadk</a></strong>: Load a function table which has been written by ftsave/ftsavek.</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h2>CONVERTERS OF DATA TYPES<br />
</h2>
<ul>
<li><h3>i &lt;- k </h3>
<p><a href="http://www.csounds.com/manual/html/opi.html"></a><a href="http://www.csounds.com/manual/html/opi.html"><strong>i(k)</strong></a> returns the value of a k-variable at init-time. This can be useful to get the value of GUI controllers, or when using the reinit feature.</p></li>
<li><h3>k &lt;- a </h3>
<p><a href="http://www.csounds.com/manual/html/downsamp.html"><strong>downsamp</strong></a> converts an a-rate signal to a k-rate signal, with optional averaging.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/max_k.html"><strong>max_k</strong></a> returns the maximum of an a-rate signal in a certain time span, with different options of calculation<br />
</p></li>
<li><h3>a &lt;- k</h3>
<p><a href="http://www.csounds.com/manual/html/upsamp.html"><strong>upsamp</strong></a> converts a k-rate signal to an a-rate signal by simple repetitions. It is the same as the statement asig=ksig.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/interp.html"><strong>interp</strong></a> converts a k-rate signal to an a-rate signal by interpolation.</p></li>
</ul></li>
</ul>
<ul>
<li><h2>PRINTING AND STRINGS<br />
</h2>
<ul>
<li><h3>Simple Printing </h3>
<p><a href="http://www.csounds.com/manual/html/print.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/print.html"><strong>print</strong></a> is a simple opcode for printing i-variables. Note that the printed numbers are rounded to 3 decimal places.</p>
<p><a href="http://www.csounds.com/manual/html/printk.html"><strong>printk</strong></a> is its counterpart for k-variables. The <em>itime</em> argument specifies the time in seconds between printings (<em>itime=0</em> means one printout in each k-cycle which is usually some thousand printings per second).</p>
<p><a href="http://www.csounds.com/manual/html/printk2.html"><strong>printk2</strong></a> prints a k-variable whenever it has changed.</p>
<p><strong><a href="http://www.csounds.com/manual/html/puts.html">puts</a></strong> prints S-variables. The <em>ktrig</em> argument lets you print either at i-time or at k-time.</p></li>
<li><h3>Formatted Printing </h3>
<p><a href="http://www.csounds.com/manual/html/prints.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/prints.html"><strong>prints</strong></a> lets you print a format string at i-time. The format is similar to the C-style syntax (verweis). There is no %s format, therefore no string variables can be printed.</p>
<p><a href="http://www.csounds.com/manual/html/printf.html"><strong>printf_i</strong></a> is very similar to prints. It also works at init-time. The advantage in comparision to prints is the ability of printing string variables. On the other hand,  you need a trigger and at least one input argument.</p>
<p><a href="http://www.csounds.com/manual/html/printks.html"><strong>printks</strong></a> is like prints, but takes k-variables, and like at printk you must specify a time between printing.</p>
<p><a href="http://www.csounds.com/manual/html/printf.html"><strong>printf</strong></a> is like printf_i, but works at k-rate.</p></li>
<li><h3>String Variables </h3>
<p><a href="http://www.csounds.com/manual/html/sprintf.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/sprintf.html"><strong>sprintf</strong></a> works like printf_i, but stores the output in a string variable, instead of printing it out.</p>
<p><a href="http://www.csounds.com/manual/html/sprintfk.html"><strong>sprintfk</strong></a> is the same for k-rate arguments.</p>
<p><a href="http://www.csounds.com/manual/html/strset.html"><strong>strset</strong></a> links any string with a numeric value.</p>
<p><a href="http://www.csounds.com/manual/html/strget.html"><strong>strget</strong></a> transforms a strset number back to a string.</p></li>
<li><h3>String Manipulation And Conversion</h3>
<p>There are many opcodes for analysing, manipulating and conversing strings. There is a good overview in the Canonical Csound Manual on <a href="http://www.csounds.com/manual/html/StringsTop.html#stringmanipulate">this</a> and <a href="http://www.csounds.com/manual/html/stringconvert.html">that</a> page.</p></li>
</ul></li>
</ul>
<h2><br />
</h2>
<p> </p>
<p><span id="ch077_realtime-interaction.xhtml"></span></p>
<h1>OPCODE GUIDE: REALTIME INTERACTION</h1>
<ul>
<li><h2>MIDI</h2>
<ul>
<li><h3>Opcodes For Use In MIDI-Triggered Instruments </h3>
<p><a href="http://www.csounds.com/manual/html/massign.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/massign.html"><strong>massign</strong></a> assigns certain midi channels to instrument numbers. See the <a href="http://en.flossmanuals.net/bin/view/Csound/TRIGGERINGINSTRUMENTINSTANCES">Triggering Instrument Instances</a> chapter for more information.</p>
<p><a href="http://www.csounds.com/manual/html/pgmassign.html"><strong>pgmassign</strong></a> assigns certain program changes to instrument numbers.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/notnum.html"><strong>notnum</strong></a> gets the midi number of the key which has been pressed and activated this instrument instance. </p>
<p><a href="http://www.csounds.com/manual/html/cpsmidi.html"><strong>cpsmidi</strong></a> converts this note number to the frequency in cycles per second (Hertz).</p>
<p><a href="http://www.csounds.com/manual/html/veloc.html"><strong>veloc</strong></a> and <a href="http://www.csounds.com/manual/html/ampmidi.html"><strong>ampmidi</strong></a> get the velocity of the key which has been pressed and activated this instrument instance.</p>
<p><a href="http://www.csounds.com/manual/html/midichn.html"><strong>midichn</strong></a> returns the midi channel number from which the note was activated.</p>
<p><a href="http://www.csounds.com/manual/html/pchbend.html"><strong>pchbend</strong></a> gets the pitch bend information.</p>
<p><a href="http://www.csounds.com/manual/html/aftouch.html"><strong>aftouch</strong></a> and <a href="http://www.csounds.com/manual/html/polyaft.html"><strong>polyaft</strong></a> get the aftertouch information.</p></li>
<li><h3>Opcodes For Use In All Instruments</h3>
<p><a href="http://www.csounds.com/manual/html/ctrl7.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/ctrl7.html"><strong>ctrl7</strong></a> gets the values of a usual (7bit) controller and scales it. <a href="http://www.csounds.com/manual/html/ctrl14.html">ctrl14</a> and <a href="http://www.csounds.com/manual/html/ctrl21.html">ctrl21</a> can be used for high definition controllers.</p>
<p><a href="http://www.csounds.com/manual/html/initc7.html"><strong>initc7</strong></a> or <a href="http://www.csounds.com/manual/html/ctrlinit.html"><strong>ctrlinit</strong></a> set the initial value of 7bit controllers. Use <a href="http://www.csounds.com/manual/html/initc14.html">initc14</a> and <a href="http://www.csounds.com/manual/html/initc21.html">initc21</a> for high definition devices.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/midiin.html"><strong>midiin</strong></a> gives access to all incoming midi events. </p>
<p><a href="http://www.csounds.com/manual/html/midiout.html"><strong>midiout</strong></a> writes any event to the midi out port.</p></li>
</ul></li>
</ul>
<ul>
<li><h2>OPEN SOUND CONTROL AND NETWORK</h2>
<ul>
<li><h3>Open Sound Control</h3>
<p><a href="http://www.csounds.com/manual/html/OSCinit.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/OSCinit.html"><strong>OSCinit</strong></a> initializes a port for later use of the OSClisten opcode.</p>
<p><a href="http://www.csounds.com/manual/html/OSClisten.html"><strong>OSClisten</strong></a> receives messages of the port which was initialized by OSCinit.</p>
<p><a href="http://www.csounds.com/manual/html/OSCsend.html"><strong>OSCsend</strong></a> sends messages to a port.</p></li>
<li><h3>Remote Instruments</h3>
<p><a href="http://www.csounds.com/manual/html/remoteport.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/remoteport.html"><strong>remoteport</strong></a> defines the port for use with the remote system.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/insremot.html"><strong>insremot</strong></a> will send note events from a source machine to one destination.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/insglobal.html"><strong>insglobal</strong></a> will send note events from a source machine to many destinations.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/midiremot.html"><strong>midiremot</strong></a> will send midi events from a source machine to one destination.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/midiglobal.html"><strong>midiglobal</strong></a> will broadcast the midi events to all the machines involved in the remote concert.</p></li>
<li><h3>Network Audio</h3>
<p><a href="http://www.csounds.com/manual/html/socksend.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/socksend.html"><strong>socksend</strong></a> sends audio data to other processes using the low-level UDP or TCP protocols.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/sockrecv.html"><strong>sockrecv</strong></a> receives audio data from other processes using the low-level UDP or TCP protocols.</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h2>HUMAN INTERFACES</h2>
<ul>
<li><h3>Widgets</h3>
<p>The FLTK Widgets are integrated in Csound. Information and examples can be found <a href="http://www.csounds.com/manual/html/ControlFltkIntro.html">here</a>.</p>
<p>QuteCsound implements a more modern and easy-to-use system for widgets. The communication between the widgets and Csound is done via <a href="http://www.csounds.com/manual/html/invalue.html">invalue</a> (or <a href="http://www.csounds.com/manual/html/chnget.html">chnget</a>) and <a href="http://www.csounds.com/manual/html/outvalue.html">outvalue</a> (or <a href="http://www.csounds.com/manual/html/chnset.html">chnset</a>).</p></li>
<li><h3>Keys</h3>
<p><a href="http://www.csounds.com/manual/html/sensekey.html"></a><a href="http://www.csounds.com/manual/html/sensekey.html"><strong>sensekey</strong></a> gets the input of your computer keys.</p></li>
<li><h3>Mouse</h3>
<p><a href="http://www.csounds.com/manual/html/xyin.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/xyin.html"><strong>xyin</strong></a> can get the mouse position if your front-end does not provide this sensing otherwise.</p></li>
<li><h3>WII</h3>
<p><a href="http://www.csounds.com/manual/html/wiiconnect.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/wiiconnect.html"><strong>wiiconnect</strong></a> reads data from a number of external Nintendo Wiimote controllers.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/wiidata.html"><strong>wiidata</strong></a> reads data fields from a number of external Nintendo Wiimote controllers.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/wiirange.html"><strong>wiirange</strong></a> sets scaling and range limits for certain Wiimote fields.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/wiisend.html"><strong>wiisend</strong></a> sends data to one of a number of external Wii controllers.</p></li>
<li><h3>P5 Glove</h3>
<p><a href="http://www.csounds.com/manual/html/p5gconnect.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/p5gconnect.html"><strong>p5gconnect</strong></a> reads data from an external P5 Glove controller.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/p5gdata.html"><strong>p5gdata</strong></a> reads data fields from an external P5 Glove controller.</p></li>
</ul></li>
</ul>
<p><span id="ch078_instrument-control.xhtml"></span></p>
<h1>OPCODE GUIDE: INSTRUMENT CONTROL</h1>
<ul>
<li><h2>SCORE PARAMETER ACCESS</h2>
<p><a href="http://www.csounds.com/manual/html/p.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/p.html"><strong>p(x)</strong></a> gets the value of a specified p-field. (So, 'p(5)' and 'p5' both return the value of the fifth parameter in a certain score line, but in the former case you can insert a variable to specify the p-field.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/pindex.html"><strong>pindex</strong></a> does actually the same, but as an opcode instead of an expression.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/pset.html"><strong>pset</strong></a> sets p-field values in case there is no value from a scoreline.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/passign.html"><strong>passign</strong></a> assigns a range of p-fields to i-variables.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/pcount.html"><strong>pcount</strong></a> returns the number of p-fields belonging to a note event.</p></li>
<li><h2>TIME AND TEMPO</h2>
<ul>
<li><h3>Time Reading</h3>
<p><a href="http://www.csounds.com/manual/html/times.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/times.html"><strong>times</strong></a> / <a href="http://www.csounds.com/manual/html/timek.html"><strong>timek</strong></a> return the time in seconds (times) or in control cycles (timek) since the start of the current Csound performance.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/timeinsts.html"><strong>timeinsts</strong></a> / <a href="http://www.csounds.com/manual/html/timeinstk.html"><strong>timeinstk</strong></a> return the time in seconds (timeinsts) or in control cycles (timeinstk) since the start of the instrument in which they are defined.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/date.html"><strong>date</strong></a> / <a href="http://www.csounds.com/manual/html/dates.html"><strong>dates</strong></a> return the number of seconds since 1 January 1970, using the operating system's clock; either as a number (date) or as a string (dates).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/setscorepos.html"><strong>setscorepos</strong></a> sets the playback position of the current score performance to a given position.</p></li>
<li><h3>Tempo Reading</h3>
<p><a href="http://www.csounds.com/manual/html/tempo.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/tempo.html"><strong>tempo</strong></a> allows the performance speed of Csound scored events to be controlled from within an orchestra.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/miditempo.html"><strong>miditempo</strong></a> returns the current tempo at k-rate, of either the midi file (if available) or the score.</p>
<p><a href="http://www.csounds.com/manual/html/tempoval.html"><strong>tempoval</strong></a> reads the current value of the tempo.</p></li>
<li><h3>Duration Modifications</h3>
<p><a href="http://www.csounds.com/manual/html/ihold.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/ihold.html"><strong>ihold</strong></a> causes a finite-duration note to become a 'held' note.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/xtratim.html"><strong>xtratim</strong></a> extend the duration of the current instrument instance.</p></li>
<li><h3>Time Signal Generators</h3>
<p><a href="http://www.csounds.com/manual/html/metro.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/metro.html"><strong>metro</strong></a> outputs a metronome-like control signal in a variable frequency.</p>
<p><a href="http://www.csounds.com/manual/html/mpulse.html"><strong>mpulse</strong></a> generates an impulse for one sample (as audio-signal), followed by a variable time span.</p></li>
</ul></li>
</ul>
<ul>
<li><h2>CONDITIONS AND LOOPS</h2>
<p><a href="http://www.csounds.com/manual/html/changed.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/changed.html"><strong>changed</strong></a> reports whether a k-variable (or at least one of some k-variables) has changed.</p>
<p><a href="http://www.csounds.com/manual/html/trigger.html"><strong>trigger</strong></a> informs whether a k-rate signal crosses a certain threshold.</p>
<p><a href="http://www.csounds.com/manual/html/if.html"><strong>if</strong></a> branches conditionally at initialization or during performance time.</p>
<p><a href="http://www.csounds.com/manual/html/loop_lt.html"><strong>loop_lt</strong></a>, <a href="http://www.csounds.com/manual/html/loop_le.html"><strong>loop_le</strong></a>, <a href="http://www.csounds.com/manual/html/loop_gt.html"><strong>loop_gt</strong></a> and <a href="http://www.csounds.com/manual/html/loop_ge.html"><strong>loop_ge</strong></a> perform loops either at i- or k-time.</p></li>
</ul>
<ul>
<li><h2>PROGRAM FLOW</h2>
<p><a href="http://www.csounds.com/manual/html/init.html"><strong>init</strong></a> initializes a k- or a-variable (assigns a value to a k- or a-variable which is valid at i-time).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/igoto.html"><strong>igoto</strong></a> jumps to a label at i-time.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/kgoto.html"><strong>kgoto</strong></a> jumps to a label at k-time.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/timout.html"><strong>timout</strong></a> jumps to a label for a given time. Can be used in conjunction with <a href="http://www.csounds.com/manual/html/reinit.html">reinit</a> to perform time loops (see the chapter about Control Structures for more information).<br />
</p>
<p><a href="http://www.csounds.com/manual/html/reinit.html"><strong>reinit</strong></a> / <a href="http://www.csounds.com/manual/html/rigoto.html"><strong>rigoto</strong></a> / <a href="http://www.csounds.com/manual/html/rireturn.html"><strong>rireturn</strong></a> forces a certain section of code to be reinitialized (= i-rate variables are renewed).</p></li>
</ul>
<h4></h4>
<ul>
<li><h2>EVENT TRIGGERING</h2>
<p><strong><a href="http://www.csounds.com/manual/html/event_i.html">event_i</a></strong> / <strong><a href="http://www.csounds.com/manual/html/event.html">event</a></strong>: Generate an instrument event at i-time (event_i) or at k-time (event). Easy to use, but you cannot send a string to the subinstrument.</p>
<p><strong><a href="http://www.csounds.com/manual/html/scoreline_i.html">scoreline_i</a></strong> / <strong><a href="http://www.csounds.com/manual/html/scoreline.html">scoreline</a></strong>: Generate an instrument at i-time (scoreline_i) or at k-time (scoreline). Like event_i/event, but you can send to more than one instrument but unlike event_i/event you can send strings. On the other hand, you must usually preformat your scoreline-string using sprintf.</p>
<p><a href="http://www.csounds.com/manual/html/schedkwhen.html"><strong>schedkwhen</strong></a> triggers an instrument event at k-time if a certain condition is given.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/seqtime.html"><strong>seqtime</strong></a> / <a href="http://www.csounds.com/manual/html/seqtime2.html"><strong>seqtime2</strong></a> can be used to generate a trigger signal according to time values in a function table.</p>
<p><a href="http://www.csounds.com/manual/html/timedseq.html"><strong>timedseq</strong></a> is an event-sequencer in which time can be controlled by a time-pointer. Sequence data are stored into a table.</p></li>
</ul>
<ul>
<li><h2>INSTRUMENT SUPERVISION</h2>
<ul>
<li><h3>Instances And Allocation</h3>
<p><a href="http://www.csounds.com/manual/html/active.html"><strong>active</strong></a> returns the number of active instances of an instrument.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/maxalloc.html"><strong>maxalloc</strong></a> limits the number of allocations (instances) of an instrument.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/prealloc.html"><strong>prealloc</strong></a> creates space for instruments but does not run them.</p></li>
</ul>
<ul>
<li><h3>Turning On And Off</h3>
<p><a href="http://www.csounds.com/manual/html/turnon.html"><strong>turnon</strong></a> activates an instrument for an indefinite time.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/turnoff.html"><strong>turnoff</strong></a> / <a href="http://www.csounds.com/manual/html/turnoff2.html"><strong>turnoff2</strong></a> enables an instrument to turn itself, or another instrument, off.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/mute.html"><strong>mute</strong></a> mutes/unmutes new instances of a given instrument.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/remove.html"><strong>remove</strong></a> removes the definition of an instrument as long as it is not in use.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/exitnow.html"><strong>exitnow</strong></a> exits csound as fast as possible, with no cleaning up.</p></li>
<li><h3>Named Instruments</h3>
<p><a href="http://www.csounds.com/manual/html/nstrnum.html"></a><a href="http://www.csounds.com/manual/html/nstrnum.html"><strong>nstrnum</strong></a> returns the number of a named instrument.</p></li>
</ul></li>
</ul>
<ul>
<li><h2>SIGNAL EXCHANGE AND MIXING</h2>
<ul>
<li><h3>chn opcodes</h3>
<p><a href="http://www.csounds.com/manual/html/chn.html"><strong>chn_k</strong></a>, <a href="http://www.csounds.com/manual/html/chn.html"><strong>chn_a</strong></a>, and <a href="http://www.csounds.com/manual/html/chn.html"><strong>chn_S</strong></a> declare a control, audio, or string channel. Note that this can be done implicitely in most cases by chnset/chnget.</p>
<p><a href="http://www.csounds.com/manual/html/chnset.html"><strong>chnset</strong></a> writes a value (i, k, S or a) to a software channel (which is identified by a string as its name).</p>
<p><a href="http://www.csounds.com/manual/html/chnget.html"><strong>chnget</strong></a> gets the value of a named software channel.</p>
<p><a href="http://www.csounds.com/manual/html/chnmix.html"><strong>chnmix</strong></a> writes audio data to an named audio channel, mixing to the previous output.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/chnclear.html"><strong>chnclear</strong></a> clears an audio channel of the named software bus to zero.</p></li>
<li><h3>zak <br />
</h3></li>
</ul></li>
</ul>
<p><span id="ch079_math-pythonsystem-plugins.xhtml"></span></p>
<h1>OPCODE GUIDE: MATH, PYTHON/ SYSTEM, PLUGINS</h1>
<h2>MATH</h2>
<ul>
<li><h2>MATHEMATICAL CALCULATIONS</h2>
<ul>
<li><h3>Arithmetic Operations<br />
</h3>
<p><a href="http://www.csounds.com/manual/html/adds.html"><strong>+</strong></a>, <a href="http://www.csounds.com/manual/html/subtracts.html"><strong>-</strong></a>, <a href="http://www.csounds.com/manual/html/multiplies.html"><strong>*</strong></a>, <a href="http://www.csounds.com/manual/html/divides.html"><strong>/</strong></a>, <a href="http://www.csounds.com/manual/html/raises.html"><strong>^</strong></a>, <a href="http://www.csounds.com/manual/html/modulus.html"><strong>%</strong></a> are the usual signs for addition, subtraction, multiplication, division, raising to a power and modulo. The precedence is like in common mathematics (a &quot;*&quot; binds stronger than &quot;+&quot; etc.), but you can change this behaviour with parentheses: 2^(1/12) returns 2 raised by 1/12 (= the 12st root of 2), while 2^1/12 returns 2 raised by 1, and the result divided by 12.</p>
<p><strong><a href="http://www.csounds.com/manual/html/exp.html">exp(x)</a></strong>, <a href="http://www.csounds.com/manual/html/log.html"><strong>log(x)</strong></a>, <a href="http://www.csounds.com/manual/html/log10.html"><strong>log10(x)</strong></a> and <a href="http://www.csounds.com/manual/html/sqrt.html"><strong>sqrt(x)</strong></a> return e raised to the xth power, the natural log of x, the base 10 log of x, and the square root of x.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/abs.html"><strong>abs(x)</strong></a> returns the absolute value of a number.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/int.html"><strong>int(x)</strong></a> and <a href="http://www.csounds.com/manual/html/frac.html"><strong>frac(x)</strong></a> return the integer respective the fractional part of a number.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/round.html"><strong>round(x)</strong></a>, <a href="http://www.csounds.com/manual/html/ceil.html"><strong>ceil(x)</strong></a>, <a href="http://www.csounds.com/manual/html/floor.html"><strong>floor(x)</strong></a> round a number to the nearest, the next higher or the next lower integer.</p></li>
<li><h3>Trigonometric Functions</h3>
<p><a href="http://www.csounds.com/manual/html/sin.html"><strong>sin(x)</strong></a>, <a href="http://www.csounds.com/manual/html/cos.html"><strong>cos(x)</strong></a>, <a href="http://www.csounds.com/manual/html/tan.html"><strong>tan(x)</strong></a> perform a sine, cosine or tangent function.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/sinh.html"><strong>sinh(x)</strong></a>, <a href="http://www.csounds.com/manual/html/cosh.html"><strong>cosh(x)</strong></a>, <a href="http://www.csounds.com/manual/html/tanh.html"><strong>tanh(x)</strong></a> perform a hyperbolic sine, cosine or tangent function.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/sininv.html"><strong>sininv(x)</strong></a>, <a href="http://www.csounds.com/manual/html/cosinv.html"><strong>cosinv(x)</strong></a>, <a href="http://www.csounds.com/manual/html/taninv.html"><strong>taninv(x)</strong></a> and <a href="http://www.csounds.com/manual/html/taninv2.html"><strong>taninv2(x)</strong></a> perform the arcsine, arccosine and arctangent functions.</p></li>
<li><h3>Logic Operators</h3>
<p><a href="http://www.csounds.com/manual/html/opand.html"></a><a href="http://www.csounds.com/manual/html/opand.html"><strong>&amp;&amp;</strong></a> and <a href="http://www.csounds.com/manual/html/opor.html"><strong>||</strong></a>  are the symbols for a logical &quot;and&quot; respective &quot;or&quot;. Note that you can use here parentheses for defining the precedence, too, for instance: if (ival1 &lt; 10 &amp;&amp; ival2 &gt; 5) || (ival1 &gt; 20 &amp;&amp; ival2 &lt; 0) then ...</p></li>
</ul></li>
</ul>
<h4></h4>
<ul>
<li><h2>CONVERTERS</h2>
<ul>
<li><h3>MIDI To Frequency </h3>
<p><a href="http://www.csounds.com/manual/html/cpsmidi.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/cpsmidi.html"><strong>cpsmidi</strong></a> converts a MIDI note number from a triggered instrument to the frequency in Hertz.</p>
<p><a href="http://www.csounds.com/manual/html/cpsmidinn.html"><strong>cpsmidinn</strong></a> does the same for any input values (i- or k-rate).</p>
<p>Other opcodes convert to Csonund's pitch- or octave-class system. They can be found <a href="http://www.csounds.com/manual/html/PitchTop.html#PitchFuncs">here</a>.</p></li>
</ul>
<ul>
<li><h3>Frequency To MIDI</h3>
<p>Csound has no own opcode for the conversion of a frequency to a midi note number, because this is a rather simple calculation. You can find a User Defined Opcode for <a href="http://en.flossmanuals.net/bin/view/Csound/%20http://www.csounds.com/udo/displayOpcode.php?opcode_id=123">rounding to the next possible midi note number</a> or for the <a href="http://en.flossmanuals.net/bin/view/Csound/%20http://www.csounds.com/udo/displayOpcode.php?opcode_id=124">exact translation to a midi note number and a cent value as fractional part</a>.</p>
<h4></h4>
<h4></h4></li>
<li><h3>Cent Values To Frequency </h3>
<p><a href="http://www.csounds.com/manual/html/cent.html"></a><a href="http://www.csounds.com/manual/html/cent.html"><strong>cent</strong></a> converts a cent value to a multiplier. For instance, <em>cent(1200)</em> returns 2, <em>cent(100)</em> returns 1.059403. If you multiply this with the frequency you reference to, you get frequency of the note which corresponds to the cent interval.</p>
<h4></h4></li>
<li><h3>Amplitude Converters</h3>
<p><a href="http://www.csounds.com/manual/html/ampdb.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/ampdb.html"><strong>ampdb</strong></a> returns the amplitude equivalent of the dB value. <em>ampdb(0)</em> returns 1, <em>ampdb(-6)</em> returns 0.501187, and so on.</p>
<p><a href="http://www.csounds.com/manual/html/ampdbfs.html"><strong>ampdbfs</strong></a> returns the amplitude equivalent of the dB value, according to what has been set as <a href="http://www.csounds.com/manual/html/0dbfs.html">0dbfs</a> (1 is recommended, the default is 15bit = 32768). So ampdbfs(-6) returns 0.501187 for 0dbfs=1, but 16422.904297 for 0dbfs=32768.</p>
<p><a href="http://www.csounds.com/manual/html/dbamp.html"><strong>dbamp</strong></a> returns the decibel equivalent of the amplitude value, where an amplitude of 1 is the maximum. So dbamp(1) -&gt; 0 and dbamp(0.5) -&gt; -6.020600.</p>
<p><a href="http://www.csounds.com/manual/html/dbfsamp.html"><strong>dbfsamp</strong></a> returns the decibel equivalent of the amplitude value set by the <a href="http://www.csounds.com/manual/html/0dbfs.html">0dbfs</a> statement. So dbfsamp(10) is 20.000002 for 0dbfs=0 but -70.308998 for 0dbfs=32768.</p>
<h4></h4></li>
<li><h3>Scaling </h3>
<p>Scaling of signals from an input range to an output range, like the &quot;scale&quot; object in Max/MSP, is not implemented in Csound, because it is a rather simple calculation. It is available as User Defined Opcode: <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=125">Scali</a> (i-rate), <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=126">Scalk</a> (k-rate) or <a href="http://www.csounds.com/udo/displayOpcode.php?opcode_id=127">Scala</a> (a-rate).<br />
</p></li>
</ul></li>
</ul>
<h2>PYTHON AND SYSTEM</h2>
<ul>
<li><h2>PYTHON OPCODES</h2>
<h4></h4>
<p><a href="http://www.csounds.com/manual/html/pyinit.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/pyinit.html"><strong>pyinit</strong></a> initializes the Python interpreter.<br />
</p>
<p><a href="http://www.csounds.com/manual/html/pyrun.html"><strong>pyrun</strong></a> runs a Python statement or block of statements.</p>
<p><a href="http://www.csounds.com/manual/html/pyexec.html"><strong>pyexec</strong></a> executes a script from a file at k-time, i-time or if a trigger has been received.</p>
<p><a href="http://www.csounds.com/manual/html/pycall.html"><strong>pycall</strong></a> invokes the specified Python callable at k-time or i-time.</p>
<p><a href="http://www.csounds.com/manual/html/pyeval.html"><strong>pyeval</strong></a> evaluates a generic Python expression and stores the result in a Csound k- or i-variable, with optional trigger.</p>
<p><a href="http://www.csounds.com/manual/html/pyassign.html"><strong>pyassign</strong></a> assigns the value of the given Csound variable to a Python variable possibly destroying its previous content.</p></li>
</ul>
<h4></h4>
<ul>
<li><h2>SYSTEM OPCODES</h2>
<p><a href="http://www.csounds.com/manual/html/getcfg.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/getcfg.html"><strong>getcfg</strong></a> returns various Csound configuration settings as a string at init time.</p>
<p><a href="http://www.csounds.com/manual/html/system.html"><strong>system</strong></a> / <a href="http://www.csounds.com/manual/html/system.html"><strong>system_i</strong></a> call an external program via the system call.</p></li>
</ul>
<h2>PLUGINS<br />
</h2>
<ul>
<li><h2>PLUGIN HOSTING</h2>
<ul>
<li><h3>LADSPA</h3>
<p><a href="http://www.csounds.com/manual/html/dssiinit.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/dssiinit.html"><strong>dssiinit</strong></a> loads a plugin.</p>
<p><a href="http://www.csounds.com/manual/html/dssiactivate.html"><strong>dssiactivate</strong></a> activates or deactivates a plugin if it has this facility.</p>
<p><a href="http://www.csounds.com/manual/html/dssilist.html"><strong>dssilist</strong></a> lists all available plugins found in the LADSPA_PATH and DSSI_PATH global variables.</p>
<p><a href="http://www.csounds.com/manual/html/dssiaudio.html"><strong>dssiaudio</strong></a> processes audio using a plugin.</p>
<p><a href="http://www.csounds.com/manual/html/dssictls.html"><strong>dssictls</strong></a> sends control information to a plugin's control port.</p></li>
<li><h3>VST</h3>
<p><a href="http://www.csounds.com/manual/html/vstinit.html"></a></p>
<p><a href="http://www.csounds.com/manual/html/vstinit.html"><strong>vstinit</strong></a> loads a plugin.</p>
<p><a href="http://www.csounds.com/manual/html/vstaudio.html"><strong>vstaudio</strong></a> / <a href="http://www.csounds.com/manual/html/vstaudio.html"><strong>vstaudiog</strong></a> return a plugin's output.</p>
<p><a href="http://www.csounds.com/manual/html/vstmidiout.html"><strong>vstmidiout</strong></a> sends midi data to a plugin.</p>
<p><a href="http://www.csounds.com/manual/html/vstparamset.html"><strong>vstparamset</strong></a> / <a href="http://www.csounds.com/manual/html/vstparamget.html"><strong>vstparamget</strong></a> sends and receives automation data to and from the plugin.</p>
<p><a href="http://www.csounds.com/manual/html/vstnote.html"><strong>vstnote</strong></a> sends a midi note with a definite duration.</p>
<p><a href="http://www.csounds.com/manual/html/vstinfo.html"><strong>vstinfo</strong></a> outputs the parameter and program names for a plugin.</p>
<p><a href="http://www.csounds.com/manual/html/vstbankload.html"><strong>vstbankload</strong></a> loads an .fxb bank.</p>
<p><a href="http://www.csounds.com/manual/html/vstprogset.html"><strong>vstprogset</strong></a> sets the program in a .fxb bank.</p>
<p><a href="http://www.csounds.com/manual/html/vstedit.html"><strong>vstedit</strong></a> opens the GUI editor for the plugin, when available.</p></li>
</ul></li>
</ul>
<p><span id="ch081_glossary.xhtml"></span></p>
<h1>GLOSSARY</h1>
<p> </p>
<p><strong>control cycle</strong>, <strong>control period</strong> or <strong>k-loop</strong> is a pass during the performance of an instrument, in which all k- and a-variables are renewed. The time for one control cycle is measured in samples and determined by the <a href="http://www.csounds.com/manual/html/ksmps.html">ksmps</a> constant in the orchestra header. If your sample rate is 44100 and your ksmps value is 10, the time for one control cycle is 1/4410 = 0.000227 seconds. See the chapter about <a href="http://en.flossmanuals.net/bin/view/Csound/InitAndPerfPass">Initialization And Performance Pass</a> for more information.</p>
<p> </p>
<p><strong>control rate</strong> or <strong>k-rate</strong> (<a href="http://www.csounds.com/manual/html/kr.html">kr</a>) is the number of control cycles per second. It can be calculated as the relationship of the sample rate <a href="http://www.csounds.com/manual/html/sr.html">sr</a> and the number of samples in one control period <a href="http://www.csounds.com/manual/html/ksmps.html">ksmps</a>. If your sample rate is 44100 and your ksmps value is 10, your control rate is 4410, so you have 4410 control cycles per second.<br />
</p>
<p> </p>
<p><strong>dummy f-statement</strong> see <strong>f-statement</strong></p>
<p><br />
</p>
<p><strong>f-statement</strong> or <strong>function table statement</strong> is a score line which starts with a &quot;f&quot; and generates a function table. See the chapter about <a href="http://en.flossmanuals.net/bin/view/Csound/FUNCTIONTABLES">function tables</a> for more information. A <strong>dummy f-statement</strong> is a statement like &quot;f 0 3600&quot; which looks like a function table statement, but instead of generating any table, it serves just for running Csound for a certain time (here 3600 seconds = 1 hour). <strong></strong><br />
</p>
<p> </p>
<p><strong></strong></p>
<p><strong>FFT</strong> Fast Fourier Transform is a system whereby audio data is stored or represented in the frequency domain as opposed to the time domain as amplitude values as is more typical. Working with FFT data facilitates transformations and manipulations that are not possible, or are at least more difficult, with audio data stored in other formats. <strong></strong><br />
</p>
<p> </p>
<p><strong>GEN rountine</strong> a GEN (generation) routine is a mechanism within Csound used to create function tables of data that will be held in RAM for all or part of the performance. A GEN routine could be a waveform, a stored sound sample, a list of explicitly defined number such as tunings for a special musical scale or an amplitude envelope. In the past function tables could only be created only in the Csound score but now they can also be created (and deleted and over-written) within the orchestra. <strong></strong><br />
</p>
<p> </p>
<p><strong>GUI</strong> Graphical User Interface refers to a system of on-screen sliders, buttons etc. used to interact with Csound, normally in realtime. <strong></strong><br />
</p>
<p> </p>
<p><strong>i-time</strong> or <strong>init-time</strong> or <strong>i-rate</strong> signify the time in which all the variables starting with an &quot;i&quot; get their values. These values are just given once for an instrument call. See the chapter about <a href="http://en.flossmanuals.net/bin/view/Csound/InitAndPerfPass">Initialization And Performance Pass</a> for more information.</p>
<p> </p>
<p><strong>k-loop</strong> see <strong>control cycle</strong><br />
</p>
<p> </p>
<p><strong>k-time</strong> is the time during the performance of an instrument, after the initialization. Variables starting with a &quot;k&quot; can alter their values in each -&gt;control cycle. See the chapter about <a href="http://en.flossmanuals.net/bin/view/Csound/InitAndPerfPass">Initialization And Performance Pass</a> for more information.</p>
<p> </p>
<p><strong>k-rate</strong> see <strong>control rate</strong> <strong></strong><br />
</p>
<p> </p>
<p><strong>opcode</strong> the code word of a basic building block with which Csound code is written. As well as the opcode code word an opcode will commonly provide output arguments (variables), listed to the left of the opcode, and input arguments (variables). listed to the right of the opcode. An opcode is equivalent to a 'ugen' (unit generator) in other languages.<strong></strong></p>
<p>  <strong></strong><br />
</p>
<p><strong>orchestra</strong> as in the Csound orchestra, is the section of Csound code where traditionally the instruments are written. In the past the 'orchestra' was one of two text files along with the 'score' that were needed to run Csound. Most people nowadays combine these two sections, along with other optional sections in a .csd (unified) Csound file. The orchestra will also normally contain header statements which will define global aspects of the Csound performance such as sampling rate.</p>
<p> </p>
<p><strong>p-field</strong> a 'p' (parameter) field normally refers to a value contained within the list of values after an event item with the Csound score.</p>
<p> </p>
<p><strong>performance pass</strong> see <strong>control cycle</strong><br />
</p>
<p> </p>
<p><strong>score</strong> as in the Csound score, is the section of Csound code where note events are written that will instruct instruments within the Csound orchestra to play. The score can also contain function tables. In the past the 'score' was one of two text files along with the 'orchestra' that were needed to run Csound. Most people nowadays combine these two sections, along with other optional sections in a .csd (unified) Csound file.<br />
</p>
<p> </p>
<p><strong>time stretching</strong> can be done in various ways in Csound. See <a href="http://www.csounds.com/manual/html/sndwarp.html">sndwarp</a>, <a href="http://www.csounds.com/manual/html/waveset.html">waveset</a>, <a href="http://www.csounds.com/manual/html/pvstanal.html">pvstanal</a> and the Granular Synthesis opcodes. In the frequency domain, you can use the pvs-opcodes <a href="http://www.csounds.com/manual/html/pvsfread.html">pvsfread</a>, <a href="http://www.csounds.com/manual/html/pvsdiskin.html">pvsdiskin</a>, <a href="http://www.csounds.com/manual/html/pvscale.html">pvscale</a>, <a href="http://www.csounds.com/manual/html/pvshift.html">pvshift</a>.<br />
</p>
<p> </p>
<p><strong>widget</strong> normally refers to some sort of standard GUI element such as a slider or a button. GUI widgets normally permit some user modifications such as size, positioning colours etc. A variety options are available for the creation of widgets usable by Csound, from it own built-in FLTK widgets to those provided by front-ends such as CsoundQT, Cabbage and Blue.<br />
</p>
<p> </p>
<p><span id="ch082_links.xhtml"></span></p>
<h1>LINKS</h1>
<h2>Downloads</h2>
<p>Csound: <a href="http://sourceforge.net/projects/csound/files/" class="uri">http://sourceforge.net/projects/csound/files/</a></p>
<p>Csound's User Defined Opcodes: <a href="http://www.csounds.com/udo/" class="uri">http://www.csounds.com/udo/</a><br />
</p>
<p>CsoundQt: <a href="http://sourceforge.net/projects/qutecsound/files/" class="uri">http://sourceforge.net/projects/qutecsound/files/</a></p>
<p>WinXound:<a href="http://winxound.codeplex.com" class="uri">http://winxound.codeplex.com</a></p>
<p>Blue: <a href="http://sourceforge.net/projects/bluemusic/files/" class="uri">http://sourceforge.net/projects/bluemusic/files/</a></p>
<p>Cabbage: <a href="http://code.google.com/p/cabbage"><span>http://code.google.com/p/cabbage</span></a></p>
<h2>Community</h2>
<p><a href="http://csound.sourceforge.net/">Csound's</a> info page on sourceforge is a good collection of links and basic infos.<br />
</p>
<p><a href="http://csounds.com/">csounds.com</a> is the main page for the Csound community, including news, online tutorial, forums and many links.</p>
<p>The <a href="http://www.csounds.com/journal/">Csound Journal</a> is a main source for different aspects of working with Csound.</p>
<h2>Mailing Lists and Bug Tracker<br />
</h2>
<p>To subscribe to the <strong>Csound User</strong> Discussion List, send a message with &quot;subscribe csound &lt;your name&gt;&quot; in the message body to <a href="mailto:sympa@lists.bath.ac.uk">sympa@lists.bath.ac.uk</a>. To post, send messages to <a href="mailto:csound@lists.bath.ac.uk">csound@lists.bath.ac.uk</a>. You can search in the list archive at <a href="http://old.nabble.com/Csound-f480.html">nabble.com</a>.</p>
<p>To subscribe to the <strong>CsoundQt User</strong> Discussion List, go to <a href="https://lists.sourceforge.net/lists/listinfo/qutecsound-users" class="uri">https://lists.sourceforge.net/lists/listinfo/qutecsound-users</a>. You can browse the list archive <a href="http://sourceforge.net/mailarchive/forum.php?forum_name=qutecsound-users">here</a>.<br />
</p>
<p><strong>Csound Developer</strong> Discussions: <a href="https://lists.sourceforge.net/lists/listinfo/csound-devel" class="uri">https://lists.sourceforge.net/lists/listinfo/csound-devel</a><br />
</p>
<p><strong>Blue</strong>: <a href="http://sourceforge.net/mail/?group_id=74382" class="uri">http://sourceforge.net/mail/?group_id=74382</a></p>
<p>Please report any <strong>bug</strong> you experienced in <strong>Csound</strong> at <a href="http://sourceforge.net/tracker/?group_id=81968&amp;atid=564599" class="uri">http://sourceforge.net/tracker/?group_id=81968&amp;atid=564599</a>, and a <strong>CsoundQt</strong> related bug at <a href="http://sourceforge.net/tracker/?func=browse&amp;group_id=227265&amp;atid=1070588" class="uri">http://sourceforge.net/tracker/?func=browse&amp;group_id=227265&amp;atid=1070588</a>. Every bug report is an important contribution.<br />
</p>
<h2>Tutorials</h2>
<p><a href="http://www.csounds.com/tootsother/vercoetut/Vercoe.html">A Beginning Tutorial</a> is a short introduction from Barry Vercoe, the &quot;father of Csound&quot;.</p>
<p><a href="http://www.csounds.com/toots/index.html">An Instrument Design TOOTorial</a> by Richard Boulanger (1991) is another classical introduction, still very worth to read.</p>
<p><a href="http://www.csounds.com/chapter1/index.html">Introduction to Sound Design in Csound</a> also by Richard Boulanger, is the first chapter of the famous Csound Book (2000).<br />
</p>
<p><a href="http://www.virtual-sound.com/sv/index.php?option=com_content&amp;view=article&amp;id=46&amp;Itemid=56">Virtual Sound</a> by Alessandro Cipriani and Maurizio Giri (2000)</p>
<p><a href="http://michael-gogins.com/archives/tutorial.pdf">A Csound Tutorial</a> by Michael Gogins (2009), one of the main Csound Developers.</p>
<p> </p>
<h2>Video Tutorials</h2>
<p>A playlist as overview by Alex Hofmann:</p>
<p><a href="http://www.youtube.com/view_play_list?p=3EE3219702D17FD3" class="uri">http://www.youtube.com/view_play_list?p=3EE3219702D17FD3</a></p>
<h3>CsoundQt (QuteCsound)</h3>
<p>QuteCsound: Where to start?<br />
<a href="http://www.youtube.com/watch?v=0XcQ3ReqJTM" class="uri" title="http://www.youtube.com/watch?v=0XcQ3ReqJTM">http://www.youtube.com/watch?v=0XcQ3ReqJTM</a></p>
<p>First instrument:<br />
<a href="http://www.youtube.com/watch?v=P5OOyFyNaCA" class="uri" title="http://www.youtube.com/watch?v=P5OOyFyNaCA">http://www.youtube.com/watch?v=P5OOyFyNaCA</a></p>
<p>Using MIDI:<br />
<a href="http://www.youtube.com/watch?v=8zszIN_N3bQ" class="uri" title="http://www.youtube.com/watch?v=8zszIN_N3bQ">http://www.youtube.com/watch?v=8zszIN_N3bQ</a></p>
<p>About configuration:<br />
<a href="http://www.youtube.com/watch?v=KgYea5s8tFs" class="uri" title="http://www.youtube.com/watch?v=KgYea5s8tFs">http://www.youtube.com/watch?v=KgYea5s8tFs</a></p>
<p>Presets tutorial:<br />
<a href="http://www.youtube.com/watch?v=KKlCTxmzcS0" class="uri" title="http://www.youtube.com/watch?v=KKlCTxmzcS0">http://www.youtube.com/watch?v=KKlCTxmzcS0</a><br />
<a href="http://www.youtube.com/watch?v=aES-ZfanF3c" class="uri" title="http://www.youtube.com/watch?v=aES-ZfanF3c">http://www.youtube.com/watch?v=aES-ZfanF3c</a></p>
<p>Live Events tutorial:<br />
<a href="http://www.youtube.com/watch?v=O9WU7DzdUmE" class="uri" title="http://www.youtube.com/watch?v=O9WU7DzdUmE">http://www.youtube.com/watch?v=O9WU7DzdUmE</a><br />
<a href="http://www.youtube.com/watch?v=Hs3eO7o349k" class="uri" title="http://www.youtube.com/watch?v=Hs3eO7o349k">http://www.youtube.com/watch?v=Hs3eO7o349k</a><br />
<a href="http://www.youtube.com/watch?v=yUMzp6556Kw" class="uri" title="http://www.youtube.com/watch?v=yUMzp6556Kw">http://www.youtube.com/watch?v=yUMzp6556Kw</a></p>
<p>New editing features in 0.6.0:<br />
<a href="http://www.youtube.com/watch?v=Hk1qPlnyv88" class="uri" title="http://www.youtube.com/watch?v=Hk1qPlnyv88">http://www.youtube.com/watch?v=Hk1qPlnyv88</a><br />
</p>
<h3>Csoundo (Csound and Processing)</h3>
<p><a href="http://csoundblog.com/2010/08/csound-processing-experiment-i/" class="uri">http://csoundblog.com/2010/08/csound-processing-experiment-i/</a></p>
<h3>Open Sound Control in Csound</h3>
<p><a href="http://csoundblog.com/2010/08/csound-processing-experiment-i/">http://www.youtube.com/watch?v=JX1C3TqP_9Y</a></p>
<p> </p>
<p><a href="http://csoundblog.com/2010/08/csound-processing-experiment-i/"></a></p>
<h2>The Csound Conference in Hannover (2011)</h2>
<p><a href="http://www.incontri.hmtm-hannover.de/de/elektronisches-studio/csound-conference/">Web page</a> with papers and program.</p>
<p>All Videos can be found via the YoutTube channel <a href="http://www.youtube.com/user/csconf2011">csconf2011</a>.<br />
</p>
<p> </p>
<h2>Example Collections</h2>
<p><a href="http://iainmccurdy.org/csound.html">Csound Realtime Examples</a> by Iain McCurdy is one of the most inspiring and up-to-date collections.</p>
<p>The <a href="http://www.music.buffalo.edu/hiller/accci/">Amsterdam Catalog</a> by John-Philipp Gather is particularily interesting because of the adaption of Jean-Claude Risset's famous &quot;Introductory Catalogue of Computer Synthesized Sounds&quot; from 1969.</p>
<h2>Books</h2>
<p><a href="http://csounds.com/shop/csound-book">The Csound Book</a> (2000) edited by Richard Boulanger is still the compendium for anyone who really wants to go in depth with Csound.</p>
<p><a href="http://www.virtual-sound.com/sv/index.php?option=com_content&amp;view=article&amp;id=46&amp;Itemid=56">Virtual Sound</a> by Alessandro Cipriani and Maurizio Giri (2000)</p>
<p><a href="http://www.peterlang.com/index.cfm?event=cmp.ccc.seitenstruktur.detailseiten&amp;seitentyp=produkt&amp;pk=13446&amp;CFID=709575&amp;CFTOKEN=84330415">Signale, Systeme, und Klangsysteme</a> by Martin Neukom (2003, german) has many interesting examples in Csound.<br />
</p>
<p><a href="http://mitpress.mit.edu/9780262014465">The Audio Programming Book</a>edited by Richard Boulanger and Victor Lazzarini (2011) is a major source with many references to Csound.</p>
<p><a href="http://courseptr.com/Courses.aspx?MenuId=13&amp;MenuSubId=7">Csound Power!</a> by Jim Aikin (2012) is a perfect up-to-date introduction for beginners.<br />
</p>
<h2><br />
</h2>
<p><span id="ch083_building-csound.xhtml"></span></p>
<h1>BUILDING CSOUND</h1>
<p>Currently (April 2012) a collection of build instructions has been started at the <a href="http://sourceforge.net/apps/mediawiki/csound/index.php?title=Main_Page">Csound Media Wiki at Sourceforge</a>. Please have a look there if you have problems in building Csound. </p>
<h2>Linux</h2>
<p> </p>
<h3>Debian</h3>
<h4> On Wheezy with an amd64 architecture.</h4>
<p>Download a copy of the Csound sources from the Sourceforge. To do so, in the terminal type:</p>
<blockquote>
<p>git clone --depth 1 git://csound.git.sourceforge.net/gitroot/csound/csound5</p>
</blockquote>
<p>Use aptitude to get (at least) the dependencies for a basic build, which are: libsndfile1-dev, python2.6-dev, scons. To do so, use the following command (with sudo or as root):</p>
<blockquote>
<p>aptitude install libsndfile1-dev python2.6-dev scons</p>
</blockquote>
<p>There are many more optional dependencies, which are recommended to get in most cases (some are already part of Debian), and which are documented <a href="http://www.csounds.com/manual/html/BuildingCsound.html" title="Building Csound">here</a>. I built with the following libraries installed: libportaudiocpp0, alsa, libportmidi0, libfltk1.1, swig2.0, libfluidsynth1 and liblo7. To install them (some might already be in your sistem), type:</p>
<blockquote>
<p>aptitude install libportaudiocpp0 alsa libportmidi0 libfltk1.1 swig2.0 libfluidsynth1 liblo7</p>
</blockquote>
<p>Go inside the csound5/ folder you downloaded from sourceforge, and edit build-linux-double.sh in order to meet your building needs, once again, read about the options in the <a href="file:///usr/share/doc/csound-doc/html/BuildingCsound.html" title="Build Csound">Build Csound</a> section of the manual.</p>
<p>On amd64 architectures, it is IMPORTANT to change gcc4opt=atom to gcc4opt=generic (otherwise it will build for single processor). I also used buildNewParser=0, since I could not get to compile with the new parser. To finally build, run the script:</p>
<blockquote>
<p>./build-linux-double.sh</p>
</blockquote>
<p>If the installation was successful, use the following command to install:</p>
<blockquote>
<p>./install.py</p>
</blockquote>
<p>Make sure that the following environment<br />
variables are set:</p>
<blockquote>
OPCODEDIR64=/usr/local/lib/csound/plugins64<br />
CSSTRNGS=/usr/local/share/locale<br />

</blockquote>
<p>If you built the python interface, move the csnd.py and -csnd.so from /usr/lib/python2.6/site-packages/ to /usr/lib/python2.6/dist-packages/ (the standard place for external Python modules since version 2.6). You can do so with the following commands:</p>
<blockquote>
<p>/usr/lib/python2.6/site-packages/csnd.py /usr/lib/python2.6/dist-packages/</p>
<p>/usr/lib/python2.6/site-packages/_csnd.so /usr/lib/python2.6/dist-packages/</p>
</blockquote>
<p>If you want to un-install, you can do so by running the following command:</p>
<blockquote>
<p>/usr/local/bin/uninstall-csound5</p>
</blockquote>
<p>Good luck!<br />
</p>
<h3><br />
</h3>
<h3>Ubuntu<br />
</h3>
<p>1. Download the sources. Either the last stable release from http://sourceforge.net/projects/csound/files/csound5/ or the latest (possible unstable) sources from git (running the command git clone git://csound.git.sourceforge.net/gitroot/csound/csound5).</p>
<p>2. Open a Terminal window and run the command</p>
<pre><code> sudo apt-get install csound</code></pre>
<p>This should install all the dependencies which are needed to build Csound.</p>
<p>3. Change the directory to the folder you have downloaded in step 1, using the command cd.</p>
<p>4. Run the command scons. You can start with</p>
<pre><code>scons -h</code></pre>
<p>to check the configuration and choose your options. See the <a href="http://www.csounds.com/manual/html/BuildingCsound.html" title="Build Csound">Build Csound</a> section of the manual for more information about the options. If you want to build the standard configuration, just run scons without any options.</p>
<p>If you get an error, these are possible reasons:</p>
<ul>
<li>You must install bison and flex to use the new parser.</li>
<li>If there is a complaint about not finding a file called custom.py, copy the file custom-linux-jpff.py and rename it as custom.py.</li>
</ul>
<p>There is also a detailed <a href="http://csounds.com/node/1373">instruction by Menno Knevel</a> at csounds.com which may help.</p>
<p>5. Run</p>
<pre><code>sudo python install.py</code></pre>
<p>You should now be able to run csound by the command /usr/local/bin/csound, or simply by the command csound.<br />
</p>
<h2>OSX</h2>
<p>As mentioned above, have a look at http://sourceforge.net/apps/mediawiki/csound/index.php?title=Main_Page. </p>
<h2>Windows<br />
</h2>
<p>There is a detailed description of Michael Gogins, entitled <em>How to Build Csound on Windows</em> in the Csound Sources. You can either download the Csound Sources at <a href="http://sourceforge.net/projects/csound/files/csound5" class="uri">http://sourceforge.net/projects/csound/files/csound5</a> or get the latest version at the <a href="http://csound.git.sourceforge.net/git/gitweb.cgi?p=csound/csound5.git;a=tree">Csound Git Repository</a>. </p>
<p> </p>
<p><span id="ch084_writing-csound-scores-by-hand.xhtml"></span></p>
<h1>METHODS OF WRITING CSOUND SCORES</h1>
<p>Although the use of Csound real-time has become more prevalent and arguably more important whilst the use if the score has diminished and become less important, composing using score events within the Csound score remains an important bedrock to working with Csound. There are many methods for writing Csound score several of which are covered here, starting with the classical method of writing scores by hand, and concluding with the definition of a user-defined score language.</p>
<h2>Writing Score by Hand<br />
</h2>
<p>In Csound's original incarnation the orchestra and score existed as separate text files. This arrangement existed partly in an attempt to appeal to composers who had come from a background of writing for conventional instruments by providing a more familiar paradigm. The three unavoidable attributes of a note event - which instrument plays it, when, and for how long - were hardwired into the structure of a note event through its first three attributes or 'p-fields'. All additional attributes (p4 and beyond), for example: dynamic, pitch, timbre, were left to the discretion of the composer, much as they would be when writing for conventional instruments. It is often overlooked that when writing score events in Csound we define start times and durations in 'beats'. It just so happens that 1 beat defaults to a duration of 1 second leading to the consequence that many Csound users spend years thinking that they are specifying note events in terms of seconds rather than beats. This default setting can easily be modified and manipulated as shown later on.</p>
<p>The most basic score event as described above might be something like this:</p>
<pre><code> i 1 0 5</code></pre>
<p>which would demand that instrument number '1' play a note at time zero (beats) for 5 beats. After time of constructing a score in this manner it quickly becomes apparent that certain patterns and repetitions recur. Frequently a single  instrument will be called repeatedly to play the notes that form a longer phrase therefore diminishing the worth of repeatedly typing the same instrument number for p1, an instrument may play a long sequence of notes of the same duration as in a phrase of running semiquavers rendering the task of inputting the same value for p3 over and over again slightly tedious and often a note will follow on immediately after the previous one as in a legato phrase intimating that the p2 start-time of that note might better be derived from the duration and start-time of the previous note by the computer than to be figured out by the composer. Inevitably short-cuts were added to the syntax to simplify these kinds of tasks:</p>
<pre><code>i 1 0 1 60
i 1 1 1 61
i 1 2 1 62
i 1 3 1 63
i 1 4 1 64</code></pre>
<p> could now be expressed as:<br />
</p>
<pre><code>i 1 0 1 60
i . + 1 &gt;
i . + 1 &gt;
i . + 1 &gt;
i . + 1 64</code></pre>
<p>where '.' would indicate that that p-field would reuse the same p-field value from the previous score event, where '+', unique for p2, would indicate that the start time would follow on immediately after the previous note had ended and '&gt;' would create a linear ramp from the first explicitly defined value (60) to the next explicitly defined value (64) in that p-field column (p4).</p>
<p>A more recent refinement of the p2 shortcut allows for staccato notes where the rhythm and timing remain unaffected. Each note lasts for 1/10 of a beat and each follows one second after the previous.<br />
</p>
<pre><code>i 1 0   .1 60
i . ^+1 .  &gt;
i . ^+1 .  &gt;
i . ^+1 .  &gt;
i . ^+1 .  64</code></pre>
<p>The benefits offered by these short cuts quickly becomes apparent when working on longer scores. In particular the editing of critical values once, rather than many times is soon appreciated.</p>
<p>Taking a step further back, a myriad of score tools, mostly also identified by a single letter, exist to manipulate entire sections of score. As previously mentioned Csound defaults to giving each beat a duration of 1 second which corresponds to this 't' statement at the beginning of a score:</p>
<pre><code>t 0 60</code></pre>
<p>&quot;At time (beat) zero set tempo to 60 beats per minute&quot;; but this could easily be anything else or evena string of tempo change events following the format of a <a href="http://www.csounds.com/manual/html/linsegb.html">linsegb</a> statement.</p>
<pre><code>t 0 120 5 120 5 90 10 60</code></pre>
<p>This time tempo begins at 120bpm and remains steady until the 5th beat, whereupon there is an immediate change to 90bpm; thereafter the tempo declines in linear fashion until the 10th beat when the tempo has reached 60bpm.</p>
<p>'m' statements allow us to define sections of the score that might be repeated ('s' statements marking the end of that section). 'n' statements referencing the name given to the original 'm' statement via their first parameter field will call for a repetition of that section.</p>
<pre><code>m verse
i 1 0   1 60
i . ^+1 .  &gt;
i . ^+1 .  &gt;
i . ^+1 .  &gt;
i . ^+1 . 64
s
n verse
n verse
n verse</code></pre>
<p>Here a 'verse' section is first defined using an 'm' section (the section is also played at this stage). 's' marks the end of the section definition and 'n' recalls this section three more times.</p>
<p>Just a selection of the techniques and shortcuts available for hand-writing scores have been introduced here (refer to the <a href="http://www.csounds.com/manual/html/index.html">Csound Reference Manual</a> for a more encyclopedic overview). It has hopefully become clear however that with a full knowledge and implementation of these techniques the user can adeptly and efficiently write and manipulate scores by hand.<br />
</p>
<h2>Extension of the Score Language: bin=&quot;...&quot; <br />
</h2>
<p>It is possible to pass the score as written through a pre-processor before it is used by Csound to play notes. instead it can be first interpretted by a binary (application), which produces a usual csound score as a result. This is done by the statement bin=&quot;...&quot; in the &lt;CsScore&gt; tag. What happens?</p>
<ol>
<li>
<p>If just a binary is specified, this binary is called and two files are passed to it:</p>
</li>
<ol>
<li>A copy of the user written score. This file has the suffix <em>.ext</em> </li>
<li>An empty file which will be read after the interpretation by Csound. This file has the usual score suffix <em>.sco</em></li>
</ol>
<li>
<p>If a binary and a script is specified, the binary calls the script and passes the two files to the script.<br />
</p>
</li>
</ol>
<p>If you have Python<span id="ch084_writing-csound-scores-by-hand.xhtml#InsertNoteID_6_marker7" class="InsertNoteMarker"><sup><a href="writing-csound-scores-by-hand#InsertNoteID_6">1</a></sup></span>  installed on your computer, you should be able to run the following examples. They do actually nothing but print the arguments (= file names).</p>
<p><em><strong>EXAMPLE ...csd: Calling a binary without a script</strong></em><br />
</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
instr 1	
endin
&lt;/CsInstruments&gt;
&lt;CsScore bin=&quot;python&quot;&gt;
from sys import argv
print &quot;File to read = &#39;%s&#39;&quot; % argv[0]
print &quot;File to write = &#39;%s&#39;&quot; % argv[1]
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>When you execute this .csd file in the terminal, your output should include something like this: </p>
<p>   File to read = '/tmp/csound-idWDwO.ext'<br />
   File to write = '/tmp/csound-EdvgYC.sco'</p>
<p>And there should be a complaint because the empty .sco file has not been written:</p>
<p>   cannot open scorefile /tmp/csound-EdvgYC.sco<br />
</p>
<p><em><strong>EXAMPLE .... csd: Calling a binary and a script</strong></em><br />
</p>
<p>To test this, first save this file as <em>print.py</em> in the same folder where your .csd examples are:</p>
<pre><code>from sys import argv
print &quot;Script = &#39;%s&#39;&quot; % argv[0]
print &quot;File to read = &#39;%s&#39;&quot; % argv[1]
print &quot;File to write = &#39;%s&#39;&quot; % argv[2]</code></pre>
<p>Then run the ....csd:</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
instr 1	
endin
&lt;/CsInstruments&gt;
&lt;CsScore bin=&quot;python print.py&quot;&gt;
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;</code></pre>
<p>The output should include these lines:</p>
<p>   Script = 'print.py'<br />
   File to read = '/tmp/csound-jwZ9Uy.ext'<br />
   File to write = '/tmp/csound-NbMTfJ.sco'<br />
</p>
<p>And again a complaint about the invalid score file:</p>
<p>   cannot open scorefile /tmp/csound-NbMTfJ.sco<br />
</p>
<p> </p>
<h3>csbeats</h3>
<p> </p>
<h3>Scripts</h3>
<p> </p>
<h3>Scripting Language Examples</h3>
<p>The following script uses a perl script to allow seeding options in the score. A random seed can be set as a comment; like &quot;;;SEED 123&quot;. If no seed has been set, the current system clock is used. So there will be a different value for the first three random statements, while the last two statements will always generate the same values.</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsInstruments&gt;
;example by tito latini

instr 1
  prints &quot;amp = %f, freq = %f\n&quot;, p4, p5;
endin

&lt;/CsInstruments&gt;
&lt;CsScore bin=&quot;perl cs_sco_rand.pl&quot;&gt;

i1  0  .01  rand()   [200 + rand(30)]
i1  +  .    rand()   [400 + rand(80)]
i1  +  .    rand()   [600 + rand(160)]
;; SEED 123
i1  +  .    rand()   [750 + rand(200)]
i1  +  .    rand()   [210 + rand(20)]
e

&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;



# cs_sco_rand.pl
my ($in, $out) = @ARGV;
open(EXT, &quot;&lt;&quot;, $in);
open(SCO, &quot;&gt;&quot;, $out);

while (&lt;EXT&gt;) {
  s/SEED\s+(\d+)/srand($1);$&amp;/e;
  s/rand\(\d*\)/eval $&amp;/ge;
  print SCO;
}
 </code></pre>
<p> </p>
<p><br />
</p>
<ol>
<li><span id="ch084_writing-csound-scores-by-hand.xhtml#InsertNoteID_6">www.python.org<span id="ch084_writing-csound-scores-by-hand.xhtml#InsertNoteID_6_LinkBacks"><sup><a href="writing-csound-scores-by-hand#InsertNoteID_6_marker7">^</a></sup></span></span></li>
</ol>
</body>
</html>
