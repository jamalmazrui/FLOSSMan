<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="The Contributors" />
  <title>ChucK</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">ChucK</h1>
<p class="author">The Contributors</p>
<p class="date">2011.04.13-10.45</p>
</header>
<p><span id="ch001_introduction.xhtml"></span></p>
<h1>Intro-ChucK-tion</h1>
<p>What it is: ChucK is a general-purpose programming language, intended for real-time audio synthesis and graphics/multimedia programming.It introduces a truly concurrent programming model that embeds timing directly in the program flow (we call this strongly-timed). Other potentially useful features include the ability to write/change programs on-the-fly.</p>
<p>Who it is for: Audio/multimedia researchers, developers, composers, and performers.</p>
<h4>Supported Platforms:</h4>
<ul>
<li>MacOS X (CoreAudio)</li>
<li>Linux (ALSA/OSS/Jack) </li>
<li>Windows/also Cygwin (DirectSound)</li>
</ul>
<h2>Strongly-timed</h2>
<p>ChucK's programming model provides programmers direct, precise, and readable control over time, durations, rates, and just about anything else involving time.  This makes ChucK a potentially fun and highly flexible tool for describing, designing, and implementing sound synthesis and music-making at both low and high levels.</p>
<h2>On-the-fly Programming</h2>
<p>On-the-fly programming is a style of programming in which the programmer/performer/composer augments and modifies the program while it is running, without stopping or restarting, in order to assert expressive, programmable control for performance, composition, and experimentation at run-time. Because of the fundamental powers of programming languages, we believe the technical and aesthetic aspects of on-the-fly programming are worth exploring.</p>
<p><span id="ch002_places.xhtml"></span></p>
<h1>Some ChucK Places</h1>
<p>Here are the many homes for ChucK:</p>
<p><strong>ChucK home page (Princeton):</strong></p>
<p><a href="http://en.flossmanuals.net/bin/view/ChucK/%20http://chuck.cs.princeton.edu/%20"></a><a href="http://chuck.cs.princeton.edu/" class="uri">http://chuck.cs.princeton.edu/</a></p>
<p><strong>ChucK home page (Stanford):</strong></p>
<p><a href="http://en.flossmanuals.net/bin/view/ChucK/%20http://chuck.stanford.edu/%20"></a><a href="http://chuck.stanford.edu/" class="uri">http://chuck.stanford.edu/</a></p>
<p><strong>ChucK Documentation + Tutorials:</strong></p>
<p><a href="http://en.flossmanuals.net/bin/view/ChucK/%20http://chuck.cs.princeton.edu/doc/%20"></a><a href="http://chuck.cs.princeton.edu/doc/" class="uri">http://chuck.cs.princeton.edu/doc/</a></p>
<p><strong>For the most updated tutorial:</strong></p>
<p><a href="http://en.flossmanuals.net/bin/view/ChucK/%20http://chuck.cs.princeton.edu/doc/learn/%20"></a><a href="http://chuck.cs.princeton.edu/doc/learn/" class="uri">http://chuck.cs.princeton.edu/doc/learn/</a></p>
<p><strong>For the ideas and design behind ChucK, read the papers at:</strong></p>
<p><a href="http://chuck.cs.princeton.edu/doc/publish/%20">http://chuck.cs.princeton.edu/doc/publish/</a></p>
<p><strong>ChucK PhD Thesis:</strong></p>
<p><a href="http://www.cs.princeton.edu/gewang/thesis.html%20">http://www.cs.princeton.edu/gewang/thesis.html</a></p>
<p><strong>ChucK Community:</strong></p>
<p><a href="http://en.flossmanuals.net/bin/view/ChucK/%20http://chuck.cs.princeton.edu/community/%20"></a><a href="http://chuck.cs.princeton.edu/community/" class="uri">http://chuck.cs.princeton.edu/community/</a></p>
<p><strong>ChucK Wiki:</strong></p>
<p><a href="http://chuck.cs.princeton.edu/wiki%20">http://chuck.cs.princeton.edu/wiki</a></p>
<p><strong>miniAudicle:</strong></p>
<p><a href="http://audicle.cs.princeton.edu/mini/%20">http://audicle.cs.princeton.edu/mini/</a></p>
<p><strong>Audicle:</strong></p>
<p><a href="http://audicle.cs.princeton.edu/%20">http://audicle.cs.princeton.edu/</a></p>
<p><strong>Princeton Sound Lab:</strong></p>
<p><a href="http://soundlab.cs.princeton.edu/%20">http://soundlab.cs.princeton.edu/</a></p>
<p><strong>Stanford University,CCRMA:</strong></p>
<p><a href="http://en.flossmanuals.net/bin/view/ChucK/%20http://ccrma.stanford.edu/%20"></a><a href="http://ccrma.stanford.edu/" class="uri">http://ccrma.stanford.edu/</a></p>
<p><span id="ch003_authors.xhtml"></span></p>
<h1>Authors of ChucK</h1>
<h4>Originated by:</h4>
<ul>
<li>Ge Wang</li>
<li>Perry R. Cook  </li>
</ul>
<h4>Chief Architect and Designer:</h4>
<ul>
<li>Ge Wang</li>
</ul>
<h4>Lead Developers:</h4>
<ul>
<li>Ge Wang -- <a href="mailto:ge@ccrma.stanford.edu">ge@ccrma.stanford.edu</a>  ||  <a href="mailto:gewang@cs.princeton.edu">gewang@cs.princeton.edu</a></li>
<li>Perry R. Cook -- <a href="mailto:prc@cs.princeton.edu%20">prc@cs.princeton.edu</a><br />
</li>
<li>Spencer Salazar -- <a href="mailto:ssalazar@cs.princeton.edu">ssalazar@cs.princeton.edu</a></li>
<li>Rebecca Fiebrink -- <a href="mailto:fiebrink@cs.princeton.edu%20">fiebrink@cs.princeton.edu</a><br />
</li>
<li>Ananya Misra -- <a href="mailto:amisra@cs.princeton.edu%20">amisra@cs.princeton.edu</a><br />
</li>
<li>Philip Davidson -- <a href="mailto:philipd@alumni.princeton.edu%20">philipd@alumni.princeton.edu</a><br />
</li>
<li>Ari Lazier -- <a href="mailto:alazier@cs.princeton.edu">alazier@cs.princeton.edu</a> </li>
</ul>
<h4>Documentation:</h4>
<ul>
<li>Adam Tindale -- <a href="mailto:adam.tindale@acad.ca">adam.tindale@acad.ca</a><br />
</li>
<li>Ge Wang<br />
</li>
<li>Rebecca Fiebrink<br />
</li>
<li>Philip Davidson<br />
</li>
<li>Ananya Misra<br />
</li>
<li>Spencer Salazar<br />
</li>
</ul>
<h4>Lead Testers:</h4>
<ul>
<li>The ChucK Development/User Community -- <a href="http://chuck.cs.princeton.edu/community/" class="uri">http://chuck.cs.princeton.edu/community/</a><br />
</li>
<li>Ge Wang<br />
</li>
<li>Ajay Kapur -- <a href="mailto:akapur@alumni.princeton.edu%20">akapur@alumni.princeton.edu</a><br />
</li>
<li>Spencer Salazar<br />
</li>
<li>Philip Davidson<br />
</li>
</ul>
<h2>Thank You</h2>
<p>Many people have further contributed to ChucK by suggesting great new ideas and improvements, reporting problems, or submitting actual code. Here is a list of these people. Help us keep it complete and exempt of errors. </p>
<ul>
<li>Andrew Appel<br />
</li>
<li>Brian Kernighan<br />
</li>
<li>Paul Lansky<br />
</li>
<li>Roger Dannenberg<br />
</li>
<li>Dan Trueman<br />
</li>
<li>Ken Steiglitz<br />
</li>
<li>Max Mathews<br />
</li>
<li>Chris Chafe<br />
</li>
<li>Szymon Rusinkiewicz<br />
</li>
<li>Graham Coleman<br />
</li>
<li>Scott Smallwood<br />
</li>
<li>Mark Daly<br />
</li>
<li>Kassen<br />
</li>
<li>Kijjaz<br />
</li>
<li>Gary Scavone<br />
</li>
<li>Brad Garton<br />
</li>
<li>Nick Collins<br />
</li>
<li>Tom Briggs<br />
</li>
<li>Paul Calamia<br />
</li>
<li>Mikael Johanssons<br />
</li>
<li>Magnus Danielson<br />
</li>
<li>Rasmus Kaj<br />
</li>
<li>Princeton Graphics Group<br />
</li>
<li>Princeton Laptop Orchestra Stanford Laptop Orchestra<br />
</li>
<li>CCRMA community<br />
</li>
<li>Smule<br />
</li>
<li>ChucK users community!!! </li>
</ul>
<p><span id="ch004_installation.xhtml"></span></p>
<h1>Installation</h1>
<p>We tried to make ChucK as easy as possible to build (if desired), install, and re-use. All sources ﬁles - headers source for compiler, vm, and audio engine - are in the same directory. Platforms differences are abstracted to the lowest level (in part thanks to Gary Scavone). None of the compiler/vm has any OS-depedent code.</p>
<p>There are also pre-compiled executables available for OS X and Windows.</p>
<p>The classic ’chuck’ runs as a command line program. There are GUI-based integrated development and performance environments as well that can be used as standalone chuck virtual machines, or in conjunction with the command version of ’chuck’. GUI-based environments include the miniAudicle (<a href="http://audicle.cs.princeton.edu/mini" class="uri">http://audicle.cs.princeton.edu/mini</a>). This section deals mainly with the classic, command-line version of chuck.</p>
<h2>Binary Installation</h2>
<p>The binary distributions include a directory called bin/ that contains the precompiled binary of ChucK for your operating system. The binary distribution is a great way to dive into ChucK.</p>
<h3>OSX</h3>
<ol>
<li><p>The terminal is located in the Utilities/ folder in the Applications/ folder of your hard drive. Open terminal (create a shortcut to it in the dock if you want, since we will be using it a lot with the command-line chuck). In the terminal go to the bin/ directory (replace chuck-x.x.x.x-exe with the actual directory name):</p>
<pre><code>%&gt;cd chuck-x.x.x.x-exe/bin</code></pre></li>
<li><p>Install it using the following command.</p>
<pre><code>%&gt;sudo cp chuck /usr/bin/ </code></pre>
<p>(enter password when prompted)</p>
<pre><code>%&gt;sudo chmod 755 /usr/bin/chuck </code></pre>
<p>Now you should be able to run ’chuck’ from any directory.<br />
</p></li>
</ol>
<h3>Windows</h3>
<ol>
<li>Place chuck.exe (found in the 'bin' folder) into c:windowssystem32</li>
<li>Open a command window found in start - run<br />
<img src="static/ChucK-startmenu-en.jpg" alt="startmenu.jpg" width="379" height="237" /></li>
<li>Type cmd and press return<br />
<img src="static/ChucK-cmd-en.jpg" alt="cmd.jpg" width="347" height="186" /></li>
<li><p>Type chuck and press return, you should see:</p>
<pre><code>chuck [chuck]: no input files... (try --help)</code></pre></li>
</ol>
<h2>Source Installation</h2>
<p>To build chuck from the source (Windows users: it’s possible to build ChucK from both Visual<br />
C++ 6.0 and from cygwin - this section describes the cygwin build):</p>
<ol>
<li><p>Go to the src/ directory (replace chuck-x.x.x.x with the actual directory name):</p>
<pre><code>%&gt;cd chuck-x.x.x.x/src/</code></pre></li>
<li><p>If you type 'make' here, you should get the following message: %&gt;make [chuck] : please use one of the following conﬁgurations: make osx, make osx-ub, make win32, make linux-oss, make linux-alsa, make linux-jack Now, type the command corresponding to your platform... for example, for MacOS X (universal binary):</p>
<pre><code>%&gt;make osx-ub</code></pre>
<p>for example, for MacOS X (current):</p>
<pre><code>%&gt;make osx</code></pre>
<p>for example, for Windows (under cygwin):</p>
<pre><code>%&gt;make win32</code></pre></li>
<li><p>If you would like to install chuck (cp into /usr/bin by default). If you don't like the destination, edit the makefile under `install', or skip this step altogether. (we recommend putting it somewhere in your path, it makes on-the-fly programming easier)</p>
<pre><code># (optional: edit the makeﬁle ﬁrst)
%&gt;make install</code></pre>
<p>You may need to have administrator privileges in order to install ChucK. If you have admin access then you can use the sudo command to install.</p>
<pre><code>%&gt;sudo make install</code></pre></li>
<li><p>If you haven't gotten any egregious error messages up to this point, then you should be done! There should be a `chuck' executable in the current directory. For a quick sanity check, execute the following (use `./chuck' if chuck is not in your path), and see if you get the same output:</p>
<pre><code>%&gt;chuck [chuck]: no input ﬁles...</code></pre>
<p>(if you do get error messages during compilation, or you run into some other problem - please let us know and we will do our best to provide support)</p></li>
</ol>
<p>You are ready to ChucK. If this is your first time programming in ChucK, you may want to look at the documentation, or take the ChucK Tutorial (<a href="http://chuck.cs.princeton.edu/doc" class="uri">http://chuck.cs.princeton.edu/doc</a>). Thank you very much. Go forth and ChucK - email us for support or to make a suggestion or to call us idiots.</p>
<p>Ge + Perry</p>
<h3>Linux building and dependencies</h3>
<h4>Compiling ChucK &amp; miniAudicle on Fedora 10, Planet CCRMA</h4>
<p>(as root)</p>
<pre><code>yum install bison flex libsndfile-devel gcc gcc-c++</code></pre>
<p>for alsa:</p>
<pre><code>yum install alsa-lib-devel</code></pre>
<p>for jack:</p>
<pre><code>yum install jack-audio-connection-kit-devel</code></pre>
<p>then in src directory, type</p>
<pre><code> make linux-alsa or make linux-jack</code></pre>
<p>for miniAudicle, add this:</p>
<pre><code>yum install wxGTK-devel</code></pre>
<p>then</p>
<pre><code> make linux-alsa or make linux-jack</code></pre>
<p>the miniAudicle executable file will be in wxw directory, which you may copy to /usr/bin</p>
<h4>Compiling ChucK &amp; miniAudicle on Ubuntu 9.10</h4>
<p>Get the following packages from Syntaptic package manager;</p>
<ul>
<li>build-essential</li>
<li>bison</li>
<li>flex<br />
</li>
<li>libsndfile-dev<br />
</li>
<li>libasound-dev (if you're compiling for ALSA)<br />
</li>
<li><p>libjack-dev (if you're compiling for JACK)</p>
<p>For miniAudicle, you'll also need</p>
<ul>
<li>libwxgtk2.8-dev</li>
</ul>
<p>To compile ChucK; From the source code's src folder, use</p>
<pre><code>make linux-alsa</code></pre>
<p>if you need alsa or</p>
<pre><code>make linux-jack</code></pre>
<p>if you need a jack version.</p>
<p>to install;</p>
<pre><code>sudo make install</code></pre>
<p>or manually copy to /usr/bin</p>
<p>To compile miniAudicle From the source code folder, use;</p>
<pre><code> make linux-alsa</code></pre>
<p>or</p>
<pre><code>make linux-jack</code></pre>
<p>The resulting executable will be miniAudicle in the wxw folder. It may be moved to /usr/bin for running it from anywhere easily. Instructions for building on Linux adapted from a forum post by Kijjaz.<br />
</p></li>
</ul>
<p><span id="ch006_hello-chuck.xhtml"></span></p>
<h1>Hello ChucK<br />
</h1>
<p><em>This tutorial was written for the command line version of ChucK (currently the most stable and widely supported). Other ways of running ChucK include using the miniAudicle (<a href="http://audicle.cs.princeton.edu/mini/">download and documentation</a>) and the Audicle (in pre-pre-alpha).  The ChucK code is the same, but the way to run them differs, depending the ChucK system.</em><br />
<br />
The first thing we are going to do is do generate a sine wave and send it to the speaker so we can hear it. We can do this easily in ChucK by connecting audio processing modules (unit generators) and having them work together to compute the sound.</p>
<p>We start with a blank ChucK program and add the following line of code:</p>
<pre><code>// connect sine oscillator to D/A convertor (sound card)
SinOsc s =&gt; dac;</code></pre>
<p>NOTE: by default, a ChucK program starts executing from the first instruction in the top-level (global) scope.</p>
<p>The above does several things:</p>
<ol>
<li>It creates a new unit generator of type `SinOsc' (sine oscillator), and stores its reference in variable `s'.</li>
<li>`dac' (D/A convertor) is a special unit generator (created by the system) which is our abstraction for the underlying audio interface. </li>
<li>We are using the ChucK operator () to ChucK `s' to `dac'. In ChucK, when one unit generator is ChucKed to another, we connect them. We can think of this line as setting up a data flow from `s', a signal generator, to `dac', the sound card/speaker. Collectively, we will call this a `patch'.<br />
</li>
</ol>
<p>The above is a valid ChucK program, but all it does so far is make the connection -- if we ran this program, it would exit immediately. In order for this to do what we want, we need to take care of one more very important thing: time. Unlike many other languages, we don't have to explicitly say &quot;play&quot; to hear the result. In ChucK, we simply have to &quot;allow time to pass&quot; for data to be computed. As we will see, time and audio data are both inextricably related in ChucK (as in reality), and separated in the way they are manipulated. But for now, let's generate our sine wave and hear it by adding one more line:</p>
<pre><code>// connect sine oscillator to D/A convertor (sound card)
SinOsc s =&gt; dac;
// allow 2 seconds to pass
2::second =&gt; now;</code></pre>
<p>Let's now run this (assuming you saved the file as `foo.ck'):</p>
<pre><code>chuck foo.ck</code></pre>
<p>This would cause the sound to play for 2 seconds (the :: operator simply multiplies the arguments), during which time audio data is processed (and heard), after which the program exits (since it has reached the end). For now, we can just take the second line of code to mean ``let time pass for 2 seconds (and let audio compute during that time)''. If you want to play it indefinitely, we could write a loop:</p>
<pre><code>// connect sine oscillator to D/A convertor (sound card) SinOsc s =&gt; dac;
// loop in time
while( true ){
  2::second =&gt; now;
}</code></pre>
<p>In ChucK, this is called a `time-loop' (in fact this particular one is an `infinite time loop'). This program executes (and generate/process audio) indefinitely. Try running this program.</p>
<p>IMPORTANT: perhaps more important than how to run ChucK is how to stop ChucK.  To stop a ongoing ChucK program from the command line, hit (ctrl  c).</p>
<p>So far, since all we are doing is advancing time; it doesn't really matter (for now) what value we advance time by - (we used 2::second here, but we could have used any number of `ms', `second', `minute', `hour', `day', and even `week'), and the result would be the same. It is good to keep in mind from this example that almost everything in ChucK happens naturally from the timing.</p>
<p>Now, let's try changing the frequency randomly every 100ms:</p>
<pre><code>// make our patch
SinOsc s =&gt; dac;
// time-loop, in which the Osc’s frequency is changed every 100 ms
while( true ) {
  100::ms =&gt; now;
  Std.rand2f(30.0, 1000.0) =&gt; s.freq;
}</code></pre>
<p>This should sound like computer mainframes in old sci-fi movies. Two more things to note here. (1) We are advancing time inside the loop by 100::ms durations. (2) A random value between 30.0 and 1000.0 is generated and 'assigned' to the oscillator's frequency, every 100::ms.</p>
<p>Go ahead and run this (again replace foo.ck with your filename):</p>
<pre><code>chuck foo.ck</code></pre>
<p>Play with the parameters in the program. Change 100::ms to something else (like 50::ms or 500::ms, or 1::ms, or 1::samp(every sample)), or change 1000.0 to 5000.0.</p>
<p>Run and listen:</p>
<pre><code>chuck foo.ck</code></pre>
<p>Once things work, hold on to this file - we will use it again soon.<br />
<br />
Concurrency in ChucK:<br />
</p>
<p>Now let's write another (slightly longer) program:</p>
<pre><code>// impulse to filter to dac
Impulse i =&gt; BiQuad f =&gt; dac;
// set the filter’s pole radius
.99 =&gt; f.prad;
// set equal gain zero’s
1 =&gt; f.eqzs;
// initialize float variable
0.0 =&gt; float v;
// infinite time-loop
while( true ) {
  // set the current sample/impulse
  1.0 =&gt; i.next;
  // sweep the filter resonant frequency
  Std.fabs(Math.sin(v)) * 4000.0 =&gt; f.pfreq;
  // increment v
  v + .1 =&gt; v;
  // advance time
  100::ms =&gt; now;
}</code></pre>
<p>Name this moe.ck, and run it:</p>
<pre><code>%&gt;chuck moe.ck</code></pre>
<p>Now, make two copies of moe.ck - larry.ck and curly.ck. Make the following modifications:<br />
</p>
<ol>
<li>Change larry.ck to advance time by 99::ms (instead of 100::ms)</li>
<li>Change curly.ck to advance time by 101::ms (instead of 100::ms)</li>
<li>Optionally, change the 4000.0 to something else (like 400.0 for curly)<br />
</li>
</ol>
<p>Run all three in parallel:</p>
<pre><code>%&gt;chuck moe.ck larry.ck curly.ck</code></pre>
<p>What you hear (if all goes well) should be 'phasing' between moe, larry, and curly, with curly emitting the lower-frequency pulses.<br />
<br />
ChucK supports sample-synchronous concurrency via the ChucK timing mechanism. Given any number of source files that uses the timing mechanism above, the ChucK VM can use the timing information to automatically synchronize all of them. Furthermore, the concurrency is 'sample-synchronous', meaning that inter-process audio timing is guaranteed to be precise to the sample. The audio samples generated by our three stooges in this examples are completely synchronized. Note that each process do not need to know about each other - it only has to deal with time locally. The VM will make sure things happen correctly and globally.<br />
</p>
<p><span id="ch007_conventions.xhtml"></span></p>
<h1>Conventions</h1>
<p>ChucK is supported under many different operating systems. While ChucK code is intended to be truly ”platform-independent”, each different OS has their own “features” that make the experience of working with ChucK slightly different. This chapter will outline some of these differences. ChucK is used as a terminal application in this tutorial, so you will need to know how to access and navigate in the terminal.</p>
<p>Here are some hints about getting started with the terminal on your operating system.</p>
<h2><span id="ch007_conventions.xhtml#OS%20X"></span> OS X</h2>
<p>The terminal is located in the Utilities/ folder in the Applications/ folder of your hard drive. Double click on Terminal. You can click and hold on the icon in the Dock and select the “Keep in Dock” option. Now the Terminal application will be conveniently located in the Dock.</p>
<p><a href="http://www.macdevcenter.com/pub/ct/51%20">http://www.macdevcenter.com/pub/ct/51</a></p>
<p><a href="http://www.atomiclearning.com/macosxterminalx.shtml%20">http://www.atomiclearning.com/macosxterminalx.shtml</a></p>
<h2><span id="ch007_conventions.xhtml#Windows"></span> Windows</h2>
<p>The terminal is accessed by clicking on the Start Menu and then clicking on run. In the window that opens type cmd.</p>
<p><a href="http://www.c3scripts.com/tutorials/msdos/" class="uri">http://www.c3scripts.com/tutorials/msdos/</a></p>
<p><a href="http://www.ss64.com/nt/" class="uri">http://www.ss64.com/nt/</a></p>
<h2><span id="ch007_conventions.xhtml#Linux"></span> Linux</h2>
<p>No hints needed here.</p>
<p><span id="ch008_on-the-fly-programming.xhtml"></span></p>
<h1>On-the-ﬂy programming</h1>
<p>by Adam Tindale</p>
<p>Navigate to the examples folder in the ChucK distribution then run the following command:</p>
<pre><code>%&gt;chuck moe.ck</code></pre>
<p>In this case, ChucK will run whatever is in moe.ck. You can replace moe.ck with the name of<br />
another ChucK ﬁle. If this script is a just a loop that never ends then we need to stop ChucK<br />
eventually. Simply press CTRL-C (hold control and press c). This is the ”kill process” hotkey in<br />
the terminal.<br />
Some ﬁrst things to try is to test the concurrency (running multiple ChucK ﬁles in parallel) are<br />
moe, larry, and curly. First, run them each individually ( run chuck on moe.ck, larry.ck, or<br />
curly.ck as shown above). Then, run them all in parallel, like this:</p>
<pre><code>%&gt;chuck moe.ck larry.ck curly.ck</code></pre>
<p>They are written to go in and out of phase with each other. Again, if any of these scripts will go<br />
on forever then you have to use CTRL-C to halt ChucK. Give it a try.<br />
Also try the improved versions of our little friends: larry++.ck curly++.ck moe++.ck</p>
<h2>Two Window ChucK</h2>
<p>Now lets roll up our sleeves a little bit and see some real ChucK power! We are going to run two window ChucK, and on-the-ﬂy! This section will walk you through a ChucK session.</p>
<p><img src="static/ChucK-2term_600wide-en.png" alt="2term_600wide.png" width="600" height="234" /></p>
<p>Here is what you do: open another terminal window just like this one. In this new window type:</p>
<pre><code>%&gt;chuck --loop</code></pre>
<p>This will start ChucK running. ChucK is now waiting for something to do. Go back to your original window where you are in your ChucK home. Be careful. If you type chuck test1.ck you will start a second ChucK running test1.ck. What we want to do is add a script to the ChucK that we set running in our second window. We will use the + operator to add a script to our ChucK and the - operator to remove a script.</p>
<pre><code>%&gt;chuck + test1.ck
%&gt;chuck - 1
%&gt;chuck test.ck
%&gt;chuck test.ck
%&gt;chuck test.ck</code></pre>
<p>What happened? That is the power of on-the-ﬂy programming. We added test1.ck. It was added as the ﬁrst shred in our ChucK. Since we knew it was shred 1 we removed it by typing chuck - 1. Great. Next we added three copies of the same script! Isn’t that cool? You can also do this chuck + test1.ck test1.ck test1.ck How do you keep track of shreds?</p>
<p>You can ask ChucK how he is doing by typing chuck --status The shortcut is chuck ˆ ChucK will answer in the other window where we left him running. He will tell you what shreds there are and what their id numbers are. He will also tell you how long he has been running.</p>
<p>When you have had enough of ChucK you can go to the other window and use your fancy CTRL-C trick or you can type chuck - -kill in your original window.</p>
<pre><code>%&gt;chuck --kill</code></pre>
<h2>One Window ChucK</h2>
<p>So you think you're pretty good? One window ChucK is only for the hardest of hardcore.1 You have been warned.</p>
<p>The concept is pretty similar to two window ChucK: ﬁrst, you start a ChucK going, then you manage the adding and removal of scripts to it. How do you start a ChucK and get the command prompt to return, you ask? In your shell you can add an ampersand (&amp;) after the command and that will tell the shell to run the command as a background process and give you the prompt back.</p>
<pre><code>%&gt;chuck --loop &amp;</code></pre>
<p>The rest is as it should be. You will have to be careful when writing your patches to not put too many print statements. When you print you will temporarily lose control of the prompt as the shell prints. This can be bad when are you are printing MIDI input. The same applies when you use the --status command to ChucK. It can also be fun to ﬁght for your command line. Who will win?</p>
<p>Note that the &quot;&amp;&quot; sytax is part of UNIX terminals like BASH, as found on Linux and OSX, and not a part of the MS Windows prompt.</p>
<p><span id="ch009_modifying-basic-patches.xhtml"></span></p>
<h1>Modifying Basic Patches</h1>
<p>by Adam Tindale</p>
<p>We have a basic patch running in ChucK but it still doesn’t sound very good. In this chapter we will cover some simple ways to rectify that problem. ChucK allows one to quickly make modiﬁcations to patches that can drastically change the sound.</p>
<p>First what we can do is change the type of our oscillator. There are many different oscillators available to use: SinOsc (sine wave), SawOsc (sawtooth), SqrOsc (square wave) and PulseOsc (pulse wave). We can simply change the type of oscillator just like below.</p>
<pre><code>SawOsc s =&gt; dac;</code></pre>
<p>Try changing the oscillator to all of the different types and a get a feel for how they sound. When changing the different Ugens always be sure to check the rest of your patches so that the parameter calls are valid. If you were to use the <strong>.width</strong> method of PulseOsc and others on a SinOsc ChucK will complain. You can comment out lines that are temporarily broken by using double slashes (//).</p>
<p>Now let’s add some effects to our patch. ChucK has many different standard effects that can be added to Ugen chains. The simplest effect we can add is an ampliﬁer. In ChucK, this object is <strong>Gain</strong>.</p>
<pre><code>SawOsc s =&gt; Gain g =&gt; dac;</code></pre>
<p>Now we can change the parameters of our effect. Gain has a parameter <strong>.gain</strong> that can be used to change the gain of signals passing through the object. Let’s go about changing the gain.</p>
<pre><code>.5 =&gt; g.gain;</code></pre>
<p>This is redundant. All Ugens have the ability to change their gain in a similar manner. (See the UGEN section in Reference for more information about UGEN parameters.)</p>
<pre><code>.5 =&gt; s.gain;</code></pre>
<p>However, this is useful when we have multiple Ugens connect to one place. If we were to connect 2 oscillators to the <strong>dac</strong> then we will get distortion. By default, these oscillators oscillate between -1 and 1. When they are connected to the same input they are added, so now they go between -2 and 2. This will clip our output. What to do? <strong>Gain</strong> to the rescue!</p>
<pre><code>SinOsc s1 =&gt; Gain g =&gt; dac; 
SinOsc s2 =&gt; g; 
.5 =&gt; g.gain;</code></pre>
<p>Now our oscillators are scaled between -1 and 1 and everything is right in the world.</p>
<p>More effects were promised, now you will see some in action. Again, one of the wonders of ChucK is how easy it is to change Ugens. We can take the above patch and change ‘Gain’ for ‘PRCRev’.</p>
<pre><code>SinOsc s1 =&gt; PRCRev g =&gt; dac; 
SinOsc s2 =&gt; g; 
.5 =&gt; g.gain; </code></pre>
<p>The Gain Ugen has been replaced by a reverb and the output is scaled by using the ‘.gain’ parameter that all Ugens posess. Now we can add a few spices to the recipe. ‘PRCRev’ has a ‘.mix’ parameter that can be changed between 0. and 1. If we wanted to have this parameter set to the same value as what we are ChucKing to g.gain we can chain it along. After assignment a Ugen will return the value that was ChucKed to it. We can use this method to propogate paramters to our oscillators.</p>
<pre><code>.5 =&gt; g.gain =&gt; g.mix; 
500 =&gt; s1.freq =&gt; s2.freq;</code></pre>
<p>Another technique for setting parameters is to read a parameter, then modify it and then ChucK it back to itself. Accessing parameters requires the addition of brackets () after the name of the parameter. Here is an example of doubling the frequency of an oscillator.</p>
<pre><code>s1.freq() * 2 =&gt; s1.freq;</code></pre>
<p>Let’s change the type of oscillators for some more fun. We can simply replace ‘SinOsc’ with any other type of oscillator. Check the Ugen section in the reference for ideas. Try changing the frequency of the oscillators and the mix parameter of the reverb for each type of oscillator you try. Endless fun!</p>
<p><span id="ch010_lfos-and-blackholes.xhtml"></span></p>
<h1>LFOs and Blackholes</h1>
<p>by Adam Tindale</p>
<p>A common technique to add variation to synthesis is modulation. Modulation is the process of changing something, usually the parameter of a signal like frequency. A Low Frequency Oscillator (LFO) is typically used for this task because the variations are fast enough to be interesting, yet slow enough to be perceptible. When a signal is modulated quickly (ie. over 20Hz or so) it tends to alter the timbre of the signal rather than add variation.</p>
<p>Ok, let’s use this idea. What we need to do is set up two oscillators and have one modulate a parameter of another. ChucK does not support the connection of Ugen signal outputs to parameter inputs. This piece of code will not work:</p>
<pre><code>SinOsc s =&gt; dac;
SinOsc lfo =&gt; s.freq;</code></pre>
<p>Foiled. What we need to do is poll our lfo at some rate that we decide on, for now we will update the frequency of s every 20 milliseconds. Remember that a SinOsc oscillates between -1 and 1, so if we just put that directly to the frequency of s we wouldn’t be able to hear it (unless you are using ChucK in a tricked out civic). What we are going to do is multiply the output of the lfo by 10 and add it to the frequency 440. The frequency will now oscillate between 430 and 450.</p>
<pre><code>SinOsc s =&gt; dac;
SinOsc lfo;
// set the frequency of the lfo
5 =&gt; lfo.freq;
while (20::ms =&gt; now)
{
     ( lfo.last() * 10 ) + 440 =&gt; s.freq;
}</code></pre>
<p>ChucK is a smart little devil. This didn’t work and now we will look into the reason. Why? Ugens are connected in a network and usually passed to the <strong>dac</strong>. When a patch is compiled ChucK looks at what is connected to the dac and as each sample is computed ChucK looks through the network of Ugens and grabs the next sample. In this case, we don’t want our Ugen connected to the <strong>dac</strong>, yet we want ChucK to grab samples from it. Enter blackhole: the sample sucker. If we connect our lfo to blackhole everything will work out just ﬁne.</p>
<pre><code>SinOsc lfo =&gt; blackhole;</code></pre>
<p>Play around with this patch in its current form and ﬁnd interesting values for the poll rate, lfo frequency and the lfo amount. Try changing the Ugens around for more interesting sounds as well.</p>
<p><span id="ch011_working-with-midi.xhtml"></span></p>
<h1>Working with MIDI</h1>
<p>by Adam Tindale</p>
<p>Adding a MIDI controller is a great way to add variety to your ChucK patches. Conversely, ChucK offers a simple and powerful way to utilize a MIDI controller for making music.</p>
<p>The ﬁrst thing to do when working with MIDI is to make sure that ChucK sees all of your devices. You can do this by using the --probe start ﬂag. Like this:</p>
<pre><code>%&gt;chuck --probe</code></pre>
<p>ChucK will display a list of the connected audio and MIDI devices and their reference ID. We will assume that your controller is found to have and ID of 0. First, we must open a connection between ChucK and the port. We can accomplish this by creating a <strong>MidiIn</strong> object and then connecting it to a port.</p>
<pre><code>//create object
MidiIn min;

//connect to port 0
min.open(0);</code></pre>
<p>If you want to send MIDI out of ChucK you use the <strong>MidiOut</strong> object and then open a port.</p>
<pre><code>//create object
MidiOut mout;

//connect to port 0
mout.open(0);</code></pre>
<p>When opening ports it is suggested that you check whether the <strong>.open</strong> function returns properly. In some situations it doesn’t make any sense for the shred to live on if there is no MIDI data available to be sent along. You can check the return value of the <strong>.open</strong> function and then exit the shred using the <strong>me</strong> keyword with the <strong>exit()</strong> function.</p>
<pre><code>MidiIn min;
min.open( 0 ) =&gt; int AmIOpen;

if( !AmIOpen ) { me.exit(); }</code></pre>
<p>We can do this in fewer lines of code. We can put the min.open(0) in the condition of the if statement. This way min.open will return true or false (which is represented as ints with a value of 1 or 0). The ! will give the opposite return value of min.open. Now the statement will mean if min.open doesn’t return true then exit. Yeah?</p>
<pre><code>if( !min.open(0) ) { me.exit(); }</code></pre>
<h2>Getting MIDI</h2>
<p>In order to receive any of the juicy data you are piping into ChucK we need to ceate a MidiMsg ob ject. This ob ject is used to hold data that can be input into ChucK or output to a MIDI port. Unless you are high skilled at managing the state of these messages (or you enjoy the headache you get from debugging) it is recommended that you create a minimum of one MidiMsg for each port you are using.</p>
<p>What we need to do is get the data from the MidiIn ob ject into a message that we can use inside of ChucK. The MidiMsg ob ject is just a container with three slots: data1, data2 and data3. We ﬁll these slots up by putting our message in the <strong>.recv( MidiMsg )</strong> function of a MidiIn object. MidiIn keeps its messages in a queue so that you can poll it for messages and it will keep giving messages until it is empty. The <strong>.recv( MidiMsg )</strong> function returns true and false so we can put it in a while loop and it will continue to run through the loop until there are no more messages left.</p>
<pre><code>// check for messages every 10 milliseconds
while(10::ms =&gt; now){
  while( min.recv(msg) ){
    &lt;&lt;&lt;msg.data1,msg.data2,msg.data3,&quot;MIDI Message&quot;&gt;&gt;&gt;;
  }
}</code></pre>
<p>The Event system makes life a little easier and also makes sure that MIDI input is dealt with as soon as ChucK receives it. All that has to be done is to ChucK the MidiIn object to <strong>now</strong> and it will wait until a message is received to go further in the program.</p>
<pre><code>while(true){
  // Use the MIDI Event from MidiIn
  min =&gt; now;
  while( min.recv(msg) ){
    &lt;&lt;&lt;msg.data1,msg.data2,msg.data3,&quot;MIDI Message&quot;&gt;&gt;&gt;;
  }
}</code></pre>
<h2>Midi Output</h2>
<p>If you have a synthesizer that you want to trigger from ChucK you can send MIDI messages to it simply. All you have to do is have a MidiMsg that will serve as the container for your data and then you will hand it to MidiOut using the <strong>.send( MidiMsg )</strong> function.</p>
<pre><code>MidiOut mout;
MidiMsg msg;
// check if port is open
if( !mout.open( 0 ) ) me.exit();

// fill the message with data
144 =&gt; msg.data1;
52 =&gt; msg.data2;
100 =&gt; msg.data3;
// bugs after this point can be sent
// to the manufacturer of your synth
mout.send( msg );</code></pre>
<p><span id="ch012_writing-to-disk.xhtml"></span></p>
<h1>Writing to Disk</h1>
<p>by Adam Tindale and Ge Wang</p>
<h2>Recording your ChucK session to ﬁle is easy!</h2>
<p>Say you want to record the output of the following:</p>
<pre><code>%&gt;chuck foo.ck bar.ck</code></pre>
<p>All you have to do is ChucK a shred that writes to ﬁle:</p>
<pre><code>%&gt;chuck foo.ck bar.ck rec.ck</code></pre>
<p>No changes to existing ﬁles are necessary. An example rec.ck can be found in examples/basic/, this guy/gal writes to “foo.wav”. Edit the ﬁle to change the output file. If you don’t want to worry about overwriting the same ﬁle everytime, you can substitute rec.ck for rec-auto.ck:</p>
<pre><code>%&gt;chuck foo.ck bar.ck rec-auto.ck</code></pre>
<p>rec-auto.ck will generate a ﬁle name using the current time. You can change the preﬁx of the ﬁlename by modifying</p>
<pre><code>&quot;data/session&quot; =&gt; w.autoPrefix;</code></pre>
<p>w is the WvOut in the patch.</p>
<p>Oh yeah, you can of course chuck rec.ck on-the-ﬂy.</p>
<p>From terminal 1</p>
<pre><code>%&gt;chuck --loop</code></pre>
<p>From terminal 2</p>
<pre><code>%&gt;⁞chuck + rec.ck</code></pre>
<h2>Silent Mode</h2>
<p>You can write directly to disk without having real-time audio by starting your programs using the --silent or -s flag.<br />
</p>
<pre><code>%&gt;chuck foo.ck bar.ck rec2.ck -s</code></pre>
<p>This will not synchronize to the audio card, and will generate samples as fast as it can.</p>
<h2>Start and Stop<br />
</h2>
<p>You can start and stop the writing to ﬁle by:<br />
</p>
<pre><code>1 =&gt; w.record; // start
0 =&gt; w.record; // stop</code></pre>
<p>As with all things ChucKian, this can be done sample-synchronously.<br />
</p>
<h2>Another halting problem</h2>
<p>What if I have inﬁnite time loop, and want to terminate the VM, will my ﬁle be written out correctly? the answer: Ctrl-C works just ﬁne.<br />
</p>
<p>ChucK STK module keeps track of open ﬁle handles and closes them even upon abnormal termination, like Ctrl-C. Actually for many, Ctrl-C is the natural way to end your ChucK session. At any rate, this is quite ghetto, but it works. As for seg-faults and other catastrophic events, like computer catching on ﬁre from ChucK exploding, the ﬁle probably is toast.<br />
</p>
<p>hmmmm, toast...<br />
</p>
<h2>The Silent Sample Sucker Strikes Again<br />
</h2>
<p>As in rec.ck, one patch to write to ﬁle is:<br />
</p>
<pre><code>dac =&gt; Gain g =&gt; WvOut w =&gt; blackhole;</code></pre>
<p>The WvOut writes to ﬁle, and also pass through the incoming samples.<br />
</p>
<p><span id="ch013_stereo.xhtml"></span></p>
<h1>Stereo</h1>
<p>by Adam Tindale</p>
<p>Accessing the stereo capabilities of ChucK is relatively simple. <strong>dac</strong> has three access points.</p>
<pre><code>UGen u;
// standard mono connection
u =&gt; dac;
// access stereo halves
u =&gt; dac.left;
u =&gt; dac.right;</code></pre>
<p><strong>adc</strong> functionality mirrors dac.</p>
<pre><code>// this reverses the stereo image of adc
adc.right =&gt; dac.left;
adc.left =&gt; dac.right;</code></pre>
<p>If you have your great UGen network going and you want to throw it somewhere in the stereo ﬁeld you can use <strong>Pan2</strong>. You can use the <strong>.pan</strong> function to move your sound between left (-1) and right (1).</p>
<pre><code>// this is a stereo connection to the dac
SinOsc s =&gt; Pan2 p =&gt; dac;
1 =&gt; p.pan;
while(1::second =&gt; now){
  // this will flip the pan from left to right
  p.pan() * -1. =&gt; p.pan;
}</code></pre>
<p>You can also mix down your stereo signal to a mono signal using the <strong>Mix2</strong> object.</p>
<pre><code>adc =&gt; Mix2 m =&gt; dac.left;</code></pre>
<p>If you remove the <strong>Mix2</strong> in the chain and replace it with a <strong>Gain</strong> object it will act the same way. When you connect a stereo object to a mono object it will sum the inputs. You will get the same effect as if you connect two mono signals to the input of another mono signal.</p>
<h2>Multi Channel Audio</h2>
<p>Individual audio inputs and outputs on available hardware can be addressed using .chan(x).</p>
<p>Audio inputs and outputs are number from 0.</p>
<pre><code>//ChucK Audio input 0 to output 4
adc.chan(0) =&gt; dac.chan(4);</code></pre>
<p><span id="ch014_using-osc-in-chuck.xhtml"></span></p>
<h1>Using OSC in ChucK</h1>
<p>by Rebecca Fiebrink</p>
<h2>To send OSC</h2>
<p>Host Decide on a host to send the messages to. E.g., ”splash.local” if sending to computer named ”Splash,” or ”localhost” to send to the same machine that is sending.</p>
<p>Port Decide on a port to which the messages will be sent. This is an integer, like 1234.</p>
<p>Message ”address” For each type of message you’re sending, decide on a way to identify this type of message, formatted like a web URL e.g., ”conductor/downbeat/beat1” or ”Rebecca/message1”</p>
<p>Message contents Decide on whether the message will contain data, which can be 0 or more ints, ﬂoats, strings, or any combination of them.</p>
<p>To set up a OSC sender in ChucK you'll need code like the following:</p>
<pre><code>//Create an OscSend object:
OscSend xmit;
//Set the host and port of this object:
xmit.setHost(&quot;localhost&quot;, 1234);</code></pre>
<p>For every message you want to send, start the message by supplying the address and format of contents, where ”f” stands for ﬂoat, ”i” stands for int, and ”s” stands for string:</p>
<pre><code>//To send a message with no contents:
xmit.startMsg(&quot;conductor/downbeat&quot;);
//To send a message with one integer:
xmit.startMsg(&quot;conductor/downbeat, i&quot;);
//To send a message with a float, an int, and another float:
xmit.startMsg(&quot;conductor/downbeat, f, i, f&quot;);</code></pre>
<p>For every piece of information in the contents of each message, add this information to the message:</p>
<pre><code>//to add an int:
xmit.addInt(10);
//to add a float:
xmit.addFloat(10.);
//to add a string:
xmit.addString(&quot;abc&quot;);</code></pre>
<p>Once all parts of the message have been added, the message will automatically be sent.</p>
<h2>To receive OSC</h2>
<p>Decide what port to listen on. This must be the same as the port number of the sender(s) you want to listener to receive messages from. Message address and format of contents: This must also be the same as what the sender is using; i.e., the same as in the sender’s startMsg function.</p>
<p>The following code shows how to setting up an OSC receiver with ChucK.</p>
<pre><code>//Create an OscRecv object:
OscRecv orec;
//Tell the OscRecv object the port:
1234 =&gt; orec.port;
//Tell the OscRecv object to start listening for OSC messages on that port:
orec.listen(); </code></pre>
<p>For each type of message, create an event that will be used to wait on that type of message, using the same argument as the sender’s startMsg function:</p>
<pre><code>orec.event(&quot;conductor/downbeat, i&quot;) @=&gt; OscEvent myDownbeat;</code></pre>
<p>To wait on an OSC message that matches the message type used for a particular event e, do</p>
<pre><code>e =&gt; now;</code></pre>
<p>This is just like waiting for regular Events in ChucK.</p>
<p>To process the message first it's necessary to grab the message out of the queue. In our example this can be achieved using e.nextMsg(). After we called this, we can use other methods on e to get the information we're interested in out of the message. We must call these functions in order, according to the formatting string we set up above.</p>
<pre><code>e.getInt() =&gt; int i;
e.getFloat() =&gt; float f;
e.getString() =&gt; string s;</code></pre>
<p>If you expect you may receive more than one message for an event at once, you should process every message waiting in the cue:</p>
<pre><code>while (e.nextMsg() != 0) {
  //process message here (no need to call nextMsg again
} </code></pre>
<p><span id="ch016_overview.xhtml"></span></p>
<h1>Overview</h1>
<p>ChucK is a strongly-typed, strongly-timed, concurrent audio and multimedia programming language. It is compiled into virtual instructions, which is immediately run in the ChucK Virtual Machine. This guide documents the features of the Language, Compiler, and Virtual Machine for a ChucK programmer.</p>
<h2>Running ChucK</h2>
<p>Some quick notes:</p>
<ul>
<li>You can install ChucK (see build instructions) or run it from a local directory.</li>
<li>ChucK is a command line application called chuck. (also see the Audicle and the miniAudicle)</li>
<li>Use the command line prompt/terminal to run ChucK: (e.g. Terminal or xterm on OS X, cmd or cygwin on Windows, on Linux, you surely have your preferred terminal.)</li>
</ul>
<p>See VM options for a more complete guide to command line options.</p>
<p>To run ChucK with a program/patch called foo.ck simply run chuck and then the name of the ﬁle:</p>
<pre><code>%&gt;chuck foo.ck </code></pre>
<p>To run ChucK with multiple patches concurrently (or the same one multiple times):</p>
<pre><code>%&gt;chuck foo.ck bar.ck bar.ck boo.ck</code></pre>
<p>There are several ﬂags you can specify to control how ChucK operates, or to ﬁnd out about the system. For example,the following probes the audio system and prints out all available audio devices and MIDI devices. You may then refer to them (by number usually) from the command line or from your program (again, see VM Options for a complete list).</p>
<pre><code>%&gt;chuck --probe</code></pre>
<p>ChucK can be run in a different terminal as a host/listener that patches may be sent to. The server should invoke the --loop ﬂag to specify that the virtual machine should not halt automatically (when the current programs exit).</p>
<pre><code>%&gt;chuck --loop </code></pre>
<p>(See the guide to On-the-ﬂy Programming for more information)</p>
<p>If a ChucK listener is running, we can (from a second terminal) send a program/patch to to the listener by using the + command line option:</p>
<pre><code>%&gt;chuck + foo.ck</code></pre>
<p>Similarly, you can use - and = to remove/replace a patch in the listener, and use ˆ to ﬁnd out the status. Again, see On-the-ﬂy Programming for more information.</p>
<p>To run most of the code or examples in this language speciﬁcation, you only need to use the basic chuck program.</p>
<h2>Comments</h2>
<p>Comments are sections of code that are ignored by a compiler. These help other programmers (and yourself ) interpret and document your code. Double slashes indicate to the compiler to skip the rest of the line.</p>
<pre><code>// this is a comment
int foo; // another comment </code></pre>
<p>Block comments are used to write comments that last more than one line, or less than an entire line. A slash followed by an asterisk starts a block comment. The block comment continues until the next asterisk followed by a slash.</p>
<pre><code>/* this
is a
block
comment */
int /* another block comment */ foo;</code></pre>
<p>Comments can also be used to temporarily disable sections of your program, without deleting it entirely. ChucK code that is commented-out will be ignored by the compiler, but can easily be brought back if you change your mind later. In the following example, the PRCRev UGen will be ignored, but we could easily re-insert it by deleting the block comment delimiters.</p>
<pre><code>SinOsc s =&gt; /* PRCRev r =&gt; */ dac;</code></pre>
<h2>Debug Print</h2>
<p>ChucK currently lacks a comprehensive system for writing to ﬁles or printing to the console. In its place we have provided a debug print syntax:</p>
<pre><code>// prints out value of expression
&lt;&lt;&lt; expression &gt;&gt;&gt;;</code></pre>
<p>This will print the values and types of any expressions placed within them. This debug print construction may be placed around any non-declaration expression ( non l-value ) and will not affect the execution of the code. Expressions which represent an object will print the value of that object’s reference address:</p>
<pre><code>// assign 5 to a newly declared variable
5 =&gt; int i;

// prints &quot;5 : (int)&quot;
&lt;&lt;&lt;i&gt;&gt;&gt;;

// prints &quot;hello! : (string)&quot;
&lt;&lt;&lt;&quot;hello!&quot;&gt;&gt;&gt;; //prints &quot;hello! : (string)&quot;

// prints &quot;3.5 : (float)&quot;
&lt;&lt;&lt;1.0 + 2.5 &gt;&gt;&gt;=&gt; float x;</code></pre>
<p>For more formatted data output, a comma-separated list of expressions will print only their respective values (with one space between):</p>
<pre><code>// prints &quot;the value of x is 3.5&quot; (x from above)
&lt;&lt;&lt;&quot;the value of x is&quot; , x &gt;&gt;&gt;;

// prints &quot;4 + 5 is 9&quot;
&lt;&lt;&lt;&quot;4 + 5 is&quot;, 4 + 5&gt;&gt;&gt;;

// prints &quot;here are 3 random numbers ? ? ?&quot;
&lt;&lt;&lt;&quot;here are 3 random numbers&quot;,
Std.rand2(0,9),
Std.rand2(0,9),
Std.rand2(0,9) &gt;&gt;&gt;;</code></pre>
<h2>Reserved Words</h2>
<p>Primitive types</p>
<ul>
<li>int</li>
<li>ﬂoat</li>
<li>time</li>
<li>dur</li>
<li>void</li>
<li>same (unimplemented)</li>
</ul>
<p>Control structures</p>
<ul>
<li>if</li>
<li>else</li>
<li>while</li>
<li>until</li>
<li>for</li>
<li>repeat</li>
<li>break</li>
<li>continue</li>
<li>return</li>
<li>switch (unimplemented)</li>
</ul>
<p>Class keywords</p>
<ul>
<li>class</li>
<li>extends</li>
<li>public</li>
<li>static</li>
<li>pure</li>
<li>this</li>
<li>super (unimplemented)</li>
<li>interface (unimplemented)</li>
<li>implements (unimplemented)</li>
<li>protected (unimplemented)</li>
<li>private (unimplemented)</li>
</ul>
<p>Other ChucK keywords</p>
<ul>
<li>function</li>
<li>fun</li>
<li>spork</li>
<li>const</li>
<li>new</li>
</ul>
<p>Special values</p>
<ul>
<li>now</li>
<li>true</li>
<li>false</li>
<li>maybe</li>
<li>null</li>
<li>NULL</li>
<li>me</li>
<li>pi</li>
</ul>
<p>Special : Default durations</p>
<ul>
<li>samp</li>
<li>ms</li>
<li>second</li>
<li>minute</li>
<li>hour</li>
<li>day</li>
<li>week</li>
</ul>
<p>Special : Global UGens</p>
<ul>
<li>dac</li>
<li>adc</li>
<li>blackhole</li>
</ul>
<p>Operators</p>
<ul>
<li>+</li>
<li>-</li>
<li>*</li>
<li>/</li>
<li>%</li>
<li>=&gt;</li>
<li>=&lt;</li>
<li>!=&gt;</li>
<li>||</li>
<li>&amp;&amp;</li>
<li>==</li>
<li>∧</li>
<li>&amp;</li>
<li>|</li>
<li>˜</li>
<li>::</li>
<li>++</li>
<li>– –</li>
<li>&gt;</li>
<li>&gt;=</li>
<li>&lt;</li>
<li>&lt;=</li>
<li>@=&gt;</li>
<li>+=&gt;</li>
<li>-=&gt;</li>
<li>*=&gt;</li>
<li>/=&gt;</li>
<li>%=&gt;</li>
</ul>
<p><span id="ch017_the-chuck-compiler-and-virtual-machine.xhtml"></span></p>
<h1>The ChucK Compiler and Virtual Machine</h1>
<p>Let’s start with the compiler/virtual machine, both of which runs in the same process. By now, you should have built/installed ChucK (guide), and perhaps taken the tutorial. This guide is intended to be more complete and referential than the tutorial.</p>
<h2>Synposis (a man-esque page)</h2>
<p>Usage:</p>
<pre><code>chuck -- [ options|commands ] [ +-=ˆ] ﬁle1 ﬁle2 ﬁle3 ...
     [ options ] =halt|loop|audio|silent|dump|nodump|about|
          srate&lt;N&gt;|bufsize&lt;N&gt;|bufnum&lt;N&gt;|dac&lt;N&gt;|adc&lt;N&gt;|
          remote&lt;hostname&gt;|port&lt;N&gt;|verbose&lt;N&gt;|
          probe|remote&lt;hostname&gt;|port&lt;N&gt;
     [ commands ] =add|remove|replace|status|time|kill
     [ +-=ˆ] = shortcuts for add, remove, replace, status</code></pre>
<h2>Description</h2>
<p>ChucK can run 1 or more processes in parallel and interactively. The programmer only needs to specify them all on the command line, and they will be compiled and run in the VM. Each input source ﬁle (.ck suffix by convention) will be run as a separate ’shred’ (user-level ChucK threads) in the VM. They can ’spork’ additional shreds and interact with existing shreds. Thanks to the ChucK timing mechanism, shreds don’t necessarily need to know about each other in order to be precisely ’shreduled’ in time - they only need to keep track of their own time, so to speak.</p>
<p>Additionally, more shreds can be added/removed/replaced manually at run-time, using on-the-ﬂy programming [ Wang and Cook 2004 ] - (see publications and <a href="http://on-the-%EF%AC%82y.cs.princeton.edu/" class="uri">http://on-the-ﬂy.cs.princeton.edu/</a>).</p>
<h3>[ options ] :</h3>
<h4>--halt / -h</h4>
<p>(on by default) - tells the vm to halt and exit if there are no more shreds in the VM.</p>
<h4>--loop / -l</h4>
<p>Tells the ChucK VM to continue executing even if there no shreds currently in the VM. This is useful because shreds can be added later on-the-ﬂy. Furthermore, it is legal to specify this option without any input ﬁles. For example:</p>
<pre><code>%&gt;chuck --loop </code></pre>
<p>The above will ’inﬁnite time-loop’ the VM, waiting for incoming shreds.</p>
<h4>--audio / -a</h4>
<p>(on by default) - enable real-time audio output.</p>
<h4>--silent / -s</h4>
<p>Disable real-time audio output - computations in the VM is not changed, except that the actual timing is no longer clocked by the real-time audio engine. Timing manipulations (such as operations on ’now’) still function fully. This is useful for synthesizing audio to disk or network. Also, it is handy for running a non-audio program.</p>
<h4>--dump / +d</h4>
<p>dump the virtual instructions emitted to stderr, for all the ﬁles after this ﬂag on the command line, until a ’nodump’ is encountered (see below). For example:</p>
<pre><code>%&gt;chuck foo.ck +d bar.ck</code></pre>
<p>Will dump the virtual ChucK instructions for bar.ck (only), with argument values, to stderr. --dump can be used in conjunction with --nodump to selectively dump ﬁles.</p>
<h4>--nodump / -d</h4>
<p>(default state) cease the dumping of virtual instructions for ﬁles that comes after this ﬂag on the command line, until a ’dump’ is encountered (see above). For example:</p>
<pre><code>%&gt;chuck +d foo.ck -d bar.ck +d doo.ck</code></pre>
<p>Will dump foo.ck, then doo.ck - but not bar.ck.</p>
<p>These are useful to debug ChucK itself, and for other entertainment purposes.</p>
<h4>--srate(N)</h4>
<p>Set the internal sample rate to (N) Hz. by default, ChucK runs at 44100Hz on OS X and Windows, and 48000Hz on linux/ALSA. even if the VM is running in --silent mode, the sample rate is still used by some unit generaters to compute audio, this is important for computing samples and writing to ﬁle. Not all sample rates are supported by all devices!</p>
<h4>--bufsize(N)</h4>
<p>set the internal audio buffer size to (N) sample frames. larger buffer size often reduce audio artifacts due to system/program timing. smaller buffers reduce audio latency. The default is 512. If (N) is not a power of 2, the next power of 2 larger than (N) is used. For example:</p>
<pre><code>%&gt;chuck --bufsize950 </code></pre>
<p>sets the buffer size to 1024.</p>
<h4>--dac(N)</h4>
<p>Opens audio output device #(N) for real-time audio. by default, (N) is 0.</p>
<h4>--adc(N)</h4>
<p>Opens audio input device #(N) for real-time audio input. by default, (N) is 0.</p>
<h4>--chan(N) / -c(N)</h4>
<p>Opens N number of input and output channels on the audio device. by default, (N) is 2.</p>
<h4>--in(N) / -i(N)</h4>
<p>Opens N number of input channels on the audio device. by default (N) is 2.</p>
<h4>--out(N) -o(N)</h4>
<p>Opens N number of output channels on the audio device. by default (N) is 2.</p>
<h4>--about / --help</h4>
<p>Prints the usage message, with the ChucK URL</p>
<h4>--callback</h4>
<p>Utilizes a callback for buffering (default).</p>
<h4>--blocking</h4>
<p>Utilizes blocking for buffering.</p>
<p><span id="ch018_on-the-fly-commands.xhtml"></span></p>
<h1>On-the-fly Programming Commands</h1>
<p>These are used for on-the-fly programming (see <a href="http://on-the-fly.cs.princeton.edu" class="uri">http://on-the-fly.cs.princeton.edu</a>). By default, this requires that a ChucK virtual machine be already running on the localhost. It communicates via sockets to add/remove/replace shreds in the VM, and to query VM state. These flags may be combined but do note that some are opposites.</p>
<h4>--loop</h4>
<p>The simplest way to set up a ChucK virtual machine to accept these commands is by starting an empty VM with loop:</p>
<pre><code>%&gt;chuck --loop</code></pre>
<p>This will start a VM, looping (and advancing time), waiting for incoming commands. Successive invocations of `chuck' with the appropriate commands will communicate with this listener VM. (for remote operations over TCP, see below)</p>
<h4>--poop</h4>
<pre><code>%&gt;chuck --poop</code></pre>
<p>A possible typo when trying to call --loop. See page XX for a in-depth explanation on why this shouldn't be used.</p>
<h4>--halt / -h</h4>
<p> - Tells the vm to halt and exit if there are no more shreds in the VM (on by default), opposite of --loop .</p>
<pre><code>%&gt;chuck --halt </code></pre>
<h4>--add / +</h4>
<p>Adds new shreds from source files to the listener VM. this process then exits. for example:</p>
<pre><code>%&gt;chuck + foo.ck bar.ck</code></pre>
<p>Integrates foo.ck and bar.ck into the listener VM. the shreds are internally responsible for finding about the timing and other shreds via the timing mechanism and vm interface.</p>
<h4>--remove / -</h4>
<p>Removes existing shreds from the VM by ID. how to find out about the id? (see status below) for example:</p>
<pre><code>%&gt;chuck - 2 3 8 </code></pre>
<p>Removes shred 2, 3, 8.</p>
<h4>--replace / =</h4>
<p>Replace existing shred with a new shred. For example:</p>
<pre><code>%&gt;chuck = 2 foo.ck </code></pre>
<p>Replaces shred 2 with foo.ck</p>
<h4>--status / ^</h4>
<p>Queries the status of the VM - output on the listener VM. For example:</p>
<pre><code>%&gt;chuck ^</code></pre>
<p>This prints the internal shred start at the listener VM, something like:</p>
<pre><code>[chuck](VM): status (now == 0h:2m:34s) ...
     [shred id]: 1 [source]: foo.ck [sporked]: 21.43s ago
     [shred id]: 2 [source]: bar.ck [sporked]: 28.37s ago </code></pre>
<h4>--time</h4>
<p>Prints out the value of now on the listener VM. For example:</p>
<pre><code>%&gt;chuck --time</code></pre>
<p>Something like:</p>
<pre><code>[chuck](VM): the value of now: now = 403457 (samp)
     = 9.148685 (second)
     = 0.152478 (minute)
     = 0.002541 (hour)
     = 0.000106 (day)
     = 0.000015 (week) </code></pre>
<h4>--kill</h4>
<p>Semi-gracefully kills the listener VM - removes all shreds first.</p>
<pre><code>%&gt;chuck --kill</code></pre>
<h4>--remote </h4>
<p>Specifies where to send the on-the-fly command. must appear in the command line before any on-the-fly commands. for example:</p>
<pre><code>%&gt;chuck @192.168.1.1 + foo.ck bar.ck </code></pre>
<p>(or)</p>
<pre><code>%&gt;chuck @foo.example.org -p8888 + foo.ck bar.ck </code></pre>
<p>Sends foo.ck and bar.ck to VM at 192.168.1.1 or foo.example.org:8888</p>
<h4>--audio / -a</h4>
<p> - Enable real-time audio output(on by default).</p>
<pre><code>%&gt;chuck --audio </code></pre>
<h4>--silent / -s</h4>
<p>Disable real-time audio output - computations in the VM is not changed, except that the actual timing is no longer clocked by the real-time audio engine. Timing manipulations (such as operations on 'now') still function fully. This is useful for synthesizing audio to disk or network. It is also handy for running a non-audio program. Note that combining this with --loop will take up 100% of your cpu doing nothing and is therefore not recommended.</p>
<pre><code>%&gt;chuck --silent </code></pre>
<h4>--srate(N)</h4>
<p>Sets the internal sample rate to (N) Hz. by default, ChucK runs at 44100Hz on OS X and Windows, and 48000Hz on linux/ALSA. even if the VM is running in --silent mode, the sample rate is still used by some unit generaters (for example SubNoise) to compute audio, this is important for computing samples and writing to file. Not all sample rates are supported by all devices! Use --probe to consult your the options on your soundcard(s). It has been found that certain soundcards that allow for using any sample-rate in a given range (most notably some RME models) will appear to give responses to --probe calls that do not reflect the full range of what can be set buy --srate. Also note that when combined with --silent you can set rates that couldn't be played back by your device, for example for the purpose of over-sampling when intending to downsample the resultant files in other programs later.<br />
</p>
<pre><code>%&gt;chuck --srate22050</code></pre>
<h4>--bufsize(N)</h4>
<p>Sets the internal audio buffer size to (N) sample frames. Larger buffer size often reduce audio artefacts due to system/program timing. Smaller buffers reduce audio latency. The default is 512. If (N) is not a power of 2, the next power of 2 larger than (N) is used. For example:</p>
<pre><code> %&gt; chuck --bufsize950</code></pre>
<p>sets the buffer size to 1024.</p>
<h4>--dac(N)</h4>
<p>opens audio output device #(N) for real-time audio. by default, (N) is 0. This should correspond to your system's default sound-device in most cases.</p>
<pre><code>%&gt; chuck --dac0</code></pre>
<h4>--adc(N)</h4>
<p>Opens audio input device #(N) for real-time audio input. by default, (N) is 0. This should correspond to your system's default sound-device in most cases.<br />
</p>
<pre><code>%&gt; chuck --adc0</code></pre>
<h4>--chan(N) / -c(N)</h4>
<p>Opens (N) number of input and output channels on the audio device. by default, (N) is 2 (or stereo).</p>
<pre><code>%&gt; chuck --chan6</code></pre>
<h4>--in(N) / -i(N)</h4>
<p>Opens (N) number of input channels on the audio device. by default (N) is 2 (or stereo).</p>
<pre><code>%&gt; chuck --in4</code></pre>
<h4>--out(N) / -o(N)</h4>
<p>Opens (N) number of output channels on the audio device. by default (N) is 2 (or stereo).</p>
<pre><code>%&gt; chuck --out6</code></pre>
<h4>--hostname(host) / -h(host)</h4>
<p>Sets the hostname to connect to if accompanied by the on-the-fly programming commands. (host) can be name or ip of the host. default is 127.0.0.1 (localhost).</p>
<pre><code>%&gt; chuck --hostname192.168.0.30</code></pre>
<h4>--port(N) / -p(N)</h4>
<p>Sets the port to listen on if not used with on-the-fly programming commands. sets the port to connect to if used with on-the-fly programming commands.</p>
<pre><code>%&gt; chuck --port418</code></pre>
<h4>--verbose(N) / -v(N)</h4>
<p>Sets the report level to (N). 0 is none, 10 is all, default is 1.</p>
<pre><code>%&gt; chuck --verbose4</code></pre>
<h4>--probe</h4>
<p>Probes the system for all audio devices and MIDI devices, and prints them. Extremely useful for detecting audio and MIDI devices and seeing what values other flags can or should be set to.</p>
<pre><code>%&gt; chuck --probe</code></pre>
<h4>--about / --help</h4>
<p>Prints the usage message, with the ChucK URL.</p>
<pre><code>%&gt; chuck --about</code></pre>
<h4>--version</h4>
<p>Prints the version of ChucK installed. Useful for confirming your update worked correctly.</p>
<pre><code>%&gt; chuck --version</code></pre>
<h4>--callback</h4>
<p>Utilizes a callback for buffering (default).</p>
<pre><code>%&gt; chuck --callback</code></pre>
<h4>--blocking</h4>
<p>Utilizes blocking for buffering.</p>
<pre><code>%&gt; chuck --blocking</code></pre>
<h4>--deprecate</h4>
<p>What the parser is to do at finding deprecated syntax/names in files. The argument should be one of &quot;:stop&quot;, &quot;:warn&quot; or &quot;:ignore&quot;, default is &quot;:warn&quot;.</p>
<pre><code>%&gt; chuck --deprecate:stop</code></pre>
<h4>--shell</h4>
<p>Opens a dialog with the -currently not fully implemented- shell. Note that this implies --loop as well in a way that supersedes --halt</p>
<pre><code>%&gt; chuck --shell</code></pre>
<h4>--empty</h4>
<p>Opens a ChucK shell without a virtual machine</p>
<pre><code>%&gt; chuck --empty --shell</code></pre>
<h4>--standalone</h4>
<p>Disable remote commands to this VM</p>
<pre><code>%&gt; chuck --standalone</code></pre>
<h4>--server</h4>
<p>Enable remote commands to this VM. On by default and --loop implies this</p>
<pre><code>%&gt; chuck --server</code></pre>
<h4>--caution-to-the-wind</h4>
<p>Enables Std.system(string), which has been disabled by default. Please note that setting this, combined with --server or it's equivalent, enables third parties to run arbitrary commands on your computer with your privileges. Consider using --standalone. Powertools can maim.</p>
<pre><code>%&gt; chuck --caution-to-the-wind</code></pre>
<h4>--abort.shred</h4>
<p>Aborts the current shred, if there is one (if there is none the VM may be empty or may be calculating the UGen-graph). Similar to the &quot;watchdog&quot; popup-dialogs in the miniAudicle.</p>
<pre><code>%&gt; chuck --abort.shred</code></pre>
<p><span id="ch019_types-values-and-variables.xhtml"></span></p>
<h1>Types, Values, and Variables</h1>
<p>ChucK is a strongly-typed language, meaning that types are resolved at compile-time. However, it is not quite statically-typed, because the compiler/type system is a part of the ChucK virtual machine, and is a runtime component. This type system helps to impose precision and clarity in the code, and naturally lends to organization of complex programs. At the same time, it is also dynamic in that changes to the type system can take place (in a well-defined manner) at runtime. This dynamic aspect forms the basis for on-the-ﬂy programming.</p>
<p>This section deals with types, values, and the declaration and usage of variables. As in other strongly-typed programming languages, we can think of a type as associated behaviors of data. (For example, an ’int’ is a type that means integer, and adding two integer is defined to produce a third integer representing the sum.) Classes and objects allow us to extend the type system with our own custom types, but we won’t cover them in this section. We will focus mainly on primitive types here, and leave the discussion of more complex types for classes and objects.</p>
<h2>Primitive Types</h2>
<p>The primitive, or intrinsic types are those which are simple datatypes (they have no additional data attributes). Objects are not primitive types. Primitive types are passed by value. Primitive types cannot be extended. The primitive types in ChucK are:</p>
<ul>
<li>int : integer (signed)</li>
<li>ﬂoat : ﬂoating point number (in ChucK, a ﬂoat is by default double-precision)</li>
<li>time : ChucKian time</li>
<li>dur : ChucKian duration</li>
<li>complex: complex number ( a + i * b)</li>
<li>polar: a pair of amplitude and phase<br />
</li>
<li>void : (no type)</li>
</ul>
<p>For a summary of operations on these types, see the Operations and Operators section.</p>
<p>All other types are derived from 'object', either as part of the ChucK standard library, or as a new class that you create. For specification, see the Classes and Objects section.</p>
<h2>Values (literals)</h2>
<p>Literal values are specified explicitly in code and are assigned a type by the compiler. The following are some examples of literal values:</p>
<p>int:</p>
<pre><code>42</code></pre>
<p>int (hexidecimal):</p>
<pre><code>0xaf30</code></pre>
<p>ﬂoat:</p>
<pre><code>1.323</code></pre>
<p>dur:</p>
<pre><code>5.5::second</code></pre>
<p>In the above code, second is an existing duration variable. For more on durations, see the manip- ulating time section.</p>
<h2>Variables</h2>
<p>Variables are locations in memory that hold data. Variables have to be declared in ChucK before they are used. For example, to declare a variable of type int called foo:</p>
<pre><code>// declare an ’int’ called ’foo’
int foo;</code></pre>
<p>We can assign a value to an existing variable by using the ChucK operator (=&gt; ). This is one of the most commonly used operators in ChucK, it’s the way to do work and take action! We will discuss this family of operators in operators and operations.</p>
<pre><code>// assign value of 2 to ’foo’
2 =&gt; foo;</code></pre>
<p>It is possible to combine the two statements into one:</p>
<pre><code>// assign 2 to a new variable ’foo’ of type ’int’
2 =&gt; int foo;</code></pre>
<p>To use a variable, just refer to it by name:</p>
<pre><code>// debug-print the value of foo
&lt;&lt;&lt; foo &gt;&gt;&gt;;</code></pre>
<p>To update the value of foo, for example:</p>
<pre><code>// multiply ’foo’ by 10, assign back to ’foo’
foo * 10 =&gt; foo;</code></pre>
<p>You can also do the above using a *=&gt;(multi-chuck):</p>
<pre><code>// multiply ’foo’ by 10, and then assign to ’foo’
10 *=&gt; foo;</code></pre>
<p>Here is an example of a duration:</p>
<pre><code>// assign value of ’5 seconds’ to new variable bar
5::second =&gt; dur bar;</code></pre>
<p>Once you have bar, you can inductively use it to construct new durations:</p>
<pre><code>// 4 bar, a measure?
4::bar =&gt; dur measure;</code></pre>
<p>Since time is central to programming ChucK, it is important to understand time, dur, the relation- ship and operations between them. There is more information in the manipulating time section.</p>
<h2>Reference Types</h2>
<p>Reference types are types which inherit from the object class. Some default reference types include:</p>
<ul>
<li>Object : base type that all classes inherit from (directly or indirectly)</li>
<li>array : N-dimensional ordered set of data (of the same type)</li>
<li>Event : fundamental, extendable, synchronization mechanism</li>
<li>UGen : extendable unit generator base class</li>
<li>string : string (of characters)</li>
</ul>
<p>New classes can be created. All classes are reference types. We will leave the full discussion to the objects and classes section.</p>
<h2>Complex Types</h2>
<p>Two special primitive types are available to to represent complex data, such as the output of an FFT: complex and polar. A complex number of the form a + bi can be declared as</p>
<pre><code>#(2,3) =&gt; complex cmp; //cmp is now 2 + 3i</code></pre>
<p>where the #(...) syntax explicitly denotes a complex number in rectangular form. Similarly, explicit complex numbers can be manipulated directly:</p>
<pre><code>#(5, -1.5) =&gt; complex cmp; // cmp is 5 - 1.5i
#(2,3) + #(5,6) + cmp =&gt; complex sum; // sum is now 12 + 7.5i</code></pre>
<p>The (ﬂoating point) real and imaginary parts of a complex number can be accessed with the .re and .im components of a complex number:</p>
<pre><code>#(2.0,3.5) =&gt; complex cmp;
cmp.re =&gt; float x; // x is 2.0
cmp.im =&gt; float y; //y is 3.5</code></pre>
<p>The polar type offers an equivalent, alternative representation of complex numbers in terms of a magnitude and phase value. A polar representation of a complex number can be declared as</p>
<pre><code>%(2, .5*pi) =&gt; polar pol; // pol is 2-V.5p</code></pre>
<p>The magnitude and phase values can be accessed via .mag and .phase:</p>
<pre><code>%(2, .5*pi) =&gt; polar pol;
pol.mag =&gt; float m; // m is 2
pol.phase =&gt; float p; //p is .5p</code></pre>
<p>Polar and complex representations can be cast to each other and multiplied/ added/assigned/etc.:</p>
<pre><code>%(2, .5*pi) =&gt; polar pol;
#(3, 4) =&gt; complex cmp;
pol $ complex + #(10, 3) + cmp =&gt; complex cmp2;
cmp $ polar + %(10, .25*pi) - pol =&gt; polar pol2;</code></pre>
<p><span id="ch020_operators-and-operations.xhtml"></span></p>
<h1>Operators and Operations</h1>
<p>Operations on data are achieved through operators. This sections deﬁnes how operators behave on various datatypes. You may have seen many of the operators in other programming languages (C/Java). Some others are native to ChucK. We start with the family of ChucK operators.</p>
<p>The ChucK operator (=&gt; ) is a massively overloaded operator that, depending on the types involved, performs various actions. It denotes action, can be chained, and imposes and clariﬁes order (always goes from left to right). The ChucK operator is the means by which work is done in ChucK. Furthermore, the ChucK operator is not a single operator, but a family of operators.</p>
<h2>=&gt; (foundational ChucK operator)</h2>
<p>We start with the standard, plain-vanilla ChucK operator (=&gt; ). It is left-associative (all ChucK operators are), which allows us to specify any ordered ﬂow of data/tasks/modules (such as unit generator connection) from left-to-right, as in written (English) text. What =&gt; does depends on the context. It always depends on the type of the entity on the left (the chucker) and the one on the right (the chuckee), and it sometimes also depends on the nature of the entity (such as whether it is a variable or not).</p>
<p>Some examples:</p>
<pre><code>// a unit generator patch - the signal flow is apparent
// (in this case, =&gt; connects two unit generators)
SinOsc b =&gt; Gain g =&gt; BiQuad f =&gt; dac;

// add 4 to foo, chuck result to new ’int’ variable ’bar’
// (in this case, =&gt; assigns a value to a variable (int)
4 + foo =&gt; int bar;

// chuck values to a function == function call
// (same as Math.rand2f( 30, 1000))
( 30, 1000 ) =&gt; Math.rand2f;</code></pre>
<p>There are many other well-deﬁned uses of the ChucK operator, depending on the context.</p>
<h2>@=&gt; (explicit assignment ChucK operator)</h2>
<p>In ChucK, there is no standard assignment operator (=), found in many other programming languages. Assignment is carried out using ChucK operators. In the previous examples, we have used =&gt; for assignment:</p>
<pre><code>// assign 4 to variable foo
4 =&gt; int foo;

// assign 1.5 to variable bar
1.5 =&gt; float bar;

// assign duration of 100 millisecond to duh
100::ms =&gt; dur duh;

// assign the time &quot;5 second from now&quot; to later
5::second + now =&gt; time later;

// assign a value to a string
&quot;Hello!&quot; =&gt; string greeting;</code></pre>
<p>The @=&gt; explicit assignment ChucK operator behaves exactly the same for the above types (int, ﬂoat, dur, time). However, the difference is that @=&gt; can also be used for reference assignments of objects (see objects and classes) whereas =&gt; only does assignment on primitive types (int, ﬂoat, dur, time, string). The behavior of =&gt; on objects is completely context-dependent.</p>
<pre><code>// using @=&gt; is same as =&gt; for primitive types
4 @=&gt; int foo;

// assign 1.5 to variable bar
1.5 @=&gt; float bar;

// (only @=&gt; can perform reference assignment on objects)
// reference assign moe to larry
// (such that both moe and larry reference the same object)
Object moe @=&gt; Object @ larry;

// array initialization
[ 1, 2 ] @=&gt; int ar[];

// using new
new Object @=&gt; moe;</code></pre>
<p>While somewhat unusual thas has the advantage of there being no ambiguity between assignment (@=&gt; or <code>&gt; ) and testing for equality (=</code>). In fact the following is not a valid ChucK statement:</p>
<pre><code>// not a valid ChucK statement!
int foo = 4; </code></pre>
<h2>+=&gt; -=&gt; *=&gt; /=&gt; etc. (arithmetic ChucK operators)</h2>
<p>These operators are used with variables (using ’int’ and ’ﬂoat’) to perform one operation with assignment.</p>
<pre><code>// add 4 to foo and assign result to foo
foo + 4 =&gt; foo;

// add 4 to foo and assign result to foo
4 +=&gt; foo;

// subtract 10 from foo and assign result to foo
// remember this is (foo-10), not (10-foo)
10 -=&gt; foo;

// 2 times foo assign result to foo
2 *=&gt; foo;

// divide 4 into foo and assign result to foo
// again remember this is (foo/4), not (4/foo)
4 /=&gt; foo;</code></pre>
<p>It is important to note the relationship between the value and variable when using -=&gt;and /=&gt;, since these operations are not commutative.</p>
<pre><code>// mod foo by T and assign result to foo
T %=&gt; foo;

// bitwise AND 0xff and bar and assign result to bar
0xff &amp;=&gt; bar;

// bitwise OR 0xff and bar and assign result to bar
0xff |=&gt; bar;</code></pre>
<p>That’s probably enough operator abuse for now.</p>
<h2>+ - * / (arithmetic)</h2>
<p>Can you add, subtract, multiply and divide? So can ChucK!</p>
<pre><code>// divide (and assign)
16 / 4 =&gt; int four;

// multiply
2 * 2 =&gt; four;

// add
3 + 1 =&gt; four;

// subtract
93 - 89 =&gt; four;

//minus (negative) works as you&#39;d expect it to
-4 +=&gt; foo;

 </code></pre>
<h2>Casting</h2>
<p>ChucK implicitly casts int values to ﬂoat when ﬂoat is expected, but not the other around. The latter could result in a loss of information and requires an explicit cast.</p>
<pre><code>// adding float and int produces a float
9.1 + 2 =&gt; float result;

// however, going from float to int requires cast
4.8 $ int =&gt; int foo; // foo == 4

// this function expects two floats
Math.rand2f( 30.0, 1000.0 );

// this is ok because of implicit cast
Math.rand2f( 30, 1000 ); </code></pre>
<h2>% (modulo)</h2>
<p>The modulo operator % computes the remainder after division for the primitives int, float, dur and time.</p>
<pre><code>// 7 mod 4 (should yield 3)
7 % 4 =&gt; int result;

// 7.3 mod 3.2 floating point mod (should yield .9)
7.3 % 3.2 =&gt; float resultf;

// duration mod
5::second % 2::second =&gt; dur foo;

// time/duration mod
now % 5::second =&gt; dur bar;</code></pre>
<p>The latter (time/duration mod) is one of many ways to dynamically synchronize timing in shreds. the examples otf 01.ck through otf 07.ck (see under examples) make use of this to on-the-ﬂy syn- chronize its various parts, no matter when each shred is added to the virtual machine:</p>
<pre><code>// define period (agreed upon by several shreds)
.5::second =&gt; dur T;

// compute the remainder of the current period ...
// and advance time by that amount
T - (now % T) =&gt; now;

// when we reach this point, we are synchronized to T period boundary
// the rest of the code
// ... </code></pre>
<p>This is one of many ways to compute and reason about time in ChucK. The appropriate solution(s) in each case depends on the intended functionality. Have fun!</p>
<h2>&amp;&amp; || <code>= </code> &lt;= &gt; &gt;= ! (logic)</h2>
<p>Logical operators - these need two operands with the exception of &quot;!&quot;. The result is an integer value of 0 or 1.</p>
<ul>
<li>&amp;&amp; : and</li>
<li>|| : or</li>
<li>== : equals</li>
<li>!= : does not equal</li>
<li>&gt; : greater than</li>
<li>&gt;= : greater than or equal to</li>
<li>&lt; : less than</li>
<li>&lt;= : less than or equal to</li>
<li>! : logical invert</li>
</ul>
<pre><code>// test some universal truths
if( 1 &lt;= 4 &amp;&amp; true )
&lt;&lt;&lt;&quot;hooray!&quot;&gt;&gt;&gt;;

// logical invert
if( !true == false )
&lt;&lt;&lt;&quot;yes&quot;&gt;&gt;&gt;; </code></pre>
<p>These operate on integers with 0 evaluating to false and anything else to true. Note that the reserved keywords &quot;true&quot; and &quot;false&quot; themselves evaluate to the integers 1 and 0, respectively</p>
<h2>&gt;&gt; &lt;&lt; &amp; | ˆ (bitwise)</h2>
<p>These are used on int values at the bit level, often for bit masking.</p>
<ul>
<li>&gt;&gt; : shift bits right ( 8 &gt;&gt;1 = 4 )</li>
<li>&lt;&lt; : shift bits left ( 8 &lt;&lt;1 = 16 )</li>
<li>&amp; : bitwise AND</li>
<li>| : bitwise OR</li>
<li>ˆ : bitwise XOR</li>
<li>~ : bitwise invert</li>
</ul>
<h2>++ - - (inc / dec)</h2>
<p>Integer values may be incremented or decremented by appending the ++ or -- operator respectively, to variable names.</p>
<pre><code>4 =&gt; int foo;
foo++; // foo is now 5
foo--; // foo is 4 again</code></pre>
<p>we can also prepend the operators to the variable. When appended the value is changed after it's returned, when prepended it's first adjusted, then returned. For example;</p>
<pre><code>4 =&gt; int foo;
&lt;&lt;&lt; foo++&gt;&gt;&gt; //will print 4 as the change is made after the print
&lt;&lt;&lt;++foo&gt;&gt;&gt;; //willprint 6 as the second change is made before the second print</code></pre>
<p>In case of doubt it's probably safer to make the change as a separate command, instead of as a part of a larger instruction.</p>
<h2>@</h2>
<p>The @ operator creates a named reference to a object of a given type without instantiating it. Later on a object isntance may be assigned to the reference (see below)</p>
<pre><code>//let&#39;s create a reference to a gain
Gain @ mixer;</code></pre>
<h2>new</h2>
<p>The &quot;new&quot; keyword instantiates a new, nameless, object of the provided type. It may then be assigned to a named reference, appended to a array or returned from a function.<br />
</p>
<pre><code>// instantiate object and assign it to a reference
new Object @=&gt; Object @ bar;

//function that returns a new object
fun Gain gainMaker()
{
  return new Gain;
}

//use this to create a Gain to assign a instance to the reference we create above
gainMaker() @=&gt; mixer;
</code></pre>
<p><span id="ch021_time-and-timing.xhtml"></span></p>
<h1>Time and Timing</h1>
<p>ChucK is a strongly-timed language, meaning that time is fundamentally embedded in the lan- guage. ChucK allows the programmer to explicitly reason about time from the code. This gives extremely ﬂexible and precise control over time and (therefore) sound synthesis.</p>
<p>In ChucK:</p>
<ul>
<li>Time and duration are native types in the language</li>
<li>Keyword now holds the current logical time</li>
<li>Time is advanced (and can only be advanced) by explicitly manipulating now</li>
<li>You have ﬂexible and precise control</li>
</ul>
<h2>Time and Duration</h2>
<p>Time and duration are native types in ChucK. time represents an absolute point in time (from the beginning of ChucK time). dur represents a duration (with the same logical units as time).</p>
<pre><code>// a duration of one second
1::second =&gt; dur foo;

// a point in time (duration of foo from now)
now + foo =&gt; time later;</code></pre>
<p>Later in this section, we outline the various arithmetic operations to perform on time and duration.</p>
<p>Durations can be used to construct new durations, which then be used to inductively construct yet other durations. For example:</p>
<pre><code>// .5 second is a quarter
.5::second =&gt; dur quarter;

// 4 quarters is whole
4::quarter =&gt; dur whole;</code></pre>
<p>By default, ChucK provides these preset duration values:</p>
<ul>
<li>samp : duration of 1 sample in ChucK time</li>
<li>ms : duration of 1 millisecond</li>
<li>second : duration of 1 second</li>
<li>minute : 1 minute</li>
<li>hour : 1 hour</li>
<li>day : 1 day</li>
<li>week : 1 week</li>
</ul>
<p>Use these to represent any duration.</p>
<pre><code>// the duration of half a sample
.5::samp =&gt; dur foo;

// 20 weeks
20::week =&gt; dur waithere;

// use in combination
2::minute + 30::second =&gt; dur bar;

// same value as above
2.5::minute =&gt; dur bar; </code></pre>
<h2>Operations on Time and Duration (Arithmetic)</h2>
<p>In ChucK, there are well-deﬁned arithmetic operations on values of type time and dur.</p>
<p>Example 1 (time offset):</p>
<pre><code>// time + dur yields time
now + 10::second =&gt; time later;</code></pre>
<p>Example 2 (time subtraction):</p>
<pre><code>// time - time yields dur
later - now =&gt; dur D;</code></pre>
<p>example 3 (addition):</p>
<pre><code>// dur + dur yields dur
10::second + 100::samp =&gt; dur foo;</code></pre>
<p>Example 4 (subtraction):</p>
<pre><code>// dur - dur yields dur
10::second - 100::samp =&gt; dur bar; </code></pre>
<p>Example 5 (division):</p>
<pre><code>// dur / dur yields float
10::second / 20::ms =&gt; float n;</code></pre>
<p>Example 6 (time mod):</p>
<pre><code>// time mod dur yields dur
now % 1::second =&gt; dur remainder;</code></pre>
<p>Example 7 (synchronize to period):</p>
<pre><code>// synchronize to period of .5 second
.5::second =&gt; dur T;
T - (now % T) =&gt; now; </code></pre>
<p>Example 8 (comparison on time):</p>
<pre><code>// compare time and time
if( t1 &lt; t2 )
  // do something...</code></pre>
<p>Example 9 (comparison on duration):</p>
<pre><code>// compare dur and dur
if( 900::ms &lt; 1::second )
  &lt;&lt;&lt; &quot;yay!&quot; &gt;&gt;&gt;; </code></pre>
<h2>The Keyword ‘now’</h2>
<p>The keyword now is the key to reasoning about and controlling time in ChucK.</p>
<p>Some properties of now include:</p>
<ul>
<li>now is a special variable of type time</li>
<li>now holds the current ChucK time (when read)</li>
<li>Modifying now has the side effects of:</li>
<li>advancing time (see below);</li>
<li>suspending the current process (called shred) until the desired time is reached - allowing other shreds and audio synthesis to compute;</li>
<li>The value of now only changes when it is explicitly modiﬁed.</li>
</ul>
<p>For more detail see the Advancing Time section.</p>
<p>Example:</p>
<pre><code>// compute value that represents &quot;5 seconds from now&quot;
now + 5::second =&gt; time later;

// while we are not at later yet...
while( now &lt; later )
{
  // print out value of now
  &lt;&lt;&lt; now &gt;&gt;&gt;;

  // advance time by 1 second
  1::second =&gt; now;
}</code></pre>
<h2>Advancing Time</h2>
<p>Advancing time allows other shreds (processes) to run and allows audio to be computed in a controlled manner. There are three ways of advancing time in ChucK:</p>
<ul>
<li>chucking (=&gt; ) a duration to now: this will advance time by that duration.</li>
<li>chucking (=&gt; ) a time to now: this will advance time to that point. (note that the desired time must be later than the current time, or at least be equal to it.)</li>
<li>chucking (=&gt; ) an Event to now: time will advance until the event is triggered. (also see event)</li>
</ul>
<h3>Advancing Time by Duration</h3>
<pre><code>// advance time by 1 second
1::second =&gt; now;

// advance time by 100 millisecond
100::ms =&gt; now;

// advance time by 1 samp (every sample)
1::samp =&gt; now;

// advance time by less than 1 samp
.024::samp =&gt; now; </code></pre>
<h3>Advancing Time by Absolute Time</h3>
<pre><code>// figure out when
now + 4::hour =&gt; time later;

// advance time to later
later =&gt; now; </code></pre>
<p>A time chucked to now will have ChucK wait until the appointed time. ChucK never misses an appointment (unless it crashes)! Again, the time chucked to now must be greater than or equal to now, otherwise an exception is thrown.</p>
<h3>Advancing Time by Event</h3>
<pre><code>// wait on event
e =&gt; now;</code></pre>
<p>See events for a more complete discussion of using events!</p>
<p>The advancement of time can occur at any point in the code.</p>
<pre><code>// our patch: sine oscillator -&gt; dac
SinOsc s =&gt; dac;

// infinite time loop
while( true )
{
  // randomly choose frequency from 30 to 1000
  Std.rand2f( 30, 1000 ) =&gt; s.freq;

  // advance time by 100 millisecond
  100::ms =&gt; now;
} </code></pre>
<p>Furthermore, there are no restrictions (other than underlying ﬂoating point precision) on how much time is advanced. So it is possible to advance time by a microsecond, a samp, 2 hours, or 10 years. The system will behave accordingly and deterministically.</p>
<p>This mechanism allows time to be controlled at any desired rate, according to any programmable pattern. With respect to sound synthesis, it is possible to control any unit generator at literally any rate, even sub-sample rate.</p>
<p>The power of the timing mechanism is extended by the ability to write parallel code, which is discussed in concurrency and shreds.</p>
<p><span id="ch022_concurrency-and-shreds.xhtml"></span></p>
<h1>Concurrency and Shreds</h1>
<p>ChucK is able to run many processes concurrently (the process behave as though they were running in parallel). A ChucKian process is called a &quot;shred&quot;. &quot;Sporking&quot; a shred means creating and adding a new process to the virtual machine. Shreds may be sporked from a variety of places, and may themselves spork new shreds.</p>
<p>Central to ChucK's timing and concurrency is the &quot;shreduler&quot;, a part of the virtual machine that keeps track of what processes are intended (or &quot;shreduled&quot;) to run at any geven time. It does so to a very high precision, much more accurate than the sample rate. This is not just because things need to happen at the right time; they also need to happen in the right order. In ChucK the order in which commands are executed is always deterministic; when several commands are shreduled to happen at the same time they will be dealt with in the order in which they were shreduled. Note that any given process/shred does not necessarily need to know about any other - it only has to deal with time locally. The virtual machine will make sure things happen correctly ”across the board”. </p>
<p>The simplest way to to run shreds concurrently is to specify them on the command line:</p>
<pre><code>%&gt;chuck foo.ck bar.ck boo.ck</code></pre>
<p>The above command tells chuck to run foo.ck, bar.ck, and boo.ck concurrently. There are other ways to run shreds concurrently (see on-the-ﬂy programming commands). Next, we show how to create new shreds from within ChucK programs.</p>
<h2>Sporking Shreds (In Code)</h2>
<p>To spork means to shredule a new shred.</p>
<p>To spork a shred, use the spork keyword/operator:</p>
<ul>
<li>Spork dynamically turns functions into processes that run parallel to the shred that sporked them<br />
</li>
<li>This new shred is shreduled to execute immediately</li>
<li>The parent shred continues to execute, until time is advanced (see manipulating time) or until the parent explicitly yields (see next section).</li>
<li>In the current implementation, when a parent shred exits, all child shreds all exit (this behavior will be enhanced in the future.)</li>
<li>Sporking a function returns a reference to the new shred, note that this operation does not return a function's return value, currently only functions of type void can be sporked - the ability to get back the return value at some later point in time will be provided in a future release.</li>
</ul>
<pre><code>// define function go()
fun void go()
{
  // insert code
}
// spork a new shred to start running from go()
spork ~ go();

// spork another, store reference to new shred in offspring
spork ~ go() =&gt; Shred @ offspring;</code></pre>
<p>A slightly longer example:</p>
<pre><code>// define function
fun void foo( string s )
{
  // infinite time loop
  while( true )
  {
    // print s
    &lt;&lt;&lt; s &gt;&gt;&gt;;

    // advance time
    500::ms =&gt; now;
  }
}

// spork shred, passing in &quot;you&quot; as argument to foo
spork ~ foo( &quot;you&quot; );

// advance time by 250 ms
250::ms =&gt; now;

// spork another shred
spork ~ foo( &quot;me&quot; );

// infinite time loop - to keep child shreds around
while( true )
  1::second =&gt; now;</code></pre>
<p>also see the function section for more information on working with functions.</p>
<h2>The ’me’ keyword</h2>
<p>The me keyword (type Shred) refers the current shred.</p>
<p>Sometimes it is useful to suspend the current shred without advancing time, and give other shreds shreduled for the current time a chance to execute. me.yield() does exactly that. This is often useful immediately after sporking a new shred, when you would like for the new shred to have a chance to run but you do not want to advance time yet for yourself.</p>
<pre><code>// spork shred
spork ~ go();

// suspend the current shred ...
// ... give other shreds (shreduled for ’now’) a chance to run
me.yield();</code></pre>
<p>The me keyword is also useful to exit the current shred. For example if a MIDI device fails to open, you may exit the current shred.</p>
<pre><code>// make a MidiIn object
MidiIn min;

// try to open device 0 (chuck --probe to list all device)
if( !min.open( 0 ) )
{
  // print error message
  &lt;&lt;&lt; &quot;can’t open MIDI device&quot; &gt;&gt;&gt;;

  // exit the current shred
  me.exit();
}</code></pre>
<p>Finally it can be used to get the shred id:</p>
<pre><code>// print out the shred id
&lt;&lt;&lt; me.id(); &gt;&gt;&gt;;</code></pre>
<p>These functions are common to all shreds, but note that yield() can only be used from within the current shred.</p>
<h2>using Machine.add()</h2>
<p>Machine.add( string path ) takes the path to a chuck program, and sporks it. Unlike with the spork command, there is no parent-child relationship between the shred that calls the function and the new shred that is added. This is useful for dynamically running stored programs.</p>
<pre><code>// spork &quot;foo.ck&quot;
Machine.add( &quot;foo.ck&quot; ); </code></pre>
<p>Presently, this returns the id of the new shred, not a reference to the shred. This will likely be changed in the future.</p>
<p>Similarly, you can remove shreds from the virtual machine.</p>
<pre><code>// add
Machine.add( &quot;foo.ck&quot; ) =&gt; int id;

// remove shred with id
Machine.remove( id );

// add
Machine.add( &quot;boo.ck&quot; ) =&gt; id

// replace shred with &quot;bar.ck&quot;
Machine.replace( id, &quot;bar.ck&quot; );</code></pre>
<h2>Inter-Shred Communication</h2>
<p>Shreds sporked in the same ﬁle can share the same global variables. They can use time and events to synchronize to each other (see Events). Shreds sporked from different ﬁles can share data (including events). For now, this is done through a public class with static data (see Classes). Static data is not completely implemented, We will ﬁx this very soon!</p>
<p><span id="ch023_events.xhtml"></span></p>
<h1>Events</h1>
<p>In addition to the built-in timing mechanisms for internal control, ChucK has an event class to allow exact synchronization across an arbitrary number of shreds.</p>
<h2>What they are</h2>
<p>ChucK events are a native class within the ChucK language. We can create an event objects, and then chuck (=&gt;) that event to now. The event places the current shred on the event's waiting list, suspends the current shred (letting time advance from that shred's point of view). When the the event is triggered, one or more of the shreds on its waiting list is shreduled to run immediately. This trigger may originate from another ChucK shred, or from activities taking place outside the Virtual Machine ( MIDI, OSC, or IPC ).</p>
<pre><code>    // declare event
    Event e;

    // function for shred
    fun void eventshred( Event event, string msg )
    {
        // infinite loop
        while ( true )
        {
            // wait on event
            event =&gt; now;
            // print
            &lt;&lt;&gt;&gt;;
        }
   }

    // create shreds
    spork   eventshred ( e, &quot;fee&quot; );
    spork   eventshred ( e, &quot;fi&quot; );
    spork   eventshred ( e, &quot;fo&quot; );
    spork   eventshred ( e, &quot;fum&quot; );

    // infinite time loop
    while ( true )
    {
        // either signal or broadcast
        if( maybe )
        {
            &lt;&lt;&lt;&quot;signaling...&quot;&gt;&gt;&gt;;
            e.signal();
        }
        else
          {
            &lt;&lt;&lt;&quot;broadcasting...&quot;&gt;&gt;&gt;;
            e.broadcast();
          }

        // advance time
        0.5::second =&gt; now;
   }</code></pre>
<h2>Use</h2>
<p>Chucking an event to now suspends the current shred, letting time advance:</p>
<pre><code>    // declare Event
    Event e;

    // ...

    // wait on the event
    e =&gt; now;

    // after the event is trigger
    &lt;&lt;&lt; &quot;I just woke up&quot; &gt;&gt;&gt;;</code></pre>
<p>As shown above, events can be triggered in two ways, depending on the desired behavior.</p>
<pre><code>    // signal one shred waiting on the event e
    e.signal();</code></pre>
<p>Signal() releases the first shred in that event's queue, and shredule it to run at the current time, respecting the order in which shreds were added to the queue.</p>
<pre><code>    // wake up all shreds waiting on the event e
    e.broadcast();</code></pre>
<p>broadcast() releases all shreds queued by that event, in the order they were added, and at the same instant in time</p>
<p>The released shreds are shreduled to run immediately. But of course they will respect other shreds also shreduled to run at the same time. Furthermore, the shred that called signal() or broadcast() will continue to run until it advances time itself, or yield the virtual machine without advancing time. (see me.yield() under concurrency)</p>
<h2>MIDI events</h2>
<p>ChucK contains built-in MIDI classes to allow for interaction with MIDI based software or devices.</p>
<pre><code>    MidiIn min;
    MidiMsg msg;

    // open midi receiver, exit on fail
    if ( !min.open(0) ) me.exit();

    while( true )
    {
        // wait on midi event
        min =&gt; now;

        // receive midimsg(s)
        while( min.recv( msg ) )
        {
            // print content
            &lt;&lt;&lt; msg.data1, msg.data2, msg.data3 &gt;&gt;&gt;;
        }
    }
 </code></pre>
<p>MidiIn is a subclass of Event, as as such can be ChucKed to now. MidiIn then takes a MidiMsg object to its .recv() method to access the MIDI data. As a default, MidiIn events trigger the broadcast() event behavior.</p>
<h2>OSC events</h2>
<p>In addition to MIDI, ChucK has OSC communication classes as well:</p>
<pre><code>    // create our OSC receiver
    OscRecv orec;
    // port 6449
    6449 =&gt; orec.port;
    // start listening (launch thread)
    orec.listen();

    function void rate_control_shred()
    {
        // create an address in the receiver
        // and store it in a new variable.
        orec.event(&quot;/sndbuf/buf/rate,f&quot;) @=&gt; OscEvent oscdata;

        while ( true )
        {
            oscdata =&gt; now; //wait for events to arrive.

            // grab the next message from the queue.
            while( oscdata.nextMsg() != 0 )
             {
                // getFloat fetches the expected float
                // as indicated in the type string &quot;,f&quot;
                buf.rate( oscdata.getFloat() );
                0 =&gt; buf.pos;
             }
        }
   }</code></pre>
<p>The OscRecv class listens for incoming OSC packets on the specified port. Each instance of OscRecv can create OscEvent objects using its event() method to listen for packets at any valid OSC address pattern.</p>
<p>An OscEvent event can then be ChucKed to now to wait for messages to arrive, after which the nextMsg() and getFloatStringInt() methods can be used to fetch message data.</p>
<h2>Creating custom events</h2>
<p>Events, like any other class, can be subclassed to add functionality and transmit data:</p>
<pre><code>    // extended event
    class TheEvent extends Event
    {
        int value;
    }

    // the event
    TheEvent e;

    // handler
    fun int hi( TheEvent event )
    {
        while( true )
         {
            // wait on event
            event =&gt; now;
            // get the data
            &lt;&lt;&gt;&gt;;
         }
     }

    // spork
    spork   hi( e );
    spork   hi( e );
    spork   hi( e );
    spork   hi( e );

    // infinite time loop
    while( true )
    {
        // advance time
        1::second =&gt; now;

        // set data
        Math.rand2( 0, 5 ) =&gt; e.value;

        // signal one waiting shred
        e.signal();
    }</code></pre>
<h2>VM Wide Events</h2>
<p>Often it can be useful to trigger events across the VM outside of the child/parent shred relationship.</p>
<p>This can be done by declaring a reference to static data within a public class. You may only declare one public class in a file so the following must be added as two files. For more on classes see Objects reference.</p>
<p>This example creates a VM wide event that also has communicates an int value.</p>
<p>File 1: Extend Event to carry int value</p>
<pre><code>//First Extend Event to carry int
public class E extends Event{
    int value;
}</code></pre>
<p>File 2:Declare static version of extend class and instantiate once.</p>
<pre><code>//Create Static Event
public class vmwEvent{
    static E @ gbEvent;
}
new E @=&gt; vmwEvent.gbEvent;</code></pre>
<p>This creates the global VM wide event which can then be used as required.</p>
<p>Write int value and broadcast event</p>
<pre><code>//send values
while (true){
    Std.rand2(100,300) =&gt; vmwEvent.gbEvent.value;
    vmwEvent.gbEvent.broadcast();
    500::ms =&gt; now;
    &lt;&lt;&lt;&quot;sent&quot;&gt;&gt;&gt;;
}</code></pre>
<p>Receive and read int value for VM wide event.</p>
<pre><code>//receive values
while (true){
    vmwEvent.gbEvent =&gt; now;
    &lt;&lt;&lt; vmwEvent.gbEvent.value &gt;&gt;&gt;;
    &lt;&lt;&lt;&quot;got&quot;&gt;&gt;&gt;;
}</code></pre>
<p><span id="ch024_control-structures.xhtml"></span></p>
<h1>Control Structures</h1>
<p>ChucK includes standard control structures similar to those in most programming languages. Control structures make use of blocks of code. A code block is delineated either by semicolons or by curly brackets.</p>
<h2>if / else</h2>
<p>The if statement executes a block if the condition is evaluated as non-zero.</p>
<pre><code>if( condition )
{
  // insert code here
}</code></pre>
<p>In the above code, &quot;condition&quot; is any expression that evaluates to an int.<br />
The else statement can be put after the if block to handle the case where the condition evaluates to 0.<br />
</p>
<pre><code>if( condition )
{
  // your code here
}
else
{
  // your other code here
}</code></pre>
<p>If statements can be nested.<br />
</p>
<h2>repeat</h2>
<p>The repeat statement creates a loop that repeats a certain number of times. This number is evaluated only once (right before the first repetition).</p>
<pre><code>repeat(3)
{
  //this code will run three times
}</code></pre>
<h2>while</h2>
<p>The while statement is a loop that repeatedly executes the body as long as the condition evaluates as non-zero.</p>
<pre><code>// here is an infinite loop
while( true )
{
  // your code loops forever!
  // (sometimes this is desirable because we can create
  // infinite time loops this way, and because we have
  // concurrency)
}</code></pre>
<h2>do</h2>
<p>The while loop will first check the condition, and executes the body as long as the condition evaluates as non-zero. To execute the body of the loop before checking the condition, you can use a do/while loop. This guarantees that the body gets executed as least once.</p>
<pre><code>do
{
  // your code executes here at least once
}
while( condition );</code></pre>
<p>A few more points:</p>
<ul>
<li> while statements can be nested.<br />
</li>
<li> see break/continue for additional control over your loops</li>
</ul>
<h2>until</h2>
<p>The until statement is the opposite of while, semantically. A until loop repeatedly executes the body until the condition evaluates as non-zero.</p>
<pre><code>// an infinite loop
until( false )
{
  // your great code loops forever!
}</code></pre>
<p>The while loop will first check the condition, and executes the body as long as the condition evaluates as zero. To execute the body of the loop before checking the condition, you can use a do/until loop. This guarantees that the body gets executed as least once.</p>
<pre><code>do
{
  // your code executes here at least once
}
until( condition );</code></pre>
<p>A few more points:</p>
<ul>
<li> until statements can be nested.<br />
</li>
<li> see break/continue for additional control over your loops</li>
</ul>
<h2>for</h2>
<p>A loop that iterates a given number of times. A temporary variable is declared that keeps track of the current index and is evaluated and incremented at each iteration.</p>
<pre><code>// for loop
for( 0 =&gt; int foo; foo &lt; 4 ;⁞ foo++ )
{
  // debug-print value of ’foo’
  &lt;&lt;&gt;&gt;&gt;;
}</code></pre>
<h2>break / continue</h2>
<p>Break allows the program flow to jump out of a loop.</p>
<pre><code> // infinite loop
while( 1 )
{
  if( condition )
    break;
}</code></pre>
<p>Continue allows a loop to continue looping but not to execute the rest of the block for the iteration where continue was executed.</p>
<pre><code>// another infinite loop
while( 1 )
{
  // check condition
  if( condition )
    continue;

  // some great code that may get skipped (if continue is taken)
}</code></pre>
<p><span id="ch025_functions.xhtml"></span></p>
<h1>Functions</h1>
<p>Functions provide ways to break up code/common tasks into individual units. This helps to promote code re-usability and readability. When you find you are using the same code a lot of times it's most likely a good idea to put it in a function. This keeps files more compact and when corrections are needed a lot of time is saved and errors are prevented.</p>
<h2>Writing</h2>
<p>Declare functions with the keyword fun (or function) followed by the return type and then the name of the function. After the name of the function parentheses must be opened to declare the types of the input arguments.</p>
<pre><code>// define function call ’funk’
fun void funk( int arg )
{
  // insert code here
}</code></pre>
<p>The above function returns no values (the return type is void). If the function is declared to return any other type of values, the function body must return a value of the appropriate type.</p>
<pre><code>// define function ’addOne’
fun int addOne(int x)
{
  // result
  return x + 1;
}</code></pre>
<p>Note that the return keyword (without a argument) can be used in functions of type void as well, in which case it breaks off execution of the function and computation resumes from where the function was called. This is not unlike how the break keyword is used in loops and occasionally useful.</p>
<pre><code>fun void noZero( int x)
{
  //stop at zero
  if ( x == 0 ) return;
  //otherwise print the input
  else &lt;&lt;&lt; x &gt;&gt;&gt;;
}</code></pre>
<h2>Calling</h2>
<p>To call a function use the name of the function with appropriate arugments.</p>
<pre><code>// define ’hey’
fun int hey( int a, int b )
{
  // do something
  return a + b;
}
// call the function; store result
hey( 1, 2 ) =&gt; int result;</code></pre>
<p>You can also use the ChucK operator to call functions!</p>
<pre><code>// call hey
( 1, 2 ) =&gt; hey =&gt; int result;

// same
hey( 1, 2 ) =&gt; int result;

// several in a row
( 10, 100 ) =&gt; Std.rand2 =&gt; Std.mtof =&gt; float foo;

// same
Std.mtof( Std.rand2( 10, 100 ) ) =&gt; float foo;</code></pre>
<h2>Overloading</h2>
<p>Overloading a function allows functions with the same name to be defined with different arguments. The function must be written in separate instances to handle the input, and the return type must be the same for all versions.</p>
<pre><code>// funk( int )
fun int add(int x)
{
  return x + x;
}

// funk( int, int )
fun int add(int x, int y)
{
  return x + y;
}

// compiler automatically choose the right one to call
add( 1 ) =&gt; int foo;
add( 1, 2 ) =&gt; int bar;
⁞</code></pre>
<p>In some cases multiple versions of the function may apply, most notably when type bar extends type foo and our fuction is overloaded to handle both. In that case ChucK should prefer the most speciffic one over the more general case.</p>
<p><span id="ch026_objects.xhtml"></span></p>
<h1>Objects</h1>
<h2>Introduction</h2>
<p>Chuck implements an object system that borrows from both C++ and Java conventions. In our case this means:</p>
<ul>
<li>You can deﬁne custom classes as new types and instantiate objects</li>
<li>ChucK supports polymorphic inheritance (this is the same model used in Java, and also known as virtual inheritance in C++)</li>
<li>All object variables are references (like Java), but instantiation resembles C++. We will discuss this in detail below.</li>
<li>There is a default class library.</li>
<li>All objects inherit from the Object class (as in Java)</li>
</ul>
<p>For the sake of clarity we will deﬁne these terms:</p>
<ul>
<li>A class is an abstraction of data (members) and behavior (methods)</li>
<li>A class is a type.</li>
<li>An object is an instantiation of that class</li>
<li>A reference variable refers indirectly to an object - it is not the object itself. All ChucK object variables are reference variables (like in Java).</li>
<li>Similarly, reference assignment duplicates a reference to an object and assigns the reference to a reference variable. The object itself is not duplicated. All ChucK object assignments are reference assignments.</li>
</ul>
<h2>Built-in Classes</h2>
<p>ChucK has a number of classes deﬁned within the language.</p>
<ul>
<li>Object : base class to all ChucK objects.</li>
<li>Event : ChucK’s basic synchronization mechanism; may be extended to create custom Event functionality (discussed here).</li>
<li>Shred : basic abstraction for a non-premptive ChucK process.</li>
<li>UGen : base unit generator class (discussed here).</li>
</ul>
<p>These are some of the more commonly used classes in ChucK.</p>
<h2>Working With Objects</h2>
<p>Let’s begin with some examples. For these examples, let’s assume Foo is a deﬁned class.</p>
<pre><code>// create a Foo object; stored in reference variable bar
Foo bar;</code></pre>
<p>The above code does two things:</p>
<ul>
<li>A reference variable bar is declared; its type is Foo</li>
<li>A new instance of Foo is created, and its reference is assigned to bar</li>
</ul>
<p>Note that in contrast to Java, this statement both declares a reference variable and instantiates a instance of that class and assigns the reference to the variable. Also note that in contrast to C++, bar is a reference, and does not represent the object itself.</p>
<p>To declare a reference variable that refers to nothing (also called a null reference):</p>
<pre><code>// create a null reference to a Foo object
Foo @ bar; </code></pre>
<p>The above code only declare a reference and initializes it to null. (random note: the above statement may be read as ”Foo at bar”).</p>
<p>We can assign a new instance to the reference variable:</p>
<pre><code>// assign new instance of Foo to bar
new Foo @=&gt; Foo @ bar;

// (this statement is equivalent to ’Foo bar’, above)</code></pre>
<p>The code above is exactly equivalent to Foo bar; as shown above. The new operator creates an instance of a class, in this case Foo. The @=&gt; operator performs the reference assignment. (see Operators chapter for more information on @=&gt;)</p>
<p>It is possible to make many references to same object:</p>
<pre><code>// make a Foo
Foo bar;

// reference assign to duh
bar @=&gt; Foo @ duh;

// (now both bar and duh points to the same object)</code></pre>
<p>ChucK objects are reference counted and garbage collection takes place automatically. (note: this is still being implemented!)</p>
<p>As stated above, a classes may contain data and behavior, in the form of member variables and mem- ber functions, respectively. Members are accessed by using ’dot notation’ - reference.memberdata and reference.memberfunc(). To invoke a member function of an object (assuming class Foo has a member function called compute that takes two integers and returns an integer):</p>
<pre><code>// make a Foo
Foo bar;
// call compute(), store result in boo
bar.compute( 1, 2 ) =&gt; int boo;</code></pre>
<h2>Writing a Class</h2>
<p>If a class has already been deﬁned in the ChucK virtual machine (either in the same ﬁle or as a public class in a different ﬁle) then it can be instantiated similar to primitive types.</p>
<p>Unless declared public, class deﬁnitions are scoped to the shred and will not conﬂict with identically named classes in other running shreds.</p>
<p>Classes encapsulate a set of behaviors and data. To deﬁne a new object type, the keyword class is used followed by the name of that class.</p>
<pre><code>// define class X
class X
{
  // insert code here
} </code></pre>
<p>If a class is deﬁned as public, it is integrated into the central namespace (instead of the local one), and can be instantiated from other programs that are subsequently compiled. There can be at most one public class per ﬁle.</p>
<pre><code>// define public class MissPopular
public class MissPopular
{
  // ...
}

// define non-public class Flarg
class Flarg
{
  // ...
}

// both MissPopular and Flarg can be used in this file
// only MissPopular can be used from another file</code></pre>
<p>We deﬁne member data and methods to specify the data types and functionality required of the class. Members, or instance data and instance functions are associated with individual instances of a class, whereas static data and functions are only associated with the class (and shared by the instances).</p>
<h2>Members (Instance Data + Functions)</h2>
<p>Instance data and methods are associated with an object.</p>
<pre><code>// define class X
class X
{
  // declare instance variable ’m_foo’
  int m_foo;

  // another instance variable ’m_bar’
  float m_bar;

  // yet another, this time an object
  Event m_event;

  // function that returns value of m_foo
  fun int getFoo() { return m_foo; }

  // function to set the value of m_foo
  fun void setFoo( int value ) { value =&gt; m_foo; }

  // calculate something
  fun float calculate( float x, float y )
  {
    // insert code
  }

  // print some stuff
  fun void print()
  {
    &lt;&lt;&lt; m_foo, m_bar, m_event &gt;&gt;&gt;;
  }
}

// instantiate an X
X x;

// set the Foo
x.setFoo( 5 );

// print the Foo
&lt;&lt;&lt; x.getFoo() &gt;&gt;&gt;;

// call print
x.print();</code></pre>
<h2>Class Constructors</h2>
<p>In the initial release, we do not support constructors yet. However, we have a single pre-constructor. The code immediately inside a class deﬁniton (and not inside any functions) is run every time an instance of that class is created.</p>
<pre><code>// define class X
class X
{
  // we can put any ChucK statements here as pre-constructor
  // initialize an instance data
  109 =&gt; int m_foo;

  // loop over stuff
  for( 0 =&gt; int i; i &lt; 5; i++ )
  {
    // print out message how silly
    &lt;&lt;&lt; &quot;part of class pre-constructor...&quot;, this, i &gt;&gt;&gt;;
  }

  // function
  fun void doit()
  {
    // ...
  }
}

// when we instantiate X, the pre-constructor is run
X x;

// print out m_foo
&lt;&lt;&lt; x.m_foo &gt;&gt;&gt;;</code></pre>
<h2>Static (Data + Functions)</h2>
<p>Static data and functions are associated with a class, and are shared by all instances of that class – in fact, static elements can be accessed without an instance, by using the name of the class: Classname.element.</p>
<pre><code>// define class X
class X
{
  // static data
  static int our_data;

  // static function
  fun static int doThatThing()
  {
    // return the data
    return our_data;
  }
}

// do not need an instance to access our_data
2 =&gt; X.our_data;

// print out
&lt;&lt;&lt; X.our_data &gt;&gt;&gt;;

// print
&lt;&lt;&lt; X.doThatThing() &gt;&gt;&gt;;

// create instances of X
X x1;
X x2;

// print out their static data - should be same
&lt;&lt;&lt; x1.our_data, x2.our_data &gt;&gt;&gt;;

// change use one
5 =&gt; x1.our_data;

// the other should be changed as well
&lt;&lt;&lt; x1.our_data, x2.our_data &gt;&gt;&gt;;</code></pre>
<h2>Inheritance</h2>
<p>Inheritance in ob ject-oriented code allows the programmer to take an existing class and extend or alter its functionality. In doing so we can create a taxonomy of classes that all share a speciﬁc set of behaviors, while implementing those behaviors in different, yet well-deﬁned, ways. We indicate that a new class inherits from another class using the extends keyword. The class from which we inherit is referred to as the parent class, and the inheriting class is the child class. The Child class receives all of the member data and functions from the parent class, although functions from the parent class may be overridden ( below ). Because the children contain the functionality of the parent class, references to instances of a child class may be assigned to a parent class reference type.</p>
<p>For now, access modiﬁers (public, protected, private) are included but not fully implemented. Everything is public by default.</p>
<pre><code>// define class X
class X
{
  // define member function
  fun void doThatThing()
  {
    &lt;&lt;&lt;&quot;Hallo&quot;&gt;&gt;&gt;;
  }

  // define another
  fun void hey()
  {
    &lt;&lt;&lt;&quot;Hey!!!&quot;&gt;&gt;&gt;;
  }

  // data
  int the_data;
}

// define child class Y
class Y extends X
{
  // override doThatThing()
  fun void doThatThing()
  {
    &lt;&lt;&lt;&quot;No! Get away from me!&quot;&gt;&gt;&gt;;
  }
}

// instantiate a Y
Y y;

// call doThatThing
y.doThatThing();

// call hey() - should use X’s hey(), since we didn’t override
y.hey();

// data is also inherited from X
&lt;&lt;&lt; y.the_data &gt;&gt;&gt;;</code></pre>
<p>Inheritance provides us a way of efficiently sharing code between classes which perform similar roles. We can deﬁne a particular complex pattern of behavior, while changing the way that certain aspects of the behavior operate.</p>
<pre><code>// parent class defines some basic data and methods
class Xfunc
{
  int x;
  fun int doSomething( int a, int b ) {
    return 0;
  }
}

// child class
// which overrides the doSomething function with an addition operation
class Xadds extends Xfunc
{
  fun int doSomething ( int a, int b )
  {
    return a + b ;
  }
}

// child class, which overrides the doSomething function with a multiply operation
class Xmuls extends Xfunc
{
  fun int doSomething ( int a, int b )
  {
    return a * b;
  }
}

// array of references to Xfunc
Xfunc @ operators[2];

// instantiate two children and assign reference to the array
new Xadds @=&gt; operators[0];
new Xmuls @=&gt; operators[1];

// loop over the Xfunc
for( 0 =&gt; int i; i &lt; operators.cap(); i++ )
{
  // doSomething, potentially different for each Xfunc
  &lt;&lt;&lt; operators[i].doSomething( 4, 5 ) &gt;&gt;&gt;;
}</code></pre>
<p>Because Xmuls and Xadds each redeﬁne doSomething( int a, int b ) with their own code, we say that they have overridden the behavior of the parent class. They observe the same interface, but have potentially different implementation. This is known as polymorphism.</p>
<h2>Overloading</h2>
<p>Function overloading in classes is similar to that of regular functions. see functions.</p>
<p><span id="ch027_arrays.xhtml"></span></p>
<h1>Arrays</h1>
<p>Arrays are used represent N-dimensional ordered sets of data (of the same type). This sections speciﬁes how arrays are declared and used in ChucK. Some quick notes:</p>
<ul>
<li>Arrays can be indexed by integer (0-indexed)</li>
<li>Any array can also be used as an associative map, indexed by strings</li>
<li>It is important to note that the integer-indexed portion and the associative portion of an array are stored in separate namespaces</li>
<li>Arrays are objects (see objects and classes), and will behave similarly under reference assign- ment and other operations common to objects</li>
</ul>
<h2>Declaration</h2>
<p>Arrays can be declared in the following way:</p>
<pre><code>// declare 10 element array of int, called foo
int foo[10];

// since array of int (primitive type), the contents
// are automatically initialized to 0</code></pre>
<p>Arrays can also be initialized:</p>
<pre><code>// chuck intializer to array reference
[ 1, 1, 2, 3, 5, 8 ] @=&gt; int foo[];</code></pre>
<p>In the above code, there are several things to note.</p>
<ul>
<li>Initializers must contain the same or similar types. the compiler will attempt to ﬁnd the highest common base type of all the elements. if no such common element is found, an error is reported.</li>
<li>The type of the initializer [ 1, 1, 2, 3, 5, 8 ] is int[ ]. The intializer is an array that can be used directly when arrays are expected.</li>
<li>The at-chuck operator (@=&gt; ) means assignment, and is discussed at length in the Operators and Operations section.</li>
<li>int foo[ ] is declaring an empty reference to an array. the statement assigns the initializer array to foo.</li>
<li>Arrays are objects.</li>
</ul>
<p>When declaring an array of ob jects, the ob jects inside the array are automatically instantiated.</p>
<pre><code>// objects in arrays are automatically instantiated
Object group[10];</code></pre>
<p>If you only want an array of object references:</p>
<pre><code>// array of null object references
Object @ group[10]; </code></pre>
<p>The above examples are 1-dimensional arrays (or vectors). Coming up next are multi-dimensional arrays!</p>
<h2>Multi-Dimensional Arrays</h2>
<p>Here's a declaration of a multi-dimensional array:</p>
<pre><code>// declare 4 by 6 by 8 array of float
float foo3D[4][6][8];</code></pre>
<p>Initializing a multi-dimensional array works in a similar way:</p>
<pre><code>// declare 2 by 2 array of int
[ [1,3], [2,4] ] @=&gt; int bar[][];</code></pre>
<p>In the above code, note the two [ ][ ] since we make a matrix.</p>
<h2>Lookup</h2>
<p>Elements in an array can be accessed using [ ] (in the appropriate quantities).</p>
<pre><code>// declare an array of floats
[ 3.2, 5.0, 7 ] @=&gt; float foo[];

// access the 0th element (debug print)
&lt;&lt;&lt; foo[0] &gt;&gt;&gt;; // hopefully 3.2

// set the 2nd element
8.5 =&gt; foo[2];</code></pre>
<p>Looping over the elements of an array:</p>
<pre><code>// array of floats again
[ 1, 2, 3, 4, 5, 6 ] @=&gt; float foo[];
// loop over the entire array
for( 0 =&gt; int i; i &lt; foo.cap(); i++ ) {
  // do something (debug print)
  &lt;&lt;&lt; foo[i] &gt;&gt;&gt;;
}</code></pre>
<p>Accessing multi-dimensional array:</p>
<pre><code>// 2D array
int foo[4][4];

// set an element
10 =&gt; foo[2][2];</code></pre>
<p>If the index exceeds the bounds of the array in any dimension, an exception is issued and the current shred is halted.</p>
<pre><code>// array capacity is 5
int foo[5];

// this should cause ArrayOutOfBoundsException
// access element 6 (index 5)
&lt;&lt;&lt; foo[5] &gt;&gt;&gt;;</code></pre>
<p>A longer program: otf_06.ck from the examples folder:</p>
<pre><code>// the period
.5::second =&gt; dur T;
// synchronize to period (for on-the-fly synchronization)
T - (now % T) =&gt; now;
// our patch
SinOsc s =&gt; JCRev r =&gt; dac;
// initialize
.05 =&gt; s.gain;
.25 =&gt; r.mix;
// scale (pentatonic; in semitones)
[ 0, 2, 4, 7, 9 ] @=&gt; int scale[];
// infinite time loop
while( true ) {
  // pick something from the scale
  scale[ Math.rand2(0,4) ] =&gt; float freq;
  // get the final freq
  Std.mtof( 69 + (Std.rand2(0,3)*12 + freq) ) =&gt; s.freq;
  // reset phase for extra bandwidth
  0 =&gt; s.phase;
  // advance time
  if( Std.randf() &gt; -.5 ) .25::T =&gt; now;
  else .5::T =&gt; now;
}</code></pre>
<h2>Associative Arrays</h2>
<p>Any array can be used also as an associative array, indexed on strings. Once the regular array is instantiated, no further work has to be done to make it associative as well - just start using it as such.</p>
<pre><code>// declare regular array (capacity doesn’t matter so much)
float foo[4];

// use as integer-indexed array
2.5 =&gt; foo[0];

// use as associative array
4.0 =&gt; foo[&quot;yoyo&quot;];

// access as associative (print)
&lt;&lt;&lt; foo[&quot;yoyo&quot;] &gt;&gt;&gt;;

// access empty element
&lt;&lt;&lt; foo[&quot;gaga&quot;] &gt;&gt;&gt;; // -&gt; should print 0.0</code></pre>
<p>It is important to note (again), that the address space of the integer portion and the associative portion of the array are completely separate. For example:</p>
<pre><code>// declare array
int foo[2];

// put something in element 0
10 =&gt; foo[0];

// put something in element &quot;0&quot;
20 =&gt; foo[&quot;0&quot;];

// this should print out 10 20
&lt;&lt;&lt; foo[0], foo[&quot;0&quot;] &gt;&gt;&gt;;</code></pre>
<p>The capacity of an array relates only to the integer portion of it. An array with an integer portion of capacity 0, for example, can still have any number of associative indexes.</p>
<pre><code>// declare array of 0 capacity
int foo[0];

// put something in element &quot;here&quot;
20 =&gt; foo[&quot;here&quot;];

// this should print out 20
&lt;&lt;&lt; foo[&quot;here&quot;] &gt;&gt;&gt;

// this should cause an exception
&lt;&lt;&lt; foo[0] &gt;&gt;&gt;</code></pre>
<p>Note: The associative capacity of an array is not deﬁned, so objects used in the associative names- pace must be explicitly instantiated, in contrast to those in the integer namespace.</p>
<p>Accessing an uninstantiated element of the associate array will return a null reference. Please check the class documentation page for an explanation of ChucK objects and references.</p>
<pre><code>class Item {
  float weight;
}
Item box[10];

// integer indices ( up to capacity ) are pre-instantiated.
1.2 =&gt; box[1].weight;

// instantiate element &quot;lamp&quot;;
new Item @=&gt; box[&quot;lamp&quot;];

// access allowed to &quot;lamp&quot;
2.0 =&gt; box[&quot;lamp&quot;].weight;

// access causes a NullPointerException
2.0 =&gt; box[&quot;sweater&quot;].weight; </code></pre>
<h2>Array Assignment</h2>
<p>Arrays are ob jects. So when we declare an array, we are actually (1) declaring a reference to array (reference variable) and (2) instantiating a new array and reference assigned to the variable. A (null) reference is a reference variable that points to no object or null. A null reference to an array can be created in this fasion:</p>
<pre><code>// declare array reference (by not specifying a capacity)
int foo[];

// we can now assign any int[] to foo
[ 1, 2, 3 ] @=&gt; foo;

// print out 0th element
&lt;&lt;&lt; foo[0] &gt;&gt;&gt;;</code></pre>
<p>This is also useful in declaring functions that have arrays as arguments or return type.</p>
<pre><code>// our function
fun void print( int bar[] ) {
  // print it
  for( 0 =&gt; int i; i &lt; bar.cap(); i++ )
  &lt;&lt;&lt; bar[0] &gt;&gt;&gt;;
}

// we can call the function with a literal
print( [ 1, 2, 3, 4, 5 ] );

// or can we can pass a reference variable
int foo[10];
print( foo );</code></pre>
<p>Like other objects, it is possible make multiple references to a single array. Like other ob jects, all assignments are reference assignments, meaning the contents are NOT copied, only a reference to array is duplicated.</p>
<pre><code>// our single array
int the_array[10];

// assign reference to foo and bar
the_array =&gt; int foo[] =&gt; int bar[];

// (the_array, foo, and bar now all reference the same array)
// we change the_array and print foo...
// they reference the same array, changing one is like changing the other
5 =&gt; the_array[0];
&lt;&lt;&lt; foo[0] &gt;&gt;&gt;; // should be 5</code></pre>
<p>It is possible to reference sub-sections of multi-dimensional arrays.</p>
<pre><code>// a 3D array
int foo3D[4][4][4];

// we can make a reference to a sub-section
foo3D[2] =&gt; int bar[][];

// (note that the dimensions must add up!)</code></pre>
<p><span id="ch028_unit-analyzers.xhtml"></span></p>
<h1>Unit Analyzers</h1>
<p>Unit Analyzers (UAnae) are analyis building blocks, similar in concept to unit generators. They perform analysis functions on audio signals and/or metadata input, and produce metadata analysis results as output. Unit analyzers can be linked together and with unit generators to form analysis/synthesis networks. Like unit generators, several unit analyzers may run concurrently, each dynamically controlled at different rates. Because data passed between UAnae is not necessarily audio samples, and the relationship of UAna computation to time is fundamentally different than that of UGens (e.g., UAnae might compute on blocks of samples, or on metadata), the connections between UAnae have a different meaning from the connections between UGens formed with the ChucK operator, =&gt; . This difference is reflected in the choice of a new connection operator, the upChucK operator: =^ . Another key difference between UGens and UAnae is that UAnae perform analysis (only) on demand, via the upchuck() function (see below). Some more quick facts about ChucK unit analyzers:</p>
<ul>
<li>All ChucK unit analyzers are objects (not primitive types). (see objects)<br />
</li>
<li>All ChucK unit analyzers inherit from the UAna class. The operation foo =^ yah, where foo and yah are UAnae, connects foo to yah.<br />
</li>
<li>Unit analyzer parameters and behaviors are controlled by calling / chucking to member functions over time, just like unit generators.<br />
</li>
<li>Analysis results are always stored in an object called a UAnaBlob. The UAnaBlob contains a time-stamp indicating when it was computed, and it may store an array of floats and/or complex values. Each UAna specifies what information is present in the UAnaBlob it produces.<br />
</li>
<li>All unit analyzers have the function upchuck(), which when called issues a cascade of analysis computations for the unit analyzer and any &quot;upstream&quot; unit analyzers on which its analysis depends. In the example of foo yah, yah.upchuck() will result in foo first performing its analysis (possibly requesting analysis results from unit analyzers further upstream), then yah, using foo's analysis results in its computation. upchuck() returns the analysis results in the form of a UAnaBlob.<br />
</li>
<li>Unit analyzers are specially integrated into the virtual machine such that each unit analyzer performs its analysis on its input whenever it or a downstream UAna is upchuck()-ed. Therefore, we have the ability to assert control over the analysis process at any point in time and at any desired control rate.</li>
</ul>
<h2>declaring</h2>
<p>Unit analyzers (UAnae) are objects, and they need to be instantiated before they can be used. We declare unit analyzers the same way we declare UGens and other objects.</p>
<pre><code>// instantiate an FFT, assign reference to variable f
FFT f; </code></pre>
<h2>connecting</h2>
<p>The upChucK operator () is only meaningful for unit analyzers. Similar to the behavior of the ChucK operator between UGens, using to connect one UAna to another connects the analysis results of the first to the analysis input of the second.</p>
<pre><code>// instantiate FFT and flux objects,
// connect to allow computation of spectrum and spectral flux on adc input
adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; </code></pre>
<p>Note that the last UAna in any chain must be chucked to the blackhole or dac to &quot;pull&quot; audio samples from the aaddcc or other unit generators upstream. It is also possible to linearly chain many UAnae together in a single statement. In the example below, the analysis of fluxcapacitor depends on the results of flux, so the flux object will always perform its analysis computation before the computation of fluxcapacitor.</p>
<pre><code>// Set up analysis on adc, via an FFT object, a spectral flux object, and a
// made-up object called a FluxCapacitor that operates on the flux value.
adc =&gt; FFT f =^ Flux flux =^ FluxCapacitor flux_capacitor =&gt; blackhole; </code></pre>
<p>Very importantly, it is possible to create connection networks containing both UAane and UGens. In the example below, an FFT transforms two (added) sinusoidal inputs, one of which has reverb added. An IFFT transforms the spectrum back into the time domain, and the result is processed with a third sinusoid by a gain object before being played through the dac. (No, this example is not supposed to do anything musically interesting, only help you get a feel for the syntax. Notice that any connection through which audio samples are passed is denoted with the operator, and the connection through which spectral data is passed (from the FFT to the IFFT) is denoted with the operator.</p>
<pre><code>//Chain a sine into a reverb, then perform FFT, then IFFT,
//then apply gain, then output
SinOsc s =&gt; JCRev r =&gt; FFT f =^ IFFT i =&gt; Gain g =&gt; dac;
// Chuck a second sine into the FFT
SinOsc s2 =&gt; f;
// Chuck a third sine into the final gain
SinOsc s3 =&gt; g; </code></pre>
<p>FFT, IFFT, and other UAnae that perform transforms between the audio domain and another domain play a special role, as illustrated above. FFT takes audio samples as input, so unit generators connect to it with the ChucK operator =&gt;. However, it outputs analysis results in the spectral domain, so it connects to other UAnae with the upChucK operator =^. Conversely, UAnae producing spectral domain output connect to the IFFT using =&gt;, and IFFT can connect to the dac or other UGens using =&gt;. This syntax allows the programmer to clearly reason about the expected behavior of an analysis/synthesis network, while it hides the internal mechanics of ChucK timing and sample buffering from the programmer. Finally, just as with unit generators, it is possible to dynamically disconnect unit analyzers, using the UnChucK operator (=&gt;or =&lt;).</p>
<h2>controlling (over time)</h2>
<p>In any ChucK program, it is necessary to advance time in order to pull audio samples through the UGen network and create sound. Additionally, it is necessary to trigger analysis computations explicitly in order for any analysis to be performed, and for sound synthesis that depends on analysis results (e.g., IFFT) to be performed. To explicitly trigger computation at a point in time, the UAna's upchuck() member function is called. In the example below, an FFT computation is triggered every 1024 samples.</p>
<pre><code>adc =&gt; FFT fft =&gt; dac;
// set the FFT to be of of size 2048 samples
2048 =&gt; fft.size;
while (true)
{
     // let 1024 samples pass
     1024::samp =&gt; now;
     // trigger the FFT computation on the last 2048 samples (the FFT size)
     fft.upchuck();
}</code></pre>
<p>In the example above, because the FFT size is 2048 samples, the while-loop causes a standard &quot;sliding-window&quot; FFT to be computed, where the hop size is equal to half a window. However, ChucK allows you to perform analysis using nonstandard, dynamically set, or even multiple hop sizes with the same object. For example, in the code below, the FFT object fft performs computation every 5 seconds as triggered by shred1, and it additionally performs computation at a variable rate as triggered by shred2.</p>
<pre><code>adc =&gt; FFT fft =&gt; dac;
2048 =&gt; fft.size;
// spork two shreds: shred1 and shred2
spork ~ shred1();
spork ~ shred2();
// shred1 computes FFT every 5 seconds
shred1()
{
     while (true)
     {
          5::second =&gt; now;
          fft.upchuck();
     }
}
// shred2 computes FFT every n seconds, where n is a random number between 1 and 10
shred2()
{
     while (true)
     {
          Std.Rand2f(1, 10)::second =&gt; now;
          fft.upchuck();
     }
}</code></pre>
<p>Parameters of unit analyzers may be controlled and altered at any point in time and at any control rate. We only have to assert control at the appropriate points as we move through time, by setting various parameters of the unit analyzer. To set the a value for a parameter of a UAna, a value of the proper type should be ChucKed to the corresponding control function.</p>
<pre><code>// connect the input to an FFT
adc =&gt; FFT fft =&gt; blackhole;

//start with a size of 1024 and a Blackman-Harris window
1024 =&gt; fft.size;
Windowing.blackmanHarris(512) =&gt; fft.window;

//advance time and compute FFT
1::minute =&gt; now;
fft.upchuck();

// change window to Hamming
Windowing.hamming(512) =&gt; fft.window;

// let time pass... and carry on.</code></pre>
<p>Since the control functions are member functions of the unit analyzer, the above syntax is equilavent to calling functions. For example, the line below could alternatively be used to change the FFT window to a Hamming window, as above.</p>
<pre><code>fft.window(Windowing.hamming(512)); </code></pre>
<p>For a list of unit analyzers and their control methods, consult UAna reference. Just like unit generators, to read the current value of certain parameters of a Uana, we may call an overloaded function of the same name. Additionally, assignments can be chained together when assigning one value to multiple targets.</p>
<pre><code>// connect adc to FFT
adc =&gt; FFT fft =&gt; blackhole;
// store the current value of the FFT size
fft.size() =&gt; int fft_size; </code></pre>
<p>What if a UAna that performs analysis on a group of audio samples is upchuck()- ed before its internal buffer is filled? This is possible if an FFT of size 1024 is instantiated, then upchuck()-ed after only 1000 samples, for example. In this case, the empty buffer slots are treated as 0's (that is, zero-padding is applied). This same behavior will occur if the FFT object's size is increased from 1024 to 2048, and then only 1023 samples pass after this change is applied; the last sample in the new (larger) buffer will be 0. Keep in mind, then, that certain analysis computations near the beginning of time and analysis computations after certain parameters have changed will logically involve a short &quot;transient&quot; period.</p>
<pre><code>// connect adc to FFT to blackhole
adc =&gt; FFT fft =&gt; blackhole;
// set the FFT size to 1024 samples
1024 =&gt; fft.size;

// allow 1000 samples to pass
1000::samp =&gt; now;

// compute the FFT: the last 24 spots in the FFT buffer haven&#39;t been filled, so they are zero-ed out
// the computation is nevertheless valid and proceeds.
fft.upchuck();

1::minute =&gt; now; // let time pass for a while

// increase the size of the FFT, and therefore the size of the sample buffer it uses
2048 =&gt; fft.size;

// let 1023 samples pass
1023::samp =&gt; now;

// at this point, only 2047 of the 2048 buffer spots have been filled
// the following computation therefore zeros out the last audio buffer spot
fft.upchuck();

1::minute =&gt; now; //let time pass for a while

// now the buffer is happy and
full fft.upchuck(); // proceeds normally on a full buffer </code></pre>
<h2>representing metadata: the UAnaBlob</h2>
<p>It is great to be able to trigger analysis computations like we've been doing above, but what if you want to actually use the analysis results? Luckily, calling the upchuck() function on a UAna returns a reference to an object that stores the results of any UAna analysis, called a UanaBlob. UanaBlobs can contain an array of floats, and/or an array of complex numbers (see the next section). The meaning and formatting of the UanaBlob fields is different for each UAna subtype. FFT, for example (see specification), fills in the complex array with the spectrum and the floating point array with the magnitude spectrum. Additionally, all UanaBlobs store the time when the blob was last computed.</p>
<p>The example below demonstrates how one might access the results of an FFT:</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;
// ... set FFT parameters here ...

UAnaBlob blob;

while (true)
{
     50::ms =&gt; now; // use hop size of 50 ms
     fft.upchuck() @=&gt; blob; // store the result in blob.
     blob.fvals @=&gt; float mag_spec[]; // get the magnitude spectrum as float array
     blob.cvals @=&gt; complex spec[]; // get the whole spectrum as complex array
     mag_spec[0] =&gt; float first_mag; // get the first bin of the magnitude spectrum
     blob.fvals(0) =&gt; float first_mag2 // equivalent way to get first bin of mag spectrum
     fft.upchuck().fvals(0) =&gt; float first_mag3 // yet another equivalent way
     fft.upchuck().cvals(0) =&gt; float first_spec // similarly, get 1st spectrum bin

     blob.when =&gt; time when_computed; // get the time it was computed
}</code></pre>
<p>Beware: whenever a UAna is upchuck()-ed, the contents of its previous UAnaBlob are overwritten. In the following code, blob1 and blob2 refer to the same UAnaBlob. When fft.upchuck() is called the second time, the contents of the UAnaBlob referred to by blob1 are overwritten.</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;

UAnaBlob blob1, blob2;
1::minute =&gt; now; //let time pass for a while
fft.upchuck() @=&gt; blob1; // blob1 points to the analysis results
1::minute =&gt; now; // let time pass again
fft.upchuck() @=&gt; blob2; // now both blob1 and blob2 refer to the same object: the new results! </code></pre>
<p>Also beware: if time is not advanced between subsequent upchuck()s of a UAna, any upchuck() after the first will not re-compute the analysis, even if UAna parameters have been changed. After the code below, blob refers to a UAnaBlob that is the result of computing the first (size 1024) FFT.</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;
1024 =&gt; fft.size;

UAnaBlob blob;
1::minute =&gt; now; //let time pass for a while
fft.upchuck() @=&gt; blob; // blob holds the result of the FFT

512 =&gt; fft.size;
fft.upchuck() @=&gt; blob; // time hasn&#39;t advanced since the last computation,
//so no re-computation is done</code></pre>
<h2>representing complex data: the complex and polar types</h2>
<p>In order to represent complex data, such as the output of an FFT, two new datatypes have been added to ChucK: complex and polar. These types are described with examples here.<br />
</p>
<h2>performing analysis in UAna networks</h2>
<p>Often, the computation of one UAna will depend on the computation results of &quot;upstream&quot; UAnae. For example, in the UAna network below, the spectral flux is computed using the results of an FFT.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; </code></pre>
<p>The flow of computation in UAna networks is set up so that every time a UAna aa is upchuck()-ed, each UAna whose output is connected to aa's input via is upchuck()-ed first, passing the results to aa for it to use. For example, a call to flux.upchuck() will first force fft to compute an FFT on the audio samples in its buffer, then flux will use the UanaBlob from fft to compute the spectral flux. This flow of computation is handled internally by ChucK; you should understand the flow of control, but you don't need to do fft.upchuck() explicitly. Just writing code like that below will do the trick:</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
UAnaBlob blob;
while (true)
{
      100::ms =&gt; now;
      flux.upchuck() @=&gt; blob;
      // causes fft to compute, then computes flux and stores result in blob
}</code></pre>
<p>Additionally, each time a UAna upchuck()s, its results are cached until time passes. This means that a UAna will only perform its computation once for a particular point in time.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole; fft =^ Centroid c =&gt; blackhole; UAnaBlob blob, blob2;
while (true)
{
     100::ms =&gt; now;
     flux.upchuck() @=&gt; blob; // causes fft to compute,
     //then computes flux and stores result in blob
     c.upchuck() @=&gt; blob2; // uses cached fft results from
     //previous line to compute centroid
}</code></pre>
<p>When no upchuck() is performed on a UAna, or on UAnae that depend on it, it will not do computation. For example, in the network below, the flux is never computed.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
UAnaBlob blob;
while (true)
{
     100::ms =&gt; now;
     fft.upchuck() @=&gt; blob; // compute fft only
} </code></pre>
<p>The combination of this &quot;compute-on-demand&quot; behavior and UAna caching means that different UAnae in a network can be upchuck()-ed at various/varying control rates, with maximum efficiency. In the example below, the FFT, centroid, and flux are all computed at different rates. When the analysis times for flux and fft or centroid and fft overlap, fft is computed just once due to its internal caching. When it is an analysis time point for fft but not for flux, flux will not be computed.</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =&gt; blackhole;
fft =^ Centroid c =&gt; blackhole;
UAnaBlob blob1, blob2, blob3;

spork do_fft();
spork do_flux();
spork do_centroid();

voi ddo_fft()
{
     while (true)
     {
          50::ms =&gt; now;
          fft.upchuck() @=&gt; blob1;
     }
}

void do_flux()
{
      while (true)
      {
           110::ms =&gt; now;
           flux.upchuck() @=&gt; blob2;
      }
}

void do_centroid()
{
     while (true)
     {
          250::ms =&gt; now;
          c.upchuck()
          @=&gt; blob3;
     }
}</code></pre>
<p>An easy way to synchronize analysis of many UAnae is to upchuck() an &quot;agglomerator&quot; UAna. In the example below, agglom.upchuck() triggers analysis of all upstream UAnae in the network. Because agglom is only a member of the UAna base class, it does no computation of its own. However, after agglom.upcuck() all other UAnae will have up-to-date results that are synchronized, computed, and cached so that they are available to be accessed via upchuck()on each UAna (possibly by a different shred waiting for an event - see below).</p>
<pre><code>adc =&gt; FFT fft =^ Flux flux =^ UAna agglom =&gt; blackhole;
fft =^ Centroid centroid =&gt; agglom;
// could add abitrarily many more UAnae that connect to agglom via =^

while (true)
{
     100::ms =&gt; now;
     agglom.upchuck();
     // forces computation of both centroid and flux (and therefore fft, too)
} </code></pre>
<p>Because of the dependency and caching behavior of upchuck()-ing in UAna networks, UAna feedback loops should be used with caution. In the network below, each time cc is upchuck()-ed, it forces bb to compute, which forces aa to compute, which then recognizes that bb has been traversed in this upChucK path but has not been able to complete its computation-- thereby recognizing a loop in the network. aa then uses bb's last computed UAnaBlob to perform its computation. This may or may not be desirable, so be careful.</p>
<pre><code>adc =&gt; UAna a =^ UAna b =^ Uana c =&gt; blackhole;
b =^ a; // creates a feedback loop

while (true)
{
     100::ms =&gt; now;
     c.upchuck(); // involves a using b&#39;s analysis results from 100 ms ago
} </code></pre>
<h2>using events</h2>
<p>When a UAna is upchuck()-ed, it triggers an event. In the example below, a separate shred prints the results of FFT whenever it is computed.</p>
<pre><code>adc =&gt; FFT fft =&gt; blackhole;
spork ~printer(); // spork a printing shred

while (true)
{
     50::ms =&gt; now; // perform FFT every 50 ms
     fft.upchuck();
}

void printer()
{
     UAnaBlob blob;
     while (true)
     {
           // wait until fft has been computed
           fft =&gt; now;
           fft.upchuck() @=&gt; blob; // get (cached) fft result

           for (int i = 0; i &lt; blob.fvals().cap(); i++)
               &lt;&lt;&lt; blob.fvals(i) &gt;&gt;&gt;;
     }
} </code></pre>
<h2>built-in unit analyzers</h2>
<p>ChucK has a number of built-in UAna classes. These classes perform many basic transform functions (FFT, IFFT) and feature extraction methods (both spectral and time-domain features). A list of built-in ChucK unit analyzers can be found here.</p>
<h2>creating</h2>
<p>( someday soon you will be able to implement your own unit analyzers! )</p>
<p><span id="ch029_standard-libraries.xhtml"></span></p>
<h1>Standard Libraries API</h1>
<p>ChucK Standard Libraries API these libraries are provide by default with ChucK - new ones can also be imported with ChucK dynamic linking (soon to be documented...). The existing libraries are organized by namespaces in ChucK. They are as follows.</p>
<h2>Std</h2>
<p>Std is a standard library in ChucK, which includes utility functions, random number generation, unit conversions and absolute value.</p>
<pre><code>/* a simple example... */
// infinite time-loop
while( true )
{
    // generate random float (and print)
    Std.rand2f( 100.0, 1000.0 )
    // wait a bit
    50::ms =&gt;now;
}</code></pre>
<ul>
<li>[function] int abs ( int value ) - returns absolute value of integer</li>
</ul>
<ul>
<li>[function] float fabs ( float value ) - returns absolute value of floating point number</li>
</ul>
<ul>
<li>[function] int rand ( ) - generates random integer</li>
<li>[function] int rand2 ( int min, int max ) - generates random integer in the range [min, max]</li>
<li>[function] float randf ( ) - generates random floating point number in the range [-1, 1]</li>
<li>[function] float rand2f ( float min, float max ) - generates random floating point number in the range [min, max]</li>
<li>[function] float srand (int value) - seeds value for random number generation</li>
<li>[function] float sgn ( float value ) - computes the sign of the input as -1.0 (negative), 0 (zero), or 1.0 (positive)</li>
<li>[function] int system ( string cmd ) - pass a command to be executed in the shell</li>
<li>[function] int atoi ( string value ) - converts ascii (string) to integer (int)</li>
<li>[function] float atof ( string value ) - converts ascii (string) to floating point value (float)</li>
<li>[function] string getenv ( string value ) - returns the value of an environment variable, such as of &quot;PATH&quot;</li>
<li>[function] int setenv ( string key, string value ) - sets environment variable named 'key' to 'value</li>
<li>[function] float mtof ( float value ) - converts a MIDI note number to frequency (Hz) note the input value is of type 'float' (supports fractional note number)</li>
<li>[function] float ftom ( float value ) - converts frequency (Hz) to MIDI note number space</li>
<li>[function] float powtodb ( float value ) - converts signal power ratio to decibels (dB)</li>
<li>[function] float rmstodb ( float value ) - converts linear amplitude to decibels (dB)</li>
<li>[function] float dbtopow ( float value ) - converts decibels (dB) to signal power ratio</li>
<li>[function] float dbtorms ( float value ) - converts decibles (dB) to linear amplitude<br />
</li>
</ul>
<h2>Machine</h2>
<p>Machine is ChucK runtime interface to the virtual machine. this interface can be used to manage shreds. They are similar to the On-the-fly Programming Commands, except these are invoked from within a ChucK program, and are subject to the timing mechanism.</p>
<pre><code>//add a file foo.ck to the VM machine.add(&quot;foo.ck&quot;);
//check the virtual machine like using &#39;chuck ^&#39; on the command line
machine.status();
//wait a week and cause ChucK to crash
1::week =&gt; now;
machine.crash();</code></pre>
<ul>
<li>[function] int add ( string path ) - compile and spork a new shred from file at 'path' into the VM now returns the shred ID (see example/machine.ck)</li>
<li>[function] int spork ( string path ) - same as add/+</li>
<li>[function] int remove ( int id ) - remove shred from VM by shred ID (returned by add/spork)</li>
<li>[function] int replace ( int id, string path ) - replace shred with new shred from file returns shred ID , or 0 on error</li>
<li>[function] int status ( ) - display current status of VM same functionality as status/ (see example/status.ck)</li>
<li>[function] void crash ( ) - iterally causes the VM to crash. the very last resort;⁞ use with care. Thanks.</li>
</ul>
<h2>Math</h2>
<p>Math contains the standard math functions. all trigonometric functions expects angles to be in radians.</p>
<pre><code>// print sine of pi/2
&lt;&lt;&lt;&lt; Math.sin( pi / 2.0 ) &gt;&gt;&gt;;</code></pre>
<ul>
<li>[function] float sin ( float x ) - computes the sine of x</li>
<li>[function] float cos ( float x ) - computes the cosine of x</li>
<li>[function] float tan( float x ) - computes the tangent of x</li>
<li>[function] float asin ( float x ) - computes the arc sine of x</li>
<li>[function] float acos ( float x ) - computes the arc cosine of x</li>
<li>[function] float atan ( float x ) - computes the arc tangent of x</li>
<li>[function] float atan2 ( float x ) - computes the principal value of the arc tangent of y/x, using the signs of both arguments to determine the quadrant of the return value</li>
<li>[function] float sinh ( float x ) - computes the hyperbolic sine of x</li>
<li>[function] float cosh ( float x ) - computes the hyperbolic cosine of x</li>
<li>[function] float tanh ( float x ) - computes the hyperbolic tangent of x</li>
<li>[function] float hypot ( float x, float y ) - computes the euclidean distance of the orthogonal vectors (x,0) and (0,y)</li>
<li>[function] float pow ( float x, float y ) - computes x taken to the y-th power</li>
<li>[function] int ensurePow2( int x ) - returns the next largest integer power of 2.<br />
</li>
<li>[function] float sqrt ( float x ) - computes the nonnegative square root of x (x must be &gt;= 0)</li>
<li>[function] float exp ( float x ) - computes ex, the base-e exponential of x</li>
<li>[function] float log ( float x ) - computes the natural logarithm of x</li>
<li>[function] float log2 ( float x ) - computes the logarithm of x to base 2</li>
<li>[function] float log10 ( float x ) - computes the logarithm of x to base 10</li>
<li>[function] float floor ( float x ) - round to largest integral value (returned as float) not greater than x</li>
<li>[function] float ceil ( float x ) - round to smallest integral value (returned as float) not less than x</li>
<li>[function] float round ( float x ) - round to nearest integral value (returned as float)</li>
<li>[function] float trunc ( float x ) - round to largest integral value (returned as float) no greater in magnitude than x</li>
<li>[function] float fmod ( float x, float y ) - computes the floating point remainder of x / y</li>
<li>[function] float remainder ( float x, float y ) - computes the value r such that r = x - n * y, where n is the integer nearest the exact value of x / y. If there are two integers closest to x / y, n shall be the even one. If r is zero, it is given the same sign as x</li>
<li>[function] float min ( float x, float y ) - choose lesser of two values</li>
<li>[function] float max ( float x, float y ) - choose greater of two values</li>
<li>[function] int nextpow2 ( int n ) - computes the integeral (returned as int) smallest power of 2 greater than the value of x</li>
<li>[function] int isinf ( float x ) - is x infinity?</li>
<li>[function] int isnan ( float x ) - is x &quot;not a number&quot;?</li>
<li>[function] float pi - (currently disabled - use pi)</li>
<li>[function] float twopi - (currently disabled)</li>
<li>[function] float e - (currently disabled - use Math.exp(1) )</li>
<li>[float] float Math.INFINITY  -constant representing infinity<br />
</li>
<li>[float] float Math.FLOAT_MAX -constant set to the largest possible value a float can have. <br />
</li>
<li>[float] float Math.FLOAT_MIN_MAG - constant set to the smallest positive value a float can have<br />
</li>
<li>[int] int Math.INT_MAX -constant set to the largest value a integer can have<br />
</li>
</ul>
<p><span id="ch030_event-reference.xhtml"></span></p>
<h1>events</h1>
<h3>Event</h3>
<p><em>event handler</em></p>
<ul>
<li>.signal() signals first waiting shred</li>
<li>.broadcast() signals all shreds</li>
</ul>
<pre><code>Event e;

fun void hi( Event ee)
{	
    ee =&gt; now;
    &lt;&lt;&lt;&quot;success&quot;&gt;&gt;&gt;;
}

spork ~ hi(e);

1::second =&gt; now;
e.signal();
1::second =&gt; now;</code></pre>
<h3>MidiIn</h3>
<p>MIDI receiver</p>
<p>extends Event</p>
<ul>
<li>.open (int, READ/WRITE) set port to receive</li>
<li>.recv (MidiMsg, READ) receives MIDI input (see MIDI tutorial)</li>
</ul>
<h3>MidiOut</h3>
<p>MIDI sender</p>
<p><em>extends Event</em></p>
<ul>
<li>.open (int, READ/WRITE) set port to send</li>
<li>.send (MidiMsg, WRITE) sends MIDI output (see MIDI tutorial)</li>
</ul>
<h3>MidiMsg</h3>
<p>MIDI data holder</p>
<ul>
<li>.data1 (int, READ/WRITE) first byte of data (member variable)</li>
<li>.data2 (int, READ/WRITE) second byte of data (member variable)</li>
<li>.data3 (int, READ/WRITE) third byte of data (member variable) (see MIDI tutorial)</li>
</ul>
<h3>OscRecv</h3>
<p>Open Sound Control receiver</p>
<ul>
<li>.port (int, READ/WRITE) set port to receive</li>
<li>.listen () starts object listening to port</li>
<li>.event (string(name), string(type), READ/WRITE) define string for event to receive (see events tutorial)</li>
</ul>
<h3>OscSend</h3>
<p>Open Sound Control sender</p>
<ul>
<li>.setHost (string(host), int(port), READ/WRITE) set port on the host to receive</li>
<li>.startMsg (string(name), string(type), READ/WRITE)  define string for event to send (see events tutorial)</li>
</ul>
<h3>OscEvent</h3>
<p>Open Sound Control event</p>
<p><em>extends Event</em></p>
<ul>
<li>.nextMsg (int, READ) the number of messages in queue</li>
<li>.getFloat (float, READ) gets float from message</li>
<li>.getInt (int, READ) gets int from message (see events tutorial)</li>
</ul>
<h3>KBHit</h3>
<p>ascii keyboard event</p>
<p><em>extends Event</em></p>
<ul>
<li>.getchar (int, READ) ascii value</li>
<li>.more (int, READ only) returns 1 if multiple keys have been pressed (see events tutorial)</li>
</ul>
<h3>Hid</h3>
<p>HID receiver</p>
<p><em>extends Event</em></p>
<ul>
<li>.openJoystick (int which), (WRITE only) open joystick number</li>
<li>.openMouse (int which), (WRITE only) open mouse number</li>
<li>.openKeyboard (int which), (WRITE only) open keyboard number</li>
<li>.openTiltSensor() opens the sudden motion sensor on Apple notebooks</li>
<li>.globalPollRate( dur period) (OSX only) sets the poll-rate for the sudden motion sensor.<br />
</li>
<li>.open( string name ) open a hid device by name.<br />
</li>
<li>.num () return joystick/mouse/keyboard number</li>
<li>.recv (HidMsg, READ only) writes the next message available for this device to the argument</li>
<li>.read( int, int, HidMsg ) (int) TODO; figure out what this does<br />
</li>
<li>.name () return device name (see events tutorial)</li>
</ul>
<h3>HidMsg</h3>
<p>HID data holder</p>
<ul>
<li>.isAxisMotion (int, READ only) non-zero if this message corresponds to movement of a joystick axis</li>
</ul>
<ul>
<li>.isButtonDown (int, READ only) non-zero if this message corresponds to button down or key down of any device type</li>
<li>.isButtonUp (int, READ only) non-zero if this message corresponds to button up or key up of any device type</li>
<li>.isMouseMotion (int, READ only) non-zero if this message corresponds to motion of a pointing device</li>
<li>.isHatMotion (int, READ only) non-zero if this message corresponds to motion of a joystick hat, point-of-view switch, or directional pad</li>
<li>.which (int, READ/WRITE) HID element number (member variable)</li>
<li>.axisPosition (float, READ/WRITE) position of joystick axis in the range [-1.0, 1.0] (member variable)</li>
<li>.deltaX (float, READ/WRITE) change in X axis of pointing device (member variable)</li>
<li>.deltaY (float, READ/WRITE) change in Y axis of pointing device (member variable)</li>
<li>.deviceNum (float, READ/WRITE) device number which produced this message (member variable)</li>
<li>.deviceType (float, READ/WRITE) device type which produced this message (member variable)</li>
<li>.type (int, READ/WRITE) message/HID element type (member variable)</li>
<li>.idata (int, READ/WRITE) data (member variable)</li>
<li>.fdata (int, READ/WRITE) data (member variable) (see events tutorial)</li>
</ul>
<p><span id="ch031_other-objects-reference.xhtml"></span></p>
<h1>Reference for other object types</h1>
<h2></h2>
<h2>Object</h2>
<p>Basic object type that all other objects extend.</p>
<ul>
<li>.toString()</li>
</ul>
<h2>Shreds</h2>
<p>Objects of type Shred abstract processes running in the virtual machine. They have member functions that deal with how they run relative to each other and to stop them from running if they are no longer needed.</p>
<ul>
<li>.exit() removes the relevant shred (and any child shreds it may have) from the VM. Does not destroy the Shred object.<br />
</li>
<li>.id() returns a int representing the id of the shred.<br />
</li>
<li>.done() returns 1 (int) if the process is done, 0 otherwise<br />
</li>
<li>.running() returns 1 (int) if the process is running, 0 otherwise</li>
</ul>
<h3>me</h3>
<p>Refers to the current shred from inside it. .yield() is only useful in this case; you can't make other shreds yield.</p>
<ul>
<li> .yield() Allows other shreds shreduled for the current time to execute but does not advance time.</li>
</ul>
<h2>StringTokenizer</h2>
<p>Splits a string by whitespace (used to be hidden PRC object)</p>
<ul>
<li>.set(string) sets the string to be tokenized.</li>
</ul>
<ul>
<li>.more() (int) returns 1 if there are more tokens to be taken from the string, 0 otherwise.</li>
</ul>
<ul>
<li>.next() (string) returns the next token as a string and removes it from the tokenizer<br />
</li>
</ul>
<p>see examples/string/token.ck</p>
<h2>ConsoleInput:</h2>
<p>Interim console input (until file I/O)(used to be hidden Skot object)</p>
<ul>
<li>.prompt(string ) (event) prompts the user for input, can be chucked to now.</li>
</ul>
<ul>
<li>.more() (int) returns 1 if there is data to be treated held by the object, 0 otherwise</li>
</ul>
<ul>
<li>.getLine() (string) returns a string of data entered by the user at the prompt<br />
</li>
</ul>
<p>see examples/string/readline.ck</p>
<h2>File IO</h2>
<p>TODO</p>
<p><span id="ch033_unit-generators.xhtml"></span></p>
<h1>Unit Generators</h1>
<p>Unit generators (ugens) can be connected using the ChucK operator ( =&gt; )</p>
<pre><code>adc =&gt; dac;</code></pre>
<p>the above connects the ugen `adc' (a/d convertor, or audio input) to `dac'  (d/a convertor, or audio output).</p>
<p>Ugens can also unlinked (using =&lt;) and relinked (see examples/unchuck.ck).</p>
<p>A unit generator may have 0 or more control parameters.  A Ugen's parameters can be set also using the ChucK operator (=&gt;, or -&gt;)</p>
<pre><code>//connect sine oscillator to dac
SinOsc osc =&gt; dac;
// set the Osc&#39;s frequency to 60.0 hz
60.0 =&gt; osc.freq;</code></pre>
<p> (see examples/osc.ck)</p>
<p>All ugen's have at least the following four parameters:</p>
<ul>
<li>
<p>.gain - (float, READ/WRITE) - set gain.</p>
</li>
<li>
<p>.op - (int, READ/WRITE) - set operation type  </p>
</li>
<ul>
<li>0: stop - always output 0.</li>
<li>1: normal operation, add all inputs (default).<br />
</li>
<li>2: normal operation, subtract all inputs starting from the earliest connected.<br />
</li>
<li>3: normal operation, multiply all inputs.    <br />
</li>
<li>4 : normal operation, divide inputs starting from the earlist connected.<br />
</li>
<li>-1: passthru - all inputs to the ugen are summed and passed directly to output.  </li>
</ul>
<li>
<p>.last - (float, READ/WRITE) - returns the last sample computed by the unit generator as a float.<br />
</p>
</li>
<li>
<p>.channels - (int, READ only) - the number channels on the UGen</p>
</li>
<li>
<p>.chan - (int) - returns a reference on a channel (0 -N-1)</p>
</li>
<li>
<p>.isConnectedTo( Ugen )  returns 1 if the unit generator connects to the argument, 0 otherwise.<br />
</p>
</li>
</ul>
<p>Multichannel UGens are adc, dac, Pan2, Mix2</p>
<pre><code>Pan2 p;    
// assumes you called chuck with at least --chan5 or -c5    
p.chan(1) =&gt; dac.chan(4);</code></pre>
<h2>Audio output</h2>
<h3>dac</h3>
<p>Digital -&gt; analog converter abstraction for underlying audio output device</p>
<ul>
<li>.left - (UGen) - input to left channel</li>
<li>.right - (UGen) - input to right channel</li>
<li>.chan( int n ) - (UGen) - input to channel N on the device (0 -N-1)</li>
<li>.channels - (int, READ only) - returns the number of channels open on device</li>
</ul>
<h3>adc</h3>
<p>Analog -&gt; digital converter abstraction for underlying audio input device. Note that this is system-wide and so all outputs can be read from as well, for example to record the signals that ChucK is generating to a wave file.</p>
<ul>
<li>.left - (UGen) - output to left channel</li>
<li>.right - (UGen) - output to right channel</li>
<li>.chan( int n ) - (UGen) - output to channel N on the device (0 -N-1)</li>
<li>.channels - (int, READ only) - returns the number of channels open on device</li>
</ul>
<h3>blackhole</h3>
<p>Sample rate sample sucker ( like dac it ticks ugens, but no more ). Useful for generating modulation signals that aren't ever send to the soundcard. While it is system-wide like dac it can't be read from; it's output will always be zero.</p>
<p>see examples/pwm.ck</p>
<h3>UGen</h3>
<p>Utility class that all other ugens inherit from. Useful in some cases to abstract sets of ugen types.<br />
</p>
<p><br />
</p>
<h2>wave forms</h2>
<h3>Impulse</h3>
<p>Pulse generator - can set the value of the next sample. Default for each sample is 0 if not set</p>
<ul>
<li>.next - (float, READ/WRITE) - set value of next sample</li>
</ul>
<p>see examples/impulse_example.ck</p>
<h3>Step</h3>
<p>Step generator - like Impulse, but once a value is set, it is held for all following samples, until the value is set again</p>
<ul>
<li>.value - (float, READ/WRITE) - set the current value</li>
<li>.next - (float, READ/WRITE) - set the step value examples/step_example.ck</li>
</ul>
<p>see examples/step.ck</p>
<h2>basic signal processing</h2>
<h3>Gain</h3>
<p>Gain control (NOTE - all unit generators can themselves change their gain) (this is a way to add N outputs together and scale them). Gain is in fact identical in function to the UGen mother class that all other UGens extend.</p>
<ul>
<li>.gain - (float, READ/WRITE) - set gain ( all ugen's have this) examples/gain_example.ck</li>
</ul>
<p>Used in examples/i-robot.ck </p>
<p> </p>
<h3>HalfRect</h3>
<p>Half wave rectifier for half-wave rectification. Only passes the signal if it's values positive, outputs zero otherwise </p>
<h3>FullRect</h3>
<p>Full wave rectifier. Transparent for positive input values, inverts negative ones.</p>
<h3>ZeroX</h3>
<p>Zero crossing detector. Emits a pulse lasting a single sample at the the zero crossing in the direction of the zero crossing.</p>
<h3>(see examples/zerox.ck)</h3>
<ul>
</ul>
<h2>filters</h2>
<p>Before using filters in ChucK, for the sake of your ears and your speakers, please read the following thread <a href="http://www.electro-music.com/forum/topic-37921.html" class="uri">http://www.electro-music.com/forum/topic-37921.html</a></p>
<h3>BiQuad</h3>
<p>BiQuad (two-pole, two-zero) filter class. examples/ugen/BiQuad.txt</p>
<ul>
<li>.b2 (float, READ/WRITE) filter coefficient</li>
<li>.b1 (float, READ/WRITE) filter coefficient</li>
<li>.b0 (float, READ/WRITE) filter coefficient</li>
<li>.a2 (float, READ/WRITE) filter coefficient</li>
<li>.a1 (float, READ/WRITE) filter coefficient</li>
<li>.a0 (float, READ only) filter coefficient</li>
<li>.pfreq (float, READ/WRITE) set resonance frequency (poles)</li>
<li>.prad (float, READ/WRITE) pole radius (&lt;= 1 to be stable)</li>
<li>.zfreq (float, READ/WRITE) notch frequency</li>
<li>.zrad (float, READ/WRITE) zero radius</li>
<li>.norm (float, READ/WRITE) normalization</li>
<li>.eqzs (float, READ/WRITE) equal gain zeroes</li>
</ul>
<h3>BPF</h3>
<p>Band pass filter.  2nd order Butterworth. (In the future, this class may be expanded so that order and type of filter can be set.) extends FilterBasic</p>
<ul>
<li>.freq (float, READ/WRITE) center frequency (Hz)</li>
<li>.Q (float, READ/WRITE) Q (default is 1)</li>
<li>.set (float, float WRITE only) set freq and Q</li>
</ul>
<h3>BRF</h3>
<p>Band reject filter.  2nd order Butterworth. (In the future, this class may be expanded so that order and type of filter can be set.) extends FilterBasic</p>
<ul>
<li>.freq (float, READ/WRITE) center frequency (Hz)</li>
<li>.Q (float, READ/WRITE) Q (default is 1)</li>
<li>.set (float, float WRITE only) set freq and Q</li>
</ul>
<h3>Filter</h3>
<p>STK filter class.</p>
<ul>
<li>.coefs (string, WRITE only)</li>
</ul>
<p>examples/ugen/Filter.txt</p>
<h3>FilterBasic</h3>
<p>base class, don't instantiate.</p>
<ul>
<li>.freq (float, READ/WRITE) cutoff/center frequency (Hz)</li>
<li>.Q (float, READ/WRITE) resonance/Q</li>
<li>.set (float, float WRITE only) set freq and Q<br />
</li>
</ul>
<h3>HPF</h3>
<p>Resonant high pass filter.  2nd order Butterworth. (In the future, this class may be expanded so that order and type of filter can be set.) extends FilterBasic</p>
<ul>
<li>.freq (float, READ/WRITE) cutoff frequency (Hz)</li>
<li>.Q (float, READ/WRITE) resonance (default is 1)</li>
<li>.set (float, float WRITE only) set freq and Q</li>
</ul>
<h3>LPF</h3>
<p>Resonant low pass filter.  2nd order Butterworth. (In the future, this class may be expanded so that order and type of filter can be set.) extends FilterBasic</p>
<ul>
<li>.freq (float, READ/WRITE) cutoff frequency (Hz)</li>
<li>.Q (float, READ/WRITE) resonance (default is 1)</li>
<li>.set (float, float WRITE only) set freq and Q</li>
</ul>
<h3>OnePole</h3>
<p>STK one-pole filter class. examples/ugen/OnePole.txt</p>
<ul>
<li>.a1 (float, READ/WRITE) filter coefficient</li>
<li>.b0 (float, READ/WRITE) filter coefficient</li>
<li>.pole (float, READ/WRITE) set pole position along real axis of z-plane</li>
</ul>
<h3>OneZero</h3>
<p>STK one-zero filter class.</p>
<ul>
<li>.zero (float, READ/WRITE) set zero position</li>
<li>.b0 (float, READ/WRITE) filter coefficient</li>
<li>.b1 (float, READ/WRITE) filter coefficient</li>
</ul>
<p>examples/ugen/OneZero.txt<br />
</p>
<h3>PoleZero</h3>
<p>STK one-pole, one-zero filter class. examples/ugen/PoleZero.txt</p>
<ul>
<li>.a1 (float, READ/WRITE) filter coefficient</li>
<li>.b0 (float, READ/WRITE) filter coefficient</li>
<li>.b1 (float, READ/WRITE) filter coefficient</li>
<li>.blockZero (float, READ/WRITE) DC blocking filter with given pole position</li>
<li>.allpass (float, READ/WRITE) allpass filter with given coefficient</li>
</ul>
<h3>ResonZ</h3>
<p>Resonance filter.  Same as BiQuad with equal gain zeros. extends FilterBasic</p>
<ul>
<li>.freq (float, READ/WRITE) center frequency (Hz)</li>
<li>.Q (float, READ/WRITE) Q (default is 1)</li>
<li>.set (float, float WRITE only) set freq and Q</li>
</ul>
<h3>TwoPole</h3>
<p>STK two-pole filter class.</p>
<ul>
<li>.a1 (float, READ/WRITE) filter coefficient</li>
<li>.a2 (float, READ/WRITE) filter coefficient</li>
<li>.b0 (float, READ/WRITE) filter coefficient</li>
<li>.freq (float, READ/WRITE) filter resonance frequency</li>
<li>.radius (float, READ/WRITE) filter resonance radius</li>
<li>.norm (float, READ/WRITE) toggle filter normalization</li>
</ul>
<p>see examples/powerup.ck examples/ugen/TwoPole.txt</p>
<h3>TwoZero</h3>
<p>STK two-zero filter class.</p>
<ul>
<li>.b0 (float, READ/WRITE) filter coefficient</li>
<li>.b1 (float, READ/WRITE) filter coefficient</li>
<li>.b2 (float, READ/WRITE) filter coefficient</li>
<li>.freq (float, READ/WRITE) filter notch frequency</li>
<li>.radius (float, READ/WRITE) filter notch radius</li>
</ul>
<p>examples/ugen/TwoZero.txt</p>
<h2>sound files</h2>
<h3>LiSa</h3>
<p>live sampling utility by Dan Trueman.</p>
<p>LiSa provides basic live sampling functionality. An internal buffer stores samples chucked to LiSa's input. Segments of this buffer can be played back, with ramping and speed/direction control. Multiple voice facility is built in, allowing for a single LiSa object to serve as a source for sample layering and granular textures.</p>
<ul>
<li>.duration - ( dur , READ/WRITE ) - sets buffer size; required to allocate memory, also resets all parameter values to default<br />
</li>
<li>.record - ( int , READ/WRITE ) - turns recording on and off<br />
</li>
<li>.getVoice - ( int READ ) - returns the voice number of the next available voice<br />
</li>
<li>.maxVoices - ( int , READ/WRITE ) - sets the maximum number of voices allowable; 10 by default (200 is the current hardwired internal limit)<br />
</li>
<li>.play - ( int, WRITE ) - turn on/off sample playback (voice 0)<br />
</li>
<li>.play - ( int voice, int, WRITE) - for particular voice (arg 1), turn on/off sample playback<br />
</li>
<li>.rampUp - ( dur, WRITE ) - turn on sample playback, with ramp (voice 0)<br />
</li>
<li>.rampUp - ( int voice dur, WRITE ) - for particular voice (arg 1), turn on sample playback, with ramp<br />
</li>
<li>.rampDown - ( dur, WRITE ) - turn off sample playback, with ramp (voice 0)<br />
</li>
<li>.rampDown - ( int voice, dur, WRITE ) - for particular voice (arg 1), turn off sample playback, with ramp<br />
</li>
<li>.rate - ( float, WRITE ) - set playback rate (voice 0). Note that the int/float type for this method will determine whether the rate is being set (float, for voice 0) or read (int, for voice number)<br />
</li>
<li>.rate - ( int voice, float, WRITE ) - for particular voice (arg 1), set playback rate<br />
</li>
<li>.rate - ( READ ) - get playback rate (voice 0)<br />
</li>
<li>.rate - ( int voice, READ ) - for particular voice (arg 1), get playback rate. Note that the int/float type for this method will determine whether the rate is being set (float, for voice 0) or read (int, for voice number)<br />
</li>
<li>.playPos - ( READ ) - get playback position (voice 0)<br />
</li>
<li>.playPos - ( int voice, READ ) - for particular voice (arg 1), get playback position<br />
</li>
<li>.playPos - ( dur, WRITE ) - set playback position (voice 0)<br />
</li>
<li>.playPos - ( int voice, dur, WRITE ) - for particular voice (arg 1), set playback position<br />
</li>
<li>.recPos - ( dur, READ/WRITE ) - get/set record position<br />
</li>
<li>.recRamp - ( dur , READ/WRITE ) - set ramping when recording (from 0 to loopEndRec)<br />
</li>
<li>.loopRec - ( int, READ/WRITE ) - turn on/off loop recording<br />
</li>
<li>.loopEndRec - ( dur, READ/WRITE ) - set end point in buffer for loop recording<br />
</li>
<li>.loopStart - ( dur , READ/WRITE ) - set loop starting point for playback (voice 0). only applicable when 1 =&gt; loop.<br />
</li>
<li>.loopStart - ( int voice, dur , WRITE ) - for particular voice (arg 1), set loop starting point for playback. only applicable when .loop(voice, 1).<br />
</li>
<li>.loopEnd - ( dur , READ/WRITE ) - set loop ending point for playback (voice 0). only applicable when 1 =&gt; loop.<br />
</li>
<li>.loopEnd - ( int voice, dur , WRITE ) - for particular voice (arg 1), set loop ending point for playback. only applicable when .loop(voice, 1).<br />
</li>
<li>.loop - ( int , READ/WRITE ) - turn on/off looping (voice 0)<br />
</li>
<li>.loop - ( int voice, int, READ/WRITE ) - for particular voice (arg 1), turn on/off looping .bi - ( int , READ/WRITE ) - turn on/off bidirectional playback (voice 0)<br />
</li>
<li>.bi - ( int voice, int , WRITE ) - for particular voice (arg 1), turn on/off bidirectional playback .</li>
<li>voiceGain - ( float , READ/WRITE ) - set playback gain (voice 0) .voiceGain - ( int voice, float , WRITE ) - for particular voice (arg 1), set gain<br />
</li>
<li>.feedback - ( float , READ/WRITE ) - get/set feedback amount when overdubbing (loop recording; how much to retain)<br />
</li>
<li>.valueAt - ( dur, READ ) - get value directly from record buffer<br />
</li>
<li>.valueAt - ( sample, dur, WRITE ) - set value directly in record buffer<br />
</li>
<li>.sync - (int, READ/WRITE) - set input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)<br />
</li>
<li>.track - (int, READ/WRITE) - identical to sync<br />
</li>
<li>.clear - clear recording buffer</li>
</ul>
<p>See examples/special (various files)</p>
<h3>SndBuf</h3>
<p>sound buffer ( now interpolating ) reads from a variety of file formats see examples/sndbuf.ck</p>
<ul>
<li>.read - (string, WRITE only) - loads file for reading</li>
<li>.chunks - (int, READ/WRITE) - size of chunk ( of frames) to read on-demand; 0 implies entire file, default; must be set before reading to take effect.</li>
<li>.write - (string, WRITE only) - loads a file for writing (currently unimplemented)</li>
<li>.pos - (int, READ/WRITE) - set position (0 p .samples)</li>
<li>.valueAt - (int, READ only) - returns the value at sample index .loop - (int, READ/WRITE) - toggle looping</li>
<li>.interp - (int, READ/WRITE) - set interpolation (0=drop, 1=linear, 2=sinc)</li>
<li>.rate - (float, READ/WRITE) - playback rate (relative to the file's natural speed)</li>
<li>.play - (float, READ/WRITE) - play (same as rate)</li>
<li>.freq - (float, READ/WRITE) - playback rate (file loops/second)</li>
<li>.phase - (float, READ/WRITE) - set phase position (0-1)</li>
<li>.channel - (int, READ/WRITE) - select channel (0 x .channels)</li>
<li>.phaseOffset - (float, READ/WRITE) - set a phase offset</li>
<li>.samples - (int, READ only) - fetch number of samples</li>
<li>.length - (dur, READ only) - fetch length as duration</li>
<li>.channels - (int, READ only) - fetch number of channels</li>
</ul>
<p><br />
</p>
<h3>WvIn</h3>
<p>STK audio data input base class. examples/ugen/WvIn.txt</p>
<ul>
<li>.rate (float, READ/WRITE) playback rate</li>
<li>.path (string, READ/WRITE) specifies file to be played</li>
</ul>
<p><br />
</p>
<h3>WaveLoop</h3>
<p>STK waveform oscillator class. see examples/dope.ck   examples/ugen/WaveLoop.txt</p>
<ul>
<li>.freq (float, READ/WRITE) frequency of playback (loops/second)</li>
<li>.addPhase (float, READ/WRITE) offset by phase</li>
<li>.addPhaseOffset (float, READ/WRITE) set phase offset</li>
</ul>
<h3>WvOut</h3>
<p>STK audio data output base class. examples/ugen/WvOut.txt</p>
<ul>
<li>.matFilename (string, WRITE only) open a matlab file for writing</li>
<li>.sndFilename (string, WRITE only) open snd file for writing</li>
<li>.wavFilename (string, WRITE only) open WAVE file for writing</li>
<li>.rawFilename (string, WRITE only) open raw file for writing</li>
<li>.aifFilename (string, WRITE only) open AIFF file for writing</li>
<li>.closeFile () close file properly </li>
</ul>
<h2>network</h2>
<h3>netout</h3>
<p>UDP-based network audio transmitter</p>
<ul>
<li>.addr (string, READ/WRITE) target address</li>
<li>.port (int, READ/WRITE) target port</li>
<li>.size (int, READ/WRITE) packet size</li>
<li>.name (string, READ/WRITE) name</li>
</ul>
<h3>netin</h3>
<p>UDP-based network audio receiver</p>
<ul>
<li>.port (int, READ/WRITE) set port to receive</li>
<li>.name (string, READ/WRITE) name</li>
</ul>
<h2>mono &lt;- -&gt; stereo</h2>
<h3>Pan2</h3>
<p>Spread mono signal to stereo see examples/stereo/moe2.ck</p>
<ul>
<li>.left (UGen) left (mono) channel out</li>
<li>.right (UGen) right (mono) channel out</li>
<li>.pan (float, READ/WRITE) pan location value (-1 to 1)</li>
</ul>
<h3>Mix2</h3>
<p>Mixes stereo input down to mono channel. Note that without this UGen or gain adjustment chucking stereo signals into a mono input will result in summing them, which may cause clipping.</p>
<ul>
<li>.left - (UGen) left (mono) channel in</li>
<li>.right - (UGen) right (mono) channel in</li>
<li>.pan - (float, READ/WRITE) mix parameter value (0 - 1)</li>
</ul>
<p>STK - Delay</p>
<h3>Delay</h3>
<p>STK non-interpolating delay line class</p>
<p>see examples/netrelay.ck<br />
</p>
<ul>
<li>.delay (dur, READ/WRITE) length of delay</li>
<li>.max (dur, READ/WRITE) max delay (buffer size)</li>
</ul>
<h3>DelayA</h3>
<p>STK allpass interpolating delay line class. examples/ugen/DelayA.txt</p>
<ul>
<li>.delay (dur, READ/WRITE) length of delay</li>
<li>.max (dur, READ/WRITE) max delay (buffer size)</li>
</ul>
<h3>DelayL</h3>
<p>STK linear interpolating delay line class.</p>
<ul>
<li>.delay (dur, READ/WRITE) length of delay</li>
<li>.max (dur, READ/WRITE) max delay (buffer size)</li>
</ul>
<p>see examples/i-robot.ck</p>
<h3>Echo</h3>
<p>STK echo effect class.  <br />
</p>
<ul>
<li>.delay (dur, READ/WRITE) length of echo</li>
<li>.max (dur, READ/WRITE) max delay</li>
<li>.mix (float, READ/WRITE) mix level (wet/dry)</li>
</ul>
<h2>STK - Envelopes</h2>
<h3>Envelope</h3>
<p>STK envelope base class.</p>
<ul>
<li>.keyOn (int, WRITE only) ramp to 1.0</li>
<li>.keyOff (int, WRITE only) ramp to 0.0</li>
<li>.target (float, READ/WRITE) ramp to arbitrary value</li>
<li>.time (float, READ/WRITE) time to reach target (in second)</li>
<li>.duration (dur, READ/WRITE) time to reach target</li>
<li>.rate (float, READ/WRITE) rate of change</li>
<li>.value (float, READ/WRITE) set immediate value</li>
</ul>
<p>see examples/sixty.ck</p>
<h3>ADSR</h3>
<p>STK ADSR envelope class.</p>
<ul>
<li>.keyOn (int, WRITE only) start the attack for non-zero values</li>
<li>.keyOff (int, WRITE only) start the release for non-zero values</li>
<li>.attackTime (dur, WRITE only) attack time</li>
<li>.attackRate (float, READ/WRITE) attack rate</li>
<li>.decayTime (dur, READ/WRITE) decay</li>
<li>.decayRate (float, READ/WRITE) decay rate</li>
<li>.sustainLevel (float, READ/WRITE) sustain level</li>
<li>.releaseTime (dur, READ/WRITE) release time</li>
<li>.releaseRate (float, READ/WRITE) release rate</li>
<li>.state (int, READ only) attack=0, decay=1, sustain=2, release=3,done=4</li>
</ul>
<p>see examples/adsr.ck</p>
<h2>STK - Reverbs</h2>
<h3>JCRev</h3>
<p>John Chowning's reverberator class. </p>
<ul>
<li>.mix (float, READ/WRITE) mix level</li>
</ul>
<h3>NRev</h3>
<p>CCRMA's NRev reverberator class.<br />
</p>
<ul>
<li>.mix (float, READ/WRITE) mix level</li>
</ul>
<h3>PRCRev</h3>
<p>Perry's simple reverberator class. </p>
<ul>
<li>.mix (float, READ/WRITE) mix level</li>
</ul>
<h2>STK - Components</h2>
<h3>Chorus</h3>
<p>STK chorus effect class.<br />
</p>
<ul>
<li>.modFreq (float, READ/WRITE) modulation frequency</li>
<li>.modDepth (float, READ/WRITE) modulation depth</li>
<li>.mix (float, READ/WRITE) effect mix</li>
<li>.baseDelay( dur ) sets current base delay<br />
</li>
</ul>
<p><br />
</p>
<h3>PitShift</h3>
<p>STK simple pitch shifter effect class. </p>
<ul>
<li>.mix (float, READ/WRITE) effect dry/wet mix level</li>
<li>.shift (float, READ/WRITE) degree of pitch shifting</li>
</ul>
<p> </p>
<h3><span class="name">Dyno</span></h3>
<p>Dynamics processor by Matt Hoffman and Graham Coleman. Includes limiter, compressor, expander, noise gate, and ducker (presets)</p>
<table>
<tbody>
<tr class="odd">
<td> preset</td>
<td>slopeAbove<br />
</td>
<td>slopeBelow<br />
</td>
<td>tresh<br />
</td>
<td>attackTime<br />
</td>
<td>releaseTime<br />
</td>
<td>ext.side<br />
</td>
</tr>
<tr class="even">
<td>limiter<br />
</td>
<td>0.1<br />
</td>
<td> 1.0</td>
<td>0.5<br />
</td>
<td>5::ms<br />
</td>
<td>300::ms<br />
</td>
<td>false</td>
</tr>
<tr class="odd">
<td>compressor</td>
<td>0.5<br />
</td>
<td>1.0<br />
</td>
<td>0.5</td>
<td>5::ms</td>
<td>300::ms<br />
</td>
<td>false</td>
</tr>
<tr class="even">
<td>expander<br />
</td>
<td>2.0<br />
</td>
<td>1.0<br />
</td>
<td>0.5<br />
</td>
<td>20::ms<br />
</td>
<td>400::ms<br />
</td>
<td>false<br />
</td>
</tr>
<tr class="odd">
<td> noise gate<br />
</td>
<td>1.0<br />
</td>
<td> 10000000</td>
<td>0.1<br />
</td>
<td>11::ms<br />
</td>
<td>100::ms<br />
</td>
<td>false<br />
</td>
</tr>
<tr class="even">
<td> ducker</td>
<td>0.5<br />
</td>
<td> 1.0</td>
<td>0.1<br />
</td>
<td>100::ms<br />
</td>
<td>second<br />
</td>
<td>true</td>
</tr>
</tbody>
</table>
<p> </p>
<div class="members">
<em>(control parameters)</em>
<ul>
<li><strong>.limit</strong> - () - <span class="comment">set parameters to default limiter values</span></li>
<li><strong>.compress</strong> - () - <span class="comment">set parameters to default compressor values</span></li>
<li><strong>.expand</strong> - () - <span class="comment">set parameters to default expander values</span></li>
<li><strong>.gate</strong> - () - <span class="comment">set parameters to default noise gate values</span></li>
<li><strong>.duck</strong> - () - <span class="comment">set parameters to default ducker values</span></li>
<li><strong>.thresh</strong> - ( float, READ/WRITE ) - <span class="comment">the point above which to stop using slopeBelow and start using slopeAbove to determine output gain vs input gain</span></li>
<li><strong>.attackTime</strong> - ( dur, READ/WRITE ) - <span class="comment">duration for the envelope to move linearly from current value to the absolute value of the signal's amplitude</span></li>
<li><strong>.releaseTime</strong> - ( dur, READ/WRITE ) - <span class="comment">duration for the envelope to decay down to around 1/10 of its current amplitude, if not brought back up by the signal</span></li>
<li><strong>.ratio</strong> - ( float, READ/WRITE ) - <span class="comment">alternate way of setting slopeAbove and slopeBelow; sets slopeBelow to 1.0 and slopeAbove to 1.0 / ratio </span></li>
<li><strong>.slopeBelow</strong> - ( float, READ/WRITE ) - <span class="comment">determines the slope of the output gain vs the input envelope's level in dB when the envelope is below thresh. For example, if slopeBelow were 0.5, thresh were 0.1, and the envelope's value were 0.05, the envelope's amplitude would be about 6 dB below thresh, so a gain of 3 dB would be applied to bring the output signal's amplitude up to only 3 dB below thresh. in general, setting slopeBelow to be lower than slopeAbove results in expansion of dynamic range.</span></li>
<li><strong>.slopeAbove</strong> - ( float, READ/WRITE ) - <span class="comment">determines the slope of the output gain vs the input envelope's level in dB when the envelope is above thresh. For example, if slopeAbove were 0.5, thresh were 0.1, and the envelope's value were 0.2, the envelope's amplitude would be about 6 dB above thresh, so a gain of -3 dB would be applied to bring the output signal's amplitude up to only 3 dB above thresh. in general, setting slopeAbove to be lower than slopeBelow results in compression of dynamic range</span></li>
<li><strong>.sideInput</strong> - ( float, READ/WRITE ) - <span class="comment">if externalSideInput is set to true, replaces the signal being processed as the input to the amplitude envelope. see dynoduck.ck for an example of using an external side chain.</span></li>
<li><strong>.externalSideInput</strong> - ( int, READ/WRITE ) - <span class="comment">set to true to cue the amplitude envelope off of sideInput instead of the input signal. note that this means you will need to manually set sideInput every so often. if false, the amplitude envelope represents the amplitude of the input signal whose dynamics are being processed. see dynoduck.ck for an example of using an external side chain.</span></li>
</ul>
</div>
<p>See examples/special/Dyno-limit.ck</p>
<p><span id="ch034_ugens-oscillators.xhtml"></span></p>
<h1>Oscillator ugens</h1>
<h2>Basic Oscillators</h2>
<h3>Phasor</h3>
<p>simple ramp generator ( 0 to 1 ) this can be fed into other oscillators ( with sync mode of 2 ) as a phase control. see examples/sixty.ck for an example</p>
<ul>
<li>.freq  (float, READ/WRITE)  oscillator frequency (Hz)</li>
<li>.sfreq  (float, READ/WRITE)  oscillator frequency (Hz), phase-matched</li>
<li>.phase  (float, READ/WRITE)  current phase</li>
<li>.sync  (int, READ/WRITE)  (0) sync frequency to input, (1) sync phase to input, (2) fm synth</li>
<li>.width  (float, READ/WRITE)  set duration of the ramp in each cycle. (default 1.0)</li>
</ul>
<p> </p>
<h3>SinOsc</h3>
<p>sine wave oscillator</p>
<ul>
<li>.freq  (float, READ/WRITE)  oscillator frequency (Hz)</li>
<li>.sfreq  (float, READ/WRITE)  oscillator frequency (Hz), phase-matched</li>
<li>.phase  (float, READ/WRITE)  current phase</li>
<li>.sync  (int, READ/WRITE) (0) sync frequency to input, (1) sync phase to input, (2) fm synth</li>
</ul>
<pre><code>SinOsc s =&gt; dac;

440 =&gt; s.freq;

1::second =&gt; now;</code></pre>
<p>see examples/osc.ck</p>
<h3>PulseOsc</h3>
<p>pulse oscillators a pulse wave oscillator with variable width.</p>
<ul>
<li>.freq  (float, READ/WRITE)  oscillator frequency (Hz)</li>
<li>.sfreq  (float, READ/WRITE)  oscillator frequency (Hz), phase-matched</li>
<li>.phase  (float, READ/WRITE)  current phase</li>
<li>.sync  (int, READ/WRITE) (0) sync frequency to input, (1) sync phase to input, (2) fm synth</li>
<li>.width  (float, WRITE)  length of duty cycle (0 - 1)</li>
</ul>
<h3>SawOsc</h3>
<p>sawtooth wave oscillator ( triangle, width forced to 0.0 or 1.0 )</p>
<ul>
<li>.freq  (float, READ/WRITE)  oscillator frequency (Hz)</li>
<li>.sfreq  (float, READ/WRITE)  oscillator frequency (Hz), phase-matched</li>
<li>.phase  (float, READ/WRITE)  current phase</li>
<li>.sync  (int, READ/WRITE) (0) sync frequency to input, (1) sync phase to input, (2) fm synth .width  (float, READ/WRITE)  increasing ( w 0.5 ) or decreasing ( w 0.5 )</li>
</ul>
<h3>TriOsc</h3>
<p>triangle wave oscillator</p>
<ul>
<li>.freq  (float, READ/WRITE)  oscillator frequency (Hz)</li>
<li>.sfreq  (float, READ/WRITE)  oscillator frequency (Hz), phase-matched</li>
<li>.phase  (float, READ/WRITE)  current phase</li>
<li>.sync  (int, READ/WRITE) (0) sync frequency to input, (1) sync phase to input, (2) fm synth</li>
<li>.width  (float, READ/WRITE)  control midpoint of triangle (0 - 1)</li>
</ul>
<p><br />
</p>
<h3>SqrOsc</h3>
<p>square wave oscillator</p>
<ul>
<li>.freq  (float, READ/WRITE)  oscillator frequency (Hz)</li>
<li>.sfreq  (float, READ/WRITE)  oscillator frequency (Hz), phase-matched</li>
<li>.phase  (float, READ/WRITE)  current phase</li>
<li>.sync  (int, READ/WRITE)  (0) sync frequency to input, (1) sync phase to input, (2) fm synth</li>
<li>.width  (float, WRITE)  fixed duty cycle of 0.5</li>
</ul>
<h2>Band Limited Oscillators</h2>
<h3>Blit</h3>
<p>band limited impulse train oscillator</p>
<ul>
<li>.freq (float, READ/WRITE) oscillator frequency (Hz)</li>
<li>.phase (float, READ/WRITE) current phase</li>
<li>.harmonics (int, READ/WRITE) number of harmonics</li>
</ul>
<p>see examples/impulse_example.ck</p>
<h3>BlitSaw</h3>
<p>band limited sawtooth wave oscillator</p>
<ul>
<li>.freq  (float, READ/WRITE)  oscillator frequency (Hz)</li>
<li>.phase  (float, READ/WRITE)  current phase</li>
<li>.harmonics  (int, READ/WRITE) number of harmonics</li>
</ul>
<h3>BlitSquare</h3>
<p>band limited square wave oscillator</p>
<ul>
<li>.freq (float, READ/WRITE) oscillator frequency (Hz)</li>
<li>.phase (float, READ/WRITE) current phase</li>
<li>.harmonics (int, READ/WRITE) number of harmonics</li>
</ul>
<h2>Noise Sources</h2>
<h3>Noise</h3>
<p>white noise generator</p>
<p>See examples/noise.ck examples/powerup.ck</p>
<h3>SubNoise</h3>
<p>STK sub-sampled noise generator.<br />
</p>
<ul>
<li>.rate (int, READ/WRITE) subsampling rate in samples<br />
</li>
</ul>
<p>see examples/ugen/SubNoise.txt </p>
<h2>Modulation Sources</h2>
<h3>Modulate</h3>
<p>STK periodic/random modulator. Generates modultion signals to affect other UGens (for example the basic oscillators using a sync value of 2)</p>
<ul>
<li>.vibratoRate (float, READ/WRITE) set rate of vibrato</li>
<li>.vibratoGain (float, READ/WRITE) gain for vibrato</li>
<li>.randomGain (float, READ/WRITE) gain for random contribution</li>
</ul>
<p><span id="ch035_ugens-stkinstruments.xhtml"></span></p>
<h1>STK - Instruments</h1>
<h2>Physical Modelling</h2>
<h3>StkInstrument</h3>
<p>Super-class for STK instruments. Useful for abstracting sets of such ugens.</p>
<ul>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change - numbers are instrument specific, value range: [0.0 - 128.0]</li>
</ul>
<p>See examples/ugen/STKinstrument.txt</p>
<h3>BandedWG</h3>
<p>Banded waveguide modeling class. Extends STKInstrument</p>
<ul>
<li>.bowPressure (float, READ/WRITE) bow pressure [0.0 - 1.0]</li>
<li>.bowMotion (float, READ/WRITE) bow motion [0.0 - 1.0]</li>
<li>.bowRate (float, READ/WRITE) strike Position</li>
<li>.strikePosition (float, READ/WRITE) strike Position</li>
<li>.integrationConstant - ( float , READ/WRITE ) - ?? [0.0 - 1.0]</li>
<li>.modesGain (float, READ/WRITE) amplitude for modes [0.0 - 1.0]</li>
<li>.preset (int, READ/WRITE) instrument presets (0 - 3, see above)</li>
<li>.pluck (float, READ/WRITE) pluck instrument [0.0 - 1.0]</li>
<li>.startBowing (float, READ/WRITE) start bowing [0.0 - 1.0]</li>
<li>.stopBowing (float, READ/WRITE) stop bowing [0.0 - 1.0] (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/BandedWG.txt</p>
<h3>BlowBotl</h3>
<p>STK blown bottle instrument. Extends STKInstrument</p>
<ul>
<li>.noiseGain - ( float , READ/WRITE ) - noise component gain [0.0 - 1.0]</li>
<li>.vibratoFreq - ( float , READ/WRITE ) - vibrato frequency (Hz)</li>
<li>.vibratoGain - ( float , READ/WRITE ) - vibrato gain [0.0 - 1.0]</li>
<li>.volume - ( float , READ/WRITE ) - yet another volume knob [0.0 - 1.0]</li>
<li>.startBlowing (float, READ/WRITE) begin blowing [0.0 - 1.0]</li>
<li>.stopBlowing (float, READ/WRITE) stop blowing [0.0 - 1.0]</li>
<li>.rate (float, READ/WRITE) - rate of attack (sec) (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/BlowBotl.txt</p>
<h3>BlowHole</h3>
<p>STK clarinet physical model with one register hole and one tonehole. Extends STKInstrument</p>
<ul>
<li>.reed (float, READ/WRITE) reed stiffness [0.0 - 1.0]</li>
<li>.noiseGain - ( float , READ/WRITE ) - noise component gain [0.0 - 1.0]</li>
<li>.vent (float, READ/WRITE) vent frequency [0.0 - 1.0]</li>
<li>.pressure (float, READ/WRITE) pressure [0.0 - 1.0]</li>
<li>.tonehole (float, READ/WRITE) tonehole size [0.0 - 1.0]</li>
<li>.startBlowing (float, READ/WRITE) start blowing [0.0 - 1.0]</li>
<li>.stopBlowing (float, READ/WRITE) stop blowing [0.0 - 1.0]</li>
<li>.rate (float, READ/WRITE) rate of change (sec) (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/BlowHole.txt</p>
<h3>Bowed</h3>
<p>STK bowed string instrument class. Extends STKInstrument</p>
<ul>
<li>.bowPressure - ( float , READ/WRITE ) - bow pressure [0.0 - 1.0]</li>
<li>.bowPosition - ( float , READ/WRITE ) - bow position [0.0 - 1.0]</li>
<li>.vibratoFreq - ( float , READ/WRITE ) - vibrato frequency (Hz)</li>
<li>.vibratoGain - ( float , READ/WRITE ) - vibrato gain [0.0 - 1.0]</li>
<li>.volume - ( float , READ/WRITE ) - volume [0.0 - 1.0]</li>
<li>.startBowing (float, READ/WRITE) begin bowing [0.0 - 1.0]</li>
<li>.stopBowing (float, READ/WRITE) stop bowing [0.0 - 1.0]</li>
<li>.rate (float, READ/WRITE) - rate of attack (sec) (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/Bowed.txt</p>
<h3>Brass</h3>
<p>STK simple brass instrument class. Extends STKInstrument</p>
<ul>
<li>.lip - ( float , READ/WRITE ) - lip tension [0.0 - 1.0]</li>
<li>.slide - ( float , READ/WRITE ) - slide length [0.0 - 1.0]</li>
<li>.vibratoFreq - ( float , READ/WRITE ) - vibrato frequency (Hz)</li>
<li>.vibratoGain - ( float , READ/WRITE ) - vibrato gain [0.0 - 1.0]</li>
<li>.volume - ( float , READ/WRITE ) - volume [0.0 - 1.0]</li>
<li>.clear - ( float , WRITE only ) - clear instrument</li>
<li>.startBlowing (float, READ/WRITE) start blowing [0.0 - 1.0]</li>
<li>.stopBlowing (float, READ/WRITE) stop blowing [0.0 - 1.0]</li>
<li>.rate (float, READ/WRITE) rate of change (sec) (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/Brass.txt</p>
<h3>Clarinet</h3>
<p>STK clarinet physical model class. Extends STKInstrument</p>
<ul>
<li>.reed - ( float , READ/WRITE ) - reed stiffness [0.0 - 1.0]</li>
<li>.noiseGain - ( float , READ/WRITE ) - noise component gain [0.0 - 1.0]</li>
<li>.clear - ( ) - clear instrument .vibratoFreq - ( float , READ/WRITE ) - vibrato frequency (Hz)</li>
<li>.vibratoGain - ( float , READ/WRITE ) - vibrato gain [0.0 - 1.0]</li>
<li>.pressure - ( float , READ/WRITE ) - pressure/volume [0.0 - 1.0]</li>
<li>.startBlowing - ( float , WRITE only ) - start blowing [0.0 - 1.0]</li>
<li>.stopBlowing - ( float , WRITE only ) - stop blowing [0.0 - 1.0]</li>
<li>.rate - ( float , READ/WRITE ) - rate of attack (sec) (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/Clarinet.txt</p>
<h3>Flute</h3>
<p>STK flute physical model class. Extends STKInstrument</p>
<ul>
<li>.jetDelay - ( float , READ/WRITE ) - jet delay [...] item</li>
<li>.jetReflection - ( float , READ/WRITE ) - jet reflection [...]</li>
<li>.endReflection - ( float , READ/WRITE ) - end delay [...]</li>
<li>.noiseGain - ( float , READ/WRITE ) - noise component gain [0.0 - 1.0]</li>
<li>.clear - ( ) - clear instrument .vibratoFreq - ( float , READ/WRITE ) - vibrato frequency (Hz)</li>
<li>.vibratoGain - ( float , READ/WRITE ) - vibrato gain [0.0 - 1.0]</li>
<li>.pressure - ( float , READ/WRITE ) - pressure/volume [0.0 - 1.0]</li>
<li>.startBlowing (float, READ/WRITE) begin bowing [0.0 - 1.0]</li>
<li>.stopBlowing (float, READ/WRITE) stop bowing [0.0 - 1.0]</li>
<li>.rate (float, READ/WRITE) - rate of attack (sec) (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/Flute.txt</p>
<h3>Mandolin</h3>
<p>STK mandolin instrument model class. Extends STKInstrument</p>
<ul>
<li>.bodySize (float, READ/WRITE) body size (percentage)</li>
<li>.pluckPos (float, READ/WRITE) pluck position [0.0 - 1.0]</li>
<li>.stringDamping (float, READ/WRITE) string damping [0.0 - 1.0]</li>
<li>.stringDetune (float, READ/WRITE) detuning of string pair [0.0 - 1.0]</li>
<li>.afterTouch (float, READ/WRITE) aftertouch (currently unsupported)</li>
<li>.pluck - ( float , WRITE only ) - pluck instrument [0.0 - 1.0] (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/mand-o-matic.ck examples/ugen/Mandolin.txt</p>
<h3>ModalBar</h3>
<p>STK resonant bar instrument class. Extends STKInstrument</p>
<ul>
<li>.stickHardness - ( float , READ/WRITE ) - stick hardness [0.0 - 1.0]</li>
<li>.strikePosition - ( float , READ/WRITE ) - strike position [0.0 - 1.0]</li>
<li>.vibratoFreq - ( float , READ/WRITE ) - vibrato frequency (Hz)</li>
<li>.vibratoGain - ( float , READ/WRITE ) - vibrato gain [0.0 - 1.0]</li>
<li>.directGain - ( float , READ/WRITE ) - direct gain [0.0 - 1.0]</li>
<li>.masterGain - ( float , READ/WRITE ) - master gain [0.0 - 1.0]</li>
<li>.volume - ( float , READ/WRITE ) - volume [0.0 - 1.0]</li>
<li>.preset - ( int , READ/WRITE ) - choose preset (see above)</li>
<li>.strike - ( float , WRITE only ) - strike bar [0.0 - 1.0]</li>
<li>.damp - ( float , WRITE only ) - damp bar [0.0 - 1.0]</li>
<li>.clear - ( ) - reset [none]</li>
<li>.mode - ( int , READ/WRITE ) - select mode [0.0 - 1.0]</li>
<li>.modeRatio - ( float , READ/WRITE ) - edit selected mode ratio [...]</li>
<li>.modeRadius - ( float , READ/WRITE ) - edit selected mode radius [0.0 - 1.0]</li>
<li>.modeGain - ( float , READ/WRITE ) - edit selected mode gain [0.0 - 1.0] (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/modalbot.ck examples/ugen/ModalBar.txt</p>
<h3>Saxofony</h3>
<p>STK faux conical bore reed instrument class. Extends STKInstrument</p>
<ul>
<li>.stiffness - ( float , READ/WRITE ) - reed stiffness [0.0 - 1.0]</li>
<li>.aperture - ( float , READ/WRITE ) - reed aperture [0.0 - 1.0]</li>
<li>.blowPosition - ( float , READ/WRITE ) - lip stiffness [0.0 - 1.0]</li>
<li>.noiseGain - ( float , READ/WRITE ) - noise component gain [0.0 - 1.0]</li>
<li>.vibratoFreq - ( float , READ/WRITE ) - vibrato frequency (Hz)</li>
<li>.vibratoGain - ( float , READ/WRITE ) - vibrato gain [0.0 - 1.0]</li>
<li>.clear - ( ) - clear instrument</li>
<li>.pressure - ( float , READ/WRITE ) - pressure/volume [0.0 - 1.0]</li>
<li>.startBlowing (float, READ/WRITE) begin blowing [0.0 - 1.0]</li>
<li>.stopBlowing (float, READ/WRITE) stop blowing [0.0 - 1.0]</li>
<li>.rate (float, READ/WRITE) - rate of attack (sec) (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/Saxofony.txt</p>
<h3>Shakers</h3>
<p>PhISEM and PhOLIES class emulating systems of particles. Extends STKInstrument</p>
<ul>
<li>.preset - ( int , READ/WRITE ) - select instrument (0 - 22; see below)</li>
<li>.energy - ( float , READ/WRITE ) - shake energy [0.0 - 1.0]</li>
<li>.decay - ( float , READ/WRITE ) - system decay [0.0 - 1.0]</li>
<li>.objects - ( float , READ/WRITE ) - number of objects [0.0 - 128.0] (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>Instrument preset numbers;</p>
<ul>
<li>Maraca = 0<br />
</li>
<li>Cabasa = 1<br />
</li>
<li>Sekere = 2<br />
</li>
<li>Guiro = 3<br />
</li>
<li>Water Drops = 4<br />
</li>
<li>Bamboo Chimes = 5<br />
</li>
<li>Tambourine = 6<br />
</li>
<li>Sleigh Bells = 7<br />
</li>
<li>Sticks = 8<br />
</li>
<li>Crunch = 9<br />
</li>
<li>Wrench = 10<br />
</li>
<li>Sand Paper = 11<br />
</li>
<li>Coke Can = 12<br />
</li>
<li>Next Mug = 13<br />
</li>
<li>Penny + Mug = 14<br />
</li>
<li>Nickle + Mug = 15<br />
</li>
<li>Dime + Mug = 16<br />
</li>
<li>Quarter + Mug = 17<br />
</li>
<li>Franc + Mug = 18<br />
</li>
<li>Peso + Mug = 19<br />
</li>
<li>Big Rocks = 20<br />
</li>
<li>Little Rocks = 21<br />
</li>
<li>Tuned Bamboo Chimes = 22</li>
</ul>
<ol>
</ol>
<p>See examples/shake-o-matic.ck examples/ugen/Shakers.txt</p>
<h3>Sitar</h3>
<p>STK sitar string model class. extends STKInstrument</p>
<ul>
<li>.pluck (float, WRITE only) pluck string [0.0 - 1.0]</li>
<li>.clear () reset (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/ugen/Sitar.txt</p>
<h3>StifKarp</h3>
<p>STK plucked stiff string instrument named after and based on the &quot;Karplus-Strong&quot; method of delay-based plucked string synthesis. Extends STKInstrument</p>
<ul>
<li>.pickupPosition - ( float , READ/WRITE ) - pickup position [0.0 - 1.0]</li>
<li>.sustain - ( float , READ/WRITE ) - string sustain [0.0 - 1.0]</li>
<li>.stretch - ( float , READ/WRITE ) - string stretch [0.0 - 1.0]</li>
<li>.pluck - ( float , WRITE only ) - pluck string [0.0 - 1.0]</li>
<li>.baseLoopGain - ( float , READ/WRITE ) - ?? [0.0 - 1.0]</li>
<li>.clear - ( ) - reset instrument (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/stifkarp.ck examples/ugen/StifKarp.txt</p>
<h3>VoicForm</h3>
<p>Four formant synthesis instrument. Extends STKInstrument</p>
<ul>
<li>.phoneme (string, READ/WRITE) select phoneme ( see &quot;name&quot; in the table below )</li>
<li>.phonemeNum - ( int , READ/WRITE ) - select phoneme by number [0.0 - 128.0] (see &quot;number&quot; in the table below)</li>
<li>.speak (float, WRITE only) start singing [0.0 - 1.0]</li>
<li>.quiet (float, WRITE only) stop singing [0.0 - 1.0]</li>
<li>.voiced (float, READ/WRITE) set mix for voiced component [0.0 - 1.0]</li>
<li>.unVoiced (float, READ/WRITE) set mix for unvoiced component [0.0 - 1.0]</li>
<li>.pitchSweepRate (float, READ/WRITE) pitch sweep [0.0 - 1.0]</li>
<li>.voiceMix (float, READ/WRITE) voiced/unvoiced mix [0.0 - 1.0]</li>
<li>.vibratoFreq (float, READ/WRITE) vibrato frequency (Hz)</li>
<li>.vibratoGain (float, READ/WRITE) vibrato gain [0.0 - 1.0]</li>
<li>.loudness (float, READ/WRITE) 'loudness' of voice [0.0 - 1.0] (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td> number</td>
<td>name<br />
</td>
<td> description</td>
<td> notes</td>
</tr>
<tr class="even">
<td> 0</td>
<td> &quot;eee&quot;</td>
<td> beet</td>
<td> </td>
</tr>
<tr class="odd">
<td> 1</td>
<td> &quot;ihh&quot;</td>
<td> bit</td>
<td> </td>
</tr>
<tr class="even">
<td> 2<br />
</td>
<td> &quot;ehh&quot;</td>
<td> bet</td>
<td> </td>
</tr>
<tr class="odd">
<td> 3<br />
</td>
<td> &quot;aaa&quot;</td>
<td> bat</td>
<td> </td>
</tr>
<tr class="even">
<td> 4<br />
</td>
<td> &quot;ahh&quot;</td>
<td> father</td>
<td> </td>
</tr>
<tr class="odd">
<td> 5<br />
</td>
<td> &quot;aww&quot;</td>
<td> bought</td>
<td> </td>
</tr>
<tr class="even">
<td> 6</td>
<td> &quot;ohh&quot;</td>
<td> bone</td>
<td> same as aww (bought)<br />
</td>
</tr>
<tr class="odd">
<td> 7<br />
</td>
<td> &quot;uhh&quot;</td>
<td> but</td>
<td> </td>
</tr>
<tr class="even">
<td> 8<br />
</td>
<td> &quot;uuu&quot;</td>
<td> foot</td>
<td> </td>
</tr>
<tr class="odd">
<td> 9<br />
</td>
<td> &quot;ooo&quot;</td>
<td> boot</td>
<td> </td>
</tr>
<tr class="even">
<td>10</td>
<td> &quot;rrr&quot;</td>
<td> bird</td>
<td> </td>
</tr>
<tr class="odd">
<td>11<br />
</td>
<td> &quot;lll&quot;</td>
<td> lull</td>
<td> </td>
</tr>
<tr class="even">
<td>12<br />
</td>
<td> &quot;mmm&quot;</td>
<td> mom</td>
<td> </td>
</tr>
<tr class="odd">
<td>13<br />
</td>
<td> &quot;nnn&quot;</td>
<td> nun</td>
<td> </td>
</tr>
<tr class="even">
<td>14<br />
</td>
<td> &quot;nng&quot;</td>
<td> sang</td>
<td> </td>
</tr>
<tr class="odd">
<td>15<br />
</td>
<td> &quot;ngg&quot;</td>
<td> bong</td>
<td> </td>
</tr>
<tr class="even">
<td>16<br />
</td>
<td> &quot;fff&quot;</td>
<td> </td>
<td> </td>
</tr>
<tr class="odd">
<td>17<br />
</td>
<td> &quot;sss&quot;</td>
<td> </td>
<td> </td>
</tr>
<tr class="even">
<td>18<br />
</td>
<td> &quot;thh&quot;</td>
<td> </td>
<td> </td>
</tr>
<tr class="odd">
<td>19<br />
</td>
<td> &quot;shh&quot;</td>
<td> </td>
<td> </td>
</tr>
<tr class="even">
<td>20<br />
</td>
<td> &quot;xxx&quot;</td>
<td> </td>
<td> not  done yet<br />
</td>
</tr>
<tr class="odd">
<td>21<br />
</td>
<td> &quot;hee&quot;</td>
<td> beet</td>
<td> </td>
</tr>
<tr class="even">
<td>22<br />
</td>
<td> &quot;hoo&quot;</td>
<td> boot</td>
<td> </td>
</tr>
<tr class="odd">
<td>23<br />
</td>
<td> &quot;hah&quot;</td>
<td> father</td>
<td> </td>
</tr>
<tr class="even">
<td>24<br />
</td>
<td> &quot;bbb&quot;</td>
<td> </td>
<td> not  done yet</td>
</tr>
<tr class="odd">
<td>25<br />
</td>
<td> &quot;ddd&quot;</td>
<td> </td>
<td> not  done yet</td>
</tr>
<tr class="even">
<td>26<br />
</td>
<td> &quot;jjj&quot;</td>
<td> </td>
<td> not  done yet</td>
</tr>
<tr class="odd">
<td>27<br />
</td>
<td> &quot;ggg&quot;</td>
<td> </td>
<td> not  done yet</td>
</tr>
<tr class="even">
<td>28<br />
</td>
<td> &quot;vvv&quot;</td>
<td> </td>
<td> not  done yet</td>
</tr>
<tr class="odd">
<td>29<br />
</td>
<td> &quot;zzz&quot;</td>
<td> </td>
<td> not  done yet</td>
</tr>
<tr class="even">
<td>30<br />
</td>
<td> &quot;thz&quot;</td>
<td> </td>
<td> not  done yet</td>
</tr>
<tr class="odd">
<td>31<br />
</td>
<td> &quot;zhh&quot;</td>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p> </p>
<p>See examples/voic-o-form.ck examples/ugen/VoicForm.txt</p>
<h2>STK Wavetable Synthesis</h2>
<h3>Moog</h3>
<p>STK moog-like swept filter sampling synthesis class Extends ugen_STKStkInstrument</p>
<ul>
<li>.filterQ - ( float , READ/WRITE ) - filter Q value [0.0 - 1.0]</li>
<li>.filterSweepRate - ( float , READ/WRITE ) - filter sweep rate [0.0 - 1.0]</li>
<li>.vibratoFreq - ( float , READ/WRITE ) - vibrato frequency (Hz)</li>
<li>.vibratoGain - ( float , READ/WRITE ) - vibrato gain [0.0 - 1.0]</li>
<li>.afterTouch - ( float , WRITE only ) - aftertouch [0.0 - 1.0] (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See examples/moogie.ck examples/ugen/Moog.txt <br />
</p>
<h2>STK - FM Synths</h2>
<h3>FM</h3>
<p>STK abstract FM synthesis base. Extends STKInstrument.</p>
<ul>
<li>.lfoSpeed (float, READ/WRITE) modulation speed (Hz)</li>
<li>.lfoDepth (float, READ/WRITE) modulation depth [0.0 - 1.0]</li>
<li>.afterTouch (float, READ/WRITE) aftertouch [0.0 - 1.0]</li>
<li>.control1 (float, READ/WRITE) FM control 1 [instrument specific]</li>
<li>.control2 (float, READ/WRITE) FM control 2 [instrument specific] it (inherited from StkInstrument)</li>
<li>.noteOn - (float velocity) - trigger note on</li>
<li>.noteOff - (float velocity) - trigger note off</li>
<li>.freq - (float frequency) - set/get frequency (Hz)</li>
<li>.controlChange - (int number, float value) - assert control change</li>
</ul>
<p>See class examples/ugen/FM.txt</p>
<h3>BeeThree</h3>
<p>STK Hammond-oid organ FM synthesis instrument. Extends FM (see super classes)</p>
<p>See examples/ugen/BeeThree.txt</p>
<h3>FMVoices</h3>
<p>STK singing FM synthesis instrument. Extends FM (see super classes).</p>
<ul>
<li>.vowel (float, WRITE only) select vowel [0.0 - 1.0]</li>
<li>.spectralTilt (float, WRITE only) spectral tilt [0.0 - 1.0]</li>
<li>.adsrTarget (float, WRITE only) adsr targets [0.0 - 1.0]</li>
</ul>
<p>See examples/ugen/FMVoices.txt</p>
<h3>HevyMetl STK</h3>
<p>STK heavy metal FM synthesis instrument. Extends FM (see super classes)</p>
<p>See examples/ugen/HevyMetl.txt</p>
<h3>PercFlut</h3>
<p>STK percussive flute FM synthesis instrument. Extends FM (see super classes)</p>
<p>See examples/ugen/PercFlut.txt</p>
<h3>Rhodey</h3>
<p>STK Fender Rhodes-like electric piano. Extends FM (see super classes)</p>
<p>extends FM (see super classes)</p>
<p>See examples/rhodey.ck examples/ugen/Rhodey.txt</p>
<h3>TubeBell</h3>
<p>STK tubular bell (orchestral chime) FM bell. Extends FM (see super classes).</p>
<p>See examples/ugen/TubeBell.txt </p>
<h3>Wurley</h3>
<p>STK Wurlitzer electric piano. Extends FM (see super classes).</p>
<p>See examples/wurley.ck<br />
</p>
<h2><br />
</h2>
<p><span id="ch036_unit-analyzer-reference.xhtml"></span></p>
<h1>UAna objects</h1>
<h3>UAna</h3>
<hr />
<ul>
<li>Unit Analyzer base class</li>
</ul>
<p>Base class from which all unit analyzers (UAnae) inherit; UAnae (note plural form) can be interconnected via =&gt; (standard chuck operator) or via =^ (upchuck operator), specify the the types of and when data is passed between UAnae and UGens. When .upchuck() is invoked on a given UAna, the UAna-chain (UAnae connected via =^) is traversed backwards from the upchucked UAna, and analysis is performed at each UAna along the chain; the updated analysis results are stored in UAnaBlobs.</p>
<p><em>extends UGen</em></p>
<ul>
<li>UAnaBlob .upchuck() initiate analysis at the UAna returns result.</li>
</ul>
<h3>[object]:UAnaBlob</h3>
<hr />
<ul>
<li>Unit Analyzer blob for contain of data </li>
</ul>
<p>This object contains results associated with UAna analysis. There is a UAnaBlob associated with every UAna. As a UAna is upchucked, the result is stored in the UAnaBlob’s floating point vector and/or complex vector. The intended interpretation of the results depends on the specific UAna.</p>
<ul>
<li>float .fval(int index) get blob's float value at index</li>
<li>complex .cval(int index) get blob's complex value at index</li>
<li>float[] .fvals() get blob's float array</li>
<li>complex[] .cvals() get blob's complex array</li>
<li>time .when() get the time when blob was last upchucked</li>
</ul>
<h3>[object]: Windowing</h3>
<hr />
<ul>
<li>Helper class for generating transform windows</li>
</ul>
<p>This class contains static methods for generating common transform windows for use with FFT/IFFT. The windows are returned in a static array associated with the Windowing class (note: do not use the returned array for anything other than reading/setting windows in FFT/IFFT).</p>
<ul>
<li>float[] .rectangle(int length) generate a rectangular window<br />
</li>
<li>float[] .triangle(int length) generate a triangular (or Barlett) window<br />
</li>
<li>float[] .hann(int length) generate a Hann window<br />
</li>
<li>float[] .hamming(int length) generate a Hamming window<br />
</li>
<li>float[] .blackmanHarris(int length) generate a blackmanHarris window</li>
</ul>
<p>examples: win.ck</p>
<h2>domain transformations</h2>
<h3>[uana]: FFT Fast Fourier Transform</h3>
<hr />
<p>This object contains results associated with UAna analysis. There is a UAnaBlob associated with every UAna. As a UAna is upchucked, the result is stored in the UAnaBlob’s floating point vector and/or complex vector. The intended interpretation of the results depends on the specific UAna. This UAna computes the Fast Fourier Transform on incoming audio samples, and outputs the result via its UAnaBlob as both the complex spectrum and the magnitude spectrum. A buffering mechanism maintains the previous FFTsize # of samples, allowing FFT’s to be taken at any point in time, on demand (via .upchuck() or by upchucking a downstream UAna; The window size (along with an arbitry window shape) is controlled via the .window method. The hop size is complete dynamic, and is throttled by how time is advanced.</p>
<p><em>extends UAna</em></p>
<ul>
<li>.size ( float, READ/WRITE ) get/set the FFT size</li>
<li>.window() ( float[], READ/WRITE ) get/set the transform window/size (also see AAA Windowing)</li>
<li>.windowSize ( int, READ only ) get the current window size</li>
<li>.transform ( float[], WRITE only ) manually take FFT (as opposed to using .upchuck() / upchuck operator)</li>
<li>.spectrum ( complex[], READ only ) manually retrieve the results of a transform</li>
</ul>
<p><em>(UAna input/output)</em><br />
</p>
<ul>
<li>input: audio samples from an incoming UGen output spectrum in complex array, magnitude spectrum in float array</li>
</ul>
<p>examples: fft.ck, fft2.ck, fft3.ck win.ck</p>
<h3>[uana]: IFFT Inverse Fast Fourier Transform</h3>
<hr />
<ul>
<li>Inverse Fast Fourier Transform</li>
</ul>
<p>This UAna computes the inverse Fast Fourier Transform on incoming spectral frames (on demand), and overlap-adds the results into its internal buffer, ready to be sent to other UGen’s connected via =&gt;. The window size (along with an arbitry window shape) is controlled via the .window method.</p>
<ul>
<li>.size - ( float, READ/WRITE ) get/set the IFFT size</li>
<li>.window() - ( float[], READ/WRITE ) get/set the transform window/size (also see AAA Windowing)</li>
<li>.windowSize - ( int, READ only ) get the current window size</li>
<li>.transform - ( complex[], WRITE only ) manually take IFFT (as opposed to using .upchuck() / upchuck operator)</li>
<li>.samples - ( float[], READ only ) manually retrieve the result of the previous IFFT (UAna input/output) input: complex spectral frames (either via UAnae connected via , or manullay via .transform()) output audio samples (overlap-added and streamed out to UGens connected via )</li>
</ul>
<p>examples: ifft.ck, fft2.ck, ifft3.ck</p>
<h3>[uana]: DCT Discrete Cosine Transform<br />
</h3>
<hr />
<p>This UAna computes the Discrete Cosine Transform on incoming audio samples, and outputs the result via its UAnaBlob as real values in the D.C. spectrum. A buffering mechanism maintains the previous DCT size # of samples, allowing DCT to be taken at any point in time, on demand (via .upchuck() or by upchucking a downstream UAna; The window size (along with an arbitry window shape) is controlled via the .window method. The hop size is complete dynamic, and is throttled by how time is advanced.</p>
<p><em>extends UAna</em></p>
<ul>
<li>.size - ( float, READ/WRITE ) get/set the DCT size</li>
<li>.window() - ( float[], READ/WRITE ) get/set the transform window/size (also see AAA Windowing)</li>
<li>.windowSize - ( int, READ only ) get the current window size</li>
<li>.transform - ( float[], WRITE ) manually take DCT (as opposed to using .upchuck() / upchuck operator)</li>
<li>.spectrum - ( float[], READ only ) manually retrieve the results of a transform</li>
</ul>
<p><em>(UAna input/output)</em><br />
</p>
<ul>
<li>[function] input: audio samples (either via UAnae connected via =^, or manullay via .transform())</li>
<li>[function] output discrete cosine spectrum</li>
</ul>
<p>examples: dct.ck</p>
<h3>[uana]: IDCT Inverse Discrete Cosine Transform</h3>
<hr />
<p>This UAna computes the inverse Discrete Cosine Transform on incoming spectral frames (on demand), and overlap-adds the results into its internal buffer, ready to be sent to other UGen’s connected via =&gt;. The window size (along with an arbitry window shape) is controlled via the .window method.</p>
<p><em>extends UAna</em></p>
<ul>
<li>.size - ( float, READ/WRITE ) get/set the IDCT size</li>
<li>.window() - ( float[], READ/WRITE ) get/set the transform window/size (also see AAA Windowing)</li>
<li>.windowSize - ( int, READ only ) get the current window size</li>
<li>.transform - ( float[], WRITE ) manually take IDCT (as opposed to using .upchuck() / upchuck operator)</li>
<li>.samples - ( float[], WRITE ) manually get result of previous IDCT</li>
</ul>
<p><em>(UAna input/output)</em></p>
<ul>
<li>input: real-valued spectral frames (either via UAnae connected via , or manullay via .transform())</li>
<li>output audio samples (overlap-added and streamed out to UGens connected via )<br />
</li>
</ul>
<p>examples: idct.ck feature extractors</p>
<h3>[uana]: Centroid Spectral Centroid</h3>
<hr />
<p>This UAna computes the spectral centroid from a magnitude spectrum (either from incoming UAna or manually given), and outputs one value in its blob.</p>
<p><em>extends UAna</em></p>
<ul>
<li>float .compute(float[]) manually computes the centroid from a float array</li>
</ul>
<p><em>(UAna input/output)</em><br />
</p>
<ul>
<li>input: complex spectral frames (e.g., via UAnae connected via )</li>
<li>output the computed Centroid value is stored in the blob's floating point vector, accessible via .fval(0). This is a normalized value in the range (0,1), mapped to the frequency range 0Hz to Nyquist</li>
</ul>
<p>examples: centroid.ck</p>
<h3>[uana]: Flux Spectral Flux</h3>
<hr />
<p>This UAna computes the spectral flux between successive magnitude spectra (via incoming UAna, or given manually), and outputs one value in its blob.</p>
<p><em>extends UAna</em><br />
</p>
<ul>
<li>void .reset( ) reset the extractor</li>
<li>float .compute(float[] f1, float[] f2) manually computes the flux between two frames</li>
<li>float .compute(float[] f1, float[] f2, float[] diff) manually computes the flux between two frames, and stores the difference in a third array</li>
</ul>
<p><em>(UAna input/output)</em></p>
<ul>
<li>input: complex spectral frames (e.g., via UAnae connected via )<br />
</li>
<li>output the computed Flux value is stored in the blob's floating point vector, accessible via .fval(0)<br />
</li>
</ul>
<p>examples: flux.ck, flux0.ck</p>
<h3>[uana]: RMS</h3>
<hr />
<ul>
<li>Spectral RMS</li>
</ul>
<p>This UAna computes the RMS power mean from a magnitude spectrum (either from an incoming UAna, or given manually), and outputs one value in its blob.</p>
<p><em>extends UAna</em></p>
<ul>
<li>float .compute(float[]) manually computes the RMS from a float array</li>
</ul>
<p><em>(UAna input/output)</em></p>
<ul>
<li>input: complex spectral frames (e.g., via UAnae connected via )</li>
<li>output the computed RMS value is stored in the blob's floating point vector, accessible via .fval(0)</li>
</ul>
<p>examples: rms.ck</p>
<h3>[uana]: RollOff</h3>
<hr />
<ul>
<li>Spectral RollOff</li>
</ul>
<p>This UAna computes the spectral rolloff from a magnitude spectrum (either from incoming UAna, or given manually), and outputs one value in its blob.</p>
<p><em>extends UAna</em></p>
<li>
<p>float .percent((float val)) set the percentage for computing rolloff</p>
</li>
<li>
<p>float .percent(( )) get the percentage specified for the rolloff</p>
</li>
<li>
<p>float .compute(float[]) manually computes the rolloff from a float array</p>
</li>
<p><em>(UAna input/output)</em></p>
<ul>
<li>input: complex spectral frames (e.g., via UAnae connected via )</li>
<li>output the computed rolloff value is stored in the blob's floating point vector, accessible via .fval(0). This is a normalized value in the range [0,1), mapped to the frequency range 0 to nyquist frequency. </li>
</ul>
<p>examples: rolloff.ck</p>
<p><span id="ch038_lick-library-for-chuck.xhtml"></span></p>
<h1> LiCK  Library for ChucK</h1>
<h2>Summary</h2>
<p>LiCK, a Library for ChucK, was born out of frequent requests on the chuck-users mailing list to have a shared repository for various bits of reusable ChucK code.</p>
<p> LiCK currently provides</p>
<ul>
<li>int, float, and Object Lists</li>
<li>Functor classes<br />
</li>
<li>Interpolating functions</li>
<li>Composite procedures for building loops<br />
</li>
<li>An Assert class for writing unit tests<br />
</li>
</ul>
<h2>Download and installation</h2>
<p>To download LiCK, visit the LiCK repository page on GitHub</p>
<p><a href="http://github.com/heuermh/lick" class="uri" title="http://github.com/heuermh/lick">http://github.com/heuermh/lick</a></p>
<p>Use git to clone to a local repository, or use the download link for a zip archive or a tarball.</p>
<p>To install and use LiCK in your own ChucK scripts, use the <a href="http://github.com/heuermh/lick/blob/master/import.ck" title="import.ck">import.ck</a> script</p>
<pre><code>$ chuck --loop &amp;

$ chuck + import.ck
...
&quot;LiCK imported.&quot; : (string)

$ chuck + my-script.ck</code></pre>
<p>If you don't want to include all of LiCK, use Machine.add(file name) to include individual LiCK source files.  Do be careful to include the LiCK source files of dependencies as well.</p>
<pre><code>Machine.add(&quot;FloatFunction.ck&quot;);
Machine.add(&quot;Interpolation.ck&quot;);
Machine.add(&quot;ExponentialOut.ck&quot;);</code></pre>
<p>Hopefully, a future version of ChucK will support a proper include and namespace mechanism, simplifying the use of external libraries like LiCK.<br />
</p>
<h2>Contributing to LiCK</h2>
<p>LiCK is welcome to any contributions! Don’t worry too much about style or formatting, that can all be worked out later.</p>
<p>Please add the license header (<a href="http://github.com/heuermh/lick/blob/master/HEADER.txt" title="HEADER.txt"><span class="caps">HEADER</span>.txt</a>) to the top of each file and provide an author statement if you wish.</p>
<p>If you add classes to LiCK, be sure to update import.ck with the new classes and their dependencies in the correct order. If you have unit tests for those classes, be sure to update <a href="http://github.com/heuermh/lick/blob/master/tests.ck" title="tests.ck">tests.ck</a> with the new unit tests.</p>
<p>Any suggestions as to where examples should live in the repository are also welcome.</p>
<h2>int, float, and Object Lists</h2>
<p>For those more comfortable with Smalltalk, C#, or Java-style collections than arrays, LiCK provides int, float, and Object Lists.</p>
<p>Lists are created and sized in manner similar to that of ChucK arrays</p>
<pre><code>// create a new object list
ArrayList list;

// initially the size of the list is zero
Assert.assertTrue(0, list.size());
Assert.assertTrue(list.isEmpty());

// pass an argument to the size method to resize the array
list.size(16);
Assert.assertTrue(16, list.size());
Assert.assertFalse(list.isEmpty());

list.clear();
Assert.assertTrue(0, list.size());
Assert.assertTrue(list.isEmpty());

// or add elements to the list to resize it dynamically
Object foo;
list.add(foo);
Assert.assertTrue(1, list.size());
Assert.assertFalse(list.isEmpty());</code></pre>
<p>Indexed access is provided via get and set methods</p>
<pre><code>ArrayList list;
Object foo;
Object bar;
Object baz;

list.set(0, foo);
list.set(1, bar);
list.set(2, baz);

Assert.assertEquals(foo, list.get(0));
Assert.assertEquals(bar, list.get(1));
Assert.assertEquals(baz, list.get(2));</code></pre>
<p> All the elements in a list can be accessed using a for loop over the indices</p>
<pre><code>for (0 =&gt; int i; i &lt; list.size(); i++)
{
  list.get(i) @=&gt; Object value;
  Assert.assertNotNull(value);
}</code></pre>
<p>an Iterator<br />
</p>
<pre><code>list.iterator() @=&gt; Iterator iterator;
while (iterator.hasNext())
{
  iterator.next() @=&gt; Object value;
  Assert.assertNotNull(value);
}</code></pre>
<p> or an internal iterator via any of the forEach methods</p>
<pre><code>class AssertNotNull extends UnaryProcedure
{
  fun void run(Object value)
  {
    Assert.assertNotNull(value);
  }
}

AssertNotNull assertNotNull;
list.forEach(assertNotNull);</code></pre>
<p>Int and float list implementations also provide similar behaviour.</p>
<pre><code>IntArrayList intList;
intList.add(42);
intList.set(1, -42);
Assert.assertEquals(42, intList.get(0));
Assert.assertEquals(-42, intList.get(1));

FloatArrayList floatList;
floatList.size(16);
floatList.assign(3.14);
floatList.iterator() @=&gt; Iterator iterator;
while (iterator.hasNext())
{
  iterator.next() =&gt; float value;
  Assert.assertEquals(3.14, value, 0.001);
}
</code></pre>
<h2>Functor classes<br />
</h2>
<p>LiCK provides a suite of Functor classes [1], objects that act as functions or procedures.  Functor objects can be passed to methods, as shown above in the ArrayList.forEach(UnaryProcedure) example.</p>
<p>A procedure accepts argument(s)</p>
<pre><code>class Write extends UnaryProcedure
{
  fun void run(Object value)
  {
    &lt;&lt;&lt;value&gt;&gt;&gt;;
  }
}</code></pre>
<p>A function accepts argument(s) and returns a value</p>
<pre><code>class Multiply extends FloatFloatFunction
{
  fun float evaluate(float value0, float value1)
  {
    return value0 * value1;
  }
}</code></pre>
<p>A predicate accepts argument(s) and returns a boolean value</p>
<pre><code>class AllPositive extends IntIntIntPredicate
{
  fun int test(int value0, int value1, int value2)
  {
    return (value &gt; 0) &amp;&amp; (value1 &gt; 0) &amp;&amp; (value2 &gt; 0);
  }
}</code></pre>
<p>Functor classes are provided for int, float, and Object arguments, in varying number of arguments.  For Object functors, the prefix indicates the number of arguments, i.e. Unary is 1 argument, Binary is 2 arguments, Tertiary is 3 arguments, Quaternary is 4 arguments.  Thus a QuaternaryFunction accepts 4 Object arguments and returns an Object value.</p>
<p>Similarly, for int and float functors, the number of prefix repeats is the number of arguments, e.g. an IntIntIntIntFunction accepts four int arguments and returns an int value.<br />
</p>
<p>For convenience, all of the functions in Math are implemented as functors</p>
<pre><code>// functors can be evaluated against scalar values
Log10 log10;
log10.evaluate(3.14) =&gt; float result;

// ...however, they really show their utility when you can pass them to a method
ArrayList list;
list.size(16);
list.assign(3.14);
list.transform(log10);  // log10 is used to transform all the values in list</code></pre>
<h2>Interpolating functions</h2>
<p>Interpolating functions.<br />
</p>
<h2>Composite procedures</h2>
<p>Composite procedures.</p>
<h2>Sample-based drum machine emulators</h2>
<p>LiCK provides classes that trigger samples for various vintage drum machines, such as the Oberheim DMX (<a href="http://github.com/heuermh/lick/blob/master/OberheimDmx.ck" title="OberheimDmx.ck">OberheimDmx.ck</a>) and the Roland TR-909 (<a href="http://github.com/heuermh/lick/blob/master/RolandTr909.ck" title="RolandTr909.ck">RolandTr909.ck</a>). To use these classes, find or record samples of each instrument and copy them to the paths in the source code, or alternatively edit the paths in the source code to match your samples directory.</p>
<p>For example, the samples directory layout for the Roland CR-78 defaults to</p>
<pre><code>samples/RolandCr78/Claves.wav
samples/RolandCr78/ClosedHat.wav
samples/RolandCr78/CowBell.wav
samples/RolandCr78/Crash.wav
samples/RolandCr78/Guiro.wav
samples/RolandCr78/HighBongo.wav
samples/RolandCr78/Kick.wav
samples/RolandCr78/LowBongo.wav
samples/RolandCr78/LowConga.wav
samples/RolandCr78/Maracas.wav
samples/RolandCr78/OpenHat.wav
samples/RolandCr78/Rim.wav
samples/RolandCr78/Snare.wav
samples/RolandCr78/Tamborine.wav </code></pre>
<p>Each sample is triggered by an IntProcedure that accepts a MIDI velocity value (0 .. 127) mapped to gain. The sample procedures also have rate and maxGain fields. Call these procedures directly in ChucK code</p>
<pre><code>RolandCr78 cr78;
while (true)
{
  cr78.kick.run(127);
  400::ms =&gt; now;
  cr78.snare.run(80);
  400::ms =&gt; now;
} </code></pre>
<p>or use a MIDI controller class, such as the nanoPAD (<a href="http://github.com/heuermh/lick/blob/master/NanoPad.ck" title="NanoPad.ck">NanoPad.ck</a>)</p>
<pre><code>NanoPad nanoPad;
RolandCr78 cr78;

// assign sample triggers to nanoPAD buttons
cr78.kick @=&gt; nanoPad.button1;
cr78.snare @=&gt; nanoPad.button2;
cr78.closedHat @=&gt; nanoPad.button3;

// open nanoPAD MIDI device 0
nanoPad.open(0); </code></pre>
<h2>Unit tests</h2>
<p>Unit testing is a software verification, validation, and documentation method in which a programmer tests if individual units of source code are fit for use [2].  LiCK provides support for unit testing via its <a href="http://github.com/heuermh/lick/blob/master/Assert.ck" title="Assert.ck">Assert.ck</a> class and the following implementation pattern.<br />
</p>
<p>ChucK currently does not support calling methods via reflection, so unit tests in LiCK should follow the pattern described below to be executed properly.</p>
<p>Each unit test should be a class which extends Assert.ck</p>
<pre><code>class MyUnitTest extends Assert
{
} </code></pre>
<p>Next, provide test methods that utilize assertXxx methods to make assertions about the class under test. Assertion messages are optional.</p>
<pre><code>class MyUnitTest extends Assert
{

  fun void testFoo()
  {
    assertTrue(&quot;this should be true&quot;, true);
  }

  fun void testBar()
  {
    assertFalse(&quot;this should be false&quot;, false);
  }
}</code></pre>
<p>Provide an pseudo-constructor method that sets exitOnFailure as desired, calls each of the testXxx methods, and prints out a message to stdout on success</p>
<pre><code>class MyUnitTest extends Assert
{
  {
    true =&gt; exitOnFailure;
    testFoo();
    testBar();
    &lt;&lt;&lt;&quot;MyUnitTest ok&quot;&gt;&gt;&gt;;
  }

  fun void testFoo()
  {
    assertTrue(&quot;this should be true&quot;, true);
  }

  fun void testBar()
  {
    assertFalse(&quot;this should be false&quot;, false);
  }
}</code></pre>
<p>Finally, instantiate the unit test and allow ChucK time to pass.</p>
<pre><code>class MyUnitTest extends Assert
{
  {
    true =&gt; exitOnFailure;
    testFoo();
    testBar();
    &lt;&lt;&lt;&quot;MyUnitTest ok&quot;&gt;&gt;&gt;;
  }

  fun void testFoo()
  {
    assertTrue(&quot;this should be true&quot;, true);
  }

  fun void testBar()
  {
    assertFalse(&quot;this should be false&quot;, false);
  }
}

MyUnitTest myUnitTest;
1::second =&gt; now;</code></pre>
<p>See <a href="http://www.junit.org/">http://www.junit.org</a> for further documentation on assertions and unit testing in general.</p>
<p>For examples of actual unit tests, see e.g. <a href="http://github.com/heuermh/lick/blob/master/ArrayListTest.ck" title="ArrayListTest.ck">ArrayListTest.ck</a>, <a href="http://github.com/heuermh/lick/blob/master/FloatArrayListTest.ck" title="FloatArrayListTest.ck">FloatArrayListTest.ck</a>, or <a href="http://github.com/heuermh/lick/blob/master/IntArrayListTest.ck" title="IntArrayListTest.ck">IntArrayListTest.ck</a> in LiCK.<br />
</p>
<h2>License</h2>
<pre><code>LiCK  Library for ChucK.
Copyright (c) 2007-2010 held jointly by the individual authors.

LiCK is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LiCK is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</code></pre>
<h2>  References</h2>
<p>1, <a href="http://c2.com/cgi/wiki?FunctorObject" class="uri" title="http://c2.com/cgi/wiki?FunctorObject">http://c2.com/cgi/wiki?FunctorObject</a><br />
</p>
<p>2,  <a href="http://en.wikipedia.org/wiki/Unit_testing" class="uri" title="http://en.wikipedia.org/wiki/Unit_testing">http://en.wikipedia.org/wiki/Unit_testing</a><br />
</p>
</body>
</html>
